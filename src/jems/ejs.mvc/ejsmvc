#!/usr/bin/env ejs
/*
    ejsmvc.es -- Ejscript web framework generator. This generates, compiles, cleans and packages Ejscript web applications. 
    For windows, this will be invoked via ejsmvc.cmd.
 */

/*
    Key directories, names should come from ejsrc
        view
        layouts
        views/layouts/default.ejs
 */

GC.enabled = false

require ejs.web
require ejs.web.template
require ejs.db
require ejs.unix

use default namespace public

class EjsMvc {

    private const DIR_PERMS: Number = 0775
    private const FILE_PERMS: Number = 0666
    private const RC: String = ".ejsrc"
    private const NextMigration: String = ".ejs/nextMigration"

    private var appName: String
    private var cmd: CmdArgs
    private var database: String = "sqlite"
    private var dirs: Object
    private var command: String 
    private var config: Object = {}
    private var db: Database
    private var debug: Boolean = false
    private var ext: Object
    private var layoutPage: String
    private var mode: String = "debug"
    private var mvc: Object
    private var options: Object
    private var overwrite: Boolean = false
    private var verbose: Number = 1
    private var ejsmvc: String

    /* This layers over App.defaultConfig */
    private var defaultConfig = {
        mode: "debug",
        cache: {
            enable: true,
            reload: true,
        },
        database: {
            timeout: 5000,
            debug: { },
            test: { },
            production: { },
        },
        directories: {
            bin: Path("bin"),
            db: Path("db"),
            cache: Path("cache"),
            controllers: Path("controllers"),
            layouts: Path("views/layouts"),
            models: Path("models"),
            views: Path("views"),
            src: Path("src"),
            web: Path("web"),
        },
        extensions: {
            es: "es",
            ejs: "ejs",
            mod: "mod",
        },
        mvc: {
            appmod: "App.mod",
            compiler: "ejsc --debug --optimize 9 --web",
            start: "start.es",
            views: {
                connectors: {
                    table: "html",
                    chart: "google",
                    rest: "html",
                },
                formats: {
                    currency: "$%10f",
                    Date: "%a %e %b %H:%M",
                },
            },
            webserver: 'ejsweb --ejs "/" --log stdout:2',
        },
        session: {
            enable: true,
            timeout: 1800,
        },
    }


    function EjsMvc() {
        blend(config, defaultConfig, false)
        loadConfig("ejsrc", true)
        ext = config.extensions

        if (config.mvc) {
            mvc = config.mvc
            dirs = config.directories
            dirs.home = App.dir
            dirs.lib = App.exeDir.join("../lib")
            dirs.mod = App.exeDir.join("../modules")
            for (d in dirs) {
                dirs[d] = Path(dirs[d])
            }
            layoutPage = dirs.layouts
            ejsmvc = Path(App.args[0]).basename
        }
    }

    private var cmdOptions = [
        [ [ "apply", "a" ] ],
        [ "database", String ],
        [ "debug" ],
        [ [ "keep", "k" ] ],
        [ "layout", String ],
        [ "min" ],
        [ "overwrite" ],
        [ [ "quiet", "q" ] ],
        [ "reverse" ],
        [ "search", String ],
        [ [ "verbose", "v" ] ],
    ]

    function usage(): Void {
        print("\nUsage: " + ejsmvc + " [options] [commands] ...\n" +
            "  Options:\n" + 
            "    --apply                      # Apply migrations\n" + 
            "    --database [sqlite | mysql]  # Sqlite only currently supported adapter\n" + 
            "    --keep\n" + 
            "    --layout layoutPage\n" + 
            "    --min\n" + 
            "    --reverse                    # Reverse generated migrations\n" + 
            "    --overwrite\n" + 
            "    --quiet\n" + 
            "    --verbose\n")

        let pre = "    " + ejsmvc + " "
        print("  Commands:\n" +
            pre + "clean\n" +
            pre + "compile [all | app | controller names | view names]\n" +
            pre + "compile path/name.ejs ...\n" +
            pre + "generate app name\n" + 
            pre + "generate controller name [action [, action] ...]\n" + 
            pre + "generate migration description model [field:type [, field:type]...]\n" +
            pre + "generate model name [field:type [, field:type]...]\n" +
            pre + "generate scaffold model [field:type [, field:type]...\n" +
            pre + "import\n" +
            pre + "migrate [forward|backward|NNN]\n" +
            pre + "run" +
            "")

        /*
            TODO
            pre + "dbconsole \n" +             # sqlite
            pre + "console \n" +               # with ejs.db, ejs.web and app loaded (all models, all controllers)
            pre + "generate package\n" +
            pre + "install (not implemented yet)\n" +
            pre + "uninstall (not implemented yet)\n" +
            pre + "mode [development | test | production] (not implemented yet)\n" +
            pre + "deploy path.zip (not implemented yet)\n" +
        */
        App.exit(1)
    }
    function main() {
        try {
            cmd = CmdArgs(cmdOptions)
        } catch (e) {
            error(e)
            usage()
        }
        try {
            processOptions(cmd)
            if (cmd.args.length == 0) {
                usage()
            }
            process()
        } catch (e) {
            if (e is String) {
                msg = e
                error("ejsmvc: Error: " + msg + "\n")
            } else {
                msg = e.message
                error("ejsmvc: Error: " + msg + "\n")
                error(e.stack + "\n")
            }
            App.exit(2)
        }
    }

    function processOptions(cmd: CmdArgs) {
        options = cmd.options
        if (options.search) {
            App.search = options.search.split(Path.SearchSeparator)
        }
        if (options.quiet) {
            options.verbose = 0
        }
        if (options.verbose) {
            verbose += (options.verbose cast Number)
        }
        App.search = [dirs.cache] + App.search
    }

    function process() {
        let task = cmd.args.shift()
        let rest = cmd.args

        switch (task) {
        case "browse":
            checkApp(task, rest)
            browse(rest)
            break

        case "clean":
            clean(rest)
            break

        case "compile":
            if (isApp()) {
                checkApp(task, rest)
            }
            compile(rest)
            break

        case "console":
            checkApp(task, rest)
            console(rest)
            break

        case "deploy":
            checkApp(task, rest)
            deploy(rest)
            break

        case "import":
            checkApp(task, rest)
            import(rest)
            break

        case "install":
            checkApp(task, rest)
            install(rest)
            break

        case "generate":
            checkApp(task, rest)
            generate(rest)
            break

        case "migrate":
            checkApp(task, rest)
            migrate(rest)
            break

        case "run":
            checkApp(task, rest)
            run(rest)
            break

        default:
            throw "Unknown command: " + task
/* UNUSED TODO
            rest = cmd.args
            compile(rest)
*/
            break
        }
        if (options.apply) {
            migrate()
        }
    }

    function clean(args: Array): Void {
        let files: Array = find(".", "*." + ext.mod)
        trace("[CLEAN]", files)
        for each (f in files) {
            rm(f)
        }
    }

    //  TODO - refactor and reorder this. Perhaps move compile, generate, migrate etc into separate files

    function compile(args: Array): Void {
        var files: Array
        if (args.length == 0) {
            if (isApp()) {
                args.append("everything")
            } else {
                args.append("")
            }
        }
        let kind: String = args[0].toLower()
        let rest: Array = args.slice(1)

        switch (kind) {
        case "everything":
            /*
             *  Build all items but NOT as one module
             */
            buildApp()
            for each (name in find(dirs.controllers, "*." + ext.es)) {
                buildController(name)
            }
            files = find(dirs.views, "*." + ext.ejs)
            for each (name in files) {
                buildView(name, true)
            }
            files = find("web", "." + ext.ejs)
            options.layoutPage = undefined;
            for each (name in files) {
                buildWebPage(name, true)
            }
            break

        case "all":
            /*
             *  Build entire app as one module
             */
            let saveVerbose = verbose
            let saveKeep = options.keep
            verbose = 0
            let pat = "*." + ext.es
            let controllers = find(dirs.controllers, pat)
            for each (c in controllers) {
                rm(dirs.cache.join(c.basename.replaceExt(ext.mod)))
            }
            buildApp()
            files = find("config", pat) + find("src", pat) + controllers + find(dirs.models, pat)
            let viewFiles = find(dirs.views, "*." + ext.ejs)
            let esPages = []
            for each (name in viewFiles) {
                if (!name.toString().contains(dirs.layouts.toString() + "/")) {
                    intermediate = buildView(name, false)
                    rm(intermediate.replaceExt(ext.mod))
                    esPages.append(intermediate)
                }
            }
            let webFiles = find("web", "*." + ext.ejs)
            for each (name in webFiles) {
                intermediate = buildWebPage(name, false)
                rm(intermediate.replaceExt(ext.mod))
                esPages.append(intermediate)
            }
            files += esPages
            options.keep = saveKeep
            verbose = saveVerbose
            buildFiles(dirs.cache.join("App").joinExt(ext.mod), files)
            if (!options.keep) {
                for each (name in esPages) {
                    rm(name)
                }
            }
            break

        case "app":
            /*
             *  Build app portions. This includes src, models and Base Controller
             */
            buildApp()
            break

        case "controller":
        case "controllers":
            /*
             *  Build controllers
             */
            if (rest.length == 0) {
                for each (name in find(dirs.controllers, "*." + ext.es)) {
                    buildController(name)
                }
            } else {
                for each (name in rest) {
                    buildController(dirs.controllers.join(name.toUpper()).joinExt(ext.es))
                }
            }
            break

        case "model":
        case "models":
            throw "WARNING: models are built with the app. Use \"" + ejsmvc + " compile app\""
            break

        case "view":
        case "views":
            if (rest.length == 0) {
                for each (view in find(dirs.views, "*." + ext.ejs)) {
                    buildView(view)
                }
            } else {
                for each (view in rest) {
                    buildView(view)
                }
            }
            break

        default:
            for each (f in args) {
                compileItem(Path(f).relative.normalize)
            }
        }
    }

    function compileItem(file: Path) {
        if (file.isDir) {
            for each (f in file.normalize.files(true)) {
                if (f.extension == ext.ejs || f.startsWith(dirs.views) || f.startsWith(dirs.controllers)) {
                    compileItem(f)
                }
            }
        } else {
            if (file.startsWith(dirs.views)) {
                buildView(file)
            } else if (file.startsWith(dirs.controllers)) {
                buildController(file)
            } else if (file.extension == ext.ejs) {
                buildWebPage(file, true)
            } else {
                throw "Can't compile " + file
            }
        }
    }

    function console(args: Array): Void {
        // cmd = 'ejs --use "' + appName + '"'
        let cmd = "ejs"
        //  TODO - this won't work without stdin
        System.run(cmd)
    }

    function buildController(file: Path) {
        if (!file.exists) {
            throw "Controller : \"" + file + "\" does not exist"   
        }
        if (!file.startsWith(dirs.controllers.toString())) {
            throw "File \"" + file + "\" is not a controller"
        }
        if (file.toString() == dirs.controllers.join("Base.es")) {
            // This is built into App.mod
            return
        }
        let out = dirs.cache.join(file.basename).replaceExt(ext.mod)
        let cmd: String
        //  MOB -- but search is an array !!
        let search = App.search.join(Path.SearchSeparator)
        cmd = getCompilerPath() + " --out " + out + " --search \"" + search + "\" " + dirs.cache.join(mvc.appmod) + 
            " " + file
        trace("[BUILD]", (verbose > 1) ? cmd : file)
        let results = command(cmd)
        if (!out) {
            throw "Compilation failed for " + out + "\n" + results
        }
    }

    function buildView(file: Path, compile: Boolean = false): String {
        if (file.toString().contains(/^views.layouts/)) {
             //  Skip layouts
            return null
        }
        if (!file.startsWith(dirs.views.toString() + "/") || file.extension != ext.ejs) {
            throw "File \"" + file + " \" is not a view. Path should be \"" + dirs.views.join("CONTROLLER/VIEW.ejs") + "\""
        }
        if (!file.exists) {
            throw "Can't find view file: " + file
        }

        let sansExt: Path = file.trimExt()
        let controller: String
        let controllerPrefix: String

        let viewName = sansExt.basename
        controller = getNthSegment(sansExt, 1).toPascal()

        // Ensure the corresponding controller (if there is one) is built first
        let controllerSource: Path = dirs.controllers.join(controller).joinExt(ext.es)
        let controllerMod: Path = dirs.cache.join(controller).joinExt(ext.mod)

        if (controllerSource.exists) {
            if (!controllerMod.exists) {
                buildController(controllerSource)
            }
            controllerPrefix = controller + "_"
        }

        if (verbose > 1) {
            trace("[PARSE]", file)
        }
        let parser: TemplateParser = new TemplateParser
/* UNUSED
        results = Templates.ViewHeader + parser.buildView(file.readString(), App.dir, options.layoutPage) + 
            Templates.ViewFooter
*/
        results = parser.buildView(controllerPrefix + viewName, file.readString(), { layout: options.layoutPage })
/* UNUSED
        results = results.replace(/\${CONTROLLER}/g, controllerPrefix)
        results = results.replace(/\${VIEW}/g, viewName)
*/

        let intermediate: Path = dirs.cache.join(md5(file)).joinExt(ext.es)
        let out = intermediate.replaceExt(ext.mod)
        try {
            Path(intermediate).write(results)
        } catch (e) {
            throw "Can't write module file: " + intermediate + ". Ensure directory is writable."
        }
        if (compile) {
            let cmd: String = getCompilerPath()
            let search = App.search.join(Path.SearchSeparator)
            if (controllerMod.exists) {
                cmd += " --out " + out + " --search \"" + search + "\" " + dirs.cache.join(mvc.appmod) + " " + 
                    controllerMod + " " + intermediate
            } else if (appName) {
                cmd += " --out " + out + " --search \"" + search + "\" " +  dirs.cache.join(mvc.appmod) + " " + 
                    intermediate
            } else {
                cmd += " --out " + out + " --search \"" + search + "\" " + intermediate
            }
            if (verbose > 1) {
                trace("[BUILD]", cmd)
            } else {
                trace("[BUILD]", file)
            }
            command(cmd)

            if (!exists(out)) {
                throw "Compilation failed for " + out + "\n" + results
            }
            if (!options.keep) {
                rm(intermediate)
            }
            return null
        }
        return intermediate
    }

    function buildWebPage(file: Path, compile: Boolean = true): String {
        let sansExt: Path = file.trimExt()
        file = file.joinExt(ext.ejs)
        if (file.extension != ext.ejs) {
            throw "File is not an Ejscript web page: " + file
        }
        if (!file.exists) {
            throw "Can't find ejs page: " + file
        }
        if (verbose > 1) {
            trace("[PARSE]", file)
        }
        let parser: TemplateParser = new TemplateParser
        results = parser.build(file.readString(), { layouts: layoutPage })
        let intermediate: Path = dirs.cache.join(md5(file)).joinExt(ext.es)
        try {
            Path(intermediate).write(results)
        } catch (e) {
            throw "Can't write module file: " + intermediate + ". Ensure directory is writable."
        }
        if (compile) {
            let out = intermediate.replaceExt(ext.mod)
            let cmd: String = getCompilerPath()
            let search = App.search.join(Path.SearchSeparator)
            cmd += " --out " + out + " --search \"" + search + "\" " + intermediate
            trace("[BUILD]", (verbose > 1) ? cmd : file)
            command(cmd)
            if (!out.exists) {
                throw "Compilation failed for " + out + "\n" + results
            }
            if (!options.keep) {
                rm(intermediate)
                return null
            }
        }
        return intermediate
    }

    function getCompilerPath(): String {
        let cmd = config.mvc.compiler
        let parts = cmd.split(" ")
        let path = parts[0].trim('"')
        if (path.isAbsolute) {
            /* Absolute compiler path */
            return cmd
        }
        path = App.exeDir.join(path)
        return '"' + path + '" ' + parts.slice(1).join(" ")
    }

    /*
        Build the entire app into a single mod file.
     */
    function buildFiles(out: Path, files: Array) {
        let sep = (Config.OS == "WIN") ? ";" : ":"
        let search = App.search.join(sep)
        let cmd = getCompilerPath() + " --out " + out + " --search \"" + search + "\" " + files.join(" ")
        if (verbose > 1) {
            trace("[BUILD]", cmd)
        } else {
            trace("[BUILD]", files.join(" "))
        }
        let results = command(cmd)
        if (!exists(out)) {
            throw "Compilation failed for " + out + "\n" + results
        }
    }

    function buildApp(): Void {
        let pat = "*." + ext.es
        let files = find("src", pat) + find(dirs.models, pat) + find(dirs.controllers, "Base.es")
        buildFiles(dirs.cache.join(mvc.appmod), files)
    }

    function browse(args: Array): Void {
        throw("No yet supported")
        let cmd = config.mvc.webserver

        if (!cmd.match(/^\/|^[a-zA-Z]:\//)) {
            cmd = cmd.trim('"').replace(/^[^ ]+/, App.exeDir.join("$&"))
        }
        trace("[RUN]", cmd)
        System.run(cmd)
    }

    function deploy(args: Array): Void {
        //  TODO
    }

    //  TODO - needs to be updated
    function import(args: Array): Void {
        overwrite = true
        let exe = ""
        let lib = ""
        switch (Config.OS) {
        case "WIN":
            exe = ".exe"
            lib = ".dll"
            break
        case "MACOSX":
            lib = ".dylib"
            break
        default:
            lib = ".so"
            break
        }

        //  TODO - import must support ajs alternatives
        binFiles = [ "ejs", "ejsc", "ejsmvc", "ejsweb" ]
        extFiles = [ "libcrypto", "libssl", "libmprssl" ]
        confFiles = [ "ejsweb.conf" ]

        if (exists(dirs.mod.join("ejs.db.mod"))) {
            //  TODO - other modules
            modFiles = [ "ejs.mod", "ejs.db.mod", "ejs.db.sqlite.mod", "ejs.web.mod" ]
            modLibFiles = [ "ejs.db.sqlite", "ejs.web" ]
            libFiles = [ "libpcre", "libec", "libmpr", "libsqlite3", "libejs" ]
        } else {
            //  Static
            modFiles = [ "ejs.mod", "ejsweb.mod" ]
            modLibFiles = [ ]
            libFiles = [ ]
            binFiles = [ "ejsc", "ejsmvc", "ejsweb" ]
        }

        for each (file in modFiles) {
            src = dirs.mod.join(file)
            dest = Path("bin").join(file)
            if (!exists(src)) {
                error("WARNING: Can't find: " + file + " Continuing ...")
            }
            copyFile(src, dest, "Import")
            chmod(dest, 0644)
        }
        for each (file in modLibFiles) {
            src = dirs.mod.join(file).toString() + lib
            dest = Path("bin").join(file).toString() + lib
            if (!exists(src)) {
                error("WARNING: Can't find: " + file + " Continuing ...")
            }
            copyFile(src, dest, "Import")
            chmod(dest, 0644)
        }
        for each (file in libFiles) {
            dest = Path("bin").join(file).joinExt(lib)
            src = dirs.lib.join(file).joinExt(lib)
            if (!exists(src)) {
                error("WARNING: Can't find: " + file + " Continuing ...")
            }
            copyFile(src, dest, "Import")
            chmod(dest, 0755)
        }
        for each (file in binFiles) {
            dest = Path("bin").join(file).joinExt(exe)
            src = dirs.bin.join(file).joinExt(exe)
            if (!exists(src)) {
                error("WARNING: Can't find: " + file + " Continuing ...")
            }
            copyFile(src, dest, "Import")
            chmod(dest, 0755)
        }
        for each (file in extFiles) {
            dest = Path("bin").join(file).joinExt(lib)
            src = dirs.bin.join(file).joinExt(lib)
            if (exists(file)) {
                copyFile(src, dest, "Import")
                chmod(dest, 0755)
            }
        }

        overwrite = false
        for each (file in confFiles) {
            dest = Path("bin").join(file)
            src = dirs.lib.join(file)
            if (!exists(src)) {
                error("WARNING: Can't find: " + file + " Continuing ...")
            }
            copyFile(src, dest, "Import")
            chmod(dest, 0644)
        }
        /*
            Update the DocumentRoot in bin/ejsweb.conf
            TODO - is this right
         */
        path = new Path("bin/ejsweb.conf")
        data = path.readString()
        path.write(data.replace(/DocumentRoot ".*"/, 'DocumentRoot "../web"'))
    }

    //  TODO - should this be here or in jem
    function install(args: Array): Void {
    }

    //  TODO - should this be here or in jem
    function uninstall(args: Array): Void {
    }

    function generate(args: Array): Void {
        if (args.length == 0) {
            args.append("all")
        }
        let kind: String = args[0].toLower()
        let rest: Array = args.slice(1)

        if (rest.length == 0) {
            usage()
            return
        }

        switch (kind) {
        case "app":
            generateApp(rest)
            break

        case "controller":
            generateController(rest)
            break

        case "migration":
            generateMigration(rest)
            break

        case "model":
            generateModel(rest, "Create Model " + rest[0].toPascal())
            break

        case "scaffold":
            generateScaffold(rest)
            break

        default:
            usage()
            return
        }
    }

    /*
        ejsmvc migrate              # Apply all migrations
        ejsmvc migrate NNN          # Intelliegently set to a specific migration
        ejsmvc migrate forward      # Migrate forward one
        ejsmvc migrate backward     # Migrate backward one
     */
    function migrate(args: Array? = null): Void {
        let files = Path("db/migrations").files().sort()
        let onlyOne = false
        let backward = false
        let targetSeq = null
        let id = null

        openDatabase()

        /*  
            Load the models
         */
        let appmod = dirs.cache.join(filesnames.appmod)
        if (!appmod.exists) {
            buildApp()
        }
        load(appmod)
        if (overwrite) {
            let name = config.database[mode].name
            rm(name)
            generateDatabase()
        }

        /*
            Each database has a _EjsMigrations table which has a record for each migration applied
         */
        let MigrationsTable = getMigrationModel()
        let migrations = MigrationsTable.findAll()
        let lastMigration = migrations.slice(-1)

        if (args && args.length > 0) {
            cmd = args.slice(0).toString().toLower()
        } else {
            cmd = ""
        }
        if (cmd == "forward" || cmd == "forw") {
            onlyOne = true

        } else if (cmd == "backward" || cmd == "back") {
            onlyOne = true
            backward = true

        } else if (cmd != "") {
            /* cmd may be a pure sequence number or a filename */
            targetSeq = cmd
            let found = false
            for each (f in files) {
                let base = f.basename.toString().toLower()
                if (Path(targetSeq).basename == base) {
                    targetSeq = base.replace(/^([0-9]*)_.*es/, "$1")
                    found = true
                } else {
                    let seq = base.replace(/^([0-9]*)_.*es/, "$1")
                    if (seq == targetSeq) {
                        found = true
                    }
                }
            }
            if (! found) {
                throw "Can't find target migration: " + targetSeq
            }
            if (lastMigration && targetSeq < lastMigration[0].version) {
                backward = true
            }
        }

        if (backward) {
            files = files.reverse()
        }

        for each (f in files) {
            let base = f.basename.toString()
            if (!base.match(/^([0-9]+).*es/)) {
                continue
            }
            let seq = base.replace(/^([0-9]*)_.*es/, "$1")
            if (seq == "") {
                continue
            }
            let found = false
            for each (appliedMigration in migrations) {
                if (appliedMigration["version"] == seq) {
                    found = true
                    id = appliedMigration["id"]
                }
            }
            if (backward) {
                found = !found
                if (targetSeq && targetSeq == seq) {
                    return
                }
            }

            if (!found) {
                try { delete Migration; } catch {}
                load(f)
                if (backward) {
                    trace("[MIGRATE]", "Reverse " + base)
                    new Migration().backward(db)
                } else {
                    trace("[MIGRATE]", "Apply " + base)
                    new Migration().forward(db)
                }
                if (backward) {
                    MigrationsTable.remove(id)
                } else {
                    migration = new MigrationsTable
                    migration["version"] = seq.toString()
                    migration.save()
                }
                if (onlyOne) {
                    return
                }
            }
            if (!backward && targetSeq && targetSeq == seq) {
                return
            }
        }
        if (onlyOne) {
            if (backward) {
                trace("[OMIT]", "All migrations reversed")
            } else {
                trace("[OMIT]", "All migrations applied")
            }
        }
    }

    function run(args: Array): Void {
        let cmd = config.mvc.webserver

        /*  Handle quotes around the program name. Because we try to convert to an absolute path, we need
            to remove quotes around a program name that has no spaces. If the program name has spaces or starts
            with quotes, we really can't convert to an absolute path easily.
         */
        argv = cmd.split(" ")
        if (argv[0].startsWith('"') && argv[0].endsWith('"')) {
            argv[0] = argv[0].trim('"')
            cmd = argv.join(" ")
        }
        if (!cmd.match(/^\/|^[a-zA-Z]:\//) && !cmd.startsWith('"')) {
            cmd = cmd.replace(/^[^ ]+/, App.exeDir.join("$&"))
        }
        trace("[RUN]", cmd)
        System.runx(cmd)
    }

    function findTop(dir: Path) {
        do {
            if (exists(dir.join("buildConfig.make"))) {
                return dir
            }
            prev = dir
            dir = dir.parent
        } while (!dir.same(prev))
        throw "Can't find buildConfig.make in local source tree"
    }

    /*  Generate an application.
        ejsmvc generate app appName
     */
    function generateApp(args: Array): Void {
        appName = args[0].toLower()
        // let f: File = new Path(appName)

        //  TODO - convert all paths to use dirs.name 
        makeDir(appName)
        App.chdir(appName)
        if (!options.min) {
            makeDir(".tmp")
            makeDir(".ejs")
            makeDir("bin")
            makeDir("doc")
            makeDir("logs")
            makeDir("messages")
            makeDir("test")
            makeDir("utils")
        }
        makeDir("cache")
        makeDir(dirs.controllers)
        makeDir("db")
        makeDir("db/migrations")
        makeDir(dirs.models)
        makeDir("src")
        makeDir(dirs.views)
        makeDir(dirs.layouts)
        makeDir("web")
        makeDir("web/default")
        makeDir("web/images")
        makeDir("web/themes")

        generateStart()
        generateAppSrc()
        generateConfig()
        generateLayouts()
        generatePages()
        generateBaseController()
        if (!options.min) {
            generateReadme()
        }
        generateDatabase()

        let files = ["src/App.es", dirs.controllers.join("Base.es")]
        buildFiles(dirs.cache.join("App").joinExt(ext.mod), files)
        App.chdir("..")

        if (verbose) {
            print("\nChange directory into your application directory: " + appName)
            print("Then run the web server via: \"" + ejsmvc + " run\"")
            print("and point your browser at: http://localhost:4000/ to view your app.")
        }
    }

    function generateConfig(): Void {
        let data = Templates.Ejsrc.replace(/\${NAME}/g, appName)
        data = data.replace(/\${PATH}/g, App.dir)
        data = data.replace(/\${WEBSERVER}/g, "ejsweb")
        makeConfigFile("ejsrc", data)
        /* Reload */
        loadConfig("ejsrc", true)
    }

    function generateLayouts(): Void {
        let data = Templates.DefaultLayout.replace(/\${NAME}/g, appName.toPascal())
        makeFile(dirs.layouts.join("default.ejs"), data, "Layout")
    }

    function generatePages(): Void {
        let path: Path = dirs.lib.join("www")
        if (!exists(path)) {
            throw "Can't find www at " + path
        }
        let web = Path("web")
        for each (f in find(path, "*")) {
            copyFile(f, "web" + f.name.slice(path.length), "Web File")
        }
    }

    function generateBaseController(): Void {
        let path: Path = dirs.controllers.join("Base.es")
        let data = Templates.BaseController.replace(/\${NAME}/g, appName)
        makeFile(path, data, "BaseController")
    }

    function generateStart(): Void {
        let data: String = Templates.Start
        makeFile("start.es", data, "start.es")
    }

    function generateAppSrc(): Void {
        let data: String = Templates.AppSrc
        makeFile("src/App.es", data, "App")
    }

    function generateReadme(): Void {
        let data: String = Templates.Readme.replace(/\${NAME}/g, appName.toPascal())
        makeFile("README", data, "README")
    }

    function loadDatabaseSupport() {
        loadMapper()
    }

    function loadMapper() {
        if (!global.Record) {
            load("ejs.db.mapper.mod")
        }
    }

    function getMigrationModel() {
        loadMapper()
        if (!global._EjsMigration) {
            eval("
                require ejs.db.mapper
                public dynamic class _EjsMigration implements Record {
                    function _EjsMigration(fields: Object = null) {
                        constructor(fields)
                    }
                }
            ")
        }
        return global["_EjsMigration"]
    }

    function generateDatabase(): Void {
        loadMapper()
        let path = config.database[mode].name
        if (!exists(path)) {
            db = new Database(database, path)
            if (debug) {
                db.trace(true)
            }
            db.createTable("_EjsMigrations", ["version:string"])
            if (debug) {
                db.trace(true)
            }
        }
    }

    function openDatabase(): Void {
        loadMapper()
        let name = config.database[mode].name
        db = new Database(database, name)
        if (debug) {
            db.trace(true)
        }
    }

    /*  generate controller name [action ...]
     */
    function generateController(args: Array): Void {
        let name: String = args[0].toPascal()
        let actions = args.slice(1)
        let path: String = dirs.controllers.join(name).joinExt(ext.es)
        let data: String = Templates.Controller.replace(/\${NAME}/g, name)
        data = data.replace(/\${APP}/g, appName)

        if (actions.length == 0) {
            actions.append("index")
        }
        for each (action in actions) {
            let actionData = Templates.Action.replace(/\${NAME}/g, action)
            data = data.replace(/NEXT_ACTION/, actionData + "NEXT_ACTION")
        }
        data = data.replace(/NEXT_ACTION/, "")
        data = data.replace(/\${MODEL}/g, name.toPascal())
        data = data.replace(/\${LOWER_MODEL}/g, name.toLower())
        makeFile(path, data, "Controller")
    }

    function createMigrationCode(model: String, forward: String, backward: String, comment: String) {
        data = Templates.Migration
        data = data.replace(/\${COMMENT}/g, comment)
        data = data.replace(/\${FORWARD}/g, forward)
        data = data.replace(/\${BACKWARD}/g, backward)

        seq = (new Date()).format("%Y%m%d%H%M%S")
        fileComment = comment.replace(/[    ]+/g, "_")
        path = Path("db/migrations/" + seq + "_" + fileComment).joinExt(ext.es)
        if (path.exists) {
            throw "Migration " + path + " already exists. Try again later."
        }
        makeFile(path, data, "Migration")
    }

    function validateAttributes(attributes: Array): Void {
        loadDatabaseSupport()
        for each (attribute in attributes) {
            column = attribute.split(":")[0]
            datatype = attribute.split(":")[1]
            if (db.dataTypeToSqlType(datatype) == undefined) {
                throw "Unsupported data type: \"" + datatype + "\" for column \"" + column + "\""
            }
        }
    }

    function createMigration(model: String, attributes: Array, comment: String, tableExists: Boolean): Void {
        let tableName = plural(model).toPascal()
        let forward = ''
        let backward = ''

        openDatabase()
        if (attributes && attributes.length > 0) {
            validateAttributes(attributes)
            if (!tableExists) {
                forward = '        db.createTable("' + tableName + '", ["' + attributes.join('", "') + '"])'
                backward = '        db.destroyTable("' + tableName + '")'

            } else {
                forward = ""
                for each (col in attributes)  {
                    spec = col.split(":")
                    forward += '        db.addColumn("' + tableName + '", "' + spec[0] + '", "' + spec[1] + '")\n'
                }
                backward = '        db.removeColumns("' + tableName + '", ['
                for each (col in attributes) {
                    backward += '"' + col.split(":")[0] + '", '
                }
                backward += '])'
            }

        } else {
            if (options.reverse) {
                forward = '        db.destroyTable("' + tableName + '")'
            }
        }
        if (options.reverse) {
            createMigrationCode(model, backward, forward, comment)
        } else {
            createMigrationCode(model, forward, backward, comment)
        }
    }

    /*  generate migration description model [field:type ...]
     */
    function generateMigration(args: Array): Void {
        if (args.length < 2) {
            usage()
        }
        comment = args[0]
        model = args[1]
        createMigration(model, args.slice(2), comment, true)
    }

    /*  generate model name [field:type ...]
     */
    function generateModel(args: Array, comment: String): Void {
        let model: String = args[0].toPascal()
        if (model.endsWith("s")) {
            error("WARNING: Models should typically be singluar not plural. Continuing ...")
        }
        let path = dirs.models.join(model).joinExt(ext.es)

        if (exists(path) && !overwrite) {
            traceFile(path, "[EXISTS] Migration (model already exists)")
        } else {
            createMigration(model, args.slice(1), comment, false)
        }
        let data = Templates.Model.replace(/\${NAME}/g, model)
        makeFile(path, data, "Model")
    }

    /*  generate scaffold model [field:type ...]
     */
    function generateScaffold(args: Array): Void {
        let model = args[0]
        if (model.match(/[a-zA-Z_]*/) != model) {
            throw "Bad model name " + model
        }
        let controller = model.toPascal()
        let attributes = args.slice(2)

        makeDir(dirs.views.join(controller))
        generateModel(args, "Create Scaffold " + model)
        generateScaffoldController(controller, model)
        generateScaffoldViews(controller, model)
        buildApp()
        if (!options.apply) {
            migrate()
        }
    }

    /*  Create a controller with scaffolding. Usage: controllerName [actions ...]
     */
    function generateScaffoldController(controller: String, model: String, extraActions: Array? = null): Void {
        let name = controller.toPascal()
        let path = dirs.controllers.join(name).joinExt(ext.es)

        let stndActions: Array = [ "index", "list", "create", "edit", "update", "destroy" ]
        let views: Array = [ "list", "edit" ]
        let actions: Array = []

        if (extraActions) {
            for each (action in extraActions) {
                if (! stndActions.contains(action)) {
                    actions.append(action.toCamel())
                }
            }
        }

        let data: String = Templates.ScaffoldController.replace(/\${APP}/g, appName.toPascal())
        data = data.replace(/\${NAME}/g, name)
        data = data.replace(/\${MODEL}/g, model.toPascal())
        data = data.replace(/\${LOWER_MODEL}/g, model.toLower())

        for each (action in actions) {
            let actionData = Templates.Action.replace(/\${NAME}/g, action)
            data = data.replace(/NEXT_ACTION/, actionData + "NEXT_ACTION")
        }
        data = data.replace(/NEXT_ACTION/, "")

        makeFile(path, data, "Controller")
    }

    /*  Create a scaffold views.  Usage: controllerName [actions ...]
     */
    function generateScaffoldViews(controller: String, model: String, extraActions: Array? = null): Void {
        let stndActions: Array = [ "index", "list", "create", "edit", "update", "destroy" ]
        let views: Array = [ "list", "edit" ]
        let actions: Array = stndActions.clone()

        if (extraActions) {
            for each (action in extraActions) {
                if (! stndActions.contains(action)) {
                    views.append(action.toCamel())
                }
            }
        }
        let data: String
        model = model.toPascal()

        for each (view in views) {
            switch (view) {
            case "edit":
                data = Templates.ScaffoldEditView.replace(/\${MODEL}/g, model)
                data = data.replace(/\${LOWER_MODEL}/g, model.toLower())
                break
            case "list":
                data = Templates.ScaffoldListView.replace(/\${MODEL}/g, model)
                break
            default:
                data = Templates.ScaffoldView.replace(/\${MODEL}/g, model)
                data = data.replace(/\${LOWER_MODEL}/g, model.toLower())
                data = data.replace(/\${CONTROLLER}/g, controller)
                data = data.replace(/\${VIEW}/g, view)
                break
            }
            let path: String = dirs.views.join(controller).join(view).joinExt(ext.ejs)
            makeFile(path, data, "View")
        }
    }

    function isApp(fatal: Boolean = false): Boolean
        dirs.controllers.exists && dirs.views.exists && exists("ejsrc")

    function checkApp(task: String, rest: Array): Void {
        if (task == "generate") {
            let what = rest[0]
            if (rest[0] == "app") {
                return
            }
            if (what != "app" && what != "controller" && what != "migration" && what != "model" && what != "scaffold") {
                usage()
                App.exit()
            }
        }
        if (!isApp(true)) {
            return
        }
        appName = App.dir.basename.toString().toLower()
    }

    function loadConfig(path: Path, overwrite: Boolean = true, mandatory: Boolean = false): Boolean {
        if (!path.exists) {
            if (mandatory) {
                throw new IOError("Can't open required configuration file: " + path)
            } else {
                return false
            }
        }
        let settings = deserialize(path.readString())
        blend(config, settings, overwrite)
        return true
    }

    //  TODO - Unused
    function loadDefaults(): Void {
        let home = Path(App.getenv("HOME"))
        loadConfig(RC) || loadConfig(home.join(RC))
    }

    function makeConfigFile(path: String, data: String): Void {
        if (exists(path) && !overwrite) {
            return
        }
        data = data.replace(/\${NAME}/g, appName)
        makeFile(path, data, "Config File")
    }

    function makeFile(path: String, data: String, msg: String): Void {
        let p: Path = new Path(path)
        if (p.exists && !overwrite) {
            traceFile(path, "[EXISTS] " + msg)
            return
        }
        if (! p.exists) {
            traceFile(path, "[CREATED] " + msg)
        } else {
            traceFile(path, "[OVERWRITTEN] " + msg)
        }
        let f: File = new File(path)
        f.open("w")
        f.write(data)
        f.close()
    }

    function makeDir(path: String): Void {
        if (isDir(path)) {
            return
        }
        trace("[CREATED] " + "Directory", path)
        mkdir(path, DIR_PERMS)
    }

    function copyFile(from: Path, to: Path, msg: String) {
        let p: Path = new Path(to)
        if (to.exists && !overwrite) {
            if (!from.isDir) {
                traceFile(to, "[EXISTS] " + msg)
            }
            return
        }
        if (!to.exists) {
            traceFile(to, "[CREATED] " + msg)
        } else {
            traceFile(to, "[OVERWRITTEN] " + msg)
        }
        if (!from.isDir) {
            mkdir(to.dirname, DIR_PERMS)
            cp(from, to)
        }
    }

    function getNthSegment(path: String, nth: Number) {
        let segments: Array = path.split(/(\\|\/)+/g)
        for (let i: Number = segments.length - 1; i >= 0; i--) {
            if (segments[0] == ".") {
                segments.remove(i, i)
            }
        }
        return segments[nth]
    }

    function command(command: String): String {
        let results
        try {
            results = System.run(command)
        } 
        catch (e) {
            msg = "Compilation failure, for " + command + "\n\n" +
                e.toString().replace(/Error Exception: Command failed: Status code [0-9]*.\n/, "")
            throw msg
        }
        return results
    }

    function traceFile(path: String, msg: String): Void {
        //  TODO - string method to add quotes would be useful
        trace(msg, '"' + path + '"')
    }

    function trace(tag: String, ...args): Void {
        if (verbose) {
            print("  " + tag + ": " + args.join(" "))
        }
    }

    //  TODO - share with rest of framework
    function plural(word: String): String {
        return word + "s"
    }
}


/*
 *  Templates for various files
 */
class Templates {
    
    /*
     ***************** ejsrc template ***********************
     */
    public static const Ejsrc =
'
{
    mode: "debug",

    cache: {
        enable: true,
        reload: true,
    },

    database: {
        class: "Database",
        adapter: "sqlite3",
        timeout: 5000,
        debug: {
            name: "db/${NAME}.sdb", username: "", password: "", trace: false,
        },
        test: {
            name: "db/${NAME}.sdb", username: "", password: "", trace: false,
        },
        production: {
            name: "db/${NAME}.sdb", username: "", password: "", trace: false,
        },
    },
    
    session: {
        enable: true,
        timeout: 1800,
    },

    mvc: {
        views: {
            connectors: {
                table: "html",
                chart: "google",
                rest: "html",
            },
            formats: {
                currency:   "$%10f",
                Date:       "%a %e %b %H:%M",
            },
        },
        webserver: \'"${WEBSERVER}" --ejs "/:${PATH}/" --log stdout:2\',
    },
}
'

    /*
     *****************  BaseController template ***********************
     */
    public static const BaseController = 
'/*
 *  BaseController.es - Base class for all controllers
 */
require ejs.web

public class BaseController extends Controller {

    public var title: String = "${NAME}"
    public var style: String

    function BaseController() {
        style = request.home.joine("/web/style.css")
    }
}
'


    /*
     *****************  Controller template ***********************
     */
    public static const Controller = 
'
require ejs.web

public class ${NAME}Controller extends BaseController {

    public var ${LOWER_MODEL}: ${MODEL}

    function ${NAME}Controller() {
    }

    use namespace action

    NEXT_ACTION
}
'


    /*
     *****************  ScaffoldController template ******************
     */
    public static const ScaffoldController = 
'
require ejs.web

public class ${NAME}Controller extends BaseController {

    public var ${LOWER_MODEL}: ${MODEL}

    function ${NAME}Controller() {
    }

    use namespace action

    action function index() { 
        renderView("list")
    }

    action function list() { 
    }

    action function edit() {
        ${LOWER_MODEL} = ${MODEL}.find(params.id)
    }

    action function create() {
        ${LOWER_MODEL} = new ${MODEL}
        renderView("edit")
    }

    action function update() {
        if (params.commit == "Cancel") {
            redirect("list")

        } else if (params.commit == "Delete") {
            destroy()

        } else if (params.id) {
            ${LOWER_MODEL} = ${MODEL}.find(params.id)
            if (${LOWER_MODEL}.saveUpdate(params.${LOWER_MODEL})) {
                inform("${MODEL} updated successfully.")
                redirect("list")
            } else {
                /* Validation failed */
                renderView("edit")
            }

        } else {
            ${LOWER_MODEL} = new ${MODEL}(params.${LOWER_MODEL})
            if (${LOWER_MODEL}.save()) {
                inform("New ${LOWER_MODEL} created")
                redirect("list")
            } else {
                renderView("edit")
            }
        }
    }

    action function destroy() {
        ${MODEL}.remove(params.id)
        inform("${MODEL} " + params.id + " removed")
        redirect("list")
    }

    NEXT_ACTION
}
'


    /*
     *****************  ScaffoldListView template ******************
     */
    public static const ScaffoldListView = 
'<h1>${MODEL} List</h1>

<% table(${MODEL}.findAll(), {click: "edit"}) %>
<br/>
<% buttonLink("New ${MODEL}", "create") %>
'


    /*
     *****************  ScaffoldEditView template ******************
     */
    public static const ScaffoldEditView = 
'<h1><%= (${LOWER_MODEL}.id) ? "Edit" : "Create" %> ${MODEL}</h1>

<% form("update", ${LOWER_MODEL}) %>

    <table border="0">
    <% for each (name in ${MODEL}.columnNames) {
        if (name == "id") continue
        uname = name.toPascal()
    %>
        <tr><td>@@uname</td><td><% input(name) %></td></tr>
    <% } %>
    </table>

    <% button("OK", "commit") %>
    <% button("Cancel", "commit") %>
    <% if (${LOWER_MODEL}.id) button("Delete", "commit") %>
<% endform() %>
'


    /*
     *****************  ScaffoldView template ******************
     */
    public static const ScaffoldView = 
'<h1>View "${CONTROLLER}/${VIEW}" for Model ${MODEL}</h1>
<p>Edit in "views/${CONTROLLER}/${VIEW}.ejs"</p>
'


    /*
     ***********************  Action template ***********************
     */
    public static const Action = '
    action function ${NAME}() {
    }

'


    /*
     ***********************  Model template ***********************
     */
    public static const Model = 
'/*
 *  ${NAME}.es - ${NAME} Model Class
 */

require ejs.db
require ejs.db.mapper

public dynamic class ${NAME} implements Record {

    function ${NAME}(fields: Object? = null) {
        constructor(fields)
    }
}
'


    /*
     ***********************  Migration template ***********************
     */
    public static const Migration = 
'/*
 *  ${COMMENT}
 */
require App
require ejs.db
require ejs.db.mapper

public class Migration {

    public function forward(db) {
${FORWARD}    }

    public function backward(db) {
${BACKWARD}
    }
}
'



    /*
     **************************** README template ***********************
     */
    public static const Readme = 
'
README - Overview of files and documentation generated by ejsmvc

These Directories are created via "ejsmvc generate app ${NAME}:"

    bin                       Programs and scripts
    cache                     Cached module files
    controllers               Controller source
    db                        SQL databases and database scripts
    db/migrations             SQL database migration scripts
    doc                       Documentation for the application
    ejsrc                     Primary configuration file
    logs                      Log files
    messages                  Internationalization messages
    models                    Database models
    src                       Extra application source
    test                      Test files
    views                     View source files
    views/layouts             View layout files
    web                       Public web directory
    web/themes                Theme style sheet directory

These files are also created:

    ejsrc                     Configuration file
    views/layouts/default.ejs Default template page for all views
    web/layout.css            Default layout style sheet
    web/themes/default.css    Default theme style sheet
    web/images/banner.jpg     Default UI banner
'


    /*
     ***************************  View header and footer templates ******************
     */
    public static const ViewHeader = 
'
require ejs.web

public dynamic class ${CONTROLLER}${VIEW}View extends View {
    function ${CONTROLLER}${VIEW}View(request: Request) {
        super(request)
    }

    override public function render(request: Request) {
'

    public static const ViewFooter = '
    }
}
'

    /*
     ***************************  start.es ****************************
     */
    public static const Start = 
'
require ejs.web
    
exports.app = function(request: Request) {
    router = new Router(Router.LegacyRoutes)
    router.route(request)
    Mvc.init(request)
    let controller = Controller.create(request)
    return controller.run(request)
}
'

    /*
     ***************************  src/App.es ****************************
     */
    public static const AppSrc = 
'
require ejs.db
require ejs.db.mapper
require ejs.web

module App {
}
'

    /*
     ***************************  Default Layout templates ******************
     */
    public static const DefaultLayout = 
'<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <meta http-equiv="content-type" content="text/html;charset=UTF-8" />
    <title>@@title</title>
    <% stylesheet(["web/layout.css", "web/themes/default.css" ]); %>
    <% script(["web/js/jquery.js", "web/js/jquery.tablesorter.js", "web/js/jquery.ejs.js"]) %>
</head>

<body>
    <div class="top">
        <h1><a href="@@request.home">${NAME} Application</a></h1>
    </div>
    <div id="logo">EJScript&trade;</div>

    <% flash(["inform", "error", "message", "warning"]) %>
    <div class="content">
        <%@ content %>
    </div>

    <div class="bottom">
        <p class="footnote">Powered by Ejscript&trade;</p>
    </div>
</body>
</html>
'

/* End of class Templates */
}


EjsMvc().main()

/*
    @copy   default
  
    Copyright (c) Embedthis Software LLC, 2003-2010. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2010. All Rights Reserved.
  
    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.
  
    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html
  
    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
  
    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com
  
    @end
 */
