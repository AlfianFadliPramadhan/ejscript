/*
    zlib.bit - Bit package for zlib
 */

let cfg
let path: Path = bit.packs.zlib.path
if (!path) {
    let vers = bit.dir.packs.join('zlib').glob('zlib-*').sort().reverse()
    path = vers[0]
}
path ||= Path('.')

if (bit.platform.os == 'win') {
    if (!path) {
        throw 'Can\'t find zlib source distribution'
    }
    let search = [path]
    let lib = probe('libz.dll', {fullpath: true, search: search}).absolute
    let dir = lib.parent
    search = [path]
    let incdir = probe('zlib.h', {search: search}).absolute
    cfg = {
        dir: dir,
        path: lib,
        includes: [ incdir ],
        libraries: [ 'z' ],
        libpaths: [ lib.parent ],
        imports: [ lib.parent.join('libz.dll'), lib.parent.join('libz.lib') ],
    }

} else if (bit.platform.os == 'macosx') {
    let search = [path, '/usr/lib']
    let lib = probe('libz.dylib', {fullpath: true, search: search}).absolute
    let dir = lib.parent
    search = [path, '/usr/include']
    let incdir = probe('zlib.h', {search: search}).absolute
    cfg = {
        dir: dir,
        path: lib,
        includes: [ incdir ],
        libraries: [ 'z' ],
        libpaths: [ lib.parent ],
        imports: lib.parent.glob('libz*.dylib')
    }

} else {
    let arch = bit.platform.arch.match(/^i.86$/) ? 'x86' : bit.platform.arch
    let search = [path, '/usr/lib', '/lib' ] + 
        Path('/usr/lib').glob(arch + '-linux-gnu') +
        Path('/lib').glob(arch + '-linux-gnu')
    let lib = probe('libz.so', {fullpath: true, search: search}).absolute
    let dir = lib.parent
    search = [path.join('include'), '/usr/include']
    let incdir = probe('zlib.h', {search: search}).absolute
    cfg = {
        dir: dir,
        path: lib,
        includes: [ incdir ],
        libraries: [ 'z' ],
        libpaths: [ lib.parent ],
        imports: lib.parent.glob('libz*.so*'),
    }
}

let template = {packs: { zlib: cfg}}
Bit.load(template)
