/*
    compiler.bit - Compile package for Bit
 */
var cc: Path
let platform = bit.platform

if (platform.like == 'posix') {
    if (!bit.emulating) {
        cc = probe('cc', {fullpath: true})
    } else {
        cc = 'cc'
    }
    Bit.load({packs: { compiler: { path: cc }}})

} else if (platform.like == 'windows') {
    let search = bit.dir.programs.glob('Microsoft Visual Studio*\\VC\\Bin')

/*
    if (platform.arch == 'x86_64') {
        if (CROSS) {
            search.map(function(e) Path(e).join('x86_64'))
        } else {
            search.map(function(e) Path(e).join('amd64'))
        }
    } else {
        search.map(function(e) Path(e).join('amd64'))
    }
*/
    let vsdir: Path
    if (bit.emulating) {
        cc = 'cl'
        vsdir = Path('$(VS)')
    } else {
        cc = probe('cl.exe', {fullpath: true, search: search.sort().reverse()})
        vsdir = cc.dirname.dirname.dirname
    }
    Bit.load({packs: { compiler: { path: cc }}})

    bit.env.PATH += [
        vsdir.join('VC\\Bin').map('\\'),
        vsdir.join('Common7\\IDE').map('\\'),
        vsdir.join('Common7\\Tools').map('\\'),
        vsdir.join('SDK\\v3.5\\bin').map('\\'),
        vsdir.join('VC\\VCPackages').map('\\'),
    ]
    bit.env.INCLUDE += [
        vsdir.join('VC\\INCLUDE').map('\\')
    ]
    bit.env.LIB += [
        Path(vsdir.join('VC\\lib').map('\\').toString().replace(/x86_amd64/, 'amd64'))
    ]

} else if (platform.os == 'vxworks') {
    let name
    if (platform.arch.match(/^i386$|^i486$/)) {
        name = 'cc386'
    } else if (platform.arch.match(/^i[56]86$/)) {
        name = 'ccpentium'
    } else if (platform.arch.match(/^ppc/)) {
        name = 'ccppc'
    } else if (platform.arch.match(/^xscale|^arm/)) {
        name = 'ccarm'
    } else if (platform.arch.match(/^68/)) {
        name = 'cc68k'
    } else if (platform.arch.match(/^sh/)) {
        name = 'ccsh'
    } else if (platform.arch.match(/^mips$/)) {
        name = 'ccmips'
    } else {
        throw 'Unsupported CPU architecture: ' + platform.arch
    }
    cc = probe(name, {fullpath: true, search: bit.packs.vxworks.search})
    Bit.load({packs: { compiler: { path: cc }}})
}

let settings = {}

if (bit.emulating) {
    if (platform.like == 'windows') {
        settings = {
            hasMmu: true,
            hasDynLoad: true,
            hasUnnamedUnions: true,
        }
    } else if (platform.os == 'linux') {
        settings = {
            hasDoubleBraces: false,
            hasDynLoad: true,
            hasMmu: true,
            hasMtune: true,
            hasPam: true,
            hasStackProtector: true,
            hasSync: true,
            hasSyncCas: true,
            hasUnnamedUnions: true,
            warn64to32: false,
            warnUnused: true,
        }
    } else if (platform.os == 'macosx') {
        settings = {
            hasDoubleBraces: true,
            hasDynLoad: true,
            hasMmu: true,
            hasMtune: true,
            hasPam: false,
            hasStackProtector: true,
            hasSync: true,
            hasSyncCas: true,
            hasUnnamedUnions: true,
            warn64to32: false,
            warnUnused: false,
        }
    }
} else if (platform.like == 'posix' || platform.os == 'vxworks') {
    settings.hasDoubleBraces = compile(cc, '', '#include <stdarg.h>\nva_list d = {{0}};')
    //  MOB - if env CFLAGS has -mtune=xxx then it should be used instead
    settings.hasMtune = compile(cc, '-mtune=generic', 'int main() { return 0;}')
    settings.hasStackProtector = compile(cc, '-fno-stack-protector', 'int main() { return 0;}')
    settings.hasSync = compile(cc, '', '#include <stdio.h>\nint main() { __sync_synchronize(); return 0; }')
    settings.warnUnused = compile(cc, '-Wno-unused-result',
        '#include <stdio.h>\n#include <stdlib.h>\nint main() { realloc(0, 1024); return 0; }')
    settings.warn64to32 = compile(cc, '-Wshorten-64-to-32', 'int main() { return 0;}')

    if (platform.os != 'vxworks') {
        settings.hasDynLoad = compile(cc, '',
            '#include <stdio.h>\n#include <dlfcn.h>\nint main() { dlopen(\"test.so\", 0); return 0; }')
        settings.hasLibEdit = compile(cc, '',
            '#include <histedit.h>\nint main() { history_init(); return 0; }')
        settings.hasMmu = compile(cc, '',
            '#include <stdio.h>\n#include <unistd.h>\nint main() { fork(); return 0; }')
        settings.hasPam = compile(cc, '',
            'extern pam_start(); \nint main() { void *x = pam_start; return 0; }')
        settings.hasSyncCas = compile(cc, '',
            '#include <stdio.h>\nint main() { void *ptr; __sync_bool_compare_and_swap(&ptr, ptr, ptr); return 0; }')
        settings.hasUnnamedUnions = compile(cc, '', 
            '#include <stdio.h>\nint main() { struct test { union { int x; int y; };}; return 0; }')
    }
} else if (platform.like == 'windows') {
    settings = {
        hasMmu: true,
        hasDynLoad: true,
        hasUnnamedUnions: true,
    }
}
Bit.load({ settings: settings })

/*
    Test compile to determine supported compiler switches
 */
function compile(cc: Path, command: String, contents: String = null): Boolean {
    //  MOB - what dir for temp file
    let file
    if (contents) {
        file = Path('/tmp/bit-' + App.pid + '.c')
        if (bit.platform.os == 'VXWORKS') {
            contents = '#define _VSB_CONFIG_FILE "vsbConfig.h\n' + contents
        }
        file.write(contents + '\n')
        command += ' -c ' + file
    }
    command = '' + cc + ' -Werror -Wall ' + command
    let cmd
    try {
        cmd = new Cmd
        cmd.env = bit.env
        cmd.start(command)
        if (cmd.status != 0) {
            App.log.debug(3, "Test " + command)
            App.log.debug(3, "Compiler package test compile result: " + cmd.error)
        }
    } finally {
        if (file) {
            file.remove()
            file.basename.replaceExt('o').remove()
        }
    }
    return cmd.status == 0
}

