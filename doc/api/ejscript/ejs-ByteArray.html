<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
   <title>Class ByteArray</title>

   <link rel="stylesheet" type="text/css" href="doc.css" />
</head>

<body>
<div class='body'>

<div class="content">

<a name='top'></a>
<h1 class='className'>ByteArray</h1>
<div class='classBlock'>
<table class='classHead' summary='ByteArray'>
   <tr><td><strong>Module</strong></td><td>ejs</td></tr>
   <tr><td><strong>Definition</strong></td><td>final  class ByteArray</td></tr>
   <tr><td><strong>Inheritance</strong></td><td>ByteArray <img src='images/inherit.gif' alt='inherit'/> <a href='ejs-Object.html'>Object</a><tr><td><strong>Specified</strong></td><td>ejscript-2.0</td></tr>
<tr><td><strong>Stability</strong></td><td>Evolving.</td></tr>
       </td></tr>
</table>

<p class='classBrief'>ByteArrays provide a resizable, integer indexed, in-memory store for bytes.</p>

<p class='classDescription'>ByteArrays can be used as a simple 
array type to store and encode data as bytes or they can be used as buffered loop-back Streams.<br/><br/>When used as a simple byte array, the ByteArray class offers a low level set of methods to insert and 
extract bytes. The index operator [] can be used to access individual bytes and the copyIn and copyOut methods 
can be used to get and put blocks of data. In this mode, the <a href='#readPosition'>readPosition</a> and <a href='#writePosition'>writePosition</a> properties are ignored.<br/><br/>Access to the byte array is from index zero up to the size defined by the length property. When constructed, 
the ByteArray can be designated as resizable, in which case the initial size will grow as required to accomodate 
data and the length property will be updated accordingly.<br/><br/>ByteArrays provide additional write methods to store data at the location specified by the <a href='#writePosition'>writePosition</a> 
property and read methods to read from the <a href='#readPosition'>readPosition</a> property. The <a href='#available'>available</a> property indicates how much 
data is available between the read and write position pointers. The <a href='#reset'>reset</a> method can reset the pointers to 
the start of the array.  When used with for/in, ByteArrays will iterate or enumerate over the available 
data between the read and write pointers.<br/><br/>If numeric values are read or written, they will be coded according to the value of the endian property 
which can be set to either LittleEndian or BigEndian.  If strings values are read or written, they will 
be encoded according to the value of the character set <a href='#encoding'>encoding</a> property.<br/><br/>When used as loop-back streams, data written to ByteArrays is immediately available for reading. 
ByteArrays can be run in sync or async mode. ByteArrays will issue events for key state transitions such as 
close, eof, readable and writable events. All event observers are called with the following signature:
function callback(event: String, ba: ByteArray): Void.</p>

</div>


<hr />
<a name='Properties'></a>
<h2 class='classSection'>Properties</h2>
<table class='itemTable' summary='properties'>
   <tr><th>Qualifiers</th><th>Property</th><th>Type</th><th width='95%'>Description</th></tr>
<a name='BigEndian'></a>
   <tr><td nowrap align='center'>public static const </td><td>BigEndian</td><td><a href='ejs-Number.html'>Number</a></td><td>Big endian byte order used for the <a href='#endian'>endian</a> property. null</td></tr>
<a name='LittleEndian'></a>
   <tr><td nowrap align='center'>public static const </td><td>LittleEndian</td><td><a href='ejs-Number.html'>Number</a></td><td>Little endian byte order used for the <a href='#endian'>endian</a> property. null</td></tr>
<a name='available'></a>
   <tr><td nowrap align='left'>public const get </td><td>available</td><td><a href='ejs-Number.html'>Number</a></td><td>Number of bytes that are currently available for reading. This consists of the bytes available
from the current <a href='#readPosition'>readPosition</a> up to the current <a href='#writePosition'>writePosition</a>. </td></tr>
<a name='length'></a>
   <tr><td nowrap align='left'>public const get </td><td>length</td><td><a href='ejs-Number.html'>Number</a></td><td>Length of the byte array. This is not the amount of read or write data, but is the size of the total 
array storage.</td></tr>
<a name='MD5'></a>
   <tr><td nowrap align='left'>public const get </td><td>MD5</td><td><a href='ejs-String.html'>String</a></td><td>An MD5 checksum for the buffer contents. null</td></tr>
<a name='resizable'></a>
   <tr><td nowrap align='left'>public const get </td><td>resizable</td><td><a href='ejs-Boolean.html'>Boolean</a></td><td>Is the ByteArray is resizable. null</td></tr>
<a name='room'></a>
   <tr><td nowrap align='left'>public const get </td><td>room</td><td><a href='ejs-Number.html'>Number</a></td><td>Number of data bytes that the array can store from the <a href='#writePosition'>writePosition</a> till the end of the array. null</td></tr>
</table>

<p class='inheritedLink'><a href='ejs-Object.html#Properties'><i>Inherited Properties</i></a></p>

<hr />
<a name='Methods'></a>
<h2 class='classSection'>ByteArray Methods</h2>
<table class='apiIndex' summary='methods'>
   <tr><th>Qualifiers</th><th width='95%'>Method</th></tr>
   <tr class='apiDef'><td class='apiType'>final </td><td><a href='#ByteArray'><b>ByteArray</b></a>(size: <a href='ejs-Number.html'>Number</a> = -1 , resizable: <a href='ejs-Boolean.html'>Boolean</a> = true)</tr><tr class='apiBrief'><td>&nbsp;</td><td>Create a new array.</td></tr>
   <tr class='apiDef'><td class='apiType'>final </td><td><a href='#ByteArray'><b>ByteArray</b></a>(size: <a href='ejs-Number.html'>Number</a> = -1 , resizable: <a href='ejs-Boolean.html'>Boolean</a> = true)</tr><tr class='apiBrief'><td>&nbsp;</td><td>Create a new array.</td></tr>
   <tr class='apiDef'><td class='apiType'>public const </td><td><a href='#close'><b>close</b></a>(): <a href='ejs-Void.html'>Void</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Close the stream.</td></tr>
   <tr class='apiDef'><td class='apiType'>public const </td><td><a href='#compact'><b>compact</b></a>(): <a href='ejs-Void.html'>Void</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Compact available data down and adjust the read/write positions accordingly.</td></tr>
   <tr class='apiDef'><td class='apiType'>public const </td><td><a href='#copyIn'><b>copyIn</b></a>(destOffset: <a href='ejs-Number.html'>Number</a>, src: <a href='ejs-ByteArray.html'>ByteArray</a>, srcOffset: <a href='ejs-Number.html'>Number</a> = 0 , count: <a href='ejs-Number.html'>Number</a> = -1): <a href='ejs-Number.html'>Number</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Copy data into the array.</td></tr>
   <tr class='apiDef'><td class='apiType'>public const </td><td><a href='#copyOut'><b>copyOut</b></a>(srcOffset: <a href='ejs-Number.html'>Number</a>, dest: <a href='ejs-ByteArray.html'>ByteArray</a>, destOffset: <a href='ejs-Number.html'>Number</a> = 0 , count: <a href='ejs-Number.html'>Number</a> = -1): <a href='ejs-Number.html'>Number</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Copy data from the array.</td></tr>
   <tr class='apiDef'><td class='apiType'>public const </td><td><a href='#flush'><b>flush</b></a>(dir: <a href='ejs-Number.html'>Number</a> = expression): <a href='ejs-Void.html'>Void</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Flush (discard) the data in the byte array and reset the read and write positions.</td></tr>
   <tr class='apiDef'><td class='apiType'>iterator const override </td><td><a href='#get'><b>get</b></a>(): <a href='iterator-Iterator.html'>Iterator</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Iterator for this array to be used by "for (v in array)".</td></tr>
   <tr class='apiDef'><td class='apiType'>iterator const override </td><td><a href='#getValues'><b>getValues</b></a>(): <a href='iterator-Iterator.html'>Iterator</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Iterator for this array to be used by "for each (v in array)".</td></tr>
   <tr class='apiDef'><td class='apiType'>public const </td><td><a href='#off'><b>off</b></a>(name: <a href='ejs-Object.html'>Object</a>, observer: <a href='ejs-Function.html'>Function</a>): <a href='ejs-Void.html'>Void</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Remove an observer from the stream.</td></tr>
   <tr class='apiDef'><td class='apiType'>public const </td><td><a href='#on'><b>on</b></a>(name: <a href='ejs-Object.html'>Object</a>, observer: <a href='ejs-Function.html'>Function</a>): <a href='ejs-Void.html'>Void</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Add an observer to the stream for the named events.</td></tr>
   <tr class='apiDef'><td class='apiType'>public const </td><td><a href='#read'><b>read</b></a>(buffer: <a href='ejs-ByteArray.html'>ByteArray</a>, offset: <a href='ejs-Number.html'>Number</a> = 0 , count: <a href='ejs-Number.html'>Number</a> = -1): <a href='ejs-Number.html'>Number</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Read a data from the stream.Data is read from the current read <a href='#position'>position</a> pointer toward the current <a href='#writePosition'>writePosition</a>. </td></tr>
   <tr class='apiDef'><td class='apiType'>public const </td><td><a href='#readBoolean'><b>readBoolean</b></a>(): <a href='ejs-Boolean.html'>Boolean</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Read a boolean from the array.</td></tr>
   <tr class='apiDef'><td class='apiType'>public const </td><td><a href='#readByte'><b>readByte</b></a>(): <a href='ejs-Number.html'>Number</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Read a byte from the array.</td></tr>
   <tr class='apiDef'><td class='apiType'>public const </td><td><a href='#readDate'><b>readDate</b></a>(): <a href='ejs-Date.html'>Date</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Read a date from the array.</td></tr>
   <tr class='apiDef'><td class='apiType'>public const </td><td><a href='#readDouble'><b>readDouble</b></a>(): <a href='ejs-Date.html'>Date</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Read a double from the array.</td></tr>
   <tr class='apiDef'><td class='apiType'>public const </td><td><a href='#readInteger'><b>readInteger</b></a>(): <a href='ejs-Number.html'>Number</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Read an 32-bit integer from the array.</td></tr>
   <tr class='apiDef'><td class='apiType'>public const </td><td><a href='#readLong'><b>readLong</b></a>(): <a href='ejs-Number.html'>Number</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Read a 64-bit long from the array.The data will be decoded according to the endian property.</td></tr>
   <tr class='apiDef'><td class='apiType'>public const </td><td><a href='#readShort'><b>readShort</b></a>(): <a href='ejs-Number.html'>Number</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Read a 16-bit short integer from the array.The data will be decoded according to the endian property.</td></tr>
   <tr class='apiDef'><td class='apiType'>public const </td><td><a href='#readString'><b>readString</b></a>(count: <a href='ejs-Number.html'>Number</a> = -1): <a href='ejs-String.html'>String</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Read a data from the array as a string.</td></tr>
   <tr class='apiDef'><td class='apiType'>public const </td><td><a href='#readXML'><b>readXML</b></a>(): <a href='ejs-XML.html'>XML</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Read an XML document from the array.</td></tr>
   <tr class='apiDef'><td class='apiType'>public const </td><td><a href='#reset'><b>reset</b></a>(): <a href='ejs-Void.html'>Void</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Reset the read and <a href='#writePosition'>writePosition</a> pointers if there is no available data.</td></tr>
   <tr class='apiDef'><td class='apiType'>public const override </td><td><a href='#toString'><b>toString</b></a>(): <a href='ejs-String.html'>String</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Convert the data in the byte array between the <a href='#readPosition'>readPosition</a> and writePosition.</td></tr>
   <tr class='apiDef'><td class='apiType'>public const </td><td><a href='#write'><b>write</b></a>(data: <a href='ejs-Array.html'>Array</a>): <a href='ejs-Number.html'>Number</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Write data to the stream.Write data to the ByteArray.</td></tr>
   <tr class='apiDef'><td class='apiType'>public const </td><td><a href='#writeByte'><b>writeByte</b></a>(data: <a href='ejs-Number.html'>Number</a>): <a href='ejs-Void.html'>Void</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Write a byte to the array.</td></tr>
   <tr class='apiDef'><td class='apiType'>public const </td><td><a href='#writeDouble'><b>writeDouble</b></a>(data: <a href='ejs-Number.html'>Number</a>): <a href='ejs-Void.html'>Void</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Write a double to the array.</td></tr>
   <tr class='apiDef'><td class='apiType'>public const </td><td><a href='#writeInteger'><b>writeInteger</b></a>(data: <a href='ejs-Number.html'>Number</a>): <a href='ejs-Void.html'>Void</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Write a 32-bit integer to the array.</td></tr>
   <tr class='apiDef'><td class='apiType'>public const </td><td><a href='#writeLong'><b>writeLong</b></a>(data: <a href='ejs-Number.html'>Number</a>): <a href='ejs-Void.html'>Void</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Write a 64 bit long integer to the array.</td></tr>
   <tr class='apiDef'><td class='apiType'>public const </td><td><a href='#writeShort'><b>writeShort</b></a>(data: <a href='ejs-Number.html'>Number</a>): <a href='ejs-Void.html'>Void</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Write a short to the array.</td></tr>
</table>

<p class='inheritedLink'><a href='ejs-Object.html#Methods'><i>Inherited Methods</i></a></p>

<hr />
<h2>Method Detail</h2>
<a name='ByteArray'></a>
<div class='api'>
<div class='apiSig'>final   ejs  ByteArray(size: <a href='ejs-Number.html'>Number</a> = -1 , resizable: <a href='ejs-Boolean.html'>Boolean</a> = true)
</div>
<div class='apiDetail'>
<p>Create a new array.</p>
<dl><dt>Parameters</dt>
<dd><table class='parameters' summary ='parameters'>
<tr class='param'><td class='param'>size: <a href='ejs-Number.html'>Number</a> </td><td>The initial size of the byte array. If not supplied a default buffer size will be used which is typically 4K or larger. [default: -1 ]</td></tr><tr class='param'><td class='param'>resizable: <a href='ejs-Boolean.html'>Boolean</a> </td><td>Set to true to automatically grow the array as required to fit written data. [default: true]</td></tr></table></dd>
</dl></div>
</div>
<hr />
<a name='ByteArray'></a>
<div class='api'>
<div class='apiSig'>final   ejs  ByteArray(size: <a href='ejs-Number.html'>Number</a> = -1 , resizable: <a href='ejs-Boolean.html'>Boolean</a> = true)
</div>
<div class='apiDetail'>
<p>Create a new array.</p>
<dl><dt>Parameters</dt>
<dd><table class='parameters' summary ='parameters'>
<tr class='param'><td class='param'>size: <a href='ejs-Number.html'>Number</a> </td><td>The initial size of the byte array. If not supplied a default buffer size will be used which is typically 4K or larger. [default: -1 ]</td></tr><tr class='param'><td class='param'>resizable: <a href='ejs-Boolean.html'>Boolean</a> </td><td>Set to true to automatically grow the array as required to fit written data. [default: true]</td></tr></table></dd>
</dl></div>
</div>
<hr />
<a name='close'></a>
<div class='api'>
<div class='apiSig'>const   public  close(): <a href='ejs-Void.html'>Void</a>
</div>
<div class='apiDetail'>
<p>Close the stream.</p>
<dl><dt>Events</dt>
<dd><table class='parameters' summary ='events'>
<td class='param'>close</td><td>A close event is issued before closing the stream.</td></tr>
</table></dd>
</dl></div>
</div>
<hr />
<a name='compact'></a>
<div class='api'>
<div class='apiSig'>const   public  compact(): <a href='ejs-Void.html'>Void</a>
</div>
<div class='apiDetail'>
<p>Compact available data down and adjust the read/write positions accordingly.</p>
<dl><dt>Description</dt><dd>This sets the read pointer 
to the zero index and adjusts the write pointer by the corresponding amount.</dd></dl>
</div>
</div>
<hr />
<a name='copyIn'></a>
<div class='api'>
<div class='apiSig'>const   public  copyIn(destOffset: <a href='ejs-Number.html'>Number</a>, src: <a href='ejs-ByteArray.html'>ByteArray</a>, srcOffset: <a href='ejs-Number.html'>Number</a> = 0 , count: <a href='ejs-Number.html'>Number</a> = -1): <a href='ejs-Number.html'>Number</a>
</div>
<div class='apiDetail'>
<p>Copy data into the array.</p>
<dl><dt>Description</dt><dd>This is a low-level data copy routine that does not update read and write positions.
Data is written at the destOffset index. This call does not issue events unless required to make room
for the incoming data ("readable" event).</dd></dl>
<dl><dt>Parameters</dt>
<dd><table class='parameters' summary ='parameters'>
<tr class='param'><td class='param'>destOffset: <a href='ejs-Number.html'>Number</a> </td><td>Index in the destination byte array to copy the data to.</td></tr><tr class='param'><td class='param'>src: <a href='ejs-ByteArray.html'>ByteArray</a> </td><td>Source byte array containing the data elements to copy.</td></tr><tr class='param'><td class='param'>srcOffset: <a href='ejs-Number.html'>Number</a> </td><td>Location in the source buffer from which to copy the data. Defaults to the start. [default: 0 ]</td></tr><tr class='param'><td class='param'>count: <a href='ejs-Number.html'>Number</a> </td><td>Number of bytes to copy. Set to -1 to read all the src buffer. [default: -1]</td></tr></table></dd>
</dl><dl><dt>Returns</dt>
<dd>The number of bytes written into the array. If the array is not resizable and there is insufficient room, this may be less than the requested amount.</dd></dl>
</div>
</div>
<hr />
<a name='copyOut'></a>
<div class='api'>
<div class='apiSig'>const   public  copyOut(srcOffset: <a href='ejs-Number.html'>Number</a>, dest: <a href='ejs-ByteArray.html'>ByteArray</a>, destOffset: <a href='ejs-Number.html'>Number</a> = 0 , count: <a href='ejs-Number.html'>Number</a> = -1): <a href='ejs-Number.html'>Number</a>
</div>
<div class='apiDetail'>
<p>Copy data from the array.</p>
<dl><dt>Description</dt><dd>Data is copied from the srcOffset pointer. This call does not update the 
read and write positions. This call does not issue events.</dd></dl>
<dl><dt>Parameters</dt>
<dd><table class='parameters' summary ='parameters'>
<tr class='param'><td class='param'>srcOffset: <a href='ejs-Number.html'>Number</a> </td><td>Location in the source array from which to copy data.</td></tr><tr class='param'><td class='param'>dest: <a href='ejs-ByteArray.html'>ByteArray</a> </td><td>Destination byte array.</td></tr><tr class='param'><td class='param'>destOffset: <a href='ejs-Number.html'>Number</a> </td><td>Location in the destination array to copy the data. Defaults to the start. [default: 0 ]</td></tr><tr class='param'><td class='param'>count: <a href='ejs-Number.html'>Number</a> </td><td>Number of bytes to read. Set to -1 to read all available data. [default: -1]</td></tr></table></dd>
</dl><dl><dt>Returns</dt>
<dd>The count of bytes read. Returns null on eof.</dd></dl>
</div>
</div>
<hr />
<a name='flush'></a>
<div class='api'>
<div class='apiSig'>const   public  flush(dir: <a href='ejs-Number.html'>Number</a> = expression): <a href='ejs-Void.html'>Void</a>
</div>
<div class='apiDetail'>
<p>Flush (discard) the data in the byte array and reset the read and write positions.</p>
<dl><dt>Description</dt><dd>This call may block if the stream is in sync mode.</dd></dl>
<dl><dt>Parameters</dt>
<dd><table class='parameters' summary ='parameters'>
<tr class='param'><td class='param'>dir: <a href='ejs-Number.html'>Number</a> </td><td>The dir parameter is Ignored. Flushing a ByteArray in either direction the same effect of  discarding all buffered data and resetting the read and write positions -- so this argument is ignored. [default: expression]</td></tr></table></dd>
</dl></div>
</div>
<hr />
<a name='get'></a>
<div class='api'>
<div class='apiSig'>const override   iterator  get(): <a href='iterator-Iterator.html'>Iterator</a>
</div>
<div class='apiDetail'>
<p>Iterator for this array to be used by "for (v in array)".</p>
<dl><dt>Description</dt><dd>This will return array indicies.</dd></dl>
</div>
</div>
<hr />
<a name='getValues'></a>
<div class='api'>
<div class='apiSig'>const override   iterator  getValues(): <a href='iterator-Iterator.html'>Iterator</a>
</div>
<div class='apiDetail'>
<p>Iterator for this array to be used by "for each (v in array)".</p>
<dl><dt>Description</dt><dd>This will return read data in the array.</dd></dl>
</div>
</div>
<hr />
<a name='off'></a>
<div class='api'>
<div class='apiSig'>const   public  off(name: <a href='ejs-Object.html'>Object</a>, observer: <a href='ejs-Function.html'>Function</a>): <a href='ejs-Void.html'>Void</a>
</div>
<div class='apiDetail'>
<p>Remove an observer from the stream.</p>
<dl><dt>Parameters</dt>
<dd><table class='parameters' summary ='parameters'>
<tr class='param'><td class='param'>name: <a href='ejs-Object.html'>Object</a> </td><td>Event name previously used with observe. The name may be an array of events.</td></tr><tr class='param'><td class='param'>observer: <a href='ejs-Function.html'>Function</a> </td><td>Observer function previously used with observe.</td></tr></table></dd>
</dl></div>
</div>
<hr />
<a name='on'></a>
<div class='api'>
<div class='apiSig'>const   public  on(name: <a href='ejs-Object.html'>Object</a>, observer: <a href='ejs-Function.html'>Function</a>): <a href='ejs-Void.html'>Void</a>
</div>
<div class='apiDetail'>
<p>Add an observer to the stream for the named events.</p>
<dl><dt>Parameters</dt>
<dd><table class='parameters' summary ='parameters'>
<tr class='param'><td class='param'>name: <a href='ejs-Object.html'>Object</a> </td><td>Name of the event to listen for. The name may be an array of events.</td></tr><tr class='param'><td class='param'>observer: <a href='ejs-Function.html'>Function</a> </td><td>Callback observer function. The function is called with the following signature: function observer(event: String, ...args): Void.</td></tr></table></dd>
</dl><dl><dt>Events</dt>
<dd><table class='parameters' summary ='events'>
<td class='param'>readable</td><td>Issued when the stream becomes readable.</td></tr>
<td class='param'>writable</td><td>Issued when the stream becomes writable.</td></tr>
<td class='param'>close</td><td>Issued when stream is being closed.</td></tr>
</table></dd>
</dl></div>
</div>
<hr />
<a name='read'></a>
<div class='api'>
<div class='apiSig'>const   public  read(buffer: <a href='ejs-ByteArray.html'>ByteArray</a>, offset: <a href='ejs-Number.html'>Number</a> = 0 , count: <a href='ejs-Number.html'>Number</a> = -1): <a href='ejs-Number.html'>Number</a>
</div>
<div class='apiDetail'>
<p>Read a data from the stream.Data is read from the current read <a href='#position'>position</a> pointer toward the current <a href='#writePosition'>writePosition</a>. </p>
<dl><dt>Description</dt><dd>If data is available, the call will return immediately. 
If no data is available and the stream is in sync mode, the call will block until data is available.
If no data is available and the stream is in async mode, the call will not block and will return immediately.
In this case a "readable" event will be issued when data is available for reading.This byte array's <a href='#readPosition'>readPosition</a> is updated. If offset is < 0, then data is copied to the destination buffer's 
<a href='#writePosition'>writePosition</a> and the destination buffer's <a href='#writePosition'>writePosition</a> is also updated. If the offset is >= 0, the 
read position is set to the specified offset and data is stored at this offset. The write position is set to
one past the last byte read.</dd></dl>
<dl><dt>Parameters</dt>
<dd><table class='parameters' summary ='parameters'>
<tr class='param'><td class='param'>buffer: <a href='ejs-ByteArray.html'>ByteArray</a> </td><td>Destination byte array for read data.</td></tr><tr class='param'><td class='param'>offset: <a href='ejs-Number.html'>Number</a> </td><td>Offset in the byte array to place the data. If the offset is -1, then data is appended to the buffer write <a href='#position'>position</a> which is then updated [default: 0 ]</td></tr><tr class='param'><td class='param'>count: <a href='ejs-Number.html'>Number</a> </td><td>Read up to this number of bytes. If -1, read as much as the buffer will hold up. If the  stream is of fixed and known length (such as a file) and the buffer is of sufficient size or is growable,  read the entire stream. [default: -1]</td></tr><tr class='param'><td class='param'>offset: <a href='ejs-Number.html'>Number</a> </td><td>null [default: 0 ]</td></tr><tr class='param'><td class='param'>count: <a href='ejs-Number.html'>Number</a> </td><td>null [default: -1]</td></tr></table></dd>
</dl><dl><dt>Events</dt>
<dd><table class='parameters' summary ='events'>
<td class='param'>readable</td><td>Issued when there is new read data available.</td></tr>
<td class='param'>writable</td><td>Issued when the stream becomes empty.</td></tr>
</table></dd>
</dl><dl><dt>Returns</dt>
<dd>A count of the bytes actually read. Returns null on eof.</dd></dl>
</div>
</div>
<hr />
<a name='readBoolean'></a>
<div class='api'>
<div class='apiSig'>const   public  readBoolean(): <a href='ejs-Boolean.html'>Boolean</a>
</div>
<div class='apiDetail'>
<p>Read a boolean from the array.</p>
<dl><dt>Description</dt><dd>Data is read from the current read <a href='#position'>position</a> pointer.
If insufficient data, a "writable" event will be issued indicating that the byte array is writable. This enables 
observers to write data into the byte array.  If there is no data available, the call 
will return return null indicating eof.</dd></dl>
<dl><dt>Returns</dt>
<dd>A boolean or null on eof.</dd></dl>
<dl><dt>Throws</dt><dd>
<a href='ejs-IOError.html'>IOError</a>: if an I/O error occurs or premature eof. 
</dd>
</dl></div>
</div>
<hr />
<a name='readByte'></a>
<div class='api'>
<div class='apiSig'>const   public  readByte(): <a href='ejs-Number.html'>Number</a>
</div>
<div class='apiDetail'>
<p>Read a byte from the array.</p>
<dl><dt>Description</dt><dd>Data is read from the current read <a href='#position'>position</a> pointer.
If insufficient data, a "write" event will be issued indicating that the byte array is 
writable.  This enables observers to write data into the byte array.  If there is no data available, the call 
will return return null indicating eof.</dd></dl>
<dl><dt>Throws</dt><dd>
<a href='ejs-IOError.html'>IOError</a>: if an I/O error occurs or premature eof. 
</dd>
</dl></div>
</div>
<hr />
<a name='readDate'></a>
<div class='api'>
<div class='apiSig'>const   public  readDate(): <a href='ejs-Date.html'>Date</a>
</div>
<div class='apiDetail'>
<p>Read a date from the array.</p>
<dl><dt>Description</dt><dd>Data is read from the current read <a href='#position'>position</a> pointer.
If insufficient data, a "write" event will be issued indicating that the byte array is 
writable.  This enables observers to write data into the byte array.  If there is no data available, the call 
will return return null indicating eof.</dd></dl>
<dl><dt>Throws</dt><dd>
<a href='ejs-IOError.html'>IOError</a>: if an I/O error occurs or premature eof. 
</dd>
</dl></div>
</div>
<hr />
<a name='readDouble'></a>
<div class='api'>
<div class='apiSig'>const   public  readDouble(): <a href='ejs-Date.html'>Date</a>
</div>
<div class='apiDetail'>
<p>Read a double from the array.</p>
<dl><dt>Description</dt><dd>The data will be decoded according to the endian property. Data is read 
from the current read <a href='#position'>position</a> pointer. If insufficient data, a "write" event will be issued indicating 
that the byte array is writable. This enables observers to write data into the byte array. If there is 
no data available, the call will return return null indicating eof.</dd></dl>
<dl><dt>Returns</dt>
<dd>A double or null on eof.</dd></dl>
<dl><dt>Throws</dt><dd>
<a href='ejs-IOError.html'>IOError</a>: if an I/O error occurs or premature eof. 
</dd>
</dl></div>
</div>
<hr />
<a name='readInteger'></a>
<div class='api'>
<div class='apiSig'>const   public  readInteger(): <a href='ejs-Number.html'>Number</a>
</div>
<div class='apiDetail'>
<p>Read an 32-bit integer from the array.</p>
<dl><dt>Description</dt><dd>The data will be decoded according to the endian property.
Data is read from the current read <a href='#position'>position</a> pointer.
If insufficient data, a "write" event will be issued indicating that the byte array is 
writable.  This enables observers to write data into the byte array.  If there is no data available, the call 
will return return null indicating eof.</dd></dl>
<dl><dt>Throws</dt><dd>
<a href='ejs-IOError.html'>IOError</a>: if an I/O error occurs or premature eof. 
</dd>
</dl></div>
</div>
<hr />
<a name='readLong'></a>
<div class='api'>
<div class='apiSig'>const   public  readLong(): <a href='ejs-Number.html'>Number</a>
</div>
<div class='apiDetail'>
<p>Read a 64-bit long from the array.The data will be decoded according to the endian property.</p>
<dl><dt>Description</dt><dd>Data is read from the current read <a href='#position'>position</a> pointer.
If insufficient data, a "write" event will be issued indicating that the byte array is 
writable.  This enables observers to write data into the byte array.  If there is no data available, the call 
will return return null indicating eof.</dd></dl>
<dl><dt>Throws</dt><dd>
<a href='ejs-IOError.html'>IOError</a>: if an I/O error occurs or premature eof. 
</dd>
</dl></div>
</div>
<hr />
<a name='readShort'></a>
<div class='api'>
<div class='apiSig'>const   public  readShort(): <a href='ejs-Number.html'>Number</a>
</div>
<div class='apiDetail'>
<p>Read a 16-bit short integer from the array.The data will be decoded according to the endian property.</p>
<dl><dt>Description</dt><dd>Data is read from the current read <a href='#position'>position</a> pointer.
If insufficient data, a "write" event will be issued indicating that the byte array is 
writable.  This enables observers to write data into the byte array.  If there is no data available, the call 
will return return null indicating eof. If there is insufficient data.</dd></dl>
<dl><dt>Returns</dt>
<dd>A short int or null on eof.</dd></dl>
<dl><dt>Throws</dt><dd>
<a href='ejs-IOError.html'>IOError</a>: if an I/O error occurs or premature eof. 
</dd>
</dl></div>
</div>
<hr />
<a name='readString'></a>
<div class='api'>
<div class='apiSig'>const   public  readString(count: <a href='ejs-Number.html'>Number</a> = -1): <a href='ejs-String.html'>String</a>
</div>
<div class='apiDetail'>
<p>Read a data from the array as a string.</p>
<dl><dt>Description</dt><dd>Read data from the <a href='#readPosition'>readPosition</a> to a string up to the <a href='#writePosition,'>writePosition,</a> but not more than count characters. If insufficient data, a "writable" event will be issued indicating that 
the byte array is writable. This enables observers to write data into the byte array.  If there is no data 
available, the call will return return null indicating eof. If there is insufficient data.</dd></dl>
<dl><dt>Parameters</dt>
<dd><table class='parameters' summary ='parameters'>
<tr class='param'><td class='param'>count: <a href='ejs-Number.html'>Number</a> </td><td>Of bytes  to read. If -1, convert the data up to the <a href='#writePosition'>writePosition</a>.  [default: -1]</td></tr></table></dd>
</dl><dl><dt>Returns</dt>
<dd>A string or null on eof.</dd></dl>
<dl><dt>Throws</dt><dd>
<a href='ejs-IOError.html'>IOError</a>: if an I/O error occurs or a premature eof.  
</dd>
</dl></div>
</div>
<hr />
<a name='readXML'></a>
<div class='api'>
<div class='apiSig'>const   public  readXML(): <a href='ejs-XML.html'>XML</a>
</div>
<div class='apiDetail'>
<p>Read an XML document from the array.</p>
<dl><dt>Description</dt><dd>Data is read from the current read <a href='#position'>position</a> pointer.</dd></dl>
<dl><dt>Returns</dt>
<dd>An XML document.</dd></dl>
<dl><dt>Throws</dt><dd>
<a href='ejs-IOError.html'>IOError</a>: if an I/O error occurs or a premature end of file. 
</dd>
</dl></div>
</div>
<hr />
<a name='reset'></a>
<div class='api'>
<div class='apiSig'>const   public  reset(): <a href='ejs-Void.html'>Void</a>
</div>
<div class='apiDetail'>
<p>Reset the read and <a href='#writePosition'>writePosition</a> pointers if there is no available data.</p>
<dl><dt>Description</dt><dd>This is used to rewind the read/write pointers to maximize available buffer space.</dd></dl>
</div>
</div>
<hr />
<a name='toString'></a>
<div class='api'>
<div class='apiSig'>const override   public  toString(): <a href='ejs-String.html'>String</a>
</div>
<div class='apiDetail'>
<p>Convert the data in the byte array between the <a href='#readPosition'>readPosition</a> and writePosition.</p>
<dl><dt>Returns</dt>
<dd>A string.</dd></dl>
</div>
</div>
<hr />
<a name='write'></a>
<div class='api'>
<div class='apiSig'>const   public  write(data: <a href='ejs-Array.html'>Array</a>): <a href='ejs-Number.html'>Number</a>
</div>
<div class='apiDetail'>
<p>Write data to the stream.Write data to the ByteArray.</p>
<dl><dt>Description</dt><dd>If the stream can accept all the write data, the call returns immediately with the number of bytes written. 
If writing more data than the stream can absorb in sync mode, the call will block until the data is written.
If writing more data than the stream can absorb in async mode, the call will not block and will buffer the
data and return immediately. Some streams will require a flush() call to actually send the data.
A "writable" event will be issued when the stream can again absorb more data.Data is written to the current <a href='#writePosition'>writePosition</a>. </dd></dl>
<dl><dt>Parameters</dt>
<dd><table class='parameters' summary ='parameters'>
<tr class='param'><td class='param'>data: <a href='ejs-Array.html'>Array</a> </td><td>Data to write.</td></tr></table></dd>
</dl><dl><dt>Events</dt>
<dd><table class='parameters' summary ='events'>
<td class='param'>readable</td><td>Issued when data is written and a consumer can read without blocking.</td></tr>
<td class='param'>writable</td><td>Issued when the stream becomes empty and it is ready to be written to.</td></tr>
</table></dd>
</dl><dl><dt>Returns</dt>
<dd>A count of the bytes actually written.</dd></dl>
<dl><dt>Throws</dt><dd>
<a href='ejs-IOError.html'>IOError</a>: if there is an I/O error. 
</dd>
</dl></div>
</div>
<hr />
<a name='writeByte'></a>
<div class='api'>
<div class='apiSig'>const   public  writeByte(data: <a href='ejs-Number.html'>Number</a>): <a href='ejs-Void.html'>Void</a>
</div>
<div class='apiDetail'>
<p>Write a byte to the array.</p>
<dl><dt>Description</dt><dd>Data is written to the current write <a href='#position'>position</a> pointer which is then incremented.
//  MOB -- no such details exist
See <a href='#write'>write</a> for details about sync, async modes and event handling.</dd></dl>
<dl><dt>Parameters</dt>
<dd><table class='parameters' summary ='parameters'>
<tr class='param'><td class='param'>data: <a href='ejs-Number.html'>Number</a> </td><td>Data to write.</td></tr></table></dd>
</dl><dl><dt>Events</dt>
<dd><table class='parameters' summary ='events'>
<td class='param'>readable</td><td>Issued when data is written and a consumer can read without blocking.</td></tr>
</table></dd>
</dl><dl><dt>Throws</dt><dd>
<a href='ejs-IOError.html'>IOError</a>: if an I/O error occurs or if the stream cannot absorb all the data. 
</dd>
</dl></div>
</div>
<hr />
<a name='writeDouble'></a>
<div class='api'>
<div class='apiSig'>const   public  writeDouble(data: <a href='ejs-Number.html'>Number</a>): <a href='ejs-Void.html'>Void</a>
</div>
<div class='apiDetail'>
<p>Write a double to the array.</p>
<dl><dt>Description</dt><dd>Data is written to the current write <a href='#position'>position</a> pointer which is then incremented.
See <a href='#write'>write</a> for details about sync, async modes and event handling.</dd></dl>
<dl><dt>Parameters</dt>
<dd><table class='parameters' summary ='parameters'>
<tr class='param'><td class='param'>data: <a href='ejs-Number.html'>Number</a> </td><td>Data to write.</td></tr></table></dd>
</dl><dl><dt>Events</dt>
<dd><table class='parameters' summary ='events'>
<td class='param'>readable</td><td>Issued when data is written and a consumer can read without blocking.</td></tr>
</table></dd>
</dl><dl><dt>Throws</dt><dd>
<a href='ejs-IOError.html'>IOError</a>: if an I/O error occurs or if the stream cannot absorb all the data. 
</dd>
</dl></div>
</div>
<hr />
<a name='writeInteger'></a>
<div class='api'>
<div class='apiSig'>const   public  writeInteger(data: <a href='ejs-Number.html'>Number</a>): <a href='ejs-Void.html'>Void</a>
</div>
<div class='apiDetail'>
<p>Write a 32-bit integer to the array.</p>
<dl><dt>Description</dt><dd>Data is written to the current write <a href='#position'>position</a> pointer which is 
then incremented.
See <a href='#write'>write</a> for details about sync, async modes and event handling.</dd></dl>
<dl><dt>Parameters</dt>
<dd><table class='parameters' summary ='parameters'>
<tr class='param'><td class='param'>data: <a href='ejs-Number.html'>Number</a> </td><td>Data to write.</td></tr></table></dd>
</dl><dl><dt>Events</dt>
<dd><table class='parameters' summary ='events'>
<td class='param'>readable</td><td>Issued when data is written and a consumer can read without blocking.</td></tr>
</table></dd>
</dl><dl><dt>Throws</dt><dd>
<a href='ejs-IOError.html'>IOError</a>: if an I/O error occurs or if the stream cannot absorb all the data. 
</dd>
</dl></div>
</div>
<hr />
<a name='writeLong'></a>
<div class='api'>
<div class='apiSig'>const   public  writeLong(data: <a href='ejs-Number.html'>Number</a>): <a href='ejs-Void.html'>Void</a>
</div>
<div class='apiDetail'>
<p>Write a 64 bit long integer to the array.</p>
<dl><dt>Description</dt><dd>Data is written to the current write <a href='#position'>position</a> pointer which is 
then incremented.
See <a href='#write'>write</a> for details about sync, async modes and event handling.</dd></dl>
<dl><dt>Parameters</dt>
<dd><table class='parameters' summary ='parameters'>
<tr class='param'><td class='param'>data: <a href='ejs-Number.html'>Number</a> </td><td>Data to write.</td></tr></table></dd>
</dl><dl><dt>Events</dt>
<dd><table class='parameters' summary ='events'>
<td class='param'>readable</td><td>Issued when data is written and a consumer can read without blocking.</td></tr>
</table></dd>
</dl><dl><dt>Throws</dt><dd>
<a href='ejs-IOError.html'>IOError</a>: if an I/O error occurs or if the stream cannot absorb all the data. 
</dd>
</dl></div>
</div>
<hr />
<a name='writeShort'></a>
<div class='api'>
<div class='apiSig'>const   public  writeShort(data: <a href='ejs-Number.html'>Number</a>): <a href='ejs-Void.html'>Void</a>
</div>
<div class='apiDetail'>
<p>Write a short to the array.</p>
<dl><dt>Description</dt><dd>Data is written to the current write <a href='#position'>position</a> pointer which is then incremented.
See <a href='#write'>write</a> for details about sync, async modes and event handling.</dd></dl>
<dl><dt>Parameters</dt>
<dd><table class='parameters' summary ='parameters'>
<tr class='param'><td class='param'>data: <a href='ejs-Number.html'>Number</a> </td><td>Data to write.</td></tr></table></dd>
</dl><dl><dt>Events</dt>
<dd><table class='parameters' summary ='events'>
<td class='param'>readable</td><td>Issued when data is written and a consumer can read without blocking.</td></tr>
</table></dd>
</dl><dl><dt>Throws</dt><dd>
<a href='ejs-IOError.html'>IOError</a>: if an I/O error occurs or if the stream cannot absorb all the data. 
</dd>
</dl></div>
</div>
<hr />
<div class="terms">
   <p class="terms">
       <a href="http://www.embedthis.com/">       Embedthis Software LLC, 2003-2011. All rights reserved. Embedthis is a trademark of Embedthis Software LLC.</a>
   </p>
</div></div>
</div>
</body>
</html>
