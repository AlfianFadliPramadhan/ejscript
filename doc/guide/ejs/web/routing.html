<!-- BeginDsi "dsi/head.html" -->
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Embedthis Ejscript 2.0.0 Documentation</title>
    <meta name="keywords" content="Ejscript, JavaScript, ECMAScript, Server-Side JavaScript, Dynamic languages, 
        Embedded, AJAX, language"/>
	<meta name="description" content="Ejscript -- Embedded Server-Side JavaScript Language."/>
	<meta name="robots" content="index,follow" />
    <link href="http://www.google.com/cse/style/look/default.css" type="text/css" rel="stylesheet" />
	<link href="../../../doc.css" rel="stylesheet" type="text/css" />
	<link href="../../../print.css" rel="stylesheet" type="text/css" media="print"/>
    <!--[if IE]>
    <link href="../../../iehacks.css" rel="stylesheet" type="text/css" />
    </![endif]-->
</head>

<body>
    <div class="top">
        <a class="logo"  href="http://ejscript.org/">&nbsp;</a>
        <div class="topRight">
            <div class="search">
                <div id="cse-search-form">Loading</div>
                <div class='version'>Embedthis Ejscript 2.0.0</div>
            </div>
        </div>
        <div class="crumbs">
            <a href="../../../product/index.html">Home</a>
<!-- EndDsi -->
             &gt;<a href="index.html">Web Framework Guide</a>&gt; <b>Controllers and Actions</b>
        </div>
    </div>
    <div class="content">
        <div class="contentRight">
            <h1>Quick Nav</h1>
            <ul>
                <li><a href="#flow">Processing Flow</a></li>
                <li><a href="#routing">Routing Requests</a></li>
                <li><a href="#anatomy">Anatomy of a Controller</a></li>
                <li><a href="#actions">Actions</a></li>
                <li><a href="#context">Controller Context</a></li>
                <li><a href="#processing">Processing Requests</a></li>
                <li><a href="#models">Model Data</a></li>
                <li><a href="#forms">Form Data</a></li>
                <li><a href="#views">Rendering Views</a></li>
                <li><a href="#generating">Generating Controllers</a></li>
                <li><a href="#controller">Controller Class</a></li>
                <!-- <li><a href="#tips">Tips and Tricks</a></li> -->
            </ul>
<!-- BeginDsi "dsi/ejsWebSeeAlso.html" -->
		        <h1>See Also</h1>
		        <ul>
		          <li><a href="../../../guide/ejs/web/webTour.html">Web Framework Tour</a></li>
		          <li><a href="../../../guide/ejs/web/mvc.html">Model-View-Controller</a></li>
		          <li><a href="../../../guide/ejs/web/generator.html">Application Generator</a></li>
		          <li><a href="../../../guide/ejs/web/controllers.html">Controllers and Actions</a></li>
		          <li><a href="../../../guide/ejs/web/views.html">Views and Layouts</a></li>
		          <li><a href="../../../guide/ejs/web/controls.html">Ajax View Controls</a></li>
		          <li><a href="../../../guide/ejs/web/models.html">Database Models</a></li>
		          <li><a href="../../../guide/ejs/web/hosting.html">Hosting in Web Servers</a></li>
		        </ul>
<!-- EndDsi -->

            <ul>
                <li><a href="../../../api/ejscript/index.html">Ejscript Library</a></li>
            </ul>
        </div>
        <div class="contentLeft">
            <h1>Request Routing</h1>
            <a name="overview"></a>
            <h2>Overview</h2>
            <p>Ejscript includes a powerful request routing engine that processes client HTTP requests. The engine
            is configured with a set of routes and when a request is received, it tests various routes and selects
            the best route to handle the request.  In the process, routes may redirect or rewrite the request 
            as required.</p>

            <img src="../../../images/routing.jpg" alt="routing"/>
            <p>An Ejscript application will typically have many routes. The configured routes 
            are tested in-order by matching the route pattern against the request URI. 
            A route may require that further preconditions be met before it is suitable to process the
            request. If the required conditions are not met, the next route in the configuration will be tested. There 
            is always a catch-all route that will process the request if all prior routes fail to qualify.</p>
            <p>A route may modify the request during processing by changing the request URI or request data. The
            route may also run commands as a side-effect during processing.</p>
            <a name="configuration"></a>

            <h2 class="section">Route Configuration</h2>
            <p>Routes are defined using the Router class and methods. Here is an example of a simple web server with
            route configuration.</p>
<pre>
require ejs.web
let server: HttpServer = new HttpServer
var r = new Router
r.add("/User/{action}", {controller: "User"})
r.addRestful()
r.show()
</pre>
            <p>This example defines a route for URIs that begin with <em>"/User/"</em>.
            The route pattern is an extended regular expression pattern that is used to match against the 
            client request URI. If the route pattern matches the URI, the route is selected to process 
            the request.</p>

            <h3>Route Ordering</h3>
            <p>Routes are processed in the order in which they are defined. Each route is tested in turn and the first
            matching route is used to process the request.  So ordering route definitions is very important. Routes
            with longer or more qualified route criteria should be defined first before more general routes.</p>

            <h2 class="section">Route Processing</h2>
            <p>To process a request, The Ejscript route engine examines each of the configured routes to determine the 
            best matching route for a request.  It does this by considering each route in the order they are defined in
            the configuration file. Each route is tested over a sequence of steps. 
            Not all steps are required. However, the selected route will always perform pattern match, param definition and 
            target execution.  If a route fails to match at a step, the route is discarded and the next configured route 
            is considered.</p>
            <img src="../../../images/routeSteps.jpg" alt="steps"/>
            <h3>Routing Steps</h3>
            <ol>
                <li><a href="#step-pattern">Pattern Matching</a> &mdash; Test if the request URI matches route pattern.</li>
                <li><a href="#step-method">Optional Method Matching</a> &mdash; Test if the request method is valid.</li>
                <li>Optional <a href="#step-header">Header Matching</a> &mdash; Test if the request has the require headers.</li>
                <li>Optional <a href="#step-form">Form Field Matching</a> &mdash; Test if form data has required values.</li>
                <li>Optional <a href="#step-condition">Condition Matching</a> &mdash; Test if the required conditions are true.</li>
                <li>Optional <a href="#step-update">Updates</a> &mdash; Modify the request with specified updates.</li>
                <li><a href="#step-param">Param Definition</a> &mdash; Define tokens as request 
                    <a href="#params">params</a>.</li>
                <li><a href="#step-target">Target Execution</a> &mdash; Select the Ejscript handler and determine the target resource.</li>
            </ol>
            <h3>Route Timing</h3>
            <p>Ejscript will initiate request routing at a different time depending on whether the request has form data. 
            If a request has form data, it is worthwhile to delay routing until after the form data
            has been read from the client. This enables the routing directives to take action based on the received form
            data. If a request has no form data, it is routed immediately after the HTTP headers have been read and 
            parsed.</p>
            <p>A request with form data has a <em>Content-Type</em> header of
            <em>application/x-www-form-urlencoded</em>. Requests with a <em>Content-Type</em> set to 
            <em>multipart/form-data</em> which indicates form based file upload, will also delay routing until the uploaded
            file has been fully received.</p>
            <a name="step-pattern"></a>
            <h3>Pattern Matching</h3>
            <p>A route pattern is a specially prepared regular expression that can be quickly matched against the 
            request URI. The route pattern may match the entire request URI, just a subset at the start of the URI
            or any portion in between. Regular expressions are ideal for route patterns as they can express a wide 
            variety of URI formats and can also extract sub-expressions for later evaluation.</p>
            <h4>URI Tokens</h4>
            <p>Often the request URI will not only provide a path to a resource, but it will contain tokens of 
            information that must be isolated and extracted from the URI. Ejscript route patterns provide an easy and
            efficient means to extract such tokens and define them as request <a href="#params">params</a>.
            To do this, Ejscript route patterns extend the standard regular expression syntax via embedded tokens.</p>
            
            <p>A token is a 
            portion of the URI that is enclosed in braces "{token}". The token name is a symbolic name that will be used
            later to define a request parameter. In the request URI, any sequence of characters except 
            "/" are acceptable in the token name. For example the route pattern:</p>
<pre>
&lt;Route ^/{controller}/{action}$>
</pre>
will match the URI:
<pre class="paper">
/user/login
</pre>
            <p>After pattern matching, the request param <em>controller</em> will be set to "user" and 
            <em>action</em> will be set to "login".</p>
            <p>Token values can be accessed in condition, update and target directives via the <em>${token}</em> syntax.</p>
            <p>To enable the extension token syntax, the standard regular expression syntax for repeat sub-expressions 
                that uses braces: {m,n} needs to be back-quoted. i.e. \{m,n}.</p>
            <h4>Sub-Expressions</h4>
            <p>In addition to route tokens, standard regular expression sub-patterns can be defined by wrapping a 
            sub-expression in parentheses. For example:</p>
<pre>
&lt;Route /(user|admin)/{cmd}>
</pre>
            <p>This will allow URIs that begin with either <em>/user</em> or <em>/admin</em>. Sub-expression and token
            values are made available to Conditions, Updates and Targets by using <em>$N</em> in the directive details. 
            The first sub-expression or token is assigned to <em>$1</em>, the second to <em>$2</em> and so on. 
            If a request with the URI <em>/user/login</em> was received, the route above would set <em>$1</em> to 
            "user" and <em>$2</em> to "login".</p>
            <h4>Conditional Sub-Expressions</h4>
            <p>Conditional sub-expressions can be defined by wrapping in "(~" and "~)". This means the wrapped
            sub-expression is valid but not required. For example:</p>
<pre>
&lt;Route /{controller}(~/{action}~) >
</pre>
will match any of the URIs:
<pre class="paper">
/user
/user/
/user/login
</pre>
            <h4>Anchoring Route Patterns</h4>
            <p>It is wise to anchor route patterns to the start of the URI. This is done by using the <em>"^"</em> character
            at the start of the URI. If the pattern describes the full request URI, the pattern can anchor to the end
            of the URI by appending <em>"$"</em>. For example:</p>
<pre>
^/{controller}(~/{action}~)$
</pre>
            <a name="step-method"></a>
            <h3>Method Matching</h3>
            <p>Method matching is an optional step. Routes can be configured to only match certain HTTP methods. 
            Method matching tests the supported route methods against the actual request HTTP method. 
            By default a route supports all methods</p>
            <a name="step-header"></a>
            <h3>Header Matching</h3>
            <p>Header matching is an optional step. Routes can be configured to require that the request has HTTP
            headers with or without defined values. For example: a route may wish to only be relevant for a 
            particular browser:</p>
<pre>
&lt;Route /info/>
    Header User-Agent /Chrome/
&lt;/Route>
</pre>
            <a name="step-form"></a>
            <h3>Form Value Matching</h3>
            <p>Form value matching is an optional step. Routes can be configured to require that the request has 
            form data with or without defined values. Form data is sourced from the request URI query string and from
            form body (POST) data. Form data must have a Content-Type of "application/x-www-form-urlencoded" &mdash;
            normal HTML forms are encoded this way.</p>
<pre>
&lt;Route ^/info/>
    Query name /(Mary)|(John)/
&lt;/Route>
</pre>
            <p>This route will match the URIs: </p>
<pre class="paper">
/info/file.html?name=Mary
/info/file.html?name=John
</pre>
            <a name="step-condition"></a>
            <h3>Condition Matching</h3>
            <p>Condition matching is an optional step where extra conditions can be tested before the route is selected.
            Conditions can test if a file exists or not and whether a file is a directory or not. Condition rules
            can also test any request parameter against a regular expression.</p>
            <a name="step-update"></a>
            <h3>Request Update</h3>
            <p>Request update matching is an optional step where the request <a href="#params">params</a> 
            can be modified.</p>
            <a name="step-param"></a>
            <h3>Param Definition</h3>
            <p>After a route fully qualifies, request <a href="#params">params</a>
            are created for route pattern tokens. This provides an
            easy mechanism for extracting useful information from the request URI and passing it to the web page or
            controller for processing.</p>
            <a name="step-target"></a>
            <h3>Target Execution</h3>
            <p>Route targets have responsibility to generate the actual response to the client.
            But, before the target can be executed, the appropriate request handler must be selected.
            If a route has an explicit handler defined via <em>SetHandler</em> then that handler will be used.
            If a set of handlers have been defined via <em>AddHandler</em> directives, then the handler defined with 
            the corresponding URI extension will be selected.</p>
            The target has four possible rules: <em>close</em>, <em>redirect</em>, <em>run</em> and
            <em>write</em>.  Of these, all except for the <em>close</em> rule take parameters that are 
            expanded using the matching sub-expressions and/or route tokens derived when matching the route pattern.
            <p>Target rule parameters can use <em>"${token}"</em> to be replaced with the value of the token.
            Target rule parameters can also use <em>"$N"</em> to be replaced with the Nth matching sub-expression, 
            <em>"$&amp;"</em> to be replaced with the entire
            matched pattern, <em>"$`"</em> to be replaced with the portion that precedes the matched pattern and 
            <em>"$'"</em> to be replaced with the portion that follows the matched pattern. 
            <p>For example:</p>
<pre>
Target write 200 "Running controller ${controller} action ${action}\n\n"
</pre>
            <p>This will write the message back to the client with a HTML status code of 200 .</p>
            <p>Note: to be more secure, the <em>write</em> rule will escape embedded HTML sequences. If you need to emit
            HTML, use the <em>-r</em> switch for raw write output.</p>
            <h3>Prefix Removal</h3>
            <p>If Ejscript is running several applications, Ejscript will need to be able to route and distinguish 
            requests for each application. There are two primary ways to achieve this: run each application
            in a separate virtual host or uniquely prefix the URIs for each application. If using the latter approach,
            routes can be defined for each application that specify the URI prefix for each application. However, it is
            often convenient to have the application prefix removed from the URI once the route is selected. The Prefix
            directive defines a URI prefix that will be stripped from the start of the request URI once the route
            is selected. If the route defines a header, form or condition that is not satisfied, the prefix is restored
            to let other routes see the full URI.</p>
            <a name="examples"></a>
            <h2 class="section">Route Examples</h2>
            <h3>Redirecting Old URIs</h3>
            <p>To redirect requests for old documents to newer versions:</p>
<pre>
&lt;Route ^/public/oldFile.html$>
    Target redirect 302 /public/newFile.html
&lt;/Route>
</pre>
            <h3>Authenticating Private Content</h3>
            <p>To secure private content :</p>
<pre>
&lt;Route /private/>
    DocumentRoot /private-docs
    AuthType digest
    AuthName "Top-Secret"
    Require valid-user
&lt;/Route>
</pre>
            <h3>Hiding PHP extensions</h3>
            <p>To hide the PHP extension in all URIs. This will automatically add the ".php" extension to the 
                request document filename.</p>
<pre>
&lt;Route ^/store/>
    DocumentRoot /store-app
    SetHandler phpHandler
    Target run $&.php
&lt;/Route>
</pre>
            <h3>Serving Compressed Content</h3>
            <p>This example enables the serving of compressed content where an equivalent compressed document exists. i.e.
               A request for <em>/manual/overview.html</em> may return <em>/manual/overview.html.gz</em> if it exists. If
               there is no compressed content, the uncompressed version is returned.</p>
<pre>
&lt;Route ^/manual/>
    Compress gzip
&lt;/Route>
</pre>
            <h3>Multi-Language Content</h3>
            <p>This example stores English content under the <em>"english-docs"</em> directory and French under the 
            <em>"french-docs"</em> directory. The client's browser should include an <em>Accept-Language</em> 
            header which stipulates what language is preferred.
            If the accept header is missing or the requested language is not English or French, then the DefaultLanguage
            directive indicates that english content should be returned.</p>
<pre>
&lt;Route />
    DefaultLanguage en
    AddLanguageDir en /path/to/english-docs
    AddLanguageDir fr /path/to/french-docs
&lt;/Route>
</pre>
            <h3>Multi-Language by Suffix</h3>
            <p>This example stores content for all languages together and includes a language suffix to the request document
            filename. If the client requested a French version of <em>index.html</em>, then the document 
            <em>index.fr.html</em> would be served.</p>
<pre>
&lt;Route />
    DefaultLanguage en
    AddLanguageSuffix en en before
    AddLanguageSuffix fr fr
&lt;/Route>
</pre>
            <h3>Application Isolation</h3>
            <p>To group routes for an application, enclose in a Route block and use a Prefix directive to remove the
                application prefix.</p>
<pre>
&lt;Route /manage/>
    Prefix /manage
    DocumentRoot manage-app
    SetHandler espHandler
    &lt;Route /manage/{controller}/{action}>
        Target run ${controller}-${action}
    &lt;/Route>
&lt;/Route>
</pre>
            <h3>Denial of Service Protection</h3>
            <p>To immediately close a connection without responding use the <em>Target close</em> directive.
<pre>
&lt;Route /hacked-url/>
    target close
&lt;/Route>
</pre>
            <h3>Missing File</h3>
            <p>To match a missing document without redirection:</p>
<pre>
&lt;Route />
    Condition ! exists ${request:filename}
    Target run /missing.html
&lt;/Route>
</pre>
        </div>
    </div>
<!-- BeginDsi "dsi/bottom.html" -->
	<div class="bottom">
		<p class="footnote"> 
            <a href="../../../product/copyright.html" >&copy; Embedthis Software LLC, 2003-2012. 
            All rights reserved. Embedthis, Ejscript and Appweb are trademarks of Embedthis Software LLC.</a>
		</p>
	</div>
</body>
    <script src="http://www.google.com/jsapi" type="text/javascript"></script>
    <script type="text/javascript"> 
      google.load('search', '1', {language : 'en'});
      google.setOnLoadCallback(function() {
        var customSearchControl = new google.search.CustomSearchControl(
          'partner-pub-9935546676162772:ysvxxv4n9rx');

        customSearchControl.setResultSetSize(google.search.Search.FILTERED_CSE_RESULTSET);
        var options = new google.search.DrawOptions();
        options.enableSearchboxOnly("http://ejscript.org/search.html");
        customSearchControl.draw('cse-search-form', options);
      }, true);
    </script>
</html>
<!-- EndDsi -->
