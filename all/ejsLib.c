#define EJS_DEFINE_OPTABLE 1
#include "ejs.h"

/******************************************************************************/
/* 
 *  This file is an amalgamation of all the individual source code files for
 *  Embedthis Ejscript 1.1.0.
 *
 *  Catenating all the source into a single file makes embedding simpler and
 *  the resulting application faster, as many compilers can do whole file
 *  optimization.
 *
 *  If you want to modify ejs, you can still get the whole source
 *  as individual files if you need.
 */


/************************************************************************/
/*
 *  Start of file "../src/vm/ejsByteCode.c"
 */
/************************************************************************/

/**
 *  ejsByteCode.c - Definition of the byte code table.
 *
 *  Copyright (c) All Rights Reserved. See details at the end of the file.
 */

/*
 *  This will define an instance of the EjsOptable which is defined in ejsByteCodeTable.h
 */
#define EJS_DEFINE_OPTABLE 1


EjsOptable *ejsGetOptable(MprCtx ctx)
{
    return ejsOptable;
}


/*
 *  @copy   default
 *
 *  Copyright (c) Embedthis Software LLC, 2003-2010. All Rights Reserved.
 *  Copyright (c) Michael O'Brien, 1993-2010. All Rights Reserved.
 *
 *  This software is distributed under commercial and open source licenses.
 *  You may use the GPL open source license described below or you may acquire
 *  a commercial license from Embedthis Software. You agree to be fully bound
 *  by the terms of either license. Consult the LICENSE.TXT distributed with
 *  this software for full details.
 *
 *  This software is open source; you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by the
 *  Free Software Foundation; either version 2 of the License, or (at your
 *  option) any later version. See the GNU General Public License for more
 *  details at: http://www.embedthis.com/downloads/gplLicense.html
 *
 *  This program is distributed WITHOUT ANY WARRANTY; without even the
 *  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 *  This GPL license does NOT permit incorporating this software into
 *  proprietary programs. If you are unable to comply with the GPL, you must
 *  acquire a commercial license to use this software. Commercial licenses
 *  for this software and support services are available from Embedthis
 *  Software at http://www.embedthis.com
 *
 *  @end
 */
/************************************************************************/
/*
 *  End of file "../src/vm/ejsByteCode.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../src/vm/ejsException.c"
 */
/************************************************************************/

/**
    ejsException.c - Error Exception class

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */



static uchar trapByteCode[] = { EJS_OP_ATTENTION };


void ejsAttention(Ejs *ejs)
{
    EjsFrame    *frame;

    frame = ejs->state->fp;
    if (frame && frame->attentionPc == 0 && !frame->ignoreAttention) {
        frame->attentionPc = frame->pc;
        frame->pc = trapByteCode;
    }
}


void ejsClearAttention(Ejs *ejs)
{
    EjsFrame    *frame;

    frame = ejs->state->fp;

    if (ejs->exception == 0 && frame && frame->attentionPc) {
        frame->pc = frame->attentionPc;
        frame->attentionPc = 0;
        mprAssert(frame->pc);
    }
}


EjsObj *ejsThrowException(Ejs *ejs, EjsObj *obj)
{
    mprAssert(obj);

    ejs->exception = obj;
    ejsAttention(ejs);
    return obj;
}


void ejsClearException(Ejs *ejs)
{
    ejs->exception = 0;
    if (ejs->state->fp) {
        ejs->state->fp->attentionPc = 0;
    }
}


static EjsObj *createException(Ejs *ejs, EjsType *type, cchar* fmt, va_list fmtArgs)
{
    EjsObj      *error, *argv[1];
    char        *msg;

    mprAssert(type);

    msg = mprVasprintf(ejs, -1, fmt, fmtArgs);
    argv[0] = (EjsObj*) ejsCreateString(ejs, msg);
    if (argv[0] == 0) {
        mprAssert(argv[0]);
        return 0;
    }
    if (!ejs->initialized) {
        mprLog(ejs, 5, "Exception: %s", msg);
        error = ejsCreateObject(ejs, type, 0);
    } else {
        error = (EjsObj*) ejsCreateInstance(ejs, type, 1, argv);
    }
    mprFree(msg);
    return error;
}


EjsObj *ejsCreateException(Ejs *ejs, int slot, cchar *fmt, va_list fmtArgs)
{
    EjsType     *type;
    EjsObj      *error;
    char        *buf;

    if (ejs->exception) {
        buf = mprVasprintf(ejs, 0, fmt, fmtArgs);
        mprError(ejs, "Double exception: %s", buf);
        mprFree(buf);
        return ejs->exception;
    }
    if (ejs->initialized) {
        type = (EjsType*) ejsGetProperty(ejs, ejs->global, slot);
    } else {
        type = 0;
    }
    if (type == 0) {
        type = ejs->errorType;
    }
    error = createException(ejs, type, fmt, fmtArgs);
    if (error) {
        ejsThrowException(ejs, error);
    }
    return error;
}


EjsObj *ejsThrowArgError(Ejs *ejs, cchar *fmt, ...)
{
    va_list     fmtArgs;

    mprAssert(fmt);
    va_start(fmtArgs, fmt);
    return ejsCreateException(ejs, ES_ArgError, fmt, fmtArgs);
}


EjsObj *ejsThrowArithmeticError(Ejs *ejs, cchar *fmt, ...)
{
    va_list     fmtArgs;

    mprAssert(fmt);
    va_start(fmtArgs, fmt);
    return ejsCreateException(ejs, ES_ArithmeticError, fmt, fmtArgs);
}


EjsObj *ejsThrowAssertError(Ejs *ejs, cchar *fmt, ...)
{
    va_list     fmtArgs;

    mprAssert(fmt);
    va_start(fmtArgs, fmt);
    return ejsCreateException(ejs, ES_AssertError, fmt, fmtArgs);
}


EjsObj *ejsThrowInstructionError(Ejs *ejs, cchar *fmt, ...)
{
    va_list     fmtArgs;

    mprAssert(fmt);
    va_start(fmtArgs, fmt);
    return ejsCreateException(ejs, ES_InstructionError, fmt, fmtArgs);
}


EjsObj *ejsThrowError(Ejs *ejs, cchar *fmt, ...)
{
    va_list     fmtArgs;

    mprAssert(fmt);
    va_start(fmtArgs, fmt);
    return ejsCreateException(ejs, ES_Error, fmt, fmtArgs);
}


EjsObj *ejsThrowIOError(Ejs *ejs, cchar *fmt, ...)
{
    va_list     fmtArgs;

    mprAssert(fmt);
    va_start(fmtArgs, fmt);
    return ejsCreateException(ejs, ES_IOError, fmt, fmtArgs);
}


EjsObj *ejsThrowInternalError(Ejs *ejs, cchar *fmt, ...)
{
    va_list     fmtArgs;

    mprAssert(fmt);
    va_start(fmtArgs, fmt);
    return ejsCreateException(ejs, ES_InternalError, fmt, fmtArgs);
}


EjsObj *ejsThrowMemoryError(Ejs *ejs)
{
    /*
        Don't do double exceptions for memory errors
     */
    if (ejs->exception == 0) {
#if BLD_WIN_LIKE
        va_list dummy = {0};
#else
        va_list dummy = {{0}};
#endif
        return ejsCreateException(ejs, ES_MemoryError, NULL, dummy);
    }
    return ejs->exception;
}


EjsObj *ejsThrowOutOfBoundsError(Ejs *ejs, cchar *fmt, ...)
{
    va_list     fmtArgs;

    mprAssert(fmt);
    va_start(fmtArgs, fmt);
    return ejsCreateException(ejs, ES_OutOfBoundsError, fmt, fmtArgs);
}


EjsObj *ejsThrowReferenceError(Ejs *ejs, cchar *fmt, ...)
{
    va_list     fmtArgs;

    mprAssert(fmt);
    va_start(fmtArgs, fmt);
    return ejsCreateException(ejs, ES_ReferenceError, fmt, fmtArgs);
}


EjsObj *ejsThrowResourceError(Ejs *ejs, cchar *fmt, ...)
{
    va_list     fmtArgs;

    mprAssert(fmt);
    va_start(fmtArgs, fmt);
    return ejsCreateException(ejs, ES_ResourceError, fmt, fmtArgs);
}


EjsObj *ejsThrowStateError(Ejs *ejs, cchar *fmt, ...)
{
    va_list     fmtArgs;

    mprAssert(fmt);
    va_start(fmtArgs, fmt);
    return ejsCreateException(ejs, ES_StateError, fmt, fmtArgs);
}


EjsObj *ejsThrowSyntaxError(Ejs *ejs, cchar *fmt, ...)
{
    va_list     fmtArgs;

    mprAssert(fmt);
    va_start(fmtArgs, fmt);
    return ejsCreateException(ejs, ES_SyntaxError, fmt, fmtArgs);
}


EjsObj *ejsThrowTypeError(Ejs *ejs, cchar *fmt, ...)
{
    va_list     fmtArgs;

    mprAssert(fmt);
    va_start(fmtArgs, fmt);
    return ejsCreateException(ejs, ES_TypeError, fmt, fmtArgs);
}


/*
    Format the stack backtrace
 */
char *ejsFormatStack(Ejs *ejs, EjsError *error)
{
    EjsType         *type;
    EjsFrame        *fp;
    cchar           *typeName, *functionName, *line, *typeSep, *codeSep;
    char            *backtrace, *traceLine;
    int             level, len, oldFlags;

    mprAssert(ejs);

    backtrace = 0;
    len = 0;
    level = 0;

    /*
        Pretend to be the compiler so we can access function frame names
     */
    oldFlags = ejs->flags;
    for (fp = ejs->state->fp; fp; fp = fp->caller) {
        typeName = "";
        functionName = "global";

        if (fp->currentLine == 0) {
            line = "";
        } else {
            for (line = fp->currentLine; *line && isspace((int) *line); line++) {
                ;
            }
        }
        if (fp) {
            if (fp->function.owner && fp->function.slotNum >= 0) {
                functionName = ejsGetPropertyName(ejs, fp->function.owner, fp->function.slotNum).name;
            }
            if (ejsIsType(fp->function.owner)) {
                type = (EjsType*) fp->function.owner;
                if (type) {
                    typeName = type->qname.name;
                }
            }
        }
        typeSep = (*typeName) ? "." : "";
        codeSep = (*line) ? "->" : "";

        if (error && backtrace == 0) {
            error->filename = mprStrdup(error, fp->filename);
            error->lineNumber = fp->lineNumber;
        }
        if ((traceLine = mprAsprintf(ejs, MPR_MAX_STRING, " [%02d] %s, %s%s%s, line %d %s %s\n",
                level++, fp->filename ? fp->filename : "script", typeName, typeSep, functionName,
                fp->lineNumber, codeSep, line)) == NULL) {
            break;
        }
        backtrace = (char*) mprRealloc(ejs, backtrace, len + (int) strlen(traceLine) + 1);
        if (backtrace == 0) {
            return 0;
        }
        memcpy(&backtrace[len], traceLine, strlen(traceLine) + 1);
        len += (int) strlen(traceLine);
        mprFree(traceLine);
    }
    ejs->flags = oldFlags;
    if (error) {
        error->stack = backtrace;
    }
    return backtrace;
}


/*
    Public routine to set the error message. Caller MUST NOT free.
 */
char *ejsGetErrorMsg(Ejs *ejs, int withStack)
{
    EjsObj      *message, *stack, *error;
    cchar       *name;
    char        *buf;

    if (!ejs->initialized) {
        return "";
    }
    error = (EjsObj*) ejs->exception;
    message = stack = 0;
    name = 0;

    if (error) {
        name = error->type->qname.name;
        if (ejsIsA(ejs, error, ejs->errorType)) {
            message = ejsGetProperty(ejs, error, ES_Error_message);
            stack = ejsGetProperty(ejs, error, ES_Error_stack);

        } else if (ejsIsString(error)) {
            name = "Error";
            message = error;

        } else if (ejsIsNumber(error)) {
            name = "Error";
            message = error;
            
        } else if (error == (EjsObj*) ejs->stopIterationType) {
            name = "StopIteration";
            message = (EjsObj*) ejsCreateString(ejs, "Uncaught StopIteration exception");
        }
    }
    if (!withStack) {
        stack = 0;
    }

    if (stack && ejsIsString(stack) && message && ejsIsString(message)){
        buf = mprAsprintf(ejs, -1, "%s Exception: %s\nStack:\n%s", name, ((EjsString*) message)->value, 
            ((EjsString*) stack)->value);

    } else if (message && ejsIsString(message)){
        buf = mprAsprintf(ejs, -1, "%s: %s", name, ((EjsString*) message)->value);

    } else if (message && ejsIsNumber(message)){
        buf = mprAsprintf(ejs, -1, "%s: %d", name, ((EjsNumber*) message)->value);
        
    } else {
        if (error) {
            buf = mprStrdup(ejs, "Unknown exception object type");
        } else {
            buf = mprStrdup(ejs, "");
        }
    }
    mprFree(ejs->errorMsg);
    ejs->errorMsg = buf;
    return buf;
}


bool ejsHasException(Ejs *ejs)
{
    return ejs->exception != 0;
}


EjsObj *ejsGetException(Ejs *ejs)
{
    return ejs->exception;
}


/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2010. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2010. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    @end
 */
/************************************************************************/
/*
 *  End of file "../src/vm/ejsException.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../src/vm/ejsGarbage.c"
 */
/************************************************************************/

/**
    ejsGarbage.c - EJS Garbage collector.

    This implements a non-compacting, generational mark and sweep collection algorithm with 
    fast pooled object allocations.

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */



static void mark(Ejs *ejs, int generation);
static void markGlobal(Ejs *ejs, int generation);
static inline bool memoryUsageOk(Ejs *ejs);
static inline void pruneTypePools(Ejs *ejs);
static void resetMarks(Ejs *ejs);
static void sweep(Ejs *ejs, int generation);

#if BLD_DEBUG
/*
    For debugging it can be helpful to disable the pooling of objects. Because mprFree will fill freed objects in 
    debug mode - bad frees will show up quickly with seg faults.

    Break on the allocation, mark and freeing of a nominated object
    Set ejsBreakAddr to the address of the object to watch and set a breakpoint in the debugger below.
    Set ejsBreakSeq to the object sequence number to watch and set a breakpoint in the debugger below.
 */
static void *ejsBreakAddr = (void*) 0;
static int ejsBreakSeq = 538825;
static void checkAddr(EjsObj *addr) {
    if ((void*) addr == ejsBreakAddr) { 
        /* Set a breakpoint here */
        addr = ejsBreakAddr;
    }
    if (addr->seq == ejsBreakSeq) {
        addr->seq = ejsBreakSeq;
    }
}
/*
    Unique allocation sequence. Helps GC debugging.
 */
static int nextSequence;

#else /* !BLD_DEBUG */
#define checkAddr(addr)
#undef ejsAddToGcStats
#define ejsAddToGcStats(ejs, vp, id)
#endif

/*
    Create the GC service
 */
int ejsCreateGCService(Ejs *ejs)
{
    EjsGC       *gc;
    int         i;

    mprAssert(ejs);

    gc = &ejs->gc;
    gc->enabled = 1;
    gc->firstGlobal = (ejs->empty) ? 0 : ES_global_NUM_CLASS_PROP;
    gc->numPools = EJS_MAX_TYPE;
    gc->allocGeneration = EJS_GEN_ETERNAL;
    ejs->workQuota = EJS_WORK_QUOTA;

    for (i = 0; i < EJS_MAX_GEN; i++) {
        gc->generations[i] = mprAllocObjZeroed(ejs->heap, EjsGen);
    }
    for (i = 0; i < EJS_MAX_TYPE; i++) {
        gc->pools[i] = mprAllocObjZeroed(ejs->heap, EjsPool);
    }
    ejs->currentGeneration = ejs->gc.generations[EJS_GEN_ETERNAL];
    return 0;
}


void ejsDestroyGCService(Ejs *ejs)
{
    EjsGC       *gc;
    EjsGen      *gen;
    EjsObj      *vp;
    MprBlk      *bp, *next;
    int         generation;
    
    gc = &ejs->gc;
    for (generation = EJS_GEN_ETERNAL; generation >= 0; generation--) {
        gen = gc->generations[generation];
        for (bp = mprGetFirstChild(gen); bp; bp = next) {
            next = bp->next;
            vp = MPR_GET_PTR(bp);
            checkAddr(vp);
            /*
                Only the types that MUST free resources will set needFinalize. All will have a destroy helper.
             */
            if (vp->type->needFinalize && vp->type->helpers->destroy) {
                (vp->type->helpers->destroy)(ejs, vp);
            }
        }
    }
}


/*
    Allocate a new variable. Size is set to the extra bytes for properties in addition to the type's instance size.
 */
EjsObj *ejsAlloc(Ejs *ejs, EjsType *type, int extra)
{
    EjsObj      *vp;
    int         size;

    mprAssert(type);
    mprAssert(extra >= 0);

    if (!type->dontPool) {
        vp = ejsAllocPooled(ejs, type->id);
    } else {
        vp = 0;
    }
    if (vp == 0) {
        size = type->instanceSize + extra;
        if ((vp = (EjsObj*) mprAllocZeroed(ejsGetAllocCtx(ejs), size)) == 0) {
            ejsThrowMemoryError(ejs);
            return 0;
        }
        if (++ejs->workDone >= ejs->workQuota && !ejs->gcRequired) {
            ejs->gcRequired = 1;
            ejsAttention(ejs);
        }
    }
    vp->type = type;
    vp->master = (ejs->master == 0);
    ejsAddToGcStats(ejs, vp, type->id);
    return (EjsObj*) vp;
}


EjsObj *ejsAllocPooled(Ejs *ejs, int id)
{
    EjsPool     *pool;
    EjsObj      *vp;
    MprBlk      *bp, *gp;

    if (0 < id && id < ejs->gc.numPools) {
        pool = ejs->gc.pools[id];
        if ((bp = mprGetFirstChild(pool)) != NULL) {
            /*
                Transfer from the pool to the current generation. Inline for speed.
             */
            gp = MPR_GET_BLK(ejs->currentGeneration);
            if (bp->prev) {
                bp->prev->next = bp->next;
            } else {
                bp->parent->children = bp->next;
            }
            if (bp->next) {
                bp->next->prev = bp->prev;
            }
            bp->parent = gp;
            if (gp->children) {
                gp->children->prev = bp;
            }
            bp->next = gp->children;
            gp->children = bp;
            bp->prev = 0;

            vp = MPR_GET_PTR(bp);
            memset(vp, 0, pool->type->instanceSize);
            vp->type = pool->type;
            vp->master = (ejs->master == 0);
#if BLD_DEBUG
            vp->seq = nextSequence++;
            checkAddr((EjsObj*) vp);
            pool->reuse++;
            pool->count--;
            mprAssert(pool->count >= 0);
            ejsAddToGcStats(ejs, vp, id);
#endif
            if (++ejs->workDone >= ejs->workQuota) {
                ejs->gcRequired = 1;
                ejsAttention(ejs);
            }
            return vp;
        }
    }
    return 0;
}


/*
    Free an object. This is should only ever be called by the destroy helpers to free a object or recycle the 
    object to a type specific free pool. 
 */
void ejsFree(Ejs *ejs, EjsObj *vp, int id)
{
    EjsType     *type;
    EjsPool     *pool;
    EjsGC       *gc;
    MprBlk      *bp, *pp;

    mprAssert(vp);
    checkAddr(vp);

    gc = &ejs->gc;
    type = vp->type;
    if (id < 0) {
        id = type->id;
    }
    pool = gc->pools[id];

    if (!type->dontPool && 0 <= id && id < gc->numPools && pool->count < EJS_MAX_OBJ_POOL) {
        /*
            Transfer from the current generation back to the pool. Inline for speed.
         */
        pool->type = vp->type; 
        pp = MPR_GET_BLK(pool);
        bp = MPR_GET_BLK(vp);
        if (bp->prev) {
            bp->prev->next = bp->next;
        } else {
            bp->parent->children = bp->next;
        }
        if (bp->next) {
            bp->next->prev = bp->prev;
        }
        if (bp->children) {
            /* Frees any allocated slots, names or traits */
            mprFreeChildren(vp);
        }
        /*
            Add to the pool
         */
        bp->parent = pp;
        if (pp->children) {
            pp->children->prev = bp;
        }
        bp->next = pp->children;
        pp->children = bp;
        bp->prev = 0;

#if BLD_DEBUG
        vp->type = (void*) -1;
        pool->allocated--;
        mprAssert(pool->allocated >= 0);
        pool->count++;
        if (pool->count > pool->peakCount) {
            pool->peakCount = pool->count;
        }
#endif
    } else {
#if BLD_DEBUG
        vp->type = (void*) -1;
        if (0 <= id && id < gc->numPools) {
            pool = gc->pools[id];
            pool->allocated--;
            mprAssert(pool->allocated >= 0);
        }
#endif
        mprFree(vp);
    }
}


/*
    Collect the garbage. This is a mark and sweep over all possible objects. If an object is not referenced, it and 
    all contained properties will be freed. Collection is done in generations.
 */
void ejsCollectGarbage(Ejs *ejs, int gen)
{
    EjsGC       *gc;
    
    gc = &ejs->gc;
    if (!gc->enabled || gc->collecting || !ejs->initialized) {
        return;
    }
    gc->collecting = 1;

    mark(ejs, gen);
    sweep(ejs, gen);
    if (!memoryUsageOk(ejs)) {
        pruneTypePools(ejs);
    }
    ejs->workDone = 0;
    ejs->gcRequired = 0;
    gc->collecting = 0;
#if BLD_DEBUG
    gc->totalSweeps++;
#endif
}


/*
    Mark phase. Mark objects that are still in use and should not be collected.
 */
static void mark(Ejs *ejs, int generation)
{
    EjsModule       *mp;
    EjsGC           *gc;
    EjsBlock        *block;
    EjsObj          *vp, **sp, **top;
    int             next;

    gc = &ejs->gc;
    gc->collectGeneration = generation;

    resetMarks(ejs);
    markGlobal(ejs, generation);

    if (ejs->result) {
        ejsMark(ejs, ejs->result);
    }
    if (ejs->exception) {
        ejsMark(ejs, ejs->exception);
    }
    if (ejs->exceptionArg) {
        ejsMark(ejs, ejs->exceptionArg);
    }
    if (ejs->memoryCallback) {
        ejsMark(ejs, (EjsObj*) ejs->memoryCallback);
    }
    if (ejs->search) {
        ejsMark(ejs, (EjsObj*) ejs->search);
    }
    if (ejs->emitter) {
        ejsMark(ejs, (EjsObj*) ejs->emitter);
    }
    if (ejs->sessions) {
        ejsMark(ejs, (EjsObj*) ejs->sessions);
    }
    if (ejs->applications) {
        ejsMark(ejs, (EjsObj*) ejs->applications);
    }
    
    /*
        Mark initializers
     */
    for (next = 0; (mp = (EjsModule*) mprGetNextItem(ejs->modules, &next)) != 0;) {
        if (mp->initializer) {
            ejsMark(ejs, (EjsObj*) mp->initializer);
        }
    }

    /*
        Mark blocks. This includes frames and blocks.
     */
    for (block = ejs->state->bp; block; block = block->prev) {
        ejsMark(ejs, (EjsObj*) block);
    }

    /*
        Mark the evaluation stack
     */
    top = ejs->state->stack;
    for (sp = ejs->state->stackBase; sp <= top; sp++) {
        if ((vp = *sp) != NULL) {
            ejsMark(ejs, vp);
        }
    }
}


/*
    Sweep up the garbage for a given generation
 */
static void sweep(Ejs *ejs, int maxGeneration)
{
    EjsObj      *vp;
    EjsGC       *gc;
    EjsGen      *gen;
    MprBlk      *bp, *next;
    int         destroyed, generation;
    
    /*
        Go from oldest to youngest incase moving objects to elder generations and we clear the mark.
     */
    gc = &ejs->gc;
    for (generation = maxGeneration; generation >= 0; generation--) {
        gc->collectGeneration = generation;
        gen = gc->generations[generation];

        for (destroyed = 0, bp = mprGetFirstChild(gen); bp; bp = next) {
            next = bp->next;
            vp = MPR_GET_PTR(bp);
            checkAddr(vp);
            if (!vp->marked && !vp->permanent) {
                (vp->type->helpers->destroy)(ejs, vp);
                destroyed++;
            }
        }
#if BLD_DEBUG
        gc->allocatedObjects -= destroyed;
        gc->totalReclaimed += destroyed;
        gen->totalReclaimed += destroyed;
        gen->totalSweeps++;
#endif
    }
}


/*
    Reset all marks prior to doing a mark/sweep
 */
static void resetMarks(Ejs *ejs)
{
    EjsGen      *gen;
    EjsGC       *gc;
    EjsObj      *vp;
    EjsBlock    *block, *b;
    MprBlk      *bp;
    int         i;

    gc = &ejs->gc;
    for (i = 0; i < EJS_MAX_GEN; i++) {
        gen = gc->generations[i];
        for (bp = mprGetFirstChild(gen); bp; bp = bp->next) {
            vp = MPR_GET_PTR(bp);
            vp->marked = 0;
        }
    }
    for (block = ejs->state->bp; block; block = block->prev) {
        block->obj.marked = 0;
        if (block->prevException) {
            block->prevException->marked = 0;
        }
        for (b = block->scopeChain; b; b = b->scopeChain) {
            b->obj.marked = 0;
        }
    }
}

    
/*
    Mark the global object
 */
static void markGlobal(Ejs *ejs, int generation)
{
    EjsGC       *gc;
    EjsObj      *obj;
    EjsBlock    *block;
    EjsObj      *item;
    MprHash     *hp;
    int         i, next;

    gc = &ejs->gc;

    obj = (EjsObj*) ejs->global;
    obj->marked = 1;

    if (generation == EJS_GEN_ETERNAL) {
        for (i = 0; i < obj->numSlots; i++) {
            ejsMark(ejs, obj->slots[i].value.ref);
        }
        for (hp = 0; (hp = mprGetNextHash(ejs->standardSpaces, hp)) != 0; ) {
            ejsMark(ejs, (EjsObj*) hp->data);
        }

    } else {
        for (i = gc->firstGlobal; i < obj->numSlots; i++) {
            ejsMark(ejs, obj->slots[i].value.ref);
        }
    }
    block = ejs->globalBlock;
    if (block->prevException) {
        ejsMark(ejs, (EjsObj*) block->prevException);
    }
    if (block->namespaces.length > 0) {
        for (next = 0; ((item = (EjsObj*) ejsGetNextItem(&block->namespaces, &next)) != 0); ) {
            ejsMark(ejs, item);
        }
    }
}


/*
    Mark a variable as used. All variable marking comes through here.
    NOTE: The container is not used by anyone (verified).
 */
void ejsMark(Ejs *ejs, EjsObj *vp)
{
    if (vp && !vp->marked) {
        checkAddr(vp);
        vp->marked = 1;
        (vp->type->helpers->mark)(ejs, vp);
    }
}


static inline bool memoryUsageOk(Ejs *ejs)
{
    MprAlloc    *alloc;
    int64        memory;

    memory = mprGetUsedMemory(ejs);
    alloc = mprGetAllocStats(ejs);
    return memory < alloc->redLine;
}


static inline void pruneTypePools(Ejs *ejs)
{
    EjsPool     *pool;
    EjsGC       *gc;
    EjsObj      *vp;
    MprAlloc    *alloc;
    MprBlk      *bp, *next;
    int64       memory;
    int         i;

    gc = &ejs->gc;

    /*
        Still insufficient memory, must reclaim all objects from the type pools.
     */
    for (i = 0; i < gc->numPools; i++) {
        pool = gc->pools[i];
        if (pool->count) {
            for (bp = mprGetFirstChild(pool); bp; bp = next) {
                next = bp->next;
                vp = MPR_GET_PTR(bp);
                mprFree(vp);
            }
            pool->count = 0;
        }
    }
    gc->totalRedlines++;

    memory = mprGetUsedMemory(ejs);
    alloc = mprGetAllocStats(ejs);

    if (memory >= alloc->maxMemory) {
        /*
            Could not provide sufficient memory. Go into graceful degrade mode
         */
        ejsThrowMemoryError(ejs);
        ejsGracefulDegrade(ejs);
    }
}


/*
    Make all eternal allocations permanent. This prevents an eternal GC from collecting core essential values like
    ejs->zeroValue. Do this to keep markGlobal() simple, otherwise it would have to enumerate values like this.
 */
void ejsMakeEternalPermanent(Ejs *ejs)
{
    EjsGen      *gen;
    EjsObj      *vp;
    MprBlk      *bp;

    gen = ejs->gc.generations[EJS_GEN_ETERNAL];
    for (bp = mprGetFirstChild(gen); bp; bp = bp->next) {
        vp = MPR_GET_PTR(bp);
        vp->permanent = 1;
    }
}


/*
    Permanent objects are never freed
 */
void ejsMakePermanent(Ejs *ejs, EjsObj *vp)
{
    vp->permanent = 1;
}


void ejsMakeTransient(Ejs *ejs, EjsObj *vp)
{
    vp->permanent = 0;
}


/*
    Return true if there is time to do a garbage collection and if we will benefit from it.
    Currently not used.
 */
int ejsIsTimeForGC(Ejs *ejs, int timeTillNextEvent)
{
    EjsGC       *gc;

    if (timeTillNextEvent < EJS_MIN_TIME_FOR_GC) {
        /*
            This is a heuristic where we want a good amount of idle time so that a proactive garbage collection won't 
            delay any I/O events.
         */
        return 0;
    }

    /*
        Return if we haven't done enough work to warrant a collection. Trigger a little short of the work quota to try 
        to run GC before a demand allocation requires it.
     */
    gc = &ejs->gc;
    if (!gc->enabled || ejs->workDone < (ejs->workQuota - EJS_SHORT_WORK_QUOTA)) {
        return 0;
    }
    mprLog(ejs, 7, "Time for GC. Work done %d, time till next event %d", ejs->workDone, timeTillNextEvent);
    return 1;
}


int ejsEnableGC(Ejs *ejs, bool on)
{
    int     old;

    old = ejs->gc.enabled;
    ejs->gc.enabled = on;
    return old;
}


/*
    On a memory allocation failure, go into graceful degrade mode. Set all slab allocation chunk increments to 1 
    so we can create an exception block to throw.
 */
void ejsGracefulDegrade(Ejs *ejs)
{
    mprLog(ejs, 1, "WARNING: Memory almost depleted. In graceful degrade mode");
    ejs->gc.degraded = 1;
    mprSignalExit(ejs);
}


int ejsSetGeneration(Ejs *ejs, int generation)
{
    int     old;
    
    old = ejs->gc.allocGeneration;
    ejs->gc.allocGeneration = generation;
    ejs->currentGeneration = ejs->gc.generations[generation];
    return old;
}


#undef ejsAddToGcStats

/*
    Update GC stats for a new object allocation
 */
void ejsAddToGcStats(Ejs *ejs, EjsObj *vp, int id)
{
#if BLD_DEBUG
    EjsPool     *pool;
    EjsGC       *gc;

    gc = &ejs->gc;
    if (id < ejs->gc.numPools) {
        pool = ejs->gc.pools[id];
        pool->allocated++;
        mprAssert(pool->allocated >= 0);
        if (pool->allocated > pool->peakAllocated) {
            pool->peakAllocated = pool->allocated;
        }
    }
    gc->totalAllocated++;
    gc->allocatedObjects++;
    if (gc->allocatedObjects >= gc->peakAllocatedObjects) {
        gc->peakAllocatedObjects = gc->allocatedObjects;
    }
    if (vp->type == ejs->typeType) {
        gc->allocatedTypes++;
        if (gc->allocatedTypes >= gc->peakAllocatedTypes) {
            gc->peakAllocatedTypes = gc->allocatedTypes;
        }
    }
    /* Convenient place for this */
    vp->seq = nextSequence++;
    checkAddr(vp);
#endif
}


void ejsPrintAllocReport(Ejs *ejs)
{
#if BLD_DEBUG
    EjsType         *type;
    EjsGC           *gc;
    EjsPool         *pool;
    MprAlloc        *ap;
    int             i, maxSlot, typeMemory, count, peakCount, freeCount, peakFreeCount, reuseCount;

    gc = &ejs->gc;
    ap = mprGetAllocStats(ejs);
    
    /*
        EJS stats
     */
    mprLog(ejs, 0, "\n\nEJS Memory Statistics");
    mprLog(ejs, 0, "  Types allocated        %,14d", gc->allocatedTypes / 2);
    mprLog(ejs, 0, "  Objects allocated      %,14d", gc->allocatedObjects);
    mprLog(ejs, 0, "  Peak objects allocated %,14d", gc->peakAllocatedObjects);

    /*
        Per type
     */
    mprLog(ejs, 0, "\nObject Cache Statistics");
    mprLog(ejs, 0, "------------------------");
    mprLog(ejs, 0, "Name                TypeSize  ObjectSize  ObjectCount  PeakCount  FreeList  PeakFreeList   ReuseCount");
    
    maxSlot = ejsGetPropertyCount(ejs, ejs->global);
    typeMemory = 0;

    count = peakCount = freeCount = peakFreeCount = reuseCount = 0;
    for (i = 0; i < gc->numPools; i++) {
        pool = gc->pools[i];
        type = ejsGetType(ejs, i);
        if (type == 0) {
            continue;
        }
        if (type->id != i) {
            /* Skip type alias (string == String) */
            continue;
        }
        mprLog(ejs, 0, "%-22s %,5d %,8d %,10d  %,10d, %,9d, %,10d, %,14d", type->qname.name, ejsGetTypeSize(ejs, type), 
            type->instanceSize, pool->allocated, pool->peakAllocated, pool->count, pool->peakCount, pool->reuse);

        typeMemory += ejsGetTypeSize(ejs, type);
        count += pool->allocated;
        peakCount += pool->peakAllocated;
        freeCount += pool->count;
        peakFreeCount += pool->peakCount;
        reuseCount += pool->reuse;
    }
    mprLog(ejs, 0, "%-22s                %,10d  %,10d, %,9d, %,10d, %,14d", "Total", 
        count, peakCount, freeCount, peakFreeCount, reuseCount);
    mprLog(ejs, 0, "\nTotal type memory        %,14d K", typeMemory / 1024);

    mprLog(ejs, 0, "\nEJS Garbage Collector Statistics");
    mprLog(ejs, 0, "  Total allocations      %,14d", gc->totalAllocated);
    mprLog(ejs, 0, "  Total reclaimations    %,14d", gc->totalReclaimed);
    mprLog(ejs, 0, "  Total sweeps           %,14d", gc->totalSweeps);
    mprLog(ejs, 0, "  Total redlines         %,14d", gc->totalRedlines);
    mprLog(ejs, 0, "  Object GC work quota   %,14d", ejs->workQuota);
    //  TODO - check these stats. Need a total of all allocations and all reuse
#endif
}

/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2010. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2010. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    @end
 */
/************************************************************************/
/*
 *  End of file "../src/vm/ejsGarbage.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../src/vm/ejsInterp.c"
 */
/************************************************************************/

/*
    ejsInterp.c - Virtual Machine Interpreter for Ejscript.

    Copyright (c) All Rights Reserved. See details at the end of the file.

    NEXT
        - Optimize and cache stack.top
        - Fix BAD BINDING
        - Move DEBUG op codes out of line
 */




static void callFunction(Ejs *ejs, EjsFunction *fun, EjsObj *thisObj, int argc, int stackAdjust);

/*
    The stack is a stack of pointers to EjsObj. The top of stack (stack.top) always points to the current top item 
    on the stack. To push a new value, top is incremented then the value is stored. To pop, simply copy the value at 
    top and decrement top ptr.
 */
#define top                     (*state.stack)
#define pop(ejs)                (*state.stack--)

#define push(value)             (*(++(state.stack))) = ((EjsObj*) (value))
#if UNUSED
#define push(value) \
    if (1) { \
        EjsObj *v = (EjsObj*) (value); \
        mprAssert(v) ; \
        (*(++(state.stack))) = v; \
    } else
#endif

#define popString(ejs)          ((EjsString*) pop(ejs))
#define popOutside(ejs)         *(ejs->state->stack)--
#define pushOutside(ejs, value) (*(++(ejs->state->stack))) = ((EjsObj*) (value))

#define FRAME                   state.fp
#define FUNCTION                state.fp.function
#define BLOCK                   state.bp

#define SWAP if (1) { \
        EjsObj *swap = state.stack[0]; \
        state.stack[0] = state.stack[-1]; \
        state.stack[-1] = swap; \
    }

#define TRACE if (1) { \
        FRAME->filename = GET_STRING(); \
        FRAME->lineNumber = GET_INT(); \
        FRAME->currentLine = GET_STRING(); \
    }


static MPR_INLINE void getPropertyFromSlot(Ejs *ejs, EjsObj *thisObj, EjsObj *obj, int slotNum) 
{
    EjsFunction     *fun, *value;

    if (ejsHasTrait(obj, slotNum, EJS_TRAIT_GETTER)) {
        fun = (EjsFunction*) ejsGetProperty(ejs, obj, slotNum);
        callFunction(ejs, fun, thisObj, 0, 0);
        if (ejsIsNativeFunction(fun)) {
            pushOutside(ejs, ejs->result);
        } else {
            ejs->state->fp->getter = 1;
        }
        return;
    }
    value = (EjsFunction*) ejsGetProperty(ejs, obj, slotNum);
    if (ejsIsFunction(value)) {
        fun = (EjsFunction*) value;
        if (!fun->thisObj && thisObj) {
            /* Function extraction. Bind the "thisObj" into a clone of the function */
            fun = ejsCloneFunction(ejs, fun, 0);
            fun->thisObj = thisObj;
        }
    }
    pushOutside(ejs, value);
}

#define GET_SLOT(thisObj, obj, slotNum) getPropertyFromSlot(ejs, (EjsObj*) thisObj, (EjsObj*) obj, slotNum)

static MPR_INLINE void checkGetter(Ejs *ejs, EjsObj *value, EjsObj *thisObj, EjsObj *obj, int slotNum) 
{
    EjsFunction     *fun;

    if (ejsIsFunction(value)) {
        fun = (EjsFunction*) value;
        if (ejsHasTrait(obj, slotNum, EJS_TRAIT_GETTER)) {
            callFunction(ejs, fun, thisObj, 0, 0);
            if (ejsIsNativeFunction(fun)) {
                pushOutside(ejs, ejs->result);
            } else {
                ejs->state->fp->getter = 1;
            }
            return;
        } else {
            if (!fun->thisObj && thisObj) {
                /* Function extraction. Bind the "thisObj" into a clone of the function */
                fun = ejsCloneFunction(ejs, fun, 0);
                fun->thisObj = thisObj;
                value = (EjsObj*) fun;
            }
        }
    } else if (value == 0) {
        value = ejs->undefinedValue;
    }
    pushOutside(ejs, value);
}

#define CHECK_VALUE(value, thisObj, obj, slotNum) \
    checkGetter(ejs, (EjsObj*) value, (EjsObj*) thisObj, (EjsObj*) obj, slotNum)

/*
    Set a slot value when we don't know if the object is an EjsObj
 */
#define SET_SLOT(thisObj, obj, slotNum, value) \
    storePropertyToSlot(ejs, (EjsObj*) thisObj, (EjsObj*) obj, slotNum, (EjsObj*) value)

/*
    Must clear attentionPc when changing the PC. Otherwise the next instruction will jump to a bad (stale) location.
 */
#define SET_PC(fp, value) \
    if (1) { \
        (fp)->pc = (uchar*) (value); \
        (fp)->attentionPc = 0; \
    } else 

#define GET_BYTE()      *(FRAME)->pc++
#define GET_DOUBLE()    ejsDecodeDouble(&(FRAME)->pc)
#define GET_INT()       (int) ejsDecodeNum(&(FRAME)->pc)
#define GET_NUM()       ejsDecodeNum(&(FRAME)->pc)
#define GET_NAME()      getNameArg(FRAME)
#define GET_STRING()    getStringArg(FRAME)
#define GET_TYPE()      ((EjsType*) getGlobalArg(ejs, FRAME))
#define GET_WORD()      ejsDecodeWord(&(FRAME)->pc)
#undef THIS
#define THIS            FRAME->function.thisObj
#define FILL(mark)      while (mark < FRAME->pc) { *mark++ = EJS_OP_NOP; }

#if BLD_DEBUG
    static EjsOpCode traceCode(Ejs *ejs, EjsOpCode opcode);
    static int opcount[256];
#else
    #define traceCode(ejs, opcode) opcode
#endif

#if LINUX || MACOSX || LINUX || SOLARIS || VXWORKS
    #define CASE(opcode) opcode
    #define BREAK goto *opcodeJump[opcode = traceCode(ejs, GET_BYTE())]
#else
    /*
        Traditional switch for compilers (looking at you MS) without computed goto.
     */
    #define BREAK break
    #define CASE(opcode) case opcode
#endif


static void callConstructor(Ejs *ejs, EjsFunction *vp, int argc, int stackAdjust);
static void callInterfaceInitializers(Ejs *ejs, EjsType *type);
static void callProperty(Ejs *ejs, EjsFunction *fun, EjsObj *thisObj, int argc, int stackAdjust);
static void checkExceptionHandlers(Ejs *ejs);
static void createExceptionBlock(Ejs *ejs, EjsEx *ex, int flags);
static EjsObj *evalBinaryExpr(Ejs *ejs, EjsObj *lhs, EjsOpCode opcode, EjsObj *rhs);
static inline uint findEndException(Ejs *ejs);
static inline EjsEx *findExceptionHandler(Ejs *ejs, int kind);
static EjsName getNameArg(EjsFrame *fp);
static EjsObj *getNthBase(Ejs *ejs, EjsObj *obj, int nthBase);
static EjsObj *getNthBaseFromBottom(Ejs *ejs, EjsObj *obj, int nthBase);
static EjsObj *getNthBlock(Ejs *ejs, int nth);
static char *getStringArg(EjsFrame *fp);
static EjsObj *getGlobalArg(Ejs *ejs, EjsFrame *fp);
static bool manageExceptions(Ejs *ejs);
static EjsBlock *popExceptionBlock(Ejs *ejs);
static void storeProperty(Ejs *ejs, EjsObj *thisObj, EjsObj *obj, EjsName *name, EjsObj *value, bool dup);
static void storePropertyToSlot(Ejs *ejs, EjsObj *thisObj, EjsObj *obj, int slotNum, EjsObj *value);
static void storePropertyToScope(Ejs *ejs, EjsName *qname, EjsObj *value, bool dup);
static void throwNull(Ejs *ejs);

/*
    Virtual Machine byte code evaluation
 */
static void VM(Ejs *ejs, EjsFunction *fun, EjsObj *otherThis, int argc, int stackAdjust)
{
    EjsState    *priorState, state;
    EjsName     qname;
    EjsObj      *result, *vp, *v1, *v2, *obj, *value;
    int         slotNum, nthBase;

    EjsBlock    *blk;
    EjsObj      *vobj, *global, *thisObj;
    EjsString   *nameVar, *spaceVar;
    EjsType     *type;
    EjsLookup   lookup;
    EjsEx       *ex;
    EjsFrame    *newFrame;
    EjsFunction *f1, *f2;
    char        *str;
    uchar       *mark;
    int         i, offset, count, opcode, attributes;

#if LINUX || MACOSX || LINUX || SOLARIS || VXWORKS 
    /*
        Direct threading computed goto processing. Include computed goto jump table.
     */
static void *opcodeJump[] = {
    &&EJS_OP_ADD,
    &&EJS_OP_ADD_NAMESPACE,
    &&EJS_OP_ADD_NAMESPACE_REF,
    &&EJS_OP_AND,
    &&EJS_OP_ATTENTION,
    &&EJS_OP_BRANCH_EQ,
    &&EJS_OP_BRANCH_STRICTLY_EQ,
    &&EJS_OP_BRANCH_FALSE,
    &&EJS_OP_BRANCH_GE,
    &&EJS_OP_BRANCH_GT,
    &&EJS_OP_BRANCH_LE,
    &&EJS_OP_BRANCH_LT,
    &&EJS_OP_BRANCH_NE,
    &&EJS_OP_BRANCH_STRICTLY_NE,
    &&EJS_OP_BRANCH_NULL,
    &&EJS_OP_BRANCH_NOT_ZERO,
    &&EJS_OP_BRANCH_TRUE,
    &&EJS_OP_BRANCH_UNDEFINED,
    &&EJS_OP_BRANCH_ZERO,
    &&EJS_OP_BRANCH_FALSE_8,
    &&EJS_OP_BRANCH_TRUE_8,
    &&EJS_OP_BREAKPOINT,
    &&EJS_OP_CALL,
    &&EJS_OP_CALL_GLOBAL_SLOT,
    &&EJS_OP_CALL_OBJ_SLOT,
    &&EJS_OP_CALL_THIS_SLOT,
    &&EJS_OP_CALL_BLOCK_SLOT,
    &&EJS_OP_CALL_OBJ_INSTANCE_SLOT,
    &&EJS_OP_CALL_OBJ_STATIC_SLOT,
    &&EJS_OP_CALL_THIS_STATIC_SLOT,
    &&EJS_OP_CALL_OBJ_NAME,
    &&EJS_OP_CALL_SCOPED_NAME,
    &&EJS_OP_CALL_CONSTRUCTOR,
    &&EJS_OP_CALL_NEXT_CONSTRUCTOR,
    &&EJS_OP_CAST,
    &&EJS_OP_CAST_BOOLEAN,
    &&EJS_OP_CLOSE_BLOCK,
    &&EJS_OP_COMPARE_EQ,
    &&EJS_OP_COMPARE_STRICTLY_EQ,
    &&EJS_OP_COMPARE_FALSE,
    &&EJS_OP_COMPARE_GE,
    &&EJS_OP_COMPARE_GT,
    &&EJS_OP_COMPARE_LE,
    &&EJS_OP_COMPARE_LT,
    &&EJS_OP_COMPARE_NE,
    &&EJS_OP_COMPARE_STRICTLY_NE,
    &&EJS_OP_COMPARE_NULL,
    &&EJS_OP_COMPARE_NOT_ZERO,
    &&EJS_OP_COMPARE_TRUE,
    &&EJS_OP_COMPARE_UNDEFINED,
    &&EJS_OP_COMPARE_ZERO,
    &&EJS_OP_DEBUG,
    &&EJS_OP_DEFINE_CLASS,
    &&EJS_OP_DEFINE_FUNCTION,
    &&EJS_OP_DELETE_NAME_EXPR,
    &&EJS_OP_DELETE_SCOPED_NAME_EXPR,
    &&EJS_OP_DIV,
    &&EJS_OP_DUP,
    &&EJS_OP_DUP2,
    &&EJS_OP_END_CODE,
    &&EJS_OP_END_EXCEPTION,
    &&EJS_OP_GOTO,
    &&EJS_OP_GOTO_8,
    &&EJS_OP_INC,
    &&EJS_OP_INIT_DEFAULT_ARGS,
    &&EJS_OP_INIT_DEFAULT_ARGS_8,
    &&EJS_OP_INST_OF,
    &&EJS_OP_IS_A,
    &&EJS_OP_LOAD_0,
    &&EJS_OP_LOAD_1,
    &&EJS_OP_LOAD_2,
    &&EJS_OP_LOAD_3,
    &&EJS_OP_LOAD_4,
    &&EJS_OP_LOAD_5,
    &&EJS_OP_LOAD_6,
    &&EJS_OP_LOAD_7,
    &&EJS_OP_LOAD_8,
    &&EJS_OP_LOAD_9,
    &&EJS_OP_LOAD_DOUBLE,
    &&EJS_OP_LOAD_FALSE,
    &&EJS_OP_LOAD_GLOBAL,
    &&EJS_OP_LOAD_INT,
    &&EJS_OP_LOAD_M1,
    &&EJS_OP_LOAD_NAMESPACE,
    &&EJS_OP_LOAD_NULL,
    &&EJS_OP_LOAD_REGEXP,
    &&EJS_OP_LOAD_STRING,
    &&EJS_OP_LOAD_THIS,
    &&EJS_OP_LOAD_TRUE,
    &&EJS_OP_LOAD_UNDEFINED,
    &&EJS_OP_LOAD_XML,
    &&EJS_OP_GET_LOCAL_SLOT_0,
    &&EJS_OP_GET_LOCAL_SLOT_1,
    &&EJS_OP_GET_LOCAL_SLOT_2,
    &&EJS_OP_GET_LOCAL_SLOT_3,
    &&EJS_OP_GET_LOCAL_SLOT_4,
    &&EJS_OP_GET_LOCAL_SLOT_5,
    &&EJS_OP_GET_LOCAL_SLOT_6,
    &&EJS_OP_GET_LOCAL_SLOT_7,
    &&EJS_OP_GET_LOCAL_SLOT_8,
    &&EJS_OP_GET_LOCAL_SLOT_9,
    &&EJS_OP_GET_OBJ_SLOT_0,
    &&EJS_OP_GET_OBJ_SLOT_1,
    &&EJS_OP_GET_OBJ_SLOT_2,
    &&EJS_OP_GET_OBJ_SLOT_3,
    &&EJS_OP_GET_OBJ_SLOT_4,
    &&EJS_OP_GET_OBJ_SLOT_5,
    &&EJS_OP_GET_OBJ_SLOT_6,
    &&EJS_OP_GET_OBJ_SLOT_7,
    &&EJS_OP_GET_OBJ_SLOT_8,
    &&EJS_OP_GET_OBJ_SLOT_9,
    &&EJS_OP_GET_THIS_SLOT_0,
    &&EJS_OP_GET_THIS_SLOT_1,
    &&EJS_OP_GET_THIS_SLOT_2,
    &&EJS_OP_GET_THIS_SLOT_3,
    &&EJS_OP_GET_THIS_SLOT_4,
    &&EJS_OP_GET_THIS_SLOT_5,
    &&EJS_OP_GET_THIS_SLOT_6,
    &&EJS_OP_GET_THIS_SLOT_7,
    &&EJS_OP_GET_THIS_SLOT_8,
    &&EJS_OP_GET_THIS_SLOT_9,
    &&EJS_OP_GET_SCOPED_NAME,
    &&EJS_OP_GET_SCOPED_NAME_EXPR,
    &&EJS_OP_GET_OBJ_NAME,
    &&EJS_OP_GET_OBJ_NAME_EXPR,
    &&EJS_OP_GET_BLOCK_SLOT,
    &&EJS_OP_GET_GLOBAL_SLOT,
    &&EJS_OP_GET_LOCAL_SLOT,
    &&EJS_OP_GET_OBJ_SLOT,
    &&EJS_OP_GET_THIS_SLOT,
    &&EJS_OP_GET_TYPE_SLOT,
    &&EJS_OP_GET_THIS_TYPE_SLOT,
    &&EJS_OP_IN,
    &&EJS_OP_LIKE,
    &&EJS_OP_LOGICAL_NOT,
    &&EJS_OP_MUL,
    &&EJS_OP_NEG,
    &&EJS_OP_NEW,
    &&EJS_OP_NEW_OBJECT,
    &&EJS_OP_NOP,
    &&EJS_OP_NOT,
    &&EJS_OP_OPEN_BLOCK,
    &&EJS_OP_OPEN_WITH,
    &&EJS_OP_OR,
    &&EJS_OP_POP,
    &&EJS_OP_POP_ITEMS,
    &&EJS_OP_PUSH_CATCH_ARG,
    &&EJS_OP_PUSH_RESULT,
    &&EJS_OP_PUT_LOCAL_SLOT_0,
    &&EJS_OP_PUT_LOCAL_SLOT_1,
    &&EJS_OP_PUT_LOCAL_SLOT_2,
    &&EJS_OP_PUT_LOCAL_SLOT_3,
    &&EJS_OP_PUT_LOCAL_SLOT_4,
    &&EJS_OP_PUT_LOCAL_SLOT_5,
    &&EJS_OP_PUT_LOCAL_SLOT_6,
    &&EJS_OP_PUT_LOCAL_SLOT_7,
    &&EJS_OP_PUT_LOCAL_SLOT_8,
    &&EJS_OP_PUT_LOCAL_SLOT_9,
    &&EJS_OP_PUT_OBJ_SLOT_0,
    &&EJS_OP_PUT_OBJ_SLOT_1,
    &&EJS_OP_PUT_OBJ_SLOT_2,
    &&EJS_OP_PUT_OBJ_SLOT_3,
    &&EJS_OP_PUT_OBJ_SLOT_4,
    &&EJS_OP_PUT_OBJ_SLOT_5,
    &&EJS_OP_PUT_OBJ_SLOT_6,
    &&EJS_OP_PUT_OBJ_SLOT_7,
    &&EJS_OP_PUT_OBJ_SLOT_8,
    &&EJS_OP_PUT_OBJ_SLOT_9,
    &&EJS_OP_PUT_THIS_SLOT_0,
    &&EJS_OP_PUT_THIS_SLOT_1,
    &&EJS_OP_PUT_THIS_SLOT_2,
    &&EJS_OP_PUT_THIS_SLOT_3,
    &&EJS_OP_PUT_THIS_SLOT_4,
    &&EJS_OP_PUT_THIS_SLOT_5,
    &&EJS_OP_PUT_THIS_SLOT_6,
    &&EJS_OP_PUT_THIS_SLOT_7,
    &&EJS_OP_PUT_THIS_SLOT_8,
    &&EJS_OP_PUT_THIS_SLOT_9,
    &&EJS_OP_PUT_OBJ_NAME_EXPR,
    &&EJS_OP_PUT_OBJ_NAME,
    &&EJS_OP_PUT_SCOPED_NAME,
    &&EJS_OP_PUT_SCOPED_NAME_EXPR,
    &&EJS_OP_PUT_BLOCK_SLOT,
    &&EJS_OP_PUT_GLOBAL_SLOT,
    &&EJS_OP_PUT_LOCAL_SLOT,
    &&EJS_OP_PUT_OBJ_SLOT,
    &&EJS_OP_PUT_THIS_SLOT,
    &&EJS_OP_PUT_TYPE_SLOT,
    &&EJS_OP_PUT_THIS_TYPE_SLOT,
    &&EJS_OP_REM,
    &&EJS_OP_RETURN,
    &&EJS_OP_RETURN_VALUE,
    &&EJS_OP_SAVE_RESULT,
    &&EJS_OP_SHL,
    &&EJS_OP_SHR,
    &&EJS_OP_SUB,
    &&EJS_OP_SUPER,
    &&EJS_OP_SWAP,
    &&EJS_OP_THROW,
    &&EJS_OP_TYPE_OF,
    &&EJS_OP_USHR,
    &&EJS_OP_XOR,
    &&EJS_OP_FINALLY,
};
#endif
    mprAssert(ejs);
    mprAssert(!mprHasAllocError(ejs));
    mprAssert(!ejs->exception);
    mprAssert(ejs->state->fp == 0 || ejs->state->fp->attentionPc == 0);

    vp = 0;
    slotNum = -1;
    global = (EjsObj*) ejs->global;

    priorState = ejs->state;
    state = *ejs->state;
    ejs->state = &state;

    callFunction(ejs, fun, otherThis, argc, stackAdjust);
    FRAME->caller = 0;
    FRAME->currentLine = 0;
    FRAME->filename = 0;
    FRAME->lineNumber = 0;

    mprAssert(!FRAME->attentionPc);

#if LINUX || MACOSX || LINUX || SOLARIS || VXWORKS 
    /*
        Direct threading computed goto processing. Include computed goto jump table.
     */
    BREAK;
#else
    /*
        Traditional switch for compilers (looking at you MS) without computed goto.
     */
    while (1) {
        opcode = (EjsOpCode) GET_BYTE();
        traceCode(ejs, opcode);
        switch (opcode) {
#endif
        /*
            Symbolic source code debug information
                Debug <filename> <lineNumber> <sourceLine>
         */
        CASE (EJS_OP_DEBUG):
            TRACE; BREAK;

        /*
            End of a code block. Used to mark the end of a script. Saves testing end of code block in VM loop.
                EndCode
         */
        CASE (EJS_OP_END_CODE):
            /*
                The "ejs" command needs to preserve the current ejs->result for interactive sessions.
             */
            if (ejs->result == 0) {
                // OPT - remove this
                ejs->result = ejs->undefinedValue;
            }
            if (FRAME->getter) {
                push(ejs->result);
            }
            FRAME = 0;
            goto done;

        /*
            Return from a function with a result
                ReturnValue
                Stack before (top)  [value]
                Stack after         []
         */
        CASE (EJS_OP_RETURN_VALUE):
            ejs->result = pop(ejs);
            if (FRAME->caller == 0) {
                goto done;
            }
            state.stack = FRAME->stackReturn;
            if (ejs->result) {
                f1 = &FRAME->function;
                if (FRAME->function.resultType) {
                    type = FRAME->function.resultType;
                    //  MOB remove this voidType
                    if (type != ejs->voidType && !ejsIsA(ejs, ejs->result, type)) {
                        if (ejs->result == ejs->nullValue || ejs->result == ejs->undefinedValue) {
                            if (FRAME->function.throwNulls) {
                                ejsThrowTypeError(ejs, "Unacceptable null or undefined return value");
                                BREAK;
                            } else if (FRAME->function.castNulls) {
                                ejs->result = ejsCast(ejs, ejs->result, type);
                                if (ejs->exception) {
                                    BREAK;
                                }
                            }
                        } else {
                            ejs->result = ejsCast(ejs, ejs->result, type);
                            if (ejs->exception) {
                                BREAK;
                            }
                        }
                    }
                }
            }
            if (FRAME->getter) {
                push(ejs->result);
            }
            state.bp = FRAME->function.block.prev;
            newFrame = FRAME->caller;
            FRAME = newFrame;
            BREAK;

        /*
            Return from a function without a result
                Return
         */
        CASE (EJS_OP_RETURN):
            ejs->result = ejs->undefinedValue;
            if (FRAME->caller == 0) {
                goto done;
            }
            state.stack = FRAME->stackReturn;
            state.bp = FRAME->function.block.prev;
            newFrame = FRAME->caller;
            FRAME = newFrame;
            BREAK;

        /*
            Load the catch argument
                PushCatchArg
                Stack before (top)  []
                Stack after         [catchArg]
         */
        CASE (EJS_OP_PUSH_CATCH_ARG):
            push(ejs->exceptionArg);
            ejs->exceptionArg = 0;
            BREAK;

        /*
            Push the function call result
                PushResult
                Stack before (top)  []
                Stack after         [result]
         */
        CASE (EJS_OP_PUSH_RESULT):
            push(ejs->result);
            BREAK;

        /*
            Save the top of stack and store in the interpreter result register
                SaveResult
                Stack before (top)  [value]
                Stack after         []
         */
        CASE (EJS_OP_SAVE_RESULT):
            ejs->result = pop(ejs);
            BREAK;

        /* Load Constants ----------------------------------------------- */

        /*
            Load a float constant
                LoadDouble          <double>
                Stack before (top)  []
                Stack after         [Double]
         */
        CASE (EJS_OP_LOAD_DOUBLE):
            push(ejsCreateNumber(ejs, GET_DOUBLE()));
            BREAK;

        /*
            Load a signed integer constant (up to 55 bits worth of data)
                LoadInt.64          <int64>
                Stack before (top)  []
                Stack after         [Number]
         */
        CASE (EJS_OP_LOAD_INT):
            push(ejsCreateNumber(ejs, (MprNumber) GET_NUM()));
            BREAK;

        /*
            Load integer constant between 0 and 9
                Load0, Load1, ... Load9
                Stack before (top)  []
                Stack after         [Number]
         */
        CASE (EJS_OP_LOAD_0):
        CASE (EJS_OP_LOAD_1):
        CASE (EJS_OP_LOAD_2):
        CASE (EJS_OP_LOAD_3):
        CASE (EJS_OP_LOAD_4):
        CASE (EJS_OP_LOAD_5):
        CASE (EJS_OP_LOAD_6):
        CASE (EJS_OP_LOAD_7):
        CASE (EJS_OP_LOAD_8):
        CASE (EJS_OP_LOAD_9):
            push(ejsCreateNumber(ejs, opcode - EJS_OP_LOAD_0));
            BREAK;

        /*
            Load the -1 integer constant
                LoadMinusOne
                Stack before (top)  []
                Stack after         [Number]
         */
        CASE (EJS_OP_LOAD_M1):
            push(ejsCreateNumber(ejs, -1));
            BREAK;

        /*
            Load a string constant
                LoadString          <string>
                Stack before (top)  []
                Stack after         [String]
         */
        CASE (EJS_OP_LOAD_STRING):
            str = GET_STRING();
            push(ejsCreateString(ejs, str));
            BREAK;

        /*
            Load a namespace constant
                LoadNamespace       <UriString>
                Stack before (top)  []
                Stack after         [Namespace]
         */
        CASE (EJS_OP_LOAD_NAMESPACE):
            str = GET_STRING();
            push(ejsCreateNamespace(ejs, str, str));
            BREAK;


        /*
            Load an XML constant
                LoadXML             <xmlString>
                Stack before (top)  []
                Stack after         [XML]
         */
        CASE (EJS_OP_LOAD_XML):
            v1 = (EjsObj*) ejsCreate(ejs, ejs->xmlType, 0);
            str = GET_STRING();
            ejsLoadXMLString(ejs, (EjsXML*) v1, str);
            push(v1);
            BREAK;

        /*
            Load a Regexp constant
                LoadRegExp
                Stack before (top)  []
                Stack after         [RegExp]
         */
        CASE (EJS_OP_LOAD_REGEXP):
            str = GET_STRING();
            v1 = (EjsObj*) ejsCreateRegExp(ejs, str);
            push(v1);
            BREAK;

        /*
            Load a null constant
                LoadNull
                Stack before (top)  []
                Stack after         [Null]
         */
        CASE (EJS_OP_LOAD_NULL):
            push(ejs->nullValue);
            BREAK;

        /*
            Load a void / undefined constant
                LoadUndefined
                Stack before (top)  []
                Stack after         [undefined]
         */
        CASE (EJS_OP_LOAD_UNDEFINED):
            push(ejs->undefinedValue);
            BREAK;

        /*
            Load the "this" value
                LoadThis
                Stack before (top)  []
                Stack after         [this]
         */
        CASE (EJS_OP_LOAD_THIS):
            push(THIS);
            BREAK;

        /*
            Load the "global" value
                LoadGlobal
                Stack before (top)  []
                Stack after         [global]
         */
        CASE (EJS_OP_LOAD_GLOBAL):
            push(ejs->global);
            BREAK;

        /*
            Load the "true" value
                LoadTrue
                Stack before (top)  []
                Stack after         [true]
         */
        CASE (EJS_OP_LOAD_TRUE):
            push(ejs->trueValue);
            BREAK;

        /*
            Load the "false" value
                LoadFalse
                Stack before (top)  []
                Stack after         [false]
         */
        CASE (EJS_OP_LOAD_FALSE):
            push(ejs->falseValue);
            BREAK;

        /*
            Load a global variable by slot number
                GetGlobalSlot       <slot>
                Stack before (top)  []
                Stack after         [PropRef]
         */
        CASE (EJS_OP_GET_GLOBAL_SLOT):
            GET_SLOT(NULL, global, GET_INT());
            BREAK;

        /*
            Load a local variable by slot number
                GetLocalSlot        <slot>
                Stack before (top)  []
                Stack after         [PropRef]
         */
        CASE (EJS_OP_GET_LOCAL_SLOT):
            GET_SLOT(NULL, FRAME, GET_INT());
            BREAK;

        /*
            Load a local variable in slot 0-9
                GetLocalSlot0, GetLocalSlot1, ... GetLocalSlot9
                Stack before (top)  []
                Stack after         [PropRef]
         */
        CASE (EJS_OP_GET_LOCAL_SLOT_0):
        CASE (EJS_OP_GET_LOCAL_SLOT_1):
        CASE (EJS_OP_GET_LOCAL_SLOT_2):
        CASE (EJS_OP_GET_LOCAL_SLOT_3):
        CASE (EJS_OP_GET_LOCAL_SLOT_4):
        CASE (EJS_OP_GET_LOCAL_SLOT_5):
        CASE (EJS_OP_GET_LOCAL_SLOT_6):
        CASE (EJS_OP_GET_LOCAL_SLOT_7):
        CASE (EJS_OP_GET_LOCAL_SLOT_8):
        CASE (EJS_OP_GET_LOCAL_SLOT_9):
            GET_SLOT(NULL, FRAME, opcode - EJS_OP_GET_LOCAL_SLOT_0);
            BREAK;

        /*
            Load a block scoped variable by slot number
                GetBlockSlot        <slot> <nthBlock>
                Stack before (top)  []
                Stack after         [value]
         */
        CASE (EJS_OP_GET_BLOCK_SLOT):
            slotNum = GET_INT();
            obj = (EjsObj*) getNthBlock(ejs, GET_INT());
            GET_SLOT(NULL, obj, slotNum);
            BREAK;

        /*
            Load a property in thisObj by slot number
                GetThisSlot         <slot>
                Stack before (top)  []
                Stack after         [value]
         */
        CASE (EJS_OP_GET_THIS_SLOT):
            GET_SLOT(THIS, THIS, GET_INT());
            BREAK;

        /*
            Load a property in slot 0-9
                GetThisSlot0, GetThisSlot1,  ... GetThisSlot9
                Stack before (top)  []
                Stack after         [value]
         */
        CASE (EJS_OP_GET_THIS_SLOT_0):
        CASE (EJS_OP_GET_THIS_SLOT_1):
        CASE (EJS_OP_GET_THIS_SLOT_2):
        CASE (EJS_OP_GET_THIS_SLOT_3):
        CASE (EJS_OP_GET_THIS_SLOT_4):
        CASE (EJS_OP_GET_THIS_SLOT_5):
        CASE (EJS_OP_GET_THIS_SLOT_6):
        CASE (EJS_OP_GET_THIS_SLOT_7):
        CASE (EJS_OP_GET_THIS_SLOT_8):
        CASE (EJS_OP_GET_THIS_SLOT_9):
            GET_SLOT(THIS, THIS, opcode - EJS_OP_GET_THIS_SLOT_0);
            BREAK;

        /*
            Load a property in an object by slot number
                GetObjSlot          <slot>
                Stack before (top)  [obj]
                Stack after         [value]
         */
        CASE (EJS_OP_GET_OBJ_SLOT):
            vp = pop(ejs);
            GET_SLOT(vp, vp, GET_INT());
            BREAK;

        /*
            Load a property in an object from slot 0-9
                GetObjSlot0, GetObjSlot1, ... GetObjSlot9
                Stack before (top)  [obj]
                Stack after         [value]
         */
        CASE (EJS_OP_GET_OBJ_SLOT_0):
        CASE (EJS_OP_GET_OBJ_SLOT_1):
        CASE (EJS_OP_GET_OBJ_SLOT_2):
        CASE (EJS_OP_GET_OBJ_SLOT_3):
        CASE (EJS_OP_GET_OBJ_SLOT_4):
        CASE (EJS_OP_GET_OBJ_SLOT_5):
        CASE (EJS_OP_GET_OBJ_SLOT_6):
        CASE (EJS_OP_GET_OBJ_SLOT_7):
        CASE (EJS_OP_GET_OBJ_SLOT_8):
        CASE (EJS_OP_GET_OBJ_SLOT_9):
            vp = pop(ejs);
            GET_SLOT(vp, vp, opcode - EJS_OP_GET_OBJ_SLOT_0);
            BREAK;

        /*
            Load a variable from a type by slot number
                GetTypeSlot         <slot> <nthBase>
                Stack before (top)  [objRef]
                Stack after         [value]
         */
        CASE (EJS_OP_GET_TYPE_SLOT):
            slotNum = GET_INT();
            thisObj = (EjsObj*) pop(ejs);
            vp = getNthBase(ejs, (EjsObj*) thisObj, GET_INT());
            GET_SLOT(thisObj, vp, slotNum);
            BREAK;

        /*
            Load a type variable by slot number from this. NthBase counts from Object up rather than "this" down.
                GetThisTypeSlot     <slot> <nthBaseFromBottom>
                Stack before (top)  []
                Stack after         [value]
         */
        CASE (EJS_OP_GET_THIS_TYPE_SLOT):
            slotNum = GET_INT();
            type = (EjsType*) getNthBaseFromBottom(ejs, THIS, GET_INT());
            if (type == 0) {
                ejsThrowReferenceError(ejs, "Bad base class reference");
            } else {
                //  MOB -- is this the right "this". Should not be an instance?
                GET_SLOT(THIS, type, slotNum);
            }
            BREAK;

        /*
            Load a variable by an unqualified name
                GetScopedName       <qname>
                Stack before (top)  []
                Stack after         [value]
         */
        CASE (EJS_OP_GET_SCOPED_NAME):
            mark = FRAME->pc - 1;
            qname = GET_NAME();
            vp = ejsGetVarByName(ejs, NULL, &qname, &lookup);
            if (unlikely(vp == 0)) {
                ejsThrowReferenceError(ejs, "%s is not defined", qname.name);
            } else {
                CHECK_VALUE(vp, NULL, lookup.obj, lookup.slotNum);
            }
            BREAK;
                
        /*
            Load a variable by an unqualified name expression
                GetScopedNameExpr
                Stack before (top)  [name]
                                    [space]
                Stack after         [value]
         */
        CASE (EJS_OP_GET_SCOPED_NAME_EXPR):
            mark = FRAME->pc - 1;
            qname.name = ejsToString(ejs, pop(ejs))->value;
            v1 = pop(ejs);
            if (ejsIsNamespace(v1)) {
                qname.space = ((EjsNamespace*) v1)->uri;
            } else {
                qname.space = ejsToString(ejs, v1)->value;
            }
            vp = ejsGetVarByName(ejs, NULL, &qname, &lookup);
            if (unlikely(vp == 0)) {
                ejsThrowReferenceError(ejs, "%s is not defined", qname.name);
            } else {
                CHECK_VALUE(vp, NULL, lookup.obj, lookup.slotNum);
            }
#if DYNAMIC_BINDING
            if (ejs->flags & EJS_FLAG_COMPILER || lookup.obj->type == ejs->objectType || lookup.slotNum >= 4096) {
                BREAK;
            }
            if (lookup.obj == ejs->global) {
                *mark++ = EJS_OP_GET_GLOBAL_SLOT;
                mark += ejsEncodeUint(mark, lookup.slotNum);

            } else if (lookup->obj == state->fp) {
                *mark++ = EJS_OP_GET_LOCAL_SLOT;
                mark += ejsEncodeUint(mark, lookup.slotNum);

            } else if (lookup->obj == state->fp->thisObj) {
                *mark++ = EJS_OP_GET_THIS_SLOT;
                mark += ejsEncodeUint(mark, lookup.slotNum);

            } else if (ejsIsA(ejs, THIS, (EjsType*) lookup.obj)) {
                *mark++ = EJS_OP_GET_BLOCK_SLOT;
                mark += ejsEncodeUint(mark, lookup.slotNum);
                mark += ejsEncodeUint(mark, lookup.nthBlock);

            } else {
                BREAK;
            }
            FILL(mark);
#endif
            BREAK;
                
        /*
            Load a property by property name
                GetObjName          <qname>
                Stack before (top)  [obj]
                Stack after         [result]
         */
        CASE (EJS_OP_GET_OBJ_NAME):
#if DYNAMIC_BINDING
            mark = FRAME->pc - 1;
#endif
            qname = GET_NAME();
            vp = pop(ejs);
            //  TODO OPT - remove vp == 0
            if (vp == 0 || vp == ejs->nullValue || vp == ejs->undefinedValue) {
                ejsThrowReferenceError(ejs, "Object reference is null");
                BREAK;
            }
            v1 = ejsGetVarByName(ejs, vp, &qname, &lookup);
            CHECK_VALUE(v1, vp, lookup.obj, lookup.slotNum);
#if DYNAMIC_BINDING
            if (lookup.slotNum < 0 || lookup.slotNum > 4096 || ejs->flags & EJS_FLAG_COMPILER) {
                BREAK;
            }
            if (lookup.obj == ejs->global) {
                *mark++ = EJS_OP_GET_GLOBAL_SLOT;
                mark += ejsEncodeUint(mark, lookup.slotNum);

            } else if (lookup.obj == (EjsObj*) state.fp) {
                *mark++ = EJS_OP_GET_LOCAL_SLOT;
                mark += ejsEncodeUint(mark, lookup.slotNum);

            } else if (lookup.obj == state.fp->thisObj) {
                *mark++ = EJS_OP_GET_THIS_SLOT;
                mark += ejsEncodeUint(mark, lookup.slotNum);
                
            } else if (ejsIsType(lookup.obj) && ejsIsA(ejs, THIS, (EjsType*) lookup.obj)) {
                *mark++ = EJS_OP_GET_TYPE_SLOT;
                mark += ejsEncodeUint(mark, lookup.slotNum);
                mark += ejsEncodeUint(mark, lookup.nthBlock + 1);

            } else if ((EjsObj*) vp->type == lookup.obj) {
                *mark++  = EJS_OP_GET_TYPE_SLOT;
                mark += ejsEncodeUint(mark, lookup.slotNum);
                mark += ejsEncodeUint(mark, lookup.nthBase);

            } else {
                *mark++  = EJS_OP_GET_OBJ_SLOT;
                mark += ejsEncodeUint(mark, lookup.slotNum);
            }
            FILL(mark);
#endif
            BREAK;

        /*
            Load a property by property a qualified name expression
                GetObjNameExpr
                Stack before (top)  [name]
                                    [space]
                                    [obj]
                Stack after         [value]
         */
        CASE (EJS_OP_GET_OBJ_NAME_EXPR):
            v1 = pop(ejs);
            v2 = pop(ejs);
            vp = pop(ejs);
            if (vp == 0 || vp == ejs->nullValue || vp == ejs->undefinedValue) {
                ejsThrowReferenceError(ejs, "Object reference is null");
                BREAK;
            }
            if (vp->type->numericIndicies && ejsIsNumber(v1)) {
                vp = ejsGetProperty(ejs, vp, ejsGetInt(ejs, v1));
                push(vp == 0 ? ejs->nullValue : vp);
                BREAK;
            } else {
                qname.name = ejsToString(ejs, v1)->value;
                if (ejsIsNamespace(v2)) {
                    qname.space = ((EjsNamespace*) v2)->uri;
                } else {
                    qname.space = ejsToString(ejs, v2)->value;
                }
                v2 = ejsGetVarByName(ejs, vp, &qname, &lookup);
                CHECK_VALUE(v2, NULL, lookup.obj, lookup.slotNum);
                BREAK;
            }


        /* Store ------------------------------- */

        /*
            Store a global variable by slot number
                Stack before (top)  [value]
                Stack after         []
                PutGlobalSlot       <slot>
         */
        CASE (EJS_OP_PUT_GLOBAL_SLOT):
            SET_SLOT(NULL, global, GET_INT(), pop(ejs));
            BREAK;

        /*
            Store a local variable by slot number
                Stack before (top)  [value]
                Stack after         []
                PutLocalSlot        <slot>
         */
        CASE (EJS_OP_PUT_LOCAL_SLOT):
            SET_SLOT(NULL, FRAME, GET_INT(), pop(ejs));
            BREAK;

        /*
            Store a local variable from slot 0-9
                PutLocalSlot0, PutLocalSlot1, ... PutLocalSlot9
                Stack before (top)  [value]
                Stack after         []
         */
        CASE (EJS_OP_PUT_LOCAL_SLOT_0):
        CASE (EJS_OP_PUT_LOCAL_SLOT_1):
        CASE (EJS_OP_PUT_LOCAL_SLOT_2):
        CASE (EJS_OP_PUT_LOCAL_SLOT_3):
        CASE (EJS_OP_PUT_LOCAL_SLOT_4):
        CASE (EJS_OP_PUT_LOCAL_SLOT_5):
        CASE (EJS_OP_PUT_LOCAL_SLOT_6):
        CASE (EJS_OP_PUT_LOCAL_SLOT_7):
        CASE (EJS_OP_PUT_LOCAL_SLOT_8):
        CASE (EJS_OP_PUT_LOCAL_SLOT_9):
            SET_SLOT(NULL, FRAME, opcode - EJS_OP_PUT_LOCAL_SLOT_0, pop(ejs));
            BREAK;

        /*
            Store a block variable by slot number
                PutBlockSlot        <slot> <nthBlock>
                Stack before (top)  [value]
                Stack after         []
         */
        CASE (EJS_OP_PUT_BLOCK_SLOT):
            slotNum = GET_INT();
            obj = (EjsObj*) getNthBlock(ejs, GET_INT());
            SET_SLOT(NULL, obj, slotNum, pop(ejs));
            BREAK;

#if FUTURE
        /*
            Store a block variable from slot 0-9
                PutBlockSlot0, PutBlockSlot1, ... PutBlockSlot9 <nthBlock>
                Stack before (top)  [value]
                Stack after         []
         */
        CASE (EJS_OP_PUT_BLOCK_SLOT_0):
        CASE (EJS_OP_PUT_BLOCK_SLOT_1):
        CASE (EJS_OP_PUT_BLOCK_SLOT_2):
        CASE (EJS_OP_PUT_BLOCK_SLOT_3):
        CASE (EJS_OP_PUT_BLOCK_SLOT_4):
        CASE (EJS_OP_PUT_BLOCK_SLOT_5):
        CASE (EJS_OP_PUT_BLOCK_SLOT_6):
        CASE (EJS_OP_PUT_BLOCK_SLOT_7):
        CASE (EJS_OP_PUT_BLOCK_SLOT_8):
        CASE (EJS_OP_PUT_BLOCK_SLOT_9):
            slotNum = opcode - EJS_OP_PUT_BLOCK_SLOT_0;
            obj = (EjsObj*) getNthBlock(ejs, GET_INT());
            SET_SLOT(NULL, obj, slotNum, pop(ejs));
            BREAK;
#endif

        /*
            Store a property by slot number
                PutThisSlot         <slot>
                Stack before (top)  [value]
                Stack after         []
         */
        CASE (EJS_OP_PUT_THIS_SLOT):
            slotNum = GET_INT();
            SET_SLOT(THIS, THIS, slotNum, pop(ejs));
            BREAK;

        /*
            Store a property to slot 0-9
                PutThisSlot0, PutThisSlot1, ... PutThisSlot9,
                Stack before (top)  [value]
                Stack after         []
         */
        CASE (EJS_OP_PUT_THIS_SLOT_0):
        CASE (EJS_OP_PUT_THIS_SLOT_1):
        CASE (EJS_OP_PUT_THIS_SLOT_2):
        CASE (EJS_OP_PUT_THIS_SLOT_3):
        CASE (EJS_OP_PUT_THIS_SLOT_4):
        CASE (EJS_OP_PUT_THIS_SLOT_5):
        CASE (EJS_OP_PUT_THIS_SLOT_6):
        CASE (EJS_OP_PUT_THIS_SLOT_7):
        CASE (EJS_OP_PUT_THIS_SLOT_8):
        CASE (EJS_OP_PUT_THIS_SLOT_9):
            SET_SLOT(THIS, THIS, opcode - EJS_OP_PUT_THIS_SLOT_0, pop(ejs));
            BREAK;

        /* 
            Store a property by slot number
                PutObjSlot          <slot>
                Stack before (top)  [obj]
                                    [value]
                Stack after         []
         */
        CASE (EJS_OP_PUT_OBJ_SLOT):
            vp = pop(ejs);
            SET_SLOT(NULL, vp, GET_INT(), pop(ejs));
            BREAK;

        /*
            Store a property to slot 0-9
                PutObjSlot0, PutObjSlot1, ... PutObjSlot9
                Stack before (top)  [obj]
                                    [value]
                Stack after         []
         */
        CASE (EJS_OP_PUT_OBJ_SLOT_0):
        CASE (EJS_OP_PUT_OBJ_SLOT_1):
        CASE (EJS_OP_PUT_OBJ_SLOT_2):
        CASE (EJS_OP_PUT_OBJ_SLOT_3):
        CASE (EJS_OP_PUT_OBJ_SLOT_4):
        CASE (EJS_OP_PUT_OBJ_SLOT_5):
        CASE (EJS_OP_PUT_OBJ_SLOT_6):
        CASE (EJS_OP_PUT_OBJ_SLOT_7):
        CASE (EJS_OP_PUT_OBJ_SLOT_8):
        CASE (EJS_OP_PUT_OBJ_SLOT_9):
            vp = pop(ejs);
            SET_SLOT(NULL, vp, opcode - EJS_OP_PUT_OBJ_SLOT_0, pop(ejs));
            BREAK;

        /*
            Store a variable by an unqualified name
                PutScopedName       <qname>
                Stack before (top)  [value]
                Stack after         []
         */
        CASE (EJS_OP_PUT_SCOPED_NAME):
            qname = GET_NAME();
            value = pop(ejs);
            storePropertyToScope(ejs, &qname, value, 0);
            BREAK;

        /*
            Store a variable by an unqualified name expression
                PutScopedName 
                Stack before (top)  [name]
                                    [space]
                                    [value]
                Stack after         []
         */
        CASE (EJS_OP_PUT_SCOPED_NAME_EXPR):
            qname.name = ejsToString(ejs, pop(ejs))->value;
            v1 = pop(ejs);
            if (ejsIsNamespace(v1)) {
                qname.space = ((EjsNamespace*) v1)->uri;
            } else {
                qname.space = ejsToString(ejs, v1)->value;
            }
            value = pop(ejs);
            storePropertyToScope(ejs, &qname, value, 1);
            BREAK;

        /*
            Store a property by property name to an object
                PutObjName
                MOB - is this right order?
                Stack before (top)  [objRef]
                                    [value]
                Stack after         []
         */
        CASE (EJS_OP_PUT_OBJ_NAME):
            qname = GET_NAME();
            obj = pop(ejs);
            value = pop(ejs);
            storeProperty(ejs, obj, obj, &qname, value, 0);
            BREAK;

        /*
            Store a property by a qualified property name expression to an object
                PutObjNameExpr
                Stack before (top)  [nameExpr]
                                    [spaceExpr]
                                    [objRef]
                                    [value]
                Stack after         []
         */
        CASE (EJS_OP_PUT_OBJ_NAME_EXPR):
            v1 = pop(ejs);
            v2 = pop(ejs);
            obj = pop(ejs);
            value = pop(ejs);
            //  MOB -- cleanup this too - push into storeProperty
            if (obj->type->numericIndicies && ejsIsNumber(v1)) {
                ejsSetProperty(ejs, obj, ejsGetInt(ejs, v1), value);
            } else {
                qname.name = ejsToString(ejs, v1)->value;
                if (ejsIsNamespace(v2)) {
                    qname.space = ((EjsNamespace*) v2)->uri;
                } else {
                    qname.space = ejsToString(ejs, v2)->value;
                }
                if (qname.name && qname.space) {
                    storeProperty(ejs, obj, obj, &qname, value, 1);
                }
            }
            BREAK;

        /*
            Store a type variable by slot number
                PutTypeSlot         <slot> <nthBase>
                Stack before (top)  [obj]
                                    [value]
                Stack after         []
         */
        CASE (EJS_OP_PUT_TYPE_SLOT):
            slotNum = GET_INT();
            vobj = pop(ejs);
            vp = getNthBase(ejs, vobj, GET_INT());
            SET_SLOT(vobj, vp, slotNum, pop(ejs));
            BREAK;

        /*
            Store a variable to a slot in the nthBase class of the current "this" object
                PutThisTypeSlot     <slot> <nthBase>
                Stack before (top)  [value]
                Stack after         []
         */
        CASE (EJS_OP_PUT_THIS_TYPE_SLOT):
            slotNum = GET_INT();
            type = (EjsType*) getNthBaseFromBottom(ejs, THIS, GET_INT());
            if (type == 0) {
                ejsThrowReferenceError(ejs, "Bad base class reference");
            } else {
                SET_SLOT(THIS, type, slotNum, pop(ejs));
            }
            BREAK;


        /* Function calling and return */

        /*
            Call a function by reference
                Stack before (top)  [args]
                                    [function]
                                    [thisObj]
                Stack after         []
         */
        CASE (EJS_OP_CALL):
            argc = GET_INT();
            vp = state.stack[-argc - 1];
            callProperty(ejs, (EjsFunction*) state.stack[-argc], vp, argc, 2);
            BREAK;

        /*
            Call a global function by slot on the given type
                CallGlobalSlot      <slot> <argc>
                Stack before (top)  [args]
                Stack after         []
         */
        CASE (EJS_OP_CALL_GLOBAL_SLOT):
            slotNum = GET_INT();
            argc = GET_INT();
            //  MOB -- this binding is okay
            callProperty(ejs, (EjsFunction*) global->slots[slotNum].value.ref, NULL, argc, 0);
            BREAK;

        /*
            Call a function by slot number on the pushed object
                CallObjSlot         <slot> <argc>
                Stack before (top)  [args]
                                    [obj]
                Stack after         []
         */
        CASE (EJS_OP_CALL_OBJ_SLOT):
            slotNum = GET_INT();
            argc = GET_INT();
            vp = state.stack[-argc];
            if (vp == ejs->nullValue || vp == ejs->undefinedValue) {
                if (vp && (slotNum == ES_Object_get || slotNum == ES_Object_getValues)) {
                    fun = (EjsFunction*) ejsGetProperty(ejs, (EjsObj*) vp->type, slotNum); 
                    callProperty(ejs, fun, vp, argc, 1);
                } else {
                    ejsThrowReferenceError(ejs, "Object reference is null or undefined");
                }
            } else {
                fun = (EjsFunction*) ejsGetProperty(ejs, (EjsObj*) vp->type, slotNum); 
                callProperty(ejs, fun, vp, argc, 1);
            }
            BREAK;

        /*
            Call a function by slot number on the current this object.
                CallThisSlot        <slot> <argc>
                Stack before (top)  [args]
                Stack after         []
         */
        CASE (EJS_OP_CALL_THIS_SLOT):
            slotNum = GET_INT();
            argc = GET_INT();
            obj = (EjsObj*) THIS->type;
            fun = (EjsFunction*) ejsGetProperty(ejs, (EjsObj*) obj, slotNum); 
            callProperty(ejs, fun, NULL, argc, 0);
            BREAK;

        /*
            Call a function by slot number on the nth enclosing block
                CallBlockSlot        <slot> <nthBlock> <argc>
                Stack before (top)  [args]
                Stack after         []
         */
        CASE (EJS_OP_CALL_BLOCK_SLOT):
            slotNum = GET_INT();
            obj = (EjsObj*) getNthBlock(ejs, GET_INT());
            argc = GET_INT();
            fun = (EjsFunction*) ejsGetProperty(ejs, (EjsObj*) obj, slotNum); 
            callProperty(ejs, fun, NULL, argc, 0);
            BREAK;

        /*
            Call a function by slot number on an object.
                CallObjInstanceSlot <slot> <argc>
                Stack before (top)  [args]
                                    [obj]
                Stack after         []
         */
        CASE (EJS_OP_CALL_OBJ_INSTANCE_SLOT):
            slotNum = GET_INT();
            argc = GET_INT();
            vp = state.stack[-argc];
            if (vp == 0 || vp == ejs->nullValue || vp == ejs->undefinedValue) {
                ejsThrowReferenceError(ejs, "Object reference is null");
            } else {
                fun = (EjsFunction*) ejsGetProperty(ejs, vp, slotNum);
                callProperty(ejs, fun, vp, argc, 1);
            }
            BREAK;

        /*
            Call a static function by slot number on the pushed object
                CallObjStaticSlot   <slot> <nthBase> <argc>
                Stack before (top)  [args]
                                    [obj]
                Stack after         []
         */
        CASE (EJS_OP_CALL_OBJ_STATIC_SLOT):
            slotNum = GET_INT();
            nthBase = GET_INT();
            argc = GET_INT();
            vp = state.stack[-argc];
            if (vp == ejs->nullValue || vp == ejs->undefinedValue) {
                throwNull(ejs);
            } else {
                type = (EjsType*) getNthBase(ejs, vp, nthBase);
                fun = (EjsFunction*) ejsGetProperty(ejs, (EjsObj*) type, slotNum);
                callProperty(ejs, fun, (EjsObj*) type, argc, 1);
            }
            BREAK;

        /*
            Call a static function by slot number on the nth base class of the current "this" object
                CallThisStaticSlot  <slot> <nthBase> <argc>
                Stack before (top)  [args]
                Stack after         []
         */
        CASE (EJS_OP_CALL_THIS_STATIC_SLOT):
            slotNum = GET_INT();
            nthBase = GET_INT();
            argc = GET_INT();
            type = (EjsType*) getNthBase(ejs, THIS, nthBase);
            if (type == ejs->objectType) {
                //  TODO - remove
                ejsThrowReferenceError(ejs, "Bad type reference");
                BREAK;
            }
            fun = (EjsFunction*) ejsGetProperty(ejs, (EjsObj*) type, slotNum);
            callProperty(ejs, fun, (EjsObj*) type, argc, 0);
            BREAK;

        /*
            Call a function by name on the pushed object
                CallObjName         <qname> <argc>
                Stack before (top)  [args]
                                    [obj]
                Stack after         []
         */
        CASE (EJS_OP_CALL_OBJ_NAME):
            qname = GET_NAME();
            argc = GET_INT();
            vp = state.stack[-argc];
            if (vp == 0) {
                ejsThrowReferenceError(ejs, "%s is not defined", qname.name);
                throwNull(ejs);
                BREAK;
            }
            slotNum = ejsLookupVar(ejs, (EjsObj*) vp, &qname, &lookup);
            if (slotNum < 0) {
                ejsThrowReferenceError(ejs, "Can't find function \"%s\"", qname.name);
            } else {
                fun = (EjsFunction*) ejsGetProperty(ejs, lookup.obj, slotNum);
                callProperty(ejs, fun, vp, argc, 1);
            }
            BREAK;

        /*
            Call a function by name in the current scope. Use existing "this" object if defined.
                CallName            <qname> <argc>
                Stack before (top)  [args]
                Stack after         []
         */
        CASE (EJS_OP_CALL_SCOPED_NAME):
            qname = GET_NAME();
            argc = GET_INT();
            lookup.storing = 0;
            slotNum = ejsLookupScope(ejs, &qname, &lookup);
            if (slotNum < 0) {
                ejsThrowReferenceError(ejs, "Can't find method %s", qname.name);
                BREAK;
            }
            fun = (EjsFunction*) ejsGetProperty(ejs, lookup.obj, slotNum);
            if (!ejsIsFunction(fun)) {
                callConstructor(ejs, fun, argc, 0);
            } else {
                /*
                    Calculate the "this" to use for the function. If required function is a method in the current 
                    "this" object use the current thisObj. If the lookup.obj is a type, then use it. Otherwise global.
                 */
                if ((vp = fun->thisObj) == 0) {
                    if (ejsIsA(ejs, THIS, (EjsType*) lookup.obj)) {
                        vp = THIS;
                    } else if (ejsIsType(lookup.obj)) {
                        vp = lookup.obj;
                    } else {
                        vp = ejs->global;
                    }
                }
                callProperty(ejs, fun, vp, argc, 0);
            }
            BREAK;

        /*
            Call a constructor
                CallConstructor     <argc>
                Stack before (top)  [args]
                                    [obj]
                Stack after         [obj]
         */
        CASE (EJS_OP_CALL_CONSTRUCTOR):
            argc = GET_INT();
            vp = state.stack[-argc];
            if (vp == 0 || vp == ejs->nullValue || vp == ejs->undefinedValue) {
                throwNull(ejs);
                BREAK;
            }
            type = vp->type;
            mprAssert(type);
            if (type && type->hasConstructor) {
                mprAssert(type->baseType);
                //  Constructor is always at slot 0 (offset by base properties)
                slotNum = type->numInherited;
                fun = (EjsFunction*) ejsGetProperty(ejs, (EjsObj*) type, slotNum);
                callFunction(ejs, fun, (EjsObj*) vp, argc, 0);
            }
            BREAK;

        /*
            Call the next constructor
                CallNextConstructor <argc>
                Stack before (top)  [args]
                Stack after         []
         */
        CASE (EJS_OP_CALL_NEXT_CONSTRUCTOR):
            argc = GET_INT();
            type = (EjsType*) FRAME->function.owner;
            mprAssert(type);
            type = type->baseType;
            mprAssert(type);
            if (type) {
                mprAssert(type->hasConstructor);
                slotNum = type->numInherited;
                fun = (EjsFunction*) ejsGetProperty(ejs, (EjsObj*) type, slotNum);
                callFunction(ejs, fun, NULL, argc, 0);
            }
            BREAK;

        /*
            Add a literal namespace to the set of open namespaces for the current block
                AddNamespace <string>
         */
        CASE (EJS_OP_ADD_NAMESPACE):
            str = GET_STRING();
            ejsAddNamespaceToBlock(ejs, state.bp, ejsCreateNamespace(ejs, str, str));
            BREAK;

        /*
            Add a namespace expression (reference) to the set of open namespaces for the current block. (use namespace).
                Stack before (top)  [namespace]
                Stack after         []
                AddNamespaceRef
         */
        CASE (EJS_OP_ADD_NAMESPACE_REF):
            ejsAddNamespaceToBlock(ejs, state.bp, (EjsNamespace*) pop(ejs));
            BREAK;

        /*
            Push a new scope block on the scope chain
                OpenBlock <slotNum> <nthBlock>
         */
        CASE (EJS_OP_OPEN_BLOCK):
            slotNum = GET_INT();
            vp = getNthBlock(ejs, GET_INT());
            v1 = ejsGetProperty(ejs, vp, slotNum);
            if (!ejsIsBlock(v1)) {
                ejsThrowReferenceError(ejs, "Reference is not a block");
                BREAK;
            }
            //  OPT
            blk = ejsCloneBlock(ejs, (EjsBlock*) v1, 0);
            blk->prev = blk->scopeChain = state.bp;
            state.bp = blk;
            blk->stackBase = state.stack;
            ejsSetDebugName(state.bp, mprGetName(v1));
            BREAK;

        /*
            Add a new scope block from the stack onto on the scope chain
                OpenWith
         */
        CASE (EJS_OP_OPEN_WITH):
            vp = pop(ejs);
            blk = ejsCreateBlock(ejs, 0);
            ejsSetDebugName(blk, "with");
            memcpy((void*) blk, vp, vp->type->instanceSize);
            blk->prev = blk->scopeChain = state.bp;
            state.bp = blk;
            BREAK;

        /*
            Store the top scope block off the scope chain
                CloseBlock
                CloseWith
         */
        CASE (EJS_OP_CLOSE_BLOCK):
            state.bp = state.bp->prev;
            BREAK;

        /*
            Define a class and initialize by calling any static initializer.
                DefineClass <type>
         */
        CASE (EJS_OP_DEFINE_CLASS):
            type = GET_TYPE();
            if (type == 0 || !ejsIsType(type)) {
                ejsThrowReferenceError(ejs, "Reference is not a class");
            } else {
                type->block.scopeChain = state.bp;
                if (type && type->hasStaticInitializer) {
                    //  Static initializer is always immediately after the constructor (if present)
                    slotNum = type->numInherited;
                    if (type->hasConstructor) {
                        slotNum++;
                    }
                    fun = (EjsFunction*) ejsGetProperty(ejs, (EjsObj*) type, slotNum);
                    callFunction(ejs, fun, (EjsObj*) type, 0, 0);
                    if (type->implements && !ejs->exception) {
                        callInterfaceInitializers(ejs, type);
                    }
                    state.bp = &FRAME->function.block;
                }
            }
            ejs->result = (EjsObj*) type;
            BREAK;

        /*
            Define a function. This is used only for non-method functions to capture the scope chain.
                DefineFunction <slot> <nthBlock>
         */
        CASE (EJS_OP_DEFINE_FUNCTION):
            slotNum = GET_INT();
            vp = getNthBlock(ejs, GET_INT());
            f1 = (EjsFunction*) ejsGetProperty(ejs, vp, slotNum);
            if (!ejsIsFunction(f1)) {
                ejsThrowReferenceError(ejs, "Reference is not a function");
            } else if (f1->fullScope) {
                f2 = ejsCloneFunction(ejs, f1, 0);
                f2->block.scopeChain = state.bp;
                f2->thisObj = FRAME->function.thisObj;
                SET_SLOT(NULL, vp, slotNum, f2);
            }
            BREAK;


        /* Exception Handling -------------------------------------------- */

        /*
            Invoke finally blocks before acting on: return, returnValue and break (goto) opcodes.
            Injected by the compiler prior to break, continue and return statements. Also at the end of a try block
            if there is a finally block.
        
                finally
         */
        CASE (EJS_OP_FINALLY):
            if ((ex = findExceptionHandler(ejs, EJS_EX_FINALLY)) != 0) {
                if (FRAME->function.inCatch) {
                    popExceptionBlock(ejs);
                    push(FRAME->pc);
                    createExceptionBlock(ejs, ex, EJS_EX_FINALLY);
                    BLOCK->breakCatch = 1;
                } else {
                    createExceptionBlock(ejs, ex, EJS_EX_FINALLY);
                }
            }
            BREAK;

        /*
            End of an exception block. Put at the end of the last catch/finally block
                EndException
         */
        CASE (EJS_OP_END_EXCEPTION):
            if (FRAME->function.inException) {
                FRAME->function.inCatch = 0;
                FRAME->function.inException = 0;
                if (BLOCK->breakCatch) {
                    /* Restart the original instruction (return, break, continue) */
                    popExceptionBlock(ejs);
                    SET_PC(FRAME, pop(ejs));
                } else {
                    offset = findEndException(ejs);
                    SET_PC(FRAME, &FRAME->function.body.code.byteCode[offset]);
                    popExceptionBlock(ejs);
                }
            }
            BREAK;

        /*
            Throw an exception
                Stack before (top)  [exceptionObj]
                Stack after         []
                Throw
         */
        CASE (EJS_OP_THROW):
            ejs->exception = pop(ejs);
            ejsAttention(ejs);
            BREAK;

        /*
            Special circumstances need attention. Exceptions, exiting and garbage collection.
         */
        CASE (EJS_OP_ATTENTION):
            mprAssert(FRAME->attentionPc);
            FRAME->pc = FRAME->attentionPc;
            mprAssert(FRAME->pc);
            FRAME->attentionPc = 0;
            if (mprHasAllocError(ejs) && !ejs->exception) {
                mprResetAllocError(ejs);
                ejsThrowMemoryError(ejs);
            }
                mprAssert(FRAME->pc);
            if (ejs->exiting || mprIsExiting(ejs)) {
                goto done;
            }
                mprAssert(FRAME->pc);
            if (ejs->gcRequired) {
                ejsCollectGarbage(ejs, EJS_GEN_NEW);
            }
                mprAssert(FRAME->pc);
            if (ejs->exception && !manageExceptions(ejs)) {
                goto done;
            }
                mprAssert(FRAME->pc);
            BREAK;


        /* Stack management ---------------------------------------------- */

        /*
            Pop one item off the stack
                Pop
                Stack before (top)  [value]
                Stack after         []
         */
        CASE (EJS_OP_POP):
            ejs->result = pop(ejs);
            BREAK;

        /*
            Pop N items off the stack
                PopItems            <count>
                Stack before (top)  [value]
                                    [...]
                Stack after         []
         */
        CASE (EJS_OP_POP_ITEMS):
            state.stack -= GET_BYTE();
            BREAK;

        /*
            Duplicate one item on the stack
                Stack before (top)  [value]
                Stack after         [value]
                                    [value]
         */
        CASE (EJS_OP_DUP):
            vp = state.stack[0];
            push(vp);
            BREAK;

        /*
            Duplicate two items on the stack
                Dup2
                Stack before (top)  [value1]
                                    [value2]
                Stack after         [value1]
                                    [value2]
                                    [value1]
                                    [value2]
         */
        CASE (EJS_OP_DUP2):
            v1 = state.stack[-1];
            push(v1);
            v1 = state.stack[0];
            push(v1);
            BREAK;

        /*
            Swap the top two items on the stack
                Swap
                Stack before (top)  [value1]
                                    [value2]
                Stack after         [value2]
                                    [value1]
         */
        CASE (EJS_OP_SWAP):
            SWAP; BREAK;


        /* Branching */

        /*
            Default function argument initialization. Computed goto for functions with more than 256 parameters.
                InitDefault         <tableSize>
         */
        CASE (EJS_OP_INIT_DEFAULT_ARGS): {
            int tableSize, numNonDefault;
            /*
                Use the argc value for the current function. Compare with the number of default args.
             */
            tableSize = (schar) GET_BYTE();
            numNonDefault = FRAME->function.numArgs - FRAME->function.numDefault;
            offset = FRAME->argc - numNonDefault;
            if (offset < 0 || offset > tableSize) {
                offset = tableSize;
            }
            FRAME->pc += ((uint*) FRAME->pc)[offset];
            BREAK;
        }

        /*
            Default function argument initialization. Computed goto for functions with less than 256 parameters.
                InitDefault.8       <tableSize.8>
         */
        CASE (EJS_OP_INIT_DEFAULT_ARGS_8): {
            int tableSize, numNonDefault;
            tableSize = (schar) GET_BYTE();
            numNonDefault = FRAME->function.numArgs - FRAME->function.numDefault;
            offset = FRAME->argc - numNonDefault;
            if (offset < 0 || offset > tableSize) {
                offset = tableSize;
            }
            FRAME->pc += FRAME->pc[offset];
            BREAK;
        }

        /*
            Unconditional branch to a new location
                Goto                <offset.32>
         */
        CASE (EJS_OP_GOTO):
            offset = GET_WORD();
            SET_PC(FRAME, &FRAME->pc[offset]);
            BREAK;

        /*
            Unconditional branch to a new location (8 bit)
                Goto.8              <offset.8>
         */
        CASE (EJS_OP_GOTO_8):
            offset = (schar) GET_BYTE();
            SET_PC(FRAME, &FRAME->pc[offset]);
            BREAK;

        /*
            Branch to offset if false
                BranchFalse
                Stack before (top)  [boolValue]
                Stack after         []
         */
        CASE (EJS_OP_BRANCH_FALSE):
            offset = GET_WORD();
            goto commonBoolBranchCode;

        /*
            Branch to offset if true
                BranchTrue
                Stack before (top)  [boolValue]
                Stack after         []
         */
        CASE (EJS_OP_BRANCH_TRUE):
            offset = GET_WORD();
            goto commonBoolBranchCode;

        /*
            Branch to offset if false (8 bit)
                BranchFalse.8
                Stack before (top)  [boolValue]
                Stack after         []
         */
        CASE (EJS_OP_BRANCH_FALSE_8):
            opcode = (EjsOpCode) (opcode - EJS_OP_BRANCH_TRUE_8 + EJS_OP_BRANCH_TRUE);
            offset = (schar) GET_BYTE();
            goto commonBoolBranchCode;

        /*
            Branch to offset if true (8 bit)
                BranchTrue.8
                Stack before (top)  [boolValue]
                Stack after         []
         */
        CASE (EJS_OP_BRANCH_TRUE_8):
            /* We want sign extension here */
            opcode = (EjsOpCode) (opcode - EJS_OP_BRANCH_TRUE_8 + EJS_OP_BRANCH_TRUE);
            offset = (schar) GET_BYTE();

        /*
            Common boolean branch code
         */
        commonBoolBranchCode:
            v1 = pop(ejs);
            if (v1 == 0 || !ejsIsBoolean(v1)) {
                v1 = ejsCast(ejs, v1, ejs->booleanType);
                if (ejs->exception) {
                    BREAK;
                }
            }
            if (!ejsIsBoolean(v1)) {
                ejsThrowTypeError(ejs, "Result of a comparision must be boolean");
                BREAK;
            }
            if (opcode == EJS_OP_BRANCH_TRUE) {
                if (((EjsBoolean*) v1)->value) {
                    SET_PC(FRAME, &FRAME->pc[offset]);
                }
            } else {
                if (((EjsBoolean*) v1)->value == 0) {
                    SET_PC(FRAME, &FRAME->pc[offset]);
                }
            }
            BREAK;

        /*
            Branch to offset if [value1] == null
                BranchNull
                Stack before (top)  [boolValue]
                Stack after         []
         */
        CASE (EJS_OP_BRANCH_NULL):
            push(ejs->nullValue);
            offset = GET_WORD();
            goto commonBranchCode;

        /*
            Branch to offset if [value1] == undefined
                BranchUndefined
                Stack before (top)  [boolValue]
                Stack after         []
         */
        CASE (EJS_OP_BRANCH_UNDEFINED):
            push(ejs->undefinedValue);
            offset = GET_WORD();
            goto commonBranchCode;

        /*
            Branch to offset if [tos] value is zero
                BranchZero
                Stack before (top)  [boolValue]
                Stack after         []
         */
        CASE (EJS_OP_BRANCH_ZERO):
            /* Fall through */

        /*
            Branch to offset if [tos] value is not zero
                BranchNotZero
                Stack before (top)  [boolValue]
                Stack after         []
         */
        CASE (EJS_OP_BRANCH_NOT_ZERO):
            push(ejs->zeroValue);
            offset = GET_WORD();
            goto commonBranchCode;

        /*
            Branch to offset if [value1] == [value2]
                BranchEQ
                Stack before (top)  [value1]
                Stack before (top)  [value2]
                Stack after         []
         */
        CASE (EJS_OP_BRANCH_EQ):

        /*
            Branch to offset if [value1] === [value2]
                BranchStrictlyEQ
                Stack before (top)  [value1]
                Stack after         [value2]
         */
        CASE (EJS_OP_BRANCH_STRICTLY_EQ):

        /*
            Branch to offset if [value1] != [value2]
                BranchNotEqual
                Stack before (top)  [value1]
                                    [value2]
                Stack after         []
         */
        CASE (EJS_OP_BRANCH_NE):

        /*
            Branch to offset if [value1] !== [value2]
                BranchStrictlyNE
                Stack before (top)  [value1]
                                    [value2]
                Stack after         []
         */
        CASE (EJS_OP_BRANCH_STRICTLY_NE):

        /*
            Branch to offset if [value1] <= [value2]
                BranchLE
                Stack before (top)  [value1]
                                    [value2]
                Stack after         []
         */
        CASE (EJS_OP_BRANCH_LE):

        /*
            Branch to offset if [value1] < [value2]
                BranchLT
                Stack before (top)  [value1]
                                    [value2]
                Stack after         []
         */
        CASE (EJS_OP_BRANCH_LT):

        /*
            Branch to offset if [value1] >= [value2]
                BranchGE
                Stack before (top)  [value1]
                                    [value2]
                Stack after         []
         */
        CASE (EJS_OP_BRANCH_GE):

        /*
            Branch to offset if [value1] > [value2]
                BranchGT
                Stack before (top)  [value1]
                                    [value2]
                Stack after         []
         */
        CASE (EJS_OP_BRANCH_GT):
            offset = GET_WORD();
            goto commonBranchCode;

        /*
            Handle all branches here. We convert to a compare opcode and pass to the type to handle.
         */
        commonBranchCode:
            opcode = (EjsOpCode) (opcode - EJS_OP_BRANCH_EQ + EJS_OP_COMPARE_EQ);
            v2 = pop(ejs);
            v1 = pop(ejs);
            result = evalBinaryExpr(ejs, v1, opcode, v2);
            if (!ejsIsBoolean(result)) {
                ejsThrowTypeError(ejs, "Result of a comparision must be boolean");
            } else {
                if (((EjsBoolean*) result)->value) {
                    SET_PC(FRAME, &FRAME->pc[offset]);
                }
            }
            BREAK;

        /*
            Compare if [value1] == true
                CompareTrue
                Stack before (top)  [value]
                Stack after         [boolean]
         */
        CASE (EJS_OP_COMPARE_TRUE):

        /*
            Compare if ![value1]
                CompareNotTrue
                Stack before (top)  [value]
                Stack after         [boolean]
         */
        CASE (EJS_OP_COMPARE_FALSE):
            v1 = pop(ejs);
            result = ejsInvokeOperator(ejs, v1, opcode, 0);
            push(result);
            BREAK;

        /*
            Compare if [value1] == NULL
                CompareNull
                Stack before (top)  [value]
                Stack after         [boolean]
         */
        CASE (EJS_OP_COMPARE_NULL):
            push(ejs->nullValue);
            goto binaryExpression;

        /*
            Compare if [item] == undefined
                CompareUndefined
                Stack before (top)  [value]
                Stack after         [boolean]
         */
        CASE (EJS_OP_COMPARE_UNDEFINED):
            push(ejs->undefinedValue);
            goto binaryExpression;

        /*
            Compare if [item] value is zero
                CompareZero
                Stack before (top)  [value]
                Stack after         [boolean]
         */
        CASE (EJS_OP_COMPARE_ZERO):
            push(ejsCreateNumber(ejs, 0));
            goto binaryExpression;

        /*
            Compare if [tos] value is not zero
                CompareZero
                Stack before (top)  [value]
                Stack after         [boolean]
         */
        CASE (EJS_OP_COMPARE_NOT_ZERO):
            push(ejsCreateNumber(ejs, 0));
            goto binaryExpression;

        /*
            Compare if [value1] == [item2]
                CompareEQ
                Stack before (top)  [value1]
                                    [value2]
                Stack after         [boolean]
         */
        CASE (EJS_OP_COMPARE_EQ):

        /*
            Compare if [value1] === [item2]
                CompareStrictlyEQ
                Stack before (top)  [value1]
                                    [value2]
                Stack after         [boolean]
         */
        CASE (EJS_OP_COMPARE_STRICTLY_EQ):

        /*
            Compare if [value1] != [item2]
                CompareNE
                Stack before (top)  [value1]
                                    [value2]
                Stack after         [boolean]
         */
        CASE (EJS_OP_COMPARE_NE):

        /*
            Compare if [value1] !== [item2]
                CompareStrictlyNE
                Stack before (top)  [value1]
                                    [value2]
                Stack after         [boolean]
         */
        CASE (EJS_OP_COMPARE_STRICTLY_NE):

        /*
            Compare if [value1] <= [item2]
                CompareLE
                Stack before (top)  [value1]
                                    [value2]
                Stack after         [boolean]
         */
        CASE (EJS_OP_COMPARE_LE):

        /*
            Compare if [value1] < [item2]
                CompareStrictlyLT
                Stack before (top)  [value1]
                                    [value2]
                Stack after         [boolean]
         */
        CASE (EJS_OP_COMPARE_LT):

        /*
            Compare if [value1] >= [item2]
                CompareGE
                Stack before (top)  [value1]
                                    [value2]
                Stack after         [boolean]
         */
        CASE (EJS_OP_COMPARE_GE):

        /*
            Compare if [value1] > [item2]
                CompareGT
                Stack before (top)  [value1]
                                    [value2]
                Stack after         [boolean]
         */
        CASE (EJS_OP_COMPARE_GT):

        /*
            Binary expressions
                Stack before (top)  [right]
                                    [left]
                Stack after         [boolean]
         */
        CASE (EJS_OP_ADD):
        CASE (EJS_OP_SUB):
        CASE (EJS_OP_MUL):
        CASE (EJS_OP_DIV):
        CASE (EJS_OP_REM):
        CASE (EJS_OP_SHL):
        CASE (EJS_OP_SHR):
        CASE (EJS_OP_USHR):
        CASE (EJS_OP_AND):
        CASE (EJS_OP_OR):
        CASE (EJS_OP_XOR):
        binaryExpression:
            v2 = pop(ejs);
            v1 = pop(ejs);
            mprAssert(v1);
            ejs->result = evalBinaryExpr(ejs, v1, opcode, v2);
            push(ejs->result);
            BREAK;


        /* Unary operators */

        /*
            Negate a value
                Neg
                Stack before (top)  [value]
                Stack after         [result]
         */
        CASE (EJS_OP_NEG):
            v1 = pop(ejs);
            //  TODO - should this assign to ejs->result
            result = ejsInvokeOperator(ejs, v1, opcode, 0);
            push(result);
            BREAK;

        /*
            Logical not (~value)
                LogicalNot
                Stack before (top)  [value]
                Stack after         [result]
         */
        CASE (EJS_OP_LOGICAL_NOT):
            v1 = pop(ejs);
            v1 = ejsCast(ejs, v1, ejs->booleanType);
            result = ejsInvokeOperator(ejs, v1, opcode, 0);
            push(result);
            BREAK;

        /*
            Bitwise not (!value)
                BitwiseNot
                Stack before (top)  [value]
                Stack after         [result]
         */
        CASE (EJS_OP_NOT):
            v1 = pop(ejs);
            result = ejsInvokeOperator(ejs, v1, opcode, 0);
            push(result);
            BREAK;

        /*
            Increment a stack variable
                Inc                 <increment>
                Stack before (top)  [value]
                Stack after         [result]
         */
        CASE (EJS_OP_INC):
            v1 = pop(ejs);
            count = (schar) GET_BYTE();
            result = evalBinaryExpr(ejs, v1, EJS_OP_ADD, (EjsObj*) ejsCreateNumber(ejs, count));
            push(result);
            BREAK;


        /* Object creation */

        /*
            Create a new object
                New
                Stack before (top)  [type]
                Stack after         [obj]
         */
        CASE (EJS_OP_NEW):
            v1 = pop(ejs);
            if (!ejsIsType(v1)) {
                if (ejsIsFunction(v1)) {
                    fun = (EjsFunction*) v1;
                    if (fun->creator == 0) {
                        fun->creator = ejsCreateTypeFromFunction(ejs, fun);
                    }
                    obj = ejsCreate(ejs, fun->creator, 0);
                } else {
                    ejsThrowReferenceError(ejs, "Can't locate type");
                    BREAK;
                }
            } else {
                obj = ejsCreate(ejs, (EjsType*) v1, 0);
            }
            push(obj);
            ejs->result = obj;
            BREAK;

        /*
            Create a new object literal
                NewObject           <type> <argc> [<attributes> ...]
                Stack before (top)  [<space><name><value>]
                                    [<space><name><value>]
                Stack after         []
         */
        CASE (EJS_OP_NEW_OBJECT):
            FRAME->ignoreAttention = 1;
            type = GET_TYPE();
            argc = GET_INT();
            vp = (EjsObj*) ejsCreateObject(ejs, type, 0);
            for (i = 1 - (argc * 3); i <= 0; ) {
                spaceVar = ejsToString(ejs, state.stack[i++]);
                if (ejs->exception) BREAK;
                nameVar = ejsToString(ejs, state.stack[i++]);
                if (ejs->exception) BREAK;
                v1 = state.stack[i++];
                attributes = GET_INT();
                if (v1 && nameVar && spaceVar) {
                    //  TODO MOB - allow types
                    ejsName(&qname, mprStrdup(vp, spaceVar->value), mprStrdup(vp, nameVar->value));
                    ejsDefineProperty(ejs, vp, -1, &qname, NULL, attributes, v1);
                }
            }
            state.stack -= (argc * 3);
            push(vp);
            FRAME->ignoreAttention = 0;
            BREAK;

        /*
            Reference the super class
                Super
                Stack before (top)  [obj]
                Stack after         [type]
         */
        CASE (EJS_OP_SUPER):
            push(FRAME->function.thisObj->type);
            BREAK;

        /*
            Delete an object property by name expression
                DeleteNameExpr
                Stack before (top)  [name]
                                    [space]
                                    [obj]
                Stack after         []
         */
        CASE (EJS_OP_DELETE_NAME_EXPR):
            qname.name = ejsToString(ejs, pop(ejs))->value;
            v1 = pop(ejs);
            if (ejsIsNamespace(v1)) {
                qname.space = ((EjsNamespace*) v1)->uri;
            } else {
                qname.space = ejsToString(ejs, v1)->value;
            }
            vp = pop(ejs);
            slotNum = ejsLookupVar(ejs, vp, &qname, &lookup);
            if (slotNum < 0) {
                ejsThrowReferenceError(ejs, "Property \"%s\" does not exist", qname.name);
            } else {
                if (!lookup.obj->dynamic) {
                    //  MOB -- probably can remove this and rely on fixed below as per ecma spec
                    ejsThrowTypeError(ejs, "Can't delete properties in a non-dynamic object");
                } else if (ejsHasTrait(lookup.obj, slotNum, EJS_TRAIT_FIXED)) {
                    ejsThrowTypeError(ejs, "Property \"%s\" is not deletable", qname.name);
                } else {
                    ejsDeleteProperty(ejs, lookup.obj, slotNum);
                }
            }
            BREAK;

        /*
            Delete an object property from the current scope
                DeleteScopedNameExpr
                Stack before (top)  [name]
                                    [space]
                Stack after         []
         */
        CASE (EJS_OP_DELETE_SCOPED_NAME_EXPR):
            qname.name = ejsToString(ejs, pop(ejs))->value;
            v1 = pop(ejs);
            if (ejsIsNamespace(v1)) {
                qname.space = ((EjsNamespace*) v1)->uri;
            } else {
                qname.space = ejsToString(ejs, v1)->value;
            }
            lookup.storing = 0;
            slotNum = ejsLookupScope(ejs, &qname, &lookup);
            if (slotNum < 0) {
                ejsThrowReferenceError(ejs, "Property \"%s\" does not exist", qname.name);
            } else {
                if (!lookup.obj->dynamic) {
                    //  MOB -- probably can remove this and rely on fixed below as per ecma spec
                    ejsThrowTypeError(ejs, "Can't delete properties in a non-dynamic object");
                } else if (ejsHasTrait(lookup.obj, slotNum, EJS_TRAIT_FIXED)) {
                    ejsThrowTypeError(ejs, "Property \"%s\" is not deletable", qname.name);
                } else {
                    ejsDeleteProperty(ejs, lookup.obj, slotNum);
                }
            }
            BREAK;

        /*
            No operation. Does nothing.
                Nop
         */
        CASE (EJS_OP_NOP):
            BREAK;

        /*
            Check if object is a given type
                IsA, Like, InstanceOf
                Stack before (top)  [type]
                                    [obj]
                Stack after         [boolean]
         */
        CASE (EJS_OP_INST_OF):
        CASE (EJS_OP_IS_A):
        CASE (EJS_OP_LIKE):
            type = (EjsType*) pop(ejs);
            v1 = pop(ejs);
            push(ejsCreateBoolean(ejs, ejsIsA(ejs, v1, type)));
            BREAK;

        /*
            Get the type of an object.
                TypeOf              <obj>
                Stack before (top)  [obj]
                Stack after         [string]
         */
        CASE (EJS_OP_TYPE_OF):
            v1 = pop(ejs);
            push(ejsGetTypeOf(ejs, v1));
            BREAK;

        /*
            Cast an object to the given the type. Throw if not castable.
                Cast
                Stack before (top)  [type]
                                    [obj]
                Stack after         [result]
         */
        CASE (EJS_OP_CAST):
            type = (EjsType*) pop(ejs);
            if (!ejsIsType(type)) {
                ejsThrowTypeError(ejs, "Not a type");
            } else {
                v1 = pop(ejs);
                push(ejsCast(ejs, v1, type));
            }
            BREAK;

        /*
            Cast to a boolean type
                CastBoolean
                Stack before (top)  [value]
                Stack after         [result]
         */
        CASE (EJS_OP_CAST_BOOLEAN):
            v1 = ejsCast(ejs, pop(ejs), ejs->booleanType);
            push(v1);
            BREAK;

        /*
            Test if a given name is the name of a property "in" an object
                Cast
                Stack before (top)  [obj]
                                    [name]
                Stack after         [result]
         */
        CASE (EJS_OP_IN):
            v1 = pop(ejs);
            nameVar = ejsToString(ejs, pop(ejs));
            if (nameVar == 0) {
                ejsThrowTypeError(ejs, "Can't convert to a name");
            } else {
                ejsName(&qname, "", nameVar->value);                        //  Don't consult namespaces
                slotNum = ejsLookupProperty(ejs, v1, &qname);
                if (slotNum < 0) {
                    slotNum = ejsLookupVar(ejs, v1, &qname, &lookup);
                    if (slotNum < 0 && ejsIsType(v1)) {
                        slotNum = ejsLookupVar(ejs, (EjsObj*) ((EjsType*) v1)->prototype, &qname, &lookup);
                    }
                }
                push(ejsCreateBoolean(ejs, slotNum >= 0));
            }
            BREAK;

        /*
            Unimplemented op codes
         */
        CASE (EJS_OP_BREAKPOINT):
            mprAssert(0);
            BREAK;

#if !LINUX && !MACOSX && !LINUX && !SOLARIS && !VXWORKS
        }
    }
#endif
    
done:
#if BLD_DEBUG && FUTURE
    if (ejs->initialized) {
        ejsShowOpFrequency(ejs);
    }
#endif
    mprAssert(FRAME == 0 || FRAME->attentionPc == 0);
    ejs->state = priorState;
    if (ejs->exception) {
        ejsAttention(ejs);
    }
}


/*
    WARNING: this may not complete the store. It may setup a setter function which then requires the VM to execute.
 */
static void storePropertyToSlot(Ejs *ejs, EjsObj *thisObj, EjsObj *obj, int slotNum, EjsObj *value)
{
    EjsFunction     *fun;
    EjsObj          *vp;
    EjsTrait        *trait;

    mprAssert(value);

    if (slotNum < 0 && !obj->dynamic) {
        ejsThrowTypeError(ejs, "Object is not extendable");
        return;
    }
    trait = ejsGetTrait(obj, slotNum);
    if (trait) {
        if (trait->attributes & EJS_TRAIT_SETTER) {
            pushOutside(ejs, value);
            fun = (EjsFunction*) ejsGetProperty(ejs, obj, slotNum);
            fun = fun->setter;
            callFunction(ejs, fun, thisObj, 1, 0);
            return;
        }
        if (trait->type) {
            if (!ejsIsA(ejs, value, trait->type)) {
                if (value == ejs->nullValue || value == ejs->undefinedValue) {
                    if (trait->attributes & EJS_TRAIT_THROW_NULLS) {
                        ejsThrowTypeError(ejs, "Unacceptable null or undefined value");
                        return;
                    } else if (trait->attributes & EJS_TRAIT_CAST_NULLS) {
                        value = ejsCast(ejs, value, trait->type);
                        if (ejs->exception) {
                            return;
                        }
                    }
                } else {
                    value = ejsCast(ejs, value, trait->type);
                    if (ejs->exception) {
                        return;
                    }
                }
            }
        }
        if (trait->attributes & EJS_TRAIT_READONLY) {
            EjsName         qname;
            vp = ejsGetProperty(ejs, obj, slotNum);
            if (vp != ejs->nullValue) {
                qname = ejsGetPropertyName(ejs, obj, slotNum);
                ejsThrowReferenceError(ejs, "Property \"%s\" is not writable", qname.name);
                return;
            }
        }
    }
    ejsSetProperty(ejs, (EjsObj*) obj, slotNum, (EjsObj*) value);
    ejs->result = value;
}


/*
    Store a property by name in the given object. Will create if the property does not already exist.
 */
static void storeProperty(Ejs *ejs, EjsObj *thisObj, EjsObj *obj, EjsName *qname, EjsObj *value, bool dupName)
{
    EjsLookup       lookup;
    int             slotNum;

    mprAssert(qname);
    mprAssert(qname->name);
    mprAssert(obj);

    //  MOB -- ONLY XML requires this.  NOTE: this bypasses ES5 traits
    if (obj->type->helpers->setPropertyByName) {
        slotNum = (*obj->type->helpers->setPropertyByName)(ejs, obj, qname, value);
        if (slotNum >= 0) {
            return;
        }
    }
    if ((slotNum = ejsLookupVar(ejs, obj, qname, &lookup)) < 0) {
        //  MOB -- who is using this
        if (dupName) {
            qname->name = mprStrdup(obj, qname->name);
            qname->space = mprStrdup(obj, qname->space);
        }
        slotNum = ejsSetPropertyName(ejs, obj, slotNum, qname);
    } else {
        obj = lookup.obj;
    }
    if (slotNum >= 0) {
        storePropertyToSlot(ejs, thisObj, obj, slotNum, value);
    }
}


/*
    Store a property by name in the scope chain. Will create properties if the given name does not already exist.
 */
static void storePropertyToScope(Ejs *ejs, EjsName *qname, EjsObj *value, bool dup)
{
    EjsFrame        *fp;
    EjsObj          *obj;
    EjsLookup       lookup;
    int             slotNum;

    mprAssert(qname);

    fp = ejs->state->fp;
    lookup.storing = 1;
    if ((slotNum = ejsLookupScope(ejs, qname, &lookup)) < 0) {
        if (fp->caller) {
            obj = (EjsObj*) fp;
        } else {
            obj = ejs->global;
        }
        if (dup) {
            qname->name = mprStrdup(obj, qname->name);
            qname->space = mprStrdup(obj, qname->space);
        }
        slotNum = ejsSetPropertyName(ejs, obj, slotNum, qname);
    } else {
        obj = lookup.obj;
    }
    storePropertyToSlot(ejs, obj, obj, slotNum, value);
}


/*
    Run the module initializer
 */
EjsObj *ejsRunInitializer(Ejs *ejs, EjsModule *mp)
{
    EjsModule   *dp;
    EjsObj      *result;
    int         next;

    if (mp->initialized || !mp->hasInitializer) {
        mp->initialized = 1;
        return ejs->nullValue;
    }
    mp->initialized = 1;

    if (mp->dependencies) {
        for (next = 0; (dp = (EjsModule*) mprGetNextItem(mp->dependencies, &next)) != 0;) {
            if (dp->hasInitializer && !dp->initialized) {
                if (ejsRunInitializer(ejs, dp) == 0) {
                    return 0;
                }
            }
        }
    }
    mprLog(ejs, 6, "Running initializer for module %s", mp->name);
    result = ejsRunFunction(ejs, mp->initializer, ejs->global, 0, NULL);

    //  TODO - not calling MakePermanent so is this really needed?
    ejsMakeTransient(ejs, (EjsObj*) mp->initializer);
    return result;
}


/*
    Run all initializers for all modules
 */
int ejsRun(Ejs *ejs)
{
    EjsModule   *mp;
    int         next;

    /*
        This is used by ejs to interpret scripts. OPT. Should not run through old modules every time
     */
    for (next = 0; (mp = (EjsModule*) mprGetNextItem(ejs->modules, &next)) != 0;) {
        if (mp->initialized) {
            continue;
        }
        if (ejsRunInitializer(ejs, mp) == 0) {
            return EJS_ERR;
        }
    }
    return 0;
}


/*
    Run a function with the given parameters
 */
EjsObj *ejsRunFunction(Ejs *ejs, EjsFunction *fun, EjsObj *thisObj, int argc, EjsObj **argv)
{
    int         i;
    
    mprAssert(ejs);
    mprAssert(fun);
    mprAssert(ejsIsFunction(fun));
    mprAssert(ejs->exception == 0);

    if (ejs->exception) {
        return 0;
    }
    ejsClearAttention(ejs);
    
    if (thisObj == 0) {
        if ((thisObj = fun->thisObj) == 0) {
            thisObj = ejs->state->fp->function.thisObj;
        }
    }    
    if (ejsIsNativeFunction(fun)) {
        if (fun->body.proc == 0) {
            ejsThrowArgError(ejs, "Native function is not defined");
            return 0;
        }
        ejs->result = (fun->body.proc)(ejs, thisObj, argc, argv);
        if (ejs->result == 0) {
            ejs->result = ejs->nullValue;
        }

    } else {
        for (i = 0; i < argc; i++) {
            pushOutside(ejs, argv[i]);
        }
        VM(ejs, fun, thisObj, argc, 0);
        ejs->state->stack -= argc;
        if (ejs->exiting || mprIsExiting(ejs)) {
            ejsAttention(ejs);
        }
    }
    return (ejs->exception) ? 0 : ejs->result;
}


//  MOB TODO - reverse obj and slot

EjsObj *ejsRunFunctionBySlot(Ejs *ejs, EjsObj *thisObj, int slotNum, int argc, EjsObj **argv)
{
    EjsFunction     *fun;

    if (thisObj == 0) {
        thisObj = ejs->global;
    }
    if (thisObj == ejs->global) {
        fun = (EjsFunction*) ejsGetProperty(ejs, thisObj, slotNum);
    } else {
        fun = (EjsFunction*) ejsGetProperty(ejs, ejsIsType(thisObj) ? thisObj : (EjsObj*) thisObj->type, slotNum);
    }
    if (fun == 0) {
        ejsThrowReferenceError(ejs, "Can't find function at slot %d in %s::%s", slotNum, thisObj->type->qname.space, 
            thisObj->type->qname.name);
        return 0;
    }
    return ejsRunFunction(ejs, fun, thisObj, argc, argv);
}


EjsObj *ejsRunFunctionByName(Ejs *ejs, EjsObj *container, EjsName *qname, EjsObj *thisObj, int argc, EjsObj **argv)
{
    EjsFunction     *fun;

    if (thisObj == 0) {
        thisObj = ejs->global;
    }
    if ((fun = (EjsFunction*) ejsGetPropertyByName(ejs, container, qname)) == 0) {
        ejsThrowReferenceError(ejs, "Can't find function %s::%s", qname->space, qname->name);
        return 0;
    }
    return ejsRunFunction(ejs, fun, thisObj, argc, argv);
}



static void badArgType(Ejs *ejs, EjsObj *activation, EjsTrait *trait, int index)
{
    EjsName     qname;

    qname = ejsGetPropertyName(ejs, activation, index);
    ejsThrowTypeError(ejs, "Unacceptable null or undefined value for arg \"%s\" (pos: %d)", qname.name, index);
}


/*
    Validate the args. This routine handles ...rest args and parameter type checking and casts. Returns the new argc 
    or < 0 on errors.
 */
static int validateArgs(Ejs *ejs, EjsFunction *fun, int argc, EjsObj **argv)
{
    EjsType     *type;
    EjsTrait    *trait;
    EjsObj      *activation, *newArg;
    EjsArray    *rest;
    int         nonDefault, i, limit, numRest;

    mprAssert(ejs->exception == 0);
    mprAssert(ejs->state->fp == 0 || ejs->state->fp->attentionPc == 0);

    nonDefault = fun->numArgs - fun->numDefault;
    activation = fun->activation;

    if (argc < nonDefault) {
        if (!fun->rest || argc != (fun->numArgs - 1)) {
            if (fun->strict) {
                ejsThrowArgError(ejs, "Insufficient actual parameters. Call requires %d parameter(s).", nonDefault);
                return EJS_ERR;
            } else {
                /* Create undefined values for missing args */
                for (i = argc; i < nonDefault; i++) {
                    pushOutside(ejs, ejs->undefinedValue);
                }
                argc = nonDefault;
            }
        }
    }

    if ((uint) argc > fun->numArgs && !fun->rest) {
        /*
            Discard excess arguments for scripted functions. No need to discard for native procs. This allows
            ejsDefineGlobalFunction to not have to bother with specifying the number of args for native procs.
         */
        if (!ejsIsNativeFunction(fun)) {
            ejs->state->stack -=  (argc - fun->numArgs);
            argc = fun->numArgs;
        }
    }

    /*
        Handle rest "..." args
     */
    if (fun->rest) {
        numRest = argc - fun->numArgs + 1;
        rest = ejsCreateArray(ejs, numRest);
        if (rest == 0) {
            return EJS_ERR;
        }
        for (i = numRest - 1; i >= 0; i--) {
            ejsSetProperty(ejs, (EjsObj*) rest, i, popOutside(ejs));
        }
        argc = argc - numRest + 1;
        pushOutside(ejs, rest);
    }

    /*
        Cast args to the right types
     */
    limit = min((uint) argc, fun->numArgs);
    for (i = 0; i < limit; i++) {
        if ((trait = ejsGetTrait(activation, i)) == 0 || trait->type == 0) {
            /* No trait - all to pass */
            continue;
        }
        type = trait->type;
        if (!ejsIsA(ejs, argv[i], type)) {
            if ((argv[i] == ejs->nullValue || argv[i] == ejs->undefinedValue)) {
                if (trait->attributes & EJS_TRAIT_THROW_NULLS) {
                    badArgType(ejs, activation, trait, i);
                    return EJS_ERR;
                }
                if (!(trait->attributes & EJS_TRAIT_CAST_NULLS)) {
                    continue;
                }
            }
            newArg = ejsCast(ejs, argv[i], trait->type);
            if (ejs->exception) {
                ejsClearException(ejs);
                badArgType(ejs, activation, trait, i);
                return EJS_ERR;
            }
            argv[i] = newArg;
        }
    }
    return argc;
}


/*
    Call a type constructor function and create a new object.
 */
static void callConstructor(Ejs *ejs, EjsFunction *vp, int argc, int stackAdjust)
{
    EjsFunction     *fun;
    EjsType         *type;
    EjsObj          *obj;
    int             slotNum;

    mprAssert(!ejsIsFunction(vp));
    mprAssert(ejs->exception == 0);
    mprAssert(ejs->state->fp->attentionPc == 0);

    if ((EjsObj*) vp == (EjsObj*) ejs->undefinedValue) {
        ejsThrowReferenceError(ejs, "Function is undefined");
        return;

    } else if (ejsIsType(vp)) {
        /* 
            Handle calling a constructor to create a new instance 
         */
        type = (EjsType*) vp;
        obj = ejsCreate(ejs, type, 0);
        ejsClearAttention(ejs);
        
        if (type->hasConstructor) {
            /*
                Constructor is always at slot 0 (offset by base properties)
             */
            slotNum = type->numInherited;
            fun = (EjsFunction*) ejsGetProperty(ejs, (EjsObj*) type, slotNum);

            if (ejsIsNativeFunction(fun)) {
                mprAssert(ejs->state->fp == 0 || ejs->state->fp->attentionPc == 0);    
                callFunction(ejs, fun, obj, argc, stackAdjust);
            } else {
                VM(ejs, fun, obj, argc, stackAdjust);
                ejs->state->stack -= (argc + stackAdjust);
                if (ejs->exiting || mprIsExiting(ejs)) {
                    ejsAttention(ejs);
                }
            }
        }
        ejs->result = obj;

    } else {
        ejsThrowReferenceError(ejs, "Reference is not a function");
    }
}


/*
    Find the right base class to use as "this" for a static method
 */
static EjsObj *getStaticThis(Ejs *ejs, EjsType *type, int slotNum)
{
    while (type) {
        if (slotNum >= type->numInherited) {
            break;
        }
        type = type->baseType;
    }
    return (EjsObj*) type;
}


static void callInterfaceInitializers(Ejs *ejs, EjsType *type)
{
    EjsType     *iface;
    EjsFunction *fun;
    int         next, slotNum;

    for (next = 0; ((iface = mprGetNextItem(type->implements, &next)) != 0); ) {
        if (iface->hasStaticInitializer) {
            slotNum = iface->numInherited;
            if (iface->hasConstructor) {
                slotNum++;
            }
            fun = (EjsFunction*) ejsGetProperty(ejs, (EjsObj*) iface, slotNum);
            callFunction(ejs, fun, (EjsObj*) type, 0, 0);
        }
    }
}


/*
    Push a block. Used by compiler.
    MOB -- move back to the compiler
 */
EjsBlock *ejsPushBlock(Ejs *ejs, EjsBlock *original)
{
    EjsBlock    *block;

    mprAssert(!ejsIsFunction(original));

    block = ejsCloneBlock(ejs, original, 0);
    block->scopeChain = ejs->state->bp;
    block->prev = ejs->state->bp;
    block->stackBase = ejs->state->stack;
    ejs->state->bp = block;
    return block;
}


/*
    Pop a block frame and return to the previous frame.  This pops functions and/or lexical blocks.
 */
EjsBlock *ejsPopBlock(Ejs *ejs)
{
    EjsBlock    *bp;

    bp = ejs->state->bp;
    if (bp->prev) {
        ejs->state->stack = bp->stackBase;
    }
    return ejs->state->bp = bp->prev;
}


/*
    Pop an exception block.
 */
static EjsBlock *popExceptionBlock(Ejs *ejs)
{
    EjsBlock     *prev;

    if ((prev = ejs->state->bp->prev) != 0) {
        if (ejs->exception == 0) {
            ejs->exception = prev->prevException;
            prev->prevException = 0;
            if (ejs->exception) {
                /* Advance by one as checkExceptionHandlers expects the PC to be advanced after parsing the opcode */
                ejs->state->fp->pc++;
                ejsAttention(ejs);
            }
        }
    }
    ejs->state->bp = prev;
    return prev;
}


/*
    Manage exceptions. Bubble up the exception until we find an exception handler for it.
 */
static bool manageExceptions(Ejs *ejs)
{
    EjsState        *state;

    state = ejs->state;

    /*
        Check at each function level for a handler to process the exception.
     */
    while (state->fp) {
        checkExceptionHandlers(ejs);
        if (ejs->exception == 0) {
            return 1;
        }
        state->stack = state->fp->stackReturn;
        state->bp = state->fp->function.block.prev;
        state->fp = state->fp->caller;
        ejsClearAttention(ejs);
    }
    return 0;
}


static inline EjsEx *findExceptionHandler(Ejs *ejs, int kind)
{
    EjsEx       *ex;
    EjsFrame    *fp;
    EjsCode     *code;
    uint        pc;
    int         i;

    ex = 0;
    fp = ejs->state->fp;
    code = &fp->function.body.code;
    pc = (uint) (fp->pc - code->byteCode - 1);

    /*
        Exception handlers are sorted with the inner most handlers first.
     */
    for (i = 0; i < code->numHandlers; i++) {
        ex = code->handlers[i];
        if (ex->tryStart <= pc && pc < ex->handlerEnd && (ex->flags & kind)) {
            if (ejs->exception == (EjsObj*) ejs->iterator || kind == EJS_EX_FINALLY || ex->catchType == ejs->voidType || 
                    /* MOB - This test is here because stopIteration throws a type and ejsIsA works only for instances */
                    ejs->exception == (EjsObj*) ex->catchType || ejsIsA(ejs, (EjsObj*) ejs->exception, ex->catchType)) {
                return ex;
            }
        }
    }
    return 0;
}

static inline EjsEx *inHandler(Ejs *ejs, int kind)
{
    EjsEx       *ex;
    EjsFrame    *fp;
    EjsCode     *code;
    uint        pc;
    int         i;
    
    ex = 0;
    fp = ejs->state->fp;
    code = &fp->function.body.code;
    pc = (uint) (fp->pc - code->byteCode - 1);
    
    /*
        Exception handlers are sorted with the inner most handlers first.
     */
    for (i = 0; i < code->numHandlers; i++) {
        ex = code->handlers[i];
        if (ex->handlerStart <= pc && pc < ex->handlerEnd && (ex->flags & kind)) {
            return ex;
        }
    }
    return 0;
}


/*
    Find the end of the last catch/finally handler.
 */
static inline uint findEndException(Ejs *ejs)
{
    EjsFrame    *fp;
    EjsEx       *best, *ex;
    EjsCode     *code;
    uint        offset, pc;
    int         i;

    ex = 0;
    fp = ejs->state->fp;
    code = &fp->function.body.code;
    pc = (uint) (fp->pc - code->byteCode - 1);
    offset = 0;

    for (best = 0, i = 0; i < code->numHandlers; i++) {
        ex = code->handlers[i];
        /*
            Comparison must include try and all catch handlers, incase there are multiple catch handlers
         */
        if (ex->tryStart <= pc && pc < ex->handlerEnd) {
            offset = ex->handlerEnd;
            for (++i; i < code->numHandlers; i++) {
                /* Find the last handler of this try block. Use tryEnd as nested try blocks can start at the same location */
                if (ex->tryEnd == code->handlers[i]->tryEnd) {
                    offset = code->handlers[i]->handlerEnd;
                }
            }
        }
    }
    mprAssert(offset);
    return offset;
}


/*
    Search for an exception handler at this level to process the exception. Return true if the exception is handled.
 */
static void checkExceptionHandlers(Ejs *ejs)
{
    EjsFrame        *fp;
    EjsCode         *code;
    EjsEx           *ex;
    uint            pc;

    ex = 0;
    fp = ejs->state->fp;
    code = &fp->function.body.code;

    if (code->numHandlers == 0) {
        return;
    }

    /*
        The PC is always one advanced from the throwing instruction. ie. the PC has advanced past the offending 
        instruction so reverse by one.
     */
    pc = (uint) (fp->pc - code->byteCode - 1);
    mprAssert(pc >= 0);

rescan:
    if (!fp->function.inException || (ejs->exception == (EjsObj*) ejs->stopIterationType)) {
        /*
            Normal exception in a try block. NOTE: the catch will jump or fall through to the finally block code.
            ie. We won't come here again for the finally code unless there is an exception in the catch block.
            Otherwise, No catch handler at this level and need to bubble up.
         */
        if ((ex = findExceptionHandler(ejs, EJS_EX_CATCH)) != 0) {
            createExceptionBlock(ejs, ex, ex->flags);
            return;
        }

    } else {
        /*
            Exception in a catch or finally block. If in a catch block, must first run the finally
            block before bubbling up. If in a finally block, we are done and upper levels will handle. We can be
            in a finally block and inException == 0. This happens because try blocks jump through directly
            into finally blocks (fast). But we need to check here if we are in the finally block explicitly.
         */
        if ((ex = inHandler(ejs, EJS_EX_FINALLY)) != 0) {
            /*
                If in a finally block, must advance the outer blocks's pc to be outside [tryStart .. finallyStart]
                This prevents this try block from handling this exception again.
             */
            SET_PC(fp, &fp->function.body.code.byteCode[ex->handlerEnd + 1]);
            fp->function.inCatch = fp->function.inException = 0;
            goto rescan;            
        }
    }

    /*
        Exception without a catch block or exception in a catch block. 
     */
    if ((ex = findExceptionHandler(ejs, EJS_EX_FINALLY)) != 0) {
        if (fp->function.inCatch) {
            popExceptionBlock(ejs);
        }
        createExceptionBlock(ejs, ex, EJS_EX_FINALLY);
    } else {
        fp->function.inCatch = fp->function.inException = 0;
    }
    ejsClearAttention(ejs);
}


/*
    Called for catch and finally blocks
 */
static void createExceptionBlock(Ejs *ejs, EjsEx *ex, int flags)
{
    EjsBlock        *block;
    EjsFrame        *fp;
    EjsState        *state;
    EjsCode         *code;
    int             i, count;

    state = ejs->state;
    fp = state->fp;
    code = &state->fp->function.body.code;
    mprAssert(ex);

    ejsClearAttention(ejs);

    if (flags & EJS_EX_ITERATION) {
        /*
            Empty handler is a special case for iteration. We simply do a break to the handler location
            which targets the end of the for/in loop.
         */
        SET_PC(fp, &fp->function.body.code.byteCode[ex->handlerStart]);
        ejs->exception = 0;
        return;
    }

    /*
        Discard all lexical blocks defined inside the try block
     */
    if (!fp->function.inCatch) {
        for (count = 0, block = state->bp; block != (EjsBlock*) state->fp; block = block->prev) {
            count++;
        }
        count -= ex->numBlocks;
        mprAssert(count >= 0);
        for (i = 0; i < count; i++) {
            ejsPopBlock(ejs);
        }
    }
    
    /*
        Allocate a new frame in which to execute the handler
     */
    block = ejsCreateBlock(ejs, 0);
    ejsSetDebugName(block, "exception");
    if (block == 0) {
        /*  Exception will continue to bubble up */
        return;
    }
    block->prev = block->scopeChain = state->bp;
    state->bp = block;

    /*
        Move the PC outside of the try region. If this is a catch block, this allows the finally block to still
        be found. But if this is processing a finally block, the scanning for a matching handler will be forced
        to bubble up.
     */
    SET_PC(fp, &fp->function.body.code.byteCode[ex->handlerStart]);

    if (flags & EJS_EX_CATCH) {
        ejs->exceptionArg = ejs->exception;
        fp->function.inCatch = 1;

    } else {
        /*
            Mask the exception while processing the finally block
         */
        block->prev->prevException = ejs->exception;
        fp->function.inCatch = 0;
        ejsAttention(ejs);
    }
    ejs->exception = 0;
    fp->function.inException = 1;
}


typedef struct OperMap {
    int         opcode;
    cchar       *name;
} OperMap;

static OperMap operMap[] = {
        { EJS_OP_MUL,           "*"     },
        { EJS_OP_DIV,           "/"     },
        { EJS_OP_REM,           "%"     },
        { EJS_OP_COMPARE_LT,    "<"     },
        { EJS_OP_COMPARE_GT,    ">"     },
        { EJS_OP_COMPARE_LE,    "<="    },
        { EJS_OP_COMPARE_GE,    ">="    },
        { 0,                    0       },
};


static int lookupOverloadedOperator(Ejs *ejs, EjsOpCode opcode, EjsObj *lhs)
{
    EjsName     qname;
    int         i;

    for (i = 0; operMap[i].opcode; i++) {
        if (operMap[i].opcode == opcode) {
            ejsName(&qname, "", operMap[i].name);
            break;
        }
    }
    return ejsLookupProperty(ejs, (EjsObj*) lhs->type, &qname);
}


/*
    Evaluate a binary expression.
    OPT -- simplify and move back inline into eval loop.
 */
static EjsObj *evalBinaryExpr(Ejs *ejs, EjsObj *lhs, EjsOpCode opcode, EjsObj *rhs)
{
    EjsObj      *result;
    int         slotNum;

    if (lhs == 0) {
        lhs = ejs->undefinedValue;
    }
    if (rhs == 0) {
        rhs = ejs->undefinedValue;
    }
    result = ejsInvokeOperator(ejs, lhs, opcode, rhs);

    if (result == 0 && ejs->exception == 0) {
        slotNum = lookupOverloadedOperator(ejs, opcode, lhs);
        if (slotNum >= 0) {
            result = ejsRunFunctionBySlot(ejs, lhs, slotNum, 1, &rhs);
        }
    }
    return result;
}


int ejsInitStack(Ejs *ejs)
{
    EjsState    *state;

    state = ejs->state = ejs->masterState = mprAllocObjZeroed(ejs, EjsState);

    /*
        Allocate the stack
     */
    state->stackSize = MPR_PAGE_ALIGN(EJS_STACK_MAX, mprGetPageSize(ejs));

    /*
        This will allocate memory virtually for systems with virutal memory. Otherwise, it will just use malloc.
        TODO - create a guard page
     */
    state->stackBase = mprMapAlloc(state->stackSize, MPR_MAP_READ | MPR_MAP_WRITE);
    if (state->stackBase == 0) {
        mprSetAllocError(ejs);
        return EJS_ERR;
    }
    state->stack = &state->stackBase[-1];
    return 0;
}


#if FUTURE
/*
    Grow the operand evaluation stack.
    Return a negative error code on memory allocation errors or if the stack grows too big.
 */
int ejsGrowStack(Ejs *ejs, int incr)
{
    EjsStack *sp;
    EjsFrame *frame;
    EjsObj **bottom;
    int i, size, moveBy;

    sp = ejs->stack;
    sp->ejs = ejs;

    incr = max(incr, EJS_STACK_INC);

    if (sp->bottom) {
        /*
            Grow an existing stack
         */
        size = sp->size + (sizeof(EjsObj*) * incr);
        bottom = (EjsObj**) mprRealloc(sp, sp->bottom, size);
        //  OPT - don't zeroed?
        memset(&bottom[sp->size], 0, (size - sp->size) * sizeof(EjsObj*));
        moveBy = (int) ((char*) bottom - (char*) sp->bottom);
        sp->top = (EjsObj**) ((char*) sp->top + moveBy);
        sp->bottom = bottom;

        /*
            Adjust all the argv pointers.
         */
        for (frame = ejs->frame; frame; frame = frame->prev) {
            if (frame->argv) {
                frame->argv = (EjsObj**) ((char*) frame->argv + moveBy);
            }
            frame->prevStackTop = (EjsObj**) ((char*) frame->prevStackTop + moveBy);
        }

    } else {
        /*
            Allocate a stack
         */
        if (sp->top >= &sp->bottom[EJS_STACK_MAX]) {
            return MPR_ERR_NO_MEMORY;
        }
        size = (sizeof(EjsObj*) * incr);
        sp->bottom = (EjsObj**) mprAlloc(sp, size);
        /*
            Push always begins with an increment of sp->top. Initially, sp_bottom points to the first (future) element.
         */
        sp->top = &sp->bottom[-1];
    }

    if (sp->bottom == 0) {
        return MPR_ERR_NO_MEMORY;
    }

    sp->end = &sp->bottom[size / sizeof(EjsObj*)];
    sp->size = size;

    for (i = 1; i <= incr; i++) {
        sp->top[i] = 0;
    }
    return 0;
}
#endif


/*
    Exit the script
 */
void ejsExit(Ejs *ejs, int status)
{
    //  TODO - should pass status back
    ejs->exiting = 1;
}


static EjsName getNameArg(EjsFrame *fp)
{
    EjsName     qname;

    qname.name = getStringArg(fp);
    qname.space = getStringArg(fp);
    return qname;
}


/*
    Get an interned string. String constants are stored as token offsets into the constant pool. The pool
    contains null terminated UTF-8 strings.
 */
static char *getStringArg(EjsFrame *fp)
{
    int     number;

    number = (int) ejsDecodeNum(&fp->pc);

    mprAssert(fp->function.body.code.constants);
    return &fp->function.body.code.constants->pool[number];
}


static EjsObj *getGlobalArg(Ejs *ejs, EjsFrame *fp)
{
    EjsObj      *vp;
    EjsName     qname;
    int         t, slotNum;

    t = (int) ejsDecodeNum(&fp->pc);
    if (t < 0) {
        return 0;
    }

    slotNum = -1;
    qname.name = 0;
    qname.space = 0;
    vp = 0;

    /*
        OPT. Could this encoding be optimized?
     */
    switch (t & EJS_ENCODE_GLOBAL_MASK) {
    default:
        mprAssert(0);
        return 0;

    case EJS_ENCODE_GLOBAL_NOREF:
        return 0;

    case EJS_ENCODE_GLOBAL_SLOT:
        slotNum = t >> 2;
        if (0 <= slotNum && slotNum < ejsGetPropertyCount(ejs, ejs->global)) {
            vp = ejsGetProperty(ejs, ejs->global, slotNum);
        }
        break;

    case EJS_ENCODE_GLOBAL_NAME:
        qname.name = &fp->function.body.code.constants->pool[t >> 2];
        if (qname.name == 0) {
            mprAssert(0);
            return 0;
        }
        qname.space = getStringArg(fp);
        if (qname.space == 0) {
            return 0;
        }
        if (qname.name) {
            vp = ejsGetPropertyByName(ejs, ejs->global, &qname);
        }
        break;
    }
    return vp;
}


static void callProperty(Ejs *ejs, EjsFunction *fun, EjsObj *thisObj, int argc, int stackAdjust)
{
    EjsTrait    *trait;

    if (ejsIsFunction(fun)) {
        //  MOB -- but the owner may not be the right owner if the property is copied
        trait = ejsGetTrait(fun->owner, fun->slotNum);
        if (trait && trait->attributes & EJS_TRAIT_GETTER) {
            fun = (EjsFunction*) ejsRunFunction(ejs, fun, thisObj, 0, NULL);
            if (ejs->exception) {
                return;
            }
        }
    }
    callFunction(ejs, fun, thisObj, argc, stackAdjust);
}


/*
    Call a function. Supports both native and scripted functions. If native, the function is fully 
    invoked here. If scripted, a new frame is created and the pc adjusted to point to the new function.
 */
static void callFunction(Ejs *ejs, EjsFunction *fun, EjsObj *thisObj, int argc, int stackAdjust)
{
    EjsState        *state;
    EjsFrame        *fp;
    EjsName         qname;
    EjsObj          **argv;

    mprAssert(fun);
    mprAssert(ejs->exception == 0);
    mprAssert(ejs->state->fp == 0 || ejs->state->fp->attentionPc == 0);    

    state = ejs->state;

    if (unlikely(!ejsIsFunction(fun))) {
        callConstructor(ejs, fun, argc, stackAdjust);
        return;
    }
    if (thisObj == 0) {
        if ((thisObj = fun->thisObj) == 0) {
            thisObj = state->fp->function.thisObj;
        } 
    } 
    if (fun->staticMethod && !ejsIsType(thisObj)) {
        /*
            Calling a static method via an instance object
         */
        thisObj = getStaticThis(ejs, thisObj->type, fun->slotNum);
    }
    /*
        Validate the args. Cast to the right type, handle rest args and return with argc adjusted.
     */
    argv = NULL;
    if (argc > 0 || fun->numArgs || fun->rest) {
        argv = &(state->stack[1 - argc]);
        if ((argc = validateArgs(ejs, fun, argc, argv)) < 0) {
            return;
        }
    }
    if (ejs->exception) {
        return;
    }
    if (ejsIsNativeFunction(fun)) {
        if (fun->body.proc == 0) {
            qname = ejsGetPropertyName(ejs, fun->owner, fun->slotNum);
            ejsThrowInternalError(ejs, "Native function \"%s\" is not defined", qname.name);
            return;
        }
        ejsClearAttention(ejs);
        ejs->result = (fun->body.proc)(ejs, thisObj, argc, argv);
        if (ejs->result == 0) {
            ejs->result = ejs->nullValue;
        }
        state->stack -= (argc + stackAdjust);

    } else {
        fp = ejsCreateFrame(ejs, fun, thisObj, argc, argv);
        fp->function.block.prev = state->bp;
        fp->caller = state->fp;
        fp->stackBase = state->stack;
        fp->stackReturn = state->stack - argc - stackAdjust;
        state->fp = fp;
        state->bp = (EjsBlock*) fp;
        ejsClearAttention(ejs);
    }
}


static void throwNull(Ejs *ejs)
{
    ejsThrowReferenceError(ejs, "Object reference is null");
}


/*
    Object can be an instance or a type. If an instance, then step to the immediate base type to begin the count.
 */
static EjsObj *getNthBase(Ejs *ejs, EjsObj *obj, int nthBase)
{
    EjsType     *type;

    if (obj) {
        if (ejsIsType(obj) || obj == ejs->global) {
            type = (EjsType*) obj;
        } else {
            type = obj->type;
            nthBase--;
        }
        for (; type && nthBase > 0; type = type->baseType) {
            nthBase--;
        }
        if (nthBase > 0) {
            ejsThrowReferenceError(ejs, "Can't find correct base class");
            return 0;
        }
        obj = (EjsObj*) type;
    }
    return obj;
}


static EjsObj *getNthBaseFromBottom(Ejs *ejs, EjsObj *obj, int nthBase)
{
    EjsType     *type, *tp;
    int         count;

    if (obj) {
        if (ejsIsType(obj) || obj == ejs->global) {
            type = (EjsType*) obj;
        } else {
            type = obj->type;
        }
        for (count = 0, tp = type->baseType; tp; tp = tp->baseType) {
            count++;
        }
        nthBase = count - nthBase;
        for (; type && nthBase > 0; type = type->baseType) {
            nthBase--;
        }
        obj = (EjsObj*) type;
    }
    return obj;
}


static EjsObj *getNthBlock(Ejs *ejs, int nth)
{
    EjsBlock    *block;

    mprAssert(ejs);
    mprAssert(nth >= 0);

    for (block = ejs->state->bp; block && --nth >= 0; ) {
        /* TODO - this is done for loading scripts into ejs. Really the compiler should remove these blocks */
        if (block->obj.hidden) nth++;
        block = block->scopeChain;
    }
    return (EjsObj*) block;
}


/*
    Enter a mesage into the log file
 */
void ejsLog(Ejs *ejs, const char *fmt, ...)
{
    va_list     args;
    char        buf[MPR_MAX_LOG_STRING];

    va_start(args, fmt);
    mprVsprintf(buf, sizeof(buf) - 1, fmt, args);
    va_end(args);

    mprLog(ejs, 0, "%s", buf);
}


void ejsShowStack(Ejs *ejs, EjsFunction *fp)
{
    char    *stack;
    
    stack = ejsFormatStack(ejs, NULL);
    mprLog(ejs, 7, "Stack\n%s", stack);
    mprFree(stack);
}


#if FUTURE

- Separate file

//  MOB - move into the mpr
#if BLD_CC_EDITLINE
static History  *cmdHistory;
static EditLine *eh; 
static cchar    *prompt;

static cchar *issuePrompt(EditLine *e) {
    return prompt;
}

static EditLine *initEditLine()
{
    EditLine    *e;
    HistEvent   ev; 

    cmdHistory = history_init(); 
    history(cmdHistory, &ev, H_SETSIZE, 100); 
    e = el_init("ejs", stdin, stdout, stderr); 
    el_set(e, EL_EDITOR, "vi");
    el_set(e, EL_HIST, history, cmdHistory);
    el_source(e, NULL);
    return e;
}


/*  
    Prompt for input with the level of current nest (block nest depth)
 */
static char *readline(cchar *msg) 
{ 
    HistEvent   ev; 
    cchar       *str; 
    char        *result;
    int         len, count; 
 
    if (eh == NULL) { 
        eh = initEditLine();
    }
    prompt = msg;
    el_set(eh, EL_PROMPT, issuePrompt);
    str = el_gets(eh, &count); 
    if (str && count > 0) { 
        result = strdup(str); 
        len = strlen(result);
        if (result[len - 1] == '\n') {
            result[len - 1] = '\0'; 
        }
        count = history(cmdHistory, &ev, H_ENTER, result); 
        return result; 
    }  
    return NULL; 
} 

#else

static char *readline(cchar *msg)
{
    char    buf[MPR_MAX_STRING];

    printf("%s", msg);
    if (fgets(buf, sizeof(buf) - 1, stdin) == 0) {
        return NULL;
    }
    return strdup(buf);
}
#endif


typedef struct EjsBreakpoint {
    cchar   *filename;
    int     lineNumber;
    int     opcode;    
} EjsBreakpoint;


static void manageBreakpoint(Ejs *ejs)
{
    EjsFrame        *fp;
    EjsState        *state;
    EjsBreakpoints  *breakpoints;
    EjsOptable      *optable;
    int             len;
    uint            offset;
    static int      once = 0;
    static int      stop = 1;

    state = ejs->state;
    fp = state->fp;
    opcount[opcode]++;

    breakpoints = ejs->breakpoints;

    offset = (uint) (fp->pc - fp->function.body.code.byteCode) - 1;
    if (offset < 0) {
        offset = 0;
    }
    str = readline("edb> ");

    Display source with current line highlighted

    //  TODO - should have a switch to turn this on / off
    //  OPT - compiler should strip '\n' from currentLine and we should explicitly add it here
    optable = ejsGetOptable(ejs);
    mprLog(ejs, 7, "%0s %04d: [%d] %02x: %-35s # %s:%d %s",
        mprGetCurrentThreadName(fp), offset, (int) (state->stack - fp->stackReturn + 1),
        (uchar) opcode, optable[opcode].name, fp->filename, fp->lineNumber, fp->currentLine);
    if (stop && once++ == 0) {
        mprSleep(ejs, 0);
    }
    mprAssert(state->stack >= fp->stackReturn);
}
#endif


#if BLD_DEBUG
#if UNUSED
void ejsShowOpFrequency(Ejs *ejs)
{
    EjsOptable      *optable;
    int             i;

    if (mprGetLogLevel(ejs) < 6) {
        return;
    }
    optable = ejsGetOptable(ejs);
    mprLog(ejs, 0, "Opcode Frequency");
    for (i = 0; i < 256 && optable[i].name; i++) {
        mprLog(ejs, 6, "%4d %24s %8d", (uchar) i, optable[i].name, opcount[i]);
    }
}
#endif


int ejsOpCount = 0;
static EjsOpCode traceCode(Ejs *ejs, EjsOpCode opcode)
{
    EjsFrame        *fp;
    EjsState        *state;
    EjsOptable      *optable;
    int             len;
    int             offset;
    static int      once = 0;
    static int      stop = 1;
#if UNUSED
    static int      showFrequency = 1;
#endif

    state = ejs->state;
    fp = state->fp;
    opcount[opcode]++;

    if (ejs->initialized && opcode != EJS_OP_DEBUG) {
        //  OPT - should strip '\n' in the compiler
        if (fp->currentLine) {
            len = (int) strlen(fp->currentLine) - 1;
            if (fp->currentLine[len] == '\n') {
                ((char*) fp->currentLine)[len] = '\0';
            }
        }
        offset = (int) (fp->pc - fp->function.body.code.byteCode) - 1;
        if (offset < 0) {
            offset = 0;
        }
        //  TODO - should have a switch to turn this on / off
        //  OPT - compiler should strip '\n' from currentLine and we should explicitly add it here
        optable = ejsGetOptable(ejs);
        mprLog(ejs, 7, "%0s %04d: [%d] %02x: %-35s # %s:%d %s",
            mprGetCurrentThreadName(fp), offset, (int) (state->stack - fp->stackReturn + 1),
            (uchar) opcode, optable[opcode].name, fp->filename, fp->lineNumber, fp->currentLine);
#if UNUSED
        if (showFrequency && ((once % 1000) == 999)) {
            ejsShowOpFrequency(ejs);
        }
#endif
        if (stop && once++ == 0) {
            mprSleep(ejs, 0);
        }
        mprAssert(state->stack >= fp->stackReturn);
    }
    ejsOpCount++;
    return opcode;
}
#endif


/*
    Cleanup defines for all-in-one builds
 */
#undef top
#undef pop
#undef push
#undef popString
#undef popOutside
#undef pushOutside
#undef FRAME
#undef FUNCTION
#undef BLOCK
#undef SWAP
#undef TRACE
#undef GET_SLOT
#undef SET_SLOT
#undef GET_BYTE
#undef GET_DOUBLE
#undef GET_INT
#undef GET_NUM
#undef GET_NAME
#undef GET_STRING
#undef GET_TYPE
#undef GET_WORD
#undef THIS
#undef FILL
#undef CASE
#undef BREAK

/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2010. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2010. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    @end
 */
/************************************************************************/
/*
 *  End of file "../src/vm/ejsInterp.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../src/vm/ejsList.c"
 */
/************************************************************************/

/**
    ejsList.c - Simple static list type.

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */




static int growList(MprCtx ctx, EjsList *lp, int incr);

#define CAPACITY(lp) (mprGetBlockSize(lp) / sizeof(void*))

//  OPT - inline some of these functions as macros

/*
    Initialize a list which may not be a memory context.
 */
void ejsInitList(EjsList *lp)
{
    lp->length = 0;
    lp->maxSize = MAXINT;
    lp->items = 0;
}


/*
    Define the list maximum size. If the list has not yet been written to, the initialSize will be observed.
 */
int ejsSetListLimits(MprCtx ctx, EjsList *lp, int initialSize, int maxSize)
{
    int         size;

    if (initialSize <= 0) {
        initialSize = MPR_LIST_INCR;
    }
    if (maxSize <= 0) {
        maxSize = MAXINT;
    }
    size = initialSize * sizeof(void*);

    if (lp->items == 0) {
        lp->items = (void**) mprAllocZeroed(ctx, size);
        if (lp->items == 0) {
            mprFree(lp);
            return MPR_ERR_NO_MEMORY;
        }
    }
    lp->maxSize = maxSize;
    return 0;
}


/*
    Add an item to the list and return the item index.
 */
int ejsAddItem(MprCtx ctx, EjsList *lp, cvoid *item)
{
    int     index, capacity;

    mprAssert(lp);
    mprAssert(lp->length >= 0);

    capacity = CAPACITY(lp->items);
    mprAssert(capacity >= 0);

    if (lp->items == 0 || lp->length >= capacity) {
        if (growList(ctx, lp, 1) < 0) {
            return MPR_ERR_TOO_MANY;
        }
    }
    index = lp->length++;
    lp->items[index] = (void*) item;
    return index;
}


int ejsAddItemToSharedList(MprCtx ctx, EjsList *lp, cvoid *item)
{
    EjsList     tmp;

    if (lp->items == NULL || mprGetParent(lp->items) != ctx) {
        tmp = *lp;
        lp->items = 0;
        lp->length = 0;
        if (ejsCopyList(ctx, lp, &tmp) < 0) {
            return MPR_ERR_NO_MEMORY;
        }
    }
    return ejsAddItem(ctx, lp, item);
}


EjsList *ejsAppendList(MprCtx ctx, EjsList *list, EjsList *add)
{
    void        *item;
    int         next;

    mprAssert(list);
    mprAssert(list != add);

    for (next = 0; ((item = ejsGetNextItem(add, &next)) != 0); ) {
        if (ejsAddItem(ctx, list, item) < 0) {
            mprFree(list);
            return 0;
        }
    }
    return list;
}


void ejsClearList(EjsList *lp)
{
    int     i;

    mprAssert(lp);

    for (i = 0; i < lp->length; i++) {
        lp->items[i] = 0;
    }
    lp->length = 0;
}


int ejsCopyList(MprCtx ctx, EjsList *dest, EjsList *src)
{
    void        *item;
    int         next, capacity;

    ejsClearList(dest);

    capacity = CAPACITY(src->items);
    if (ejsSetListLimits(ctx, dest, capacity, src->maxSize) < 0) {
        return MPR_ERR_NO_MEMORY;
    }
    for (next = 0; (item = ejsGetNextItem(src, &next)) != 0; ) {
        if (ejsAddItem(ctx, dest, item) < 0) {
            return MPR_ERR_NO_MEMORY;
        }
    }
    return 0;
}


void *ejsGetItem(EjsList *lp, int index)
{
    mprAssert(lp);

    if (index < 0 || index >= lp->length) {
        return 0;
    }
    return lp->items[index];
}


void *ejsGetLastItem(EjsList *lp)
{
    mprAssert(lp);

    if (lp == 0) {
        return 0;
    }

    if (lp->length == 0) {
        return 0;
    }
    return lp->items[lp->length - 1];
}


void *ejsGetNextItem(EjsList *lp, int *next)
{
    void    *item;
    int     index;

    mprAssert(next);
    mprAssert(*next >= 0);

    if (lp == 0) {
        return 0;
    }
    index = *next;
    if (index < lp->length) {
        item = lp->items[index];
        *next = ++index;
        return item;
    }
    return 0;
}


int ejsGetListCount(EjsList *lp)
{
    if (lp == 0) {
        return 0;
    }

    return lp->length;
}


void *ejsGetPrevItem(EjsList *lp, int *next)
{
    int     index;

    mprAssert(next);

    if (lp == 0) {
        return 0;
    }
    if (*next < 0) {
        *next = lp->length;
    }
    index = *next;
    if (--index < lp->length && index >= 0) {
        *next = index;
        return lp->items[index];
    }
    return 0;
}


int ejsRemoveLastItem(EjsList *lp)
{
    mprAssert(lp);
    mprAssert(lp->length > 0);

    if (lp->length <= 0) {
        return MPR_ERR_NOT_FOUND;
    }
    return ejsRemoveItemAtPos(lp, lp->length - 1);
}


/*
    Remove an index from the list. Return the index where the item resided.
 */
int ejsRemoveItemAtPos(EjsList *lp, int index)
{
    void    **items;
    int     i;

    mprAssert(lp);
    mprAssert(index >= 0);
    mprAssert(lp->length > 0);

    if (index < 0 || index >= lp->length) {
        return MPR_ERR_NOT_FOUND;
    }
    items = lp->items;
    for (i = index; i < (lp->length - 1); i++) {
        items[i] = items[i + 1];
    }
    lp->length--;
    lp->items[lp->length] = 0;
    return index;
}


/*
    Grow the list by the requried increment
 */
static int growList(MprCtx ctx, EjsList *lp, int incr)
{
    int     len, memsize, capacity;

    /*
     *  Need to grow the list
     */
    capacity = CAPACITY(lp->items);
    mprAssert(capacity >= 0);
    
    if (capacity >= lp->maxSize) {
        if (lp->maxSize == 0) {
            lp->maxSize = INT_MAX;
        } else {
            mprAssert(capacity < lp->maxSize);
            return MPR_ERR_TOO_MANY;
        }
    }

    /*
     *  If growing by 1, then use the default increment which exponentially grows.
     *  Otherwise, assume the caller knows exactly how the list needs to grow.
     */
    if (incr <= 1) {
        len = MPR_LIST_INCR + capacity + capacity;
    } else {
        len = capacity + incr;
    }
    memsize = len * sizeof(void*);

    /*
        Grow the list of items. Use the existing context for lp->items if it already exists. Otherwise use the list as the
        memory context owner.
     */
    lp->items = (void**) mprRealloc(ctx, lp->items, memsize);

    /*
     *  Zero the new portion (required for no-compact lists)
     */
    memset(&lp->items[capacity], 0, sizeof(void*) * (len - capacity));
    return 0;
}


int ejsLookupItem(EjsList *lp, cvoid *item)
{
    int     i;

    mprAssert(lp);
    
    for (i = 0; i < lp->length; i++) {
        if (lp->items[i] == item) {
            return i;
        }
    }
    return MPR_ERR_NOT_FOUND;
}


#if KEEP
/*
    Change the item in the list at index. Return the old item.
 */
void *ejsSetItem(MprCtx ctx, EjsList *lp, int index, cvoid *item)
{
    void    *old;

    mprAssert(lp);
    mprAssert(lp->length >= 0);

    if (index >= lp->length) {
        lp->length = index + 1;
    }
    capacity = CAPACITY(lp->items);
    if (lp->length > capacity) {
        if (growList(ctx, lp, lp->length - capacity) < 0) {
            return 0;
        }
    }
    old = lp->items[index];
    lp->items[index] = (void*) item;
    return old;
}


/*
    Insert an item to the list at a specified position. We insert before "index".
 */
int ejsInsertItemAtPos(MprCtx ctx, EjsList *lp, int index, cvoid *item)
{
    void    **items;
    int     i;

    mprAssert(lp);
    mprAssert(lp->length >= 0);

    if (lp->length >= CAPACITY(lp->items)) {
        if (growList(ctx, lp, 1) < 0) {
            return MPR_ERR_TOO_MANY;
        }
    }

    /*
     *  Copy up items to make room to insert
     */
    items = lp->items;
    for (i = lp->length; i > index; i--) {
        items[i] = items[i - 1];
    }
    lp->items[index] = (void*) item;
    lp->length++;
    return index;
}


/*
    Remove an item from the list. Return the index where the item resided.
 */
int ejsRemoveItem(MprCtx ctx, EjsList *lp, void *item)
{
    int     index;

    mprAssert(lp);
    mprAssert(lp->length > 0);

    index = ejsLookupItem(lp, item);
    if (index < 0) {
        return index;
    }
    return ejsRemoveItemAtPos(ctx, lp, index);
}


/*
    Remove a set of items. Return 0 if successful.
 */
int ejsRemoveRangeOfItems(EjsList *lp, int start, int end)
{
    void    **items;
    int     i, count, capacity;

    mprAssert(lp);
    mprAssert(lp->length > 0);
    mprAssert(start > end);

    if (start < 0 || start >= lp->length) {
        return MPR_ERR_NOT_FOUND;
    }
    if (end < 0 || end >= lp->length) {
        return MPR_ERR_NOT_FOUND;
    }
    if (start > end) {
        return MPR_ERR_BAD_ARGS;
    }

    /*
     *  Copy down to coejsess
     */
    items = lp->items;
    count = end - start;
    for (i = start; i < (lp->length - count); i++) {
        items[i] = items[i + count];
    }
    lp->length -= count;
    capacity = CAPACITY(lp->items);
    for (i = lp->length; i < capacity; i++) {
        items[i] = 0;
    }
    return 0;
}


void *ejsGetFirstItem(EjsList *lp)
{
    mprAssert(lp);

    if (lp == 0) {
        return 0;
    }
    if (lp->length == 0) {
        return 0;
    }
    return lp->items[0];
}


int ejsGetListCapacity(EjsList *lp)
{
    mprAssert(lp);

    if (lp == 0) {
        return 0;
    }
    return CAPACITY(lp->items);
}

#endif

/*
    @copy   default
    
    Copyright (c) Embedthis Software LLC, 2003-2010. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2010. All Rights Reserved.
    
    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire 
    a commercial license from Embedthis Software. You agree to be fully bound 
    by the terms of either license. Consult the LICENSE.TXT distributed with 
    this software for full details.
    
    This software is open source; you can redistribute it and/or modify it 
    under the terms of the GNU General Public License as published by the 
    Free Software Foundation; either version 2 of the License, or (at your 
    option) any later version. See the GNU General Public License for more 
    details at: http://www.embedthis.com/downloads/gplLicense.html
    
    This program is distributed WITHOUT ANY WARRANTY; without even the 
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
    
    This GPL license does NOT permit incorporating this software into 
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses 
    for this software and support services are available from Embedthis 
    Software at http://www.embedthis.com 
    
    @end
 */
/************************************************************************/
/*
 *  End of file "../src/vm/ejsList.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../src/vm/ejsLoader.c"
 */
/************************************************************************/

/**
    ejsLoader.c - Ejscript module file file loader

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */




static int  addFixup(Ejs *ejs, int kind, EjsObj *target, int slotNum, EjsTypeFixup *fixup);
static int  alreadyLoaded(Ejs *ejs, cchar *name, int minVersion, int maxVersion);
static void createLoadState(Ejs *ejs, int flags);
static EjsTypeFixup *createFixup(Ejs *ejs, EjsName *qname, int slotNum);
static int  fixupTypes(Ejs *ejs, MprList *list);
static EjsObj *getCurrentBlock(Ejs *ejs, EjsModule *mp);
static int  getVersion(cchar *name);
static int  initializeModule(Ejs *ejs, EjsModule *mp, cchar *path);
static int  loadBlockSection(Ejs *ejs, MprFile *file, EjsModule *mp);
static int  loadClassSection(Ejs *ejs, MprFile *file, EjsModule *mp);
static int  loadDependencySection(Ejs *ejs, MprFile *file, EjsModule *mp);
static int  loadEndBlockSection(Ejs *ejs, MprFile *file, EjsModule *mp);
static int  loadEndFunctionSection(Ejs *ejs, MprFile *file, EjsModule *mp);
static int  loadEndClassSection(Ejs *ejs, MprFile *file, EjsModule *mp);
static int  loadEndModuleSection(Ejs *ejs, MprFile *file, EjsModule *mp);
static int  loadExceptionSection(Ejs *ejs, MprFile *file, EjsModule *mp);
static int  loadFunctionSection(Ejs *ejs, MprFile *file, EjsModule *mp);
static int  loadModFile(Ejs *ejs, cchar *filename, int minVersion, int maxVersion, int flags);
static EjsModule *loadModuleSection(Ejs *ejs, MprFile *file, EjsModuleHdr *hdr, int *created, int flags);
static int  loadSections(Ejs *ejs, MprFile *file, cchar *path, EjsModuleHdr *hdr, int flags);
static int  loadPropertySection(Ejs *ejs, MprFile *file, EjsModule *mp, int sectionType);
static int  loadScriptModule(Ejs *ejs, MprFile *file, cchar *path, int flags);
static char *makeModuleName(MprCtx ctx, cchar *name);
static int  readNumber(Ejs *ejs, MprFile *file, int *number);
static int  readWord(Ejs *ejs, MprFile *file, int *number);
static char *search(Ejs *ejs, cchar *filename, int minVersion, int maxVersion);
static int  swapShort(Ejs *ejs, int word);
static int  swapWord(Ejs *ejs, int word);
static char *tokenToString(EjsModule *mp, int   token);
static int  trimModule(Ejs *ejs, char *name);

#if !BLD_FEATURE_STATIC
static int  loadNativeLibrary(Ejs *ejs, EjsModule *mp, cchar *path);
#endif

static int  loadDocSection(Ejs *ejs, MprFile *file, EjsModule *mp);
static void setDoc(Ejs *ejs, EjsModule *mp, EjsObj *block, int slotNum);

/**
    Load a module file and return a list of the loaded modules. This is used to load scripted module files with
    optional native (shared / DLL) implementations. If loading a scripted module that has native declarations, a
    search for the corresponding native DLL will be performed and both scripted and native module files will be loaded.
    NOTE: this may recursively call itself as it loads dependent modules.

    @param ejs Ejs handle
    @param path Module name or path to load. May be "." separated path. May include or omit the ".mod" extension.
    @param minVersion Minimum acceptable version (inclusive). Set to zero for unversioned.
    @param maxVersion Maximum acceptable version (inclusive). Set to -1 for all versions.
    @param flags Reserved. Must be set to zero.
    @param modulesArg List of modules loaded. Will only return a list if successful and doing a top level load. 
        When ejsLoadModule is called to load dependant modules, not list of modules will be returned.
        The final list of modules aggregates all modules loaded including those from dependant modules.
    @return Returns the last loaded module.
 */
int ejsLoadModule(Ejs *ejs, cchar *path, int minVersion, int maxVersion, int flags)
{
    EjsModule       *mp;
    char            *trimmedPath, *name;
    int             nextModule, next, status, version;

    mprAssert(path && *path);

    trimmedPath = mprStrdup(ejs, path);
    if ((version = trimModule(ejs, trimmedPath)) != 0) {
        minVersion = maxVersion = version;
    }
    name = mprGetPathBase(ejs, trimmedPath);
    nextModule = mprGetListCount(ejs->modules);

    if ((status = alreadyLoaded(ejs, name, minVersion, maxVersion)) == 0) {
        createLoadState(ejs, flags);
        if (strcmp(name, "ejs") == 0) {
            flags |= EJS_LOADER_BUILTIN;
        }
        if ((status = loadModFile(ejs, trimmedPath, minVersion, maxVersion, flags)) == 0) {
            /*
                Do fixups and run initializers when all dependent modules are loaded. Solves forward ref problem.
             */
            if (fixupTypes(ejs, ejs->loadState->typeFixups) == 0) {
                //  MOB rationalize down to just ejs flag
                if (!ejs->empty && !(flags & EJS_LOADER_NO_INIT) && !(ejs->flags & EJS_FLAG_NO_INIT)) {
                    for (next = nextModule; (mp = mprGetNextItem(ejs->modules, &next)) != 0; ) {
                        if ((status = initializeModule(ejs, mp, mp->path)) < 0) {
                            break;
                        }
                    }
                }
            }
        }
        mprFree(ejs->loadState);
        ejs->loadState = 0;
    }
    mprFree(trimmedPath);
    mprFree(name);
    return status;
}


static int loadModFile(Ejs *ejs, cchar *filename, int minVersion, int maxVersion, int flags)
{
    MprFile         *file;
    char            *path;
    int             status;

    mprAssert(filename && *filename);

    if ((path = search(ejs, filename, minVersion, maxVersion)) == 0) {
        return MPR_ERR_CANT_ACCESS;
    }
    if ((file = mprOpen(ejs, path, O_RDONLY | O_BINARY, 0666)) != NULL) {
        mprLog(ejs, 4, "Loading module %s", path);
        mprEnableFileBuffering(file, 0, 0);
        status = loadScriptModule(ejs, file, path, flags);
        mprFree(file);
    } else {
        ejsThrowIOError(ejs, "Can't open module file %s", path);
        status = MPR_ERR_CANT_OPEN;
    }
    mprFree(path);
    return status;
}


static int initializeModule(Ejs *ejs, EjsModule *mp, cchar *path)
{
    EjsNativeModule     *nativeModule;
    int                 priorGen;

    priorGen = 0;

    if (mp->hasNative && !mp->configured) {
        /*
            See if a native module initialization routine has been registered. If so, use that. Otherwise, look
            for a backing DSO.
         */
        if ((nativeModule = ejsLookupNativeModule(ejs, mp->name)) == 0) {
#if !BLD_FEATURE_STATIC
            if (loadNativeLibrary(ejs, mp, path) < 0) {
                if (ejs->exception == 0) {
                    ejsThrowIOError(ejs, "Can't load the native module file \"%s\"", path);
                }
                return MPR_ERR_CANT_INITIALIZE;
            }
            nativeModule = ejsLookupNativeModule(ejs, mp->name);
#endif
            if (!(ejs->flags & EJS_FLAG_NO_INIT)) {
                if (nativeModule->checksum != mp->checksum) {
                    ejsThrowIOError(ejs, "Module \"%s\" does not match native code (%d, %d)", path, nativeModule->checksum, 
                        mp->checksum);
                    return MPR_ERR_BAD_STATE;
                }
            }
        }
        if (nativeModule->flags & EJS_LOADER_ETERNAL) {
            priorGen = ejsSetGeneration(ejs, EJS_GEN_ETERNAL);
        }
        if (nativeModule && (nativeModule->callback)(ejs) < 0) {
            return MPR_ERR_CANT_INITIALIZE;
        }
        if (nativeModule->flags & EJS_LOADER_ETERNAL) {
            ejsSetGeneration(ejs, priorGen);
        }
        if (ejs->hasError || ejs->errorType == 0 || mprHasAllocError(ejs)) {
            if (!ejs->exception) {
                ejsThrowIOError(ejs, "Initialization error for %s (%d, %d)", path, ejs->hasError, mprHasAllocError(ejs));
            }
            return MPR_ERR;
        }
    }
    mp->configured = 1;
    if (ejsRunInitializer(ejs, mp) == 0) {
        return MPR_ERR_CANT_INITIALIZE;
    }
    return 0;
}


static char *search(Ejs *ejs, cchar *filename, int minVersion, int maxVersion) 
{
    char        *path;

    mprAssert(filename && *filename);

    if ((path = ejsSearchForModule(ejs, filename, minVersion, maxVersion)) == 0) {
        mprLog(ejs, 2, "Can't find module file \"%s.mod\"", filename);
        if (minVersion < 0 || maxVersion < 0) {
            ejsThrowReferenceError(ejs,  "Can't find module file \"%s\"", filename);
        } else {
            ejsThrowReferenceError(ejs,  "Can't find module file \"%s\", min version %d.%d.%d, max version %d.%d.%d", 
                filename, 
                EJS_MAJOR(minVersion), EJS_MINOR(minVersion), EJS_PATCH(minVersion),
                EJS_MAJOR(maxVersion), EJS_MINOR(maxVersion), EJS_PATCH(maxVersion));
        }
        return 0;
    }
    return path;
}


/*
    Load the sections: classes, properties and functions. Return the first module loaded in pup.
 */
static int loadSections(Ejs *ejs, MprFile *file, cchar *path, EjsModuleHdr *hdr, int flags)
{
    EjsModule   *mp;
    int         rc, sectionType, created;

    created = 0;
    mp = 0;

    while ((sectionType = mprGetc(file)) >= 0) {
        if (sectionType < 0 || sectionType >= EJS_SECT_MAX) {
            mprError(ejs, "Bad section type %d in %s", sectionType, mp->name);
            return EJS_ERR;
        }
        mprLog(ejs, 9, "Load section type %d", sectionType);

        rc = 0;
        switch (sectionType) {

        case EJS_SECT_BLOCK:
            rc = loadBlockSection(ejs, file, mp);
            break;

        case EJS_SECT_BLOCK_END:
            rc = loadEndBlockSection(ejs, file, mp);
            break;

        case EJS_SECT_CLASS:
            rc = loadClassSection(ejs, file, mp);
            break;

        case EJS_SECT_CLASS_END:
            rc = loadEndClassSection(ejs, file, mp);
            break;

        case EJS_SECT_DEPENDENCY:
            rc = loadDependencySection(ejs, file, mp);
            /*  Update the first free global (dependencies come before types, methods and properties of all kinds) */
            mp->firstGlobal = ejsGetPropertyCount(ejs, ejs->global);
            break;

        case EJS_SECT_EXCEPTION:
            rc = loadExceptionSection(ejs, file, mp);
            break;

        case EJS_SECT_FUNCTION:
            rc = loadFunctionSection(ejs, file, mp);
            break;

        case EJS_SECT_FUNCTION_END:
            rc = loadEndFunctionSection(ejs, file, mp);
            break;

        case EJS_SECT_MODULE:
            if ((mp = loadModuleSection(ejs, file, hdr, &created, flags)) != 0) {
                ejsAddModule(ejs, mp);
                mp->path = mprStrdup(mp, path);
            }
            mp->firstGlobal = (ejs->initialized) ? ejsGetPropertyCount(ejs, ejs->global) : 0;
            break;

        case EJS_SECT_MODULE_END:
            rc = loadEndModuleSection(ejs, file, mp);
            mp->lastGlobal = ejsGetPropertyCount(ejs, ejs->global);
            break;

        case EJS_SECT_PROPERTY:
            rc = loadPropertySection(ejs, file, mp, sectionType);
            break;

        case EJS_SECT_DOC:
            rc = loadDocSection(ejs, file, mp);
            break;

        default:
            mprAssert(0);
            return EJS_ERR;
        }
        if (rc < 0) {
            if (mp && mp->name && created) {
                ejsRemoveModule(ejs, mp);
                mprFree(mp);
            }
            return rc;
        }
    }
    return 0;
}


/*
    Load a module section and constant pool.
 */
static EjsModule *loadModuleSection(Ejs *ejs, MprFile *file, EjsModuleHdr *hdr, int *created, int flags)
{
    EjsModule   *mp;
    char        *pool, *name;
    int         rc, version, checksum, poolSize, nameToken;

    mprAssert(created);

    *created = 0;
    checksum = 0;

    /*
        We don't have the constant pool yet so we cant resolve the name yet.
     */
    rc = 0;
    rc += readNumber(ejs, file, &nameToken);
    rc += readNumber(ejs, file, &version);
    rc += readWord(ejs, file, &checksum);
    rc += readNumber(ejs, file, &poolSize);
    if (rc < 0 || poolSize <= 0 || poolSize > EJS_MAX_POOL) {
        return 0;
    }

    /*
        Read the string constant pool. The pool calls Steal when the module is created.
     */
    pool = (char*) mprAlloc(file, poolSize);
    if (pool == 0) {
        return 0;
    }
    if (mprRead(file, pool, poolSize) != poolSize) {
        mprFree(pool);
        return 0;
    }

    /*
        Convert module token into a name
     */
    if (nameToken < 0 || nameToken >= poolSize) {
        mprAssert(0);
        return 0;
    }
    name = &pool[nameToken];
    if (name == 0) {
        mprAssert(name);
        mprFree(pool);
        return 0;
    }

    mp = ejsCreateModule(ejs, name, version);
    if (mp == 0) {
        mprFree(pool);
        return 0;
    }
    ejsSetModuleConstants(ejs, mp, pool, poolSize);
    mp->scopeChain = ejs->globalBlock;
    mp->checksum = checksum;
    *created = 1;

    if (strcmp(name, EJS_DEFAULT_MODULE) != 0) {
        /*
            Signify that loading the module has begun. We allow multiple loads into the default module.
         */
        mp->loaded = 1;
        mp->constants->locked = 1;
    }
    mp->file = file;
    mp->flags = flags;

    if (ejs->loaderCallback) {
        (ejs->loaderCallback)(ejs, EJS_SECT_MODULE, mp);
    }
    mprLog(ejs, 9, "Load module section %s", name);
    return mp;
}


static int loadEndModuleSection(Ejs *ejs, MprFile *file, EjsModule *mp)
{
    mprLog(ejs, 9, "End module section %s", mp->name);

    if (ejs->loaderCallback) {
        (ejs->loaderCallback)(ejs, EJS_SECT_MODULE_END, mp);
    }
    return 0;
}


static int loadDependencySection(Ejs *ejs, MprFile *file, EjsModule *mp)
{
    EjsModule   *module;
    void        *saveCallback;
    char        *name;
    int         rc, next, minVersion, maxVersion, checksum, nextModule;

    mprAssert(ejs);
    mprAssert(file);
    mprAssert(mp);

    name = ejsModuleReadString(ejs, mp);
    ejsModuleReadNumber(ejs, mp, &checksum);
    ejsModuleReadNumber(ejs, mp, &minVersion);
    ejsModuleReadNumber(ejs, mp, &maxVersion);
    
    if (mp->hasError) {
        return MPR_ERR_CANT_READ;
    }
    if (ejsLookupModule(ejs, name, minVersion, maxVersion) != 0) {
        return 0;
    }
    saveCallback = ejs->loaderCallback;
    //  TODO - was ejs->loadState->modules
    nextModule = mprGetListCount(ejs->modules);
    ejs->loaderCallback = NULL;

    mprLog(ejs, 5, "    Load dependency section %s", name);
    rc = loadModFile(ejs, name, minVersion, maxVersion, mp->flags | EJS_LOADER_DEP);
    ejs->loaderCallback = saveCallback;
    if (rc < 0) {
        return rc;
    }
    if ((module = ejsLookupModule(ejs, name, minVersion, maxVersion)) != 0) {
        if (checksum != module->checksum) {
            ejsThrowIOError(ejs, "Can't load module %s.\n"
                "It was compiled using a different version of module %s.", 
                mp->name, name);
            return MPR_ERR_BAD_STATE;
        }
    }

    if (mp->dependencies == 0) {
        mp->dependencies = mprCreateList(mp);
    }
    for (next = nextModule; (module = mprGetNextItem(ejs->modules, &next)) != 0; ) {
        mprAddItem(mp->dependencies, module);
        if (ejs->loaderCallback) {
            (ejs->loaderCallback)(ejs, EJS_SECT_DEPENDENCY, mp, module);
        }
    }
    return 0;
}


static int loadBlockSection(Ejs *ejs, MprFile *file, EjsModule *mp)
{
    EjsBlock    *bp;
    EjsObj      *current;
    EjsName     qname;
    int         slotNum, numSlot;

    qname.space = EJS_BLOCK_NAMESPACE;
    qname.name = ejsModuleReadString(ejs, mp);
    ejsModuleReadNumber(ejs, mp, &slotNum);
    ejsModuleReadNumber(ejs, mp, &numSlot);

    if (mp->hasError) {
        return MPR_ERR_CANT_READ;
    }
    bp = ejsCreateBlock(ejs, numSlot);
    ejsSetDebugName(bp, qname.name);
    current = getCurrentBlock(ejs, mp);

    /*
        TODO - replace this strict mode with dont-delete on a per property basis. Redefinition is then okay if the
        property to be replaced is !dont-delete
     */
    if (ejs->loadState->flags & EJS_LOADER_STRICT) {
        if (ejsLookupProperty(ejs, current, &qname) >= 0) {
            ejsThrowReferenceError(ejs, "Block \"%s\" already loaded", qname.name);
            return MPR_ERR_CANT_CREATE;
        }
    }
    slotNum = ejsDefineProperty(ejs, current, slotNum, &qname, ejs->blockType, 0, (EjsObj*) bp);
    if (slotNum < 0) {
        return MPR_ERR_CANT_WRITE;
    }
    if (ejs->loaderCallback) {
        (ejs->loaderCallback)(ejs, EJS_SECT_BLOCK, mp, current, slotNum, qname.name, numSlot, bp);
    }
    bp->scopeChain = mp->scopeChain;
    mp->scopeChain = bp;
    return 0;
}


static int loadEndBlockSection(Ejs *ejs, MprFile *file, EjsModule *mp)
{
    mprLog(ejs, 9, "    End block section %s", mp->name);

    if (ejs->loaderCallback) {
        (ejs->loaderCallback)(ejs, EJS_SECT_BLOCK_END, mp);
    }
    mp->scopeChain = mp->scopeChain->scopeChain;
    return 0;
}


static int loadClassSection(Ejs *ejs, MprFile *file, EjsModule *mp)
{
    EjsType         *type, *baseType, *iface, *nativeType;
    EjsTypeFixup    *fixup, *ifixup;
    EjsName         qname, baseClassName, ifaceClassName;
    EjsBlock        *block;
    int             attributes, numTypeProp, numInstanceProp, slotNum, numInterfaces, i;

    fixup = 0;
    ifixup = 0;
    
    qname.name = ejsModuleReadString(ejs, mp);
    qname.space = ejsModuleReadString(ejs, mp);

    ejsModuleReadNumber(ejs, mp, &attributes);
    ejsModuleReadNumber(ejs, mp, &slotNum);
    ejsModuleReadType(ejs, mp, &baseType, &fixup, &baseClassName, 0);
    ejsModuleReadNumber(ejs, mp, &numTypeProp);
    ejsModuleReadNumber(ejs, mp, &numInstanceProp);
    ejsModuleReadNumber(ejs, mp, &numInterfaces);

    if (mp->hasError) {
        return MPR_ERR_CANT_READ;
    }
    if (ejs->loadState->flags & EJS_LOADER_STRICT) {
        if (ejsLookupProperty(ejs, ejs->global, &qname) >= 0) {
            ejsThrowReferenceError(ejs, "Class \"%s\" already loaded", qname.name);
            return MPR_ERR_CANT_CREATE;
        }
    }
    if (fixup || (baseType && baseType->needFixup)) {
        attributes |= EJS_TYPE_FIXUP;
    }
    type = nativeType = 0;
    if (!ejs->empty) {
        /*
            Find pre-existing native types.
         */
        if (attributes & EJS_PROP_NATIVE) {
            type = nativeType = (EjsType*) mprLookupHash(ejs->coreTypes, qname.name);
            if (type == 0) {
                mprLog(ejs, 1, "WARNING: can't find native type \"%s\"", qname.name);
            }
        } else {
    #if BLD_DEBUG
            if (mprLookupHash(ejs->coreTypes, qname.name)) {
                mprError(ejs, "WARNING: type \"%s\" defined as a native type but not declared as native", qname.name);
            }
    #endif
        }
    }
    if (attributes & EJS_TYPE_FIXUP) {
        baseType = 0;
        if (fixup == 0) {
            fixup = createFixup(ejs, (baseType) ? &baseType->qname : &ejs->objectType->qname, -1);
        }
    }
    mprLog(ejs, 9, "    Load %s class %s for module %s at slot %d", qname.space, qname.name, mp->name, slotNum);

    if (slotNum < 0) {
        slotNum = ejs->globalBlock->obj.numSlots;
    }
    if (type == 0) {
        type = ejsCreateType(ejs, &qname, mp, baseType, sizeof(EjsObj), slotNum, numTypeProp, numInstanceProp, attributes,0);
        if (type == 0) {
            ejsThrowInternalError(ejs, "Can't create class %s", qname.name);
            return MPR_ERR_BAD_STATE;
        }

    } else {
        if (ejsConfigureType(ejs, type, mp, baseType, numTypeProp, numInstanceProp, attributes) < 0) {
            ejsThrowInternalError(ejs, "Can't configure class %s", qname.name);
            return MPR_ERR_BAD_STATE;
        }
        mp->hasNative = 1;
#if FUTURE
        /*
            Currently errors on Namespace
         */
        if (attributes & EJS_TYPE_HAS_CONSTRUCTOR && !type->hasConstructor) {
            mprError(ejs, "WARNING: module indicates a constructor required but none exists for \"%s\"", type->qname.name);
        }
#endif
#if UNUSED && KEEP
        if (!type->native) {
            mprError(ejs, "WARNING: type not defined as native: \"%s\"", type->qname.name);
        }
#endif
    }
    mprAssert(type->helpers);
    
    /*
        Read implemented interfaces. Add to type->implements. Create fixup record if the interface type is not yet known.
     */
    if (numInterfaces > 0) {
        type->implements = mprCreateList(type);
        for (i = 0; i < numInterfaces; i++) {
            if (ejsModuleReadType(ejs, mp, &iface, &ifixup, &ifaceClassName, 0) < 0) {
                return MPR_ERR_CANT_READ;
            }
            if (iface) {
                mprAddItem(type->implements, iface);
            } else {
                if (addFixup(ejs, EJS_FIXUP_INTERFACE_TYPE, (EjsObj*) type, -1, ifixup) < 0) {
                    ejsThrowMemoryError(ejs);
                    return MPR_ERR_NO_MEMORY;
                }
            }
        }
    }
    if (mp->flags & EJS_LOADER_BUILTIN) {
        type->block.obj.builtin = 1;
    }
    if (attributes & EJS_TYPE_HAS_STATIC_INITIALIZER) {
        type->hasStaticInitializer = 1;
    }
    if (attributes & EJS_TYPE_DYNAMIC_INSTANCE) {
        type->dynamicInstance = 1;
    }
    slotNum = ejsDefineProperty(ejs, ejs->global, slotNum, &qname, ejs->typeType, attributes, (EjsObj*) type);
    if (slotNum < 0) {
        ejsThrowMemoryError(ejs);
        return MPR_ERR_NO_MEMORY;
    }
    type->module = mp;

    if (fixup) {
        if (addFixup(ejs, EJS_FIXUP_BASE_TYPE, (EjsObj*) type, -1, fixup) < 0) {
            ejsThrowMemoryError(ejs);
            return MPR_ERR_NO_MEMORY;
        }
    }
    setDoc(ejs, mp, ejs->global, slotNum);

    block = (EjsBlock*) type;
    block->scopeChain = mp->scopeChain;
    mp->scopeChain = block;

    if (ejs->loaderCallback) {
        (ejs->loaderCallback)(ejs, EJS_SECT_CLASS, mp, slotNum, qname, type, attributes);
    }
    return 0;
}


static int loadEndClassSection(Ejs *ejs, MprFile *file, EjsModule *mp)
{
    EjsType     *type;

    mprLog(ejs, 9, "    End class section");

    if (ejs->loaderCallback) {
        (ejs->loaderCallback)(ejs, EJS_SECT_CLASS_END, mp, mp->scopeChain);
    }
    type = (EjsType*) mp->scopeChain;
    if (type->block.obj.hasScriptFunctions && type->baseType) {
        ejsDefineTypeNamespaces(ejs, type);
    }
    mp->scopeChain = mp->scopeChain->scopeChain;
    return 0;
}


static int loadFunctionSection(Ejs *ejs, MprFile *file, EjsModule *mp)
{
    EjsType         *returnType;
    EjsTypeFixup    *fixup;
    EjsFunction     *fun;
    EjsName         qname, returnTypeName;
    EjsObj          *current;
    uchar           *code;
    int             slotNum, numSlots, numArgs, numDefault, codeLen, numExceptions, attributes, strict, sn;

    strict = 0;
    qname.name = ejsModuleReadString(ejs, mp);
    qname.space = ejsModuleReadString(ejs, mp);

    ejsModuleReadNumber(ejs, mp, &attributes);
    ejsModuleReadByte(ejs, mp, &strict);
 
    ejsModuleReadType(ejs, mp, &returnType, &fixup, &returnTypeName, 0);
    ejsModuleReadNumber(ejs, mp, &slotNum);
    ejsModuleReadNumber(ejs, mp, &numSlots);
    ejsModuleReadNumber(ejs, mp, &numArgs);
    ejsModuleReadNumber(ejs, mp, &numDefault);
    ejsModuleReadNumber(ejs, mp, &numExceptions);
    ejsModuleReadNumber(ejs, mp, &codeLen);

    if (mp->hasError) {
        return MPR_ERR_CANT_READ;
    }
    current = getCurrentBlock(ejs, mp);

    mprAssert(current);
    mprAssert(numArgs >= 0 && numArgs < EJS_MAX_ARGS);
    mprAssert(numExceptions >= 0 && numExceptions < EJS_MAX_EXCEPTIONS);

    mprLog(ejs, 9, "Loading function %s:%s at slot %d", qname.space, qname.name, slotNum);

    /*
        Read the code. We pass ownership of the code to createMethod i.e. don't free.
     */
    if (codeLen > 0) {
        code = (uchar*) mprAlloc(ejsGetAllocCtx(ejs), codeLen);
        if (code == 0) {
            return MPR_ERR_NO_MEMORY;
        }
        if (mprRead(file, code, codeLen) != codeLen) {
            mprFree(code);
            return MPR_ERR_CANT_READ;
        }
        current->hasScriptFunctions = 1;
    } else {
        code = 0;
    }
    if (attributes & EJS_PROP_NATIVE) {
        mp->hasNative = 1;
    }
    if (attributes & EJS_FUN_INITIALIZER) {
        mp->hasInitializer = 1;
    }
    if (ejs->loadState->flags & EJS_LOADER_STRICT) {
        if ((sn = ejsLookupProperty(ejs, current, &qname)) >= 0 && !(attributes & EJS_FUN_OVERRIDE)) {
            if (!(attributes & EJS_TRAIT_SETTER && ejsHasTrait(current, sn, EJS_TRAIT_GETTER))) {
                if (ejsIsType(current)) {
                    ejsThrowReferenceError(ejs,
                        "function \"%s\" already defined in type \"%s\". Add \"override\" to the function declaration.", 
                        qname.name, ((EjsType*) current)->qname.name);
                } else {
                    ejsThrowReferenceError(ejs,
                        "function \"%s\" already defined. Try adding \"override\" to the function declaration.", qname.name);
                }
                return MPR_ERR_CANT_CREATE;
            }
        }
    }

    /*
        Create the function using the current scope chain. Non-methods revise this scope chain via 
        the DefineFunction op code.
     */
    fun = ejsCreateFunction(ejs, code, codeLen, numArgs, numDefault, numExceptions, returnType, attributes, mp->constants, 
        mp->scopeChain, strict);
    if (fun == 0) {
        mprFree(code);
        return MPR_ERR_NO_MEMORY;
    }
    if (mp->flags & EJS_LOADER_BUILTIN) {
        fun->block.obj.builtin = 1;
    }
    if (code) {
        mprStealBlock(fun, code);
    }
    ejsSetDebugName(fun, qname.name);

    if (numSlots > 0) {
        fun->activation = ejsCreateActivation(ejs, fun, numSlots);
    }

    if (current == ejs->global && slotNum < 0) {
        if (attributes & EJS_FUN_OVERRIDE) {
            slotNum = ejsLookupProperty(ejs, current, &qname);
            if (slotNum < 0) {
                mprError(ejs, "Can't find method \"%s\" to override", qname.name);
                return MPR_ERR_NO_MEMORY;
            }

        } else {
            slotNum = -1;
        }
    }
    if (attributes & EJS_FUN_INITIALIZER && current == ejs->global) {
        mp->initializer = fun;
        slotNum = -1;
    } else {
        slotNum = ejsDefineProperty(ejs, current, slotNum, &qname, ejs->functionType, attributes, (EjsObj*) fun);
        if (slotNum < 0) {
            return MPR_ERR_NO_MEMORY;
        }
    }
    if (fixup) {
        mprAssert(returnType == 0);
        if (addFixup(ejs, EJS_FIXUP_RETURN_TYPE, (EjsObj*) fun, -1, fixup) < 0) {
            ejsThrowMemoryError(ejs);
            return MPR_ERR_NO_MEMORY;
        }
    }
    setDoc(ejs, mp, current, slotNum);

    mp->currentMethod = fun;
    fun->block.scopeChain = mp->scopeChain;
    mp->scopeChain = (EjsBlock*) fun;

    if (ejs->loaderCallback) {
        (ejs->loaderCallback)(ejs, EJS_SECT_FUNCTION, mp, current, slotNum, qname, fun, attributes);
    }
    return 0;
}


static int loadEndFunctionSection(Ejs *ejs, MprFile *file, EjsModule *mp)
{
    EjsFunction         *fun;

    mprLog(ejs, 9, "    End function section");

    fun = (EjsFunction*) mp->scopeChain;
    if (ejs->loaderCallback) {
        (ejs->loaderCallback)(ejs, EJS_SECT_FUNCTION_END, mp, fun);
    }
    mp->scopeChain = mp->scopeChain->scopeChain;
    return 0;
}


static int loadExceptionSection(Ejs *ejs, MprFile *file, EjsModule *mp)
{
    EjsFunction         *fun;
    EjsType             *catchType;
    EjsTypeFixup        *fixup;
    EjsCode             *code;
    EjsEx               *ex;
    int                 tryStart, tryEnd, handlerStart, handlerEnd, numBlocks, numStack, flags, i;

    fun = mp->currentMethod;
    mprAssert(fun);

    flags = 0;
    code = &fun->body.code;

    for (i = 0; i < code->numHandlers; i++) {
        ejsModuleReadByte(ejs, mp, &flags);
        ejsModuleReadNumber(ejs, mp, &tryStart);
        ejsModuleReadNumber(ejs, mp, &tryEnd);
        ejsModuleReadNumber(ejs, mp, &handlerStart);
        ejsModuleReadNumber(ejs, mp, &handlerEnd);
        ejsModuleReadNumber(ejs, mp, &numBlocks);
        ejsModuleReadNumber(ejs, mp, &numStack);
        ejsModuleReadType(ejs, mp, &catchType, &fixup, 0, 0);
        if (mp->hasError) {
            return MPR_ERR_CANT_READ;
        }
        ex = ejsAddException(fun, tryStart, tryEnd, catchType, handlerStart, handlerEnd, numBlocks, numStack, flags, i);
        if (fixup) {
            mprAssert(catchType == 0);
            if (addFixup(ejs, EJS_FIXUP_EXCEPTION, (EjsObj*) ex, 0, fixup) < 0) {
                mprAssert(0);
                return MPR_ERR_NO_MEMORY;
            }
        }
    }
    if (ejs->loaderCallback) {
        (ejs->loaderCallback)(ejs, EJS_SECT_EXCEPTION, mp, fun);
    }
    return 0;
}

/*
    Define a global, class or block property. Not used for function locals or args.
 */
static int loadPropertySection(Ejs *ejs, MprFile *file, EjsModule *mp, int sectionType)
{
    EjsType         *type;
    EjsTypeFixup    *fixup;
    EjsName         qname, propTypeName;
    EjsObj          *current, *value;
    cchar           *str;
    int             slotNum, attributes, fixupKind;

    value = 0;
    current = getCurrentBlock(ejs, mp);
    qname.name = ejsModuleReadString(ejs, mp);
    qname.space = ejsModuleReadString(ejs, mp);
    
    ejsModuleReadNumber(ejs, mp, &attributes);
    ejsModuleReadNumber(ejs, mp, &slotNum);
    ejsModuleReadType(ejs, mp, &type, &fixup, &propTypeName, 0);

    //  MOB -- remove the need for this flag
    if (attributes & EJS_PROP_HAS_VALUE) {
        if ((str = ejsModuleReadString(ejs, mp)) == 0) {
            return MPR_ERR_CANT_READ;
        }
        /*  Only doing for namespaces currently */
        value = (EjsObj*) ejsCreateNamespace(ejs, str, str);
    }

    mprLog(ejs, 9, "Loading property %s:%s at slot %d", qname.space, qname.name, slotNum);

    if (attributes & EJS_PROP_NATIVE) {
        mp->hasNative = 1;
    }
    if (ejs->loadState->flags & EJS_LOADER_STRICT) {
        if (ejsLookupProperty(ejs, current, &qname) >= 0) {
            ejsThrowReferenceError(ejs, "property \"%s\" already loaded", qname.name);
            return MPR_ERR_CANT_CREATE;
        }
    }
    if (ejsIsType(current) && !(attributes & EJS_PROP_STATIC) && current != ejs->global && ((EjsType*) current)->prototype){
        current = (EjsObj*) ((EjsType*) current)->prototype;
    }

    slotNum = ejsDefineProperty(ejs, current, slotNum, &qname, type, attributes, value);
    if (slotNum < 0) {
        return MPR_ERR_CANT_WRITE;
    }
    if (mp->flags & EJS_LOADER_BUILTIN) {
        value = ejsGetProperty(ejs, current, slotNum);
        value->builtin = 1;
    }

    if (fixup) {
        if (ejsIsFunction(current)) {
            fixupKind = EJS_FIXUP_LOCAL;
        } else if (ejsIsType(current) && !(attributes & EJS_PROP_STATIC) && current != ejs->global) {
            mprAssert(((EjsType*) current)->prototype);
            current = (EjsObj*) ((EjsType*) current)->prototype;
            fixupKind = EJS_FIXUP_INSTANCE_PROPERTY;
        } else {
            fixupKind = EJS_FIXUP_TYPE_PROPERTY;
        }
        mprAssert(type == 0);
        if (addFixup(ejs, fixupKind, current, slotNum, fixup) < 0) {
            ejsThrowMemoryError(ejs);
            return MPR_ERR_NO_MEMORY;
        }
    }
    setDoc(ejs, mp, current, slotNum);

    if (ejs->loaderCallback) {
        (ejs->loaderCallback)(ejs, EJS_SECT_PROPERTY, mp, current, slotNum, qname, attributes, propTypeName);
    }
    return 0;
}


static int loadDocSection(Ejs *ejs, MprFile *file, EjsModule *mp)
{
    char        *doc;

    mprLog(ejs, 9, "    Documentation section");

    doc = ejsModuleReadString(ejs, mp);

    if (ejs->flags & EJS_FLAG_DOC) {
        mp->doc = doc;
        if (ejs->loaderCallback) {
            (ejs->loaderCallback)(ejs, EJS_SECT_DOC, doc);
        }
    }
    return 0;
}


#if !BLD_FEATURE_STATIC
/*
    Check if a native module exists at the given path. If so, load it. If the path is a scripted module
    but has a corresponding native module, then load that. Return 1 if loaded, -1 for errors, 0 if no
    native module found.
 */
static int loadNativeLibrary(Ejs *ejs, EjsModule *mp, cchar *modPath)
{
    MprModule   *mm;
    char        *bare, *path, initName[MPR_MAX_PATH], moduleName[MPR_MAX_PATH], *cp;

    /*
        Replace ".mod" with ".so", ".dll" or ".dylib"
     */
    bare = mprStrdup(ejs, modPath);
    if ((cp = strrchr(bare, '.')) != 0 && strcmp(cp, EJS_MODULE_EXT) == 0) {
        *cp = '\0';
    }
    path = mprStrcat(ejs, -1, bare, BLD_SHOBJ, NULL);
    mprFree(bare);

    if (! mprPathExists(ejs, path, R_OK)) {
        mprError(ejs, "Native module not found %s", path);
        mprFree(path);
        return MPR_ERR_CANT_ACCESS;
    }

    /*
        Build the DSO entry point name. Format is "Name_ModuleInit" where Name has "." converted to "_"
        Typical name: ejs_io_Init or com_acme_rockets_Init
     */
    mprStrcpy(moduleName, sizeof(moduleName), mp->name);
    moduleName[0] = tolower((int) moduleName[0]);
    mprSprintf(initName, sizeof(initName), "%s_Init", moduleName);
    for (cp = initName; *cp; cp++) {
        if (*cp == '.') {
            *cp = '_';
        }
    }
    mprLog(ejs, 4, "Loading native module %s", path);
    mm = mprLoadModule(ejs, path, initName, mp);
    mprFree(path);
    return (mm == 0) ? MPR_ERR_CANT_OPEN : 1;
}
#endif


/*
    Load a scripted module file
 */
static int loadScriptModule(Ejs *ejs, MprFile *file, cchar *path, int flags)
{
    EjsModuleHdr    hdr;
    int             status;

    mprAssert(path);

    /*
        Read module file header
     */
    if ((mprRead(file, &hdr, sizeof(hdr))) != sizeof(hdr)) {
        ejsThrowIOError(ejs, "Error reading module file %s, corrupt header", path);
        return EJS_ERR;
    }
    if ((int) swapShort(ejs, hdr.magic) != EJS_MODULE_MAGIC) {
        ejsThrowIOError(ejs, "Bad module file format in %s", path);
        return EJS_ERR;
    }
    if (swapWord(ejs, hdr.fileVersion) != EJS_MODULE_VERSION) {
        ejsThrowIOError(ejs, "Incompatible module file format in %s", path);
        return EJS_ERR;
    }
    if (ejs->loaderCallback) {
        (ejs->loaderCallback)(ejs, EJS_SECT_START, path, &hdr);
    }

    /*
        Load the sections: classes, properties and functions. This may load multiple modules.
     */
    if ((status = loadSections(ejs, file, path, &hdr, flags)) < 0) {
        if (ejs->exception == 0) {
            ejsThrowReferenceError(ejs, "Can't load module file %s", path);
        }
        return status;
    }
    if (ejs->loaderCallback) {
        (ejs->loaderCallback)(ejs, EJS_SECT_END, ejs->modules, ejs->loadState->firstModule);
    }
    return 0;
}


static EjsObj *getCurrentBlock(Ejs *ejs, EjsModule *mp)
{
    EjsFunction     *fun;
    EjsObj          *block;
    
    block = (EjsObj*) mp->scopeChain;
    mprAssert(block);

    if (ejsIsFunction(block)) {
        fun = (EjsFunction*) block;
        if (fun->activation) {
            return fun->activation;
        }
    }
    return block;
}

static int fixupTypes(Ejs *ejs, MprList *list)
{
    EjsTypeFixup    *fixup;
    EjsModule       *mp;
    EjsType         *type, *targetType;
    EjsTrait        *trait;
    EjsFunction     *targetFunction;
    EjsEx           *targetException;
    int             next;

    for (next = 0; (fixup = (EjsTypeFixup*) mprGetNextItem(list, &next)) != 0; ) {
        mp = 0;
        type = 0;
        if (fixup->typeSlotNum >= 0) {
            type = (EjsType*) ejsGetProperty(ejs, ejs->global, fixup->typeSlotNum);

        } else if (fixup->typeName.name) {
            mprAssert(fixup->typeSlotNum < 0);
            type = (EjsType*) ejsGetPropertyByName(ejs, ejs->global, &fixup->typeName);
            
        } else {
            continue;
        }
        if (type == 0) {
            if (fixup->typeName.name) {
                ejsThrowReferenceError(ejs, "Can't fixup forward type reference for \"%s\". Fixup kind %d", 
                    fixup->typeName.name, fixup->kind);
            } else {
#if BLD_DEBUG
                ejsThrowReferenceError(ejs, "Can't fixup forward type reference for \"%s\". Fixup kind %d", 
                    fixup->target->name, fixup->kind);
#else
                ejsThrowReferenceError(ejs, "Can't fixup forward type reference for \"%s\". Fixup kind %d", 
                    fixup->typeName.name, fixup->kind);
#endif
            }
            return EJS_ERR;
        }

        switch (fixup->kind) {
        case EJS_FIXUP_BASE_TYPE:
            mprAssert(fixup->target);
            targetType = (EjsType*) fixup->target;
            targetType->needFixup = 1;
            ejsFixupType(ejs, targetType, type, 0);
            if (targetType->block.namespaces.length == 0 && type->block.obj.hasScriptFunctions) {
                ejsDefineTypeNamespaces(ejs, targetType);
            }
            break;

        case EJS_FIXUP_INTERFACE_TYPE:
            targetType = (EjsType*) fixup->target;
            mprAddItem(targetType->implements, type);
            break;

        case EJS_FIXUP_RETURN_TYPE:
            mprAssert(fixup->target);
            targetFunction = (EjsFunction*) fixup->target;
            targetFunction->resultType = type;
            break;

        case EJS_FIXUP_TYPE_PROPERTY:
            mprAssert(fixup->target);
            trait = ejsGetPropertyTrait(ejs, fixup->target, fixup->slotNum);
            mprAssert(trait);
            if (trait) {
                trait->type = type;
            }
            break;

        case EJS_FIXUP_INSTANCE_PROPERTY:
            mprAssert(fixup->target);
            mprAssert(ejsIsBlock(fixup->target));
            mprAssert(fixup->target->isPrototype);
            trait = ejsGetPropertyTrait(ejs, fixup->target, fixup->slotNum);
            mprAssert(trait);
            if (trait) {
                trait->type = type;
            }
            break;

        case EJS_FIXUP_LOCAL:
            mprAssert(fixup->target);
            trait = ejsGetPropertyTrait(ejs, fixup->target, fixup->slotNum);
            mprAssert(trait);
            if (trait) {
                trait->type = type;
            }
            break;

        case EJS_FIXUP_EXCEPTION:
            mprAssert(fixup->target);
            targetException = (EjsEx*) fixup->target;
            targetException->catchType = type;
            break;

        default:
            mprAssert(0);
        }
    }
    return 0;
}


/*
    Parse a major.minor.version string
 */
int ejsParseModuleVersion(cchar *name)
{
    char    *tok;
    int     major, minor, patch;

    minor = patch = 0;
    major = (int) mprAtoi(name, 10);
    if ((tok = strchr(name, '.')) != 0) {
        minor = (int) mprAtoi(++tok, 10);
    }
    if ((tok = strchr(tok, '.')) != 0) {
        patch = (int) mprAtoi(++tok, 10);
    }
    return EJS_MAKE_VERSION(major, minor, patch);
}


/*
    Remove "-version" and ".mod"
 */
static int trimModule(Ejs *ejs, char *name)
{
    cchar   *lastSlash;
    char    *cp, *vp;

    if ((cp = strrchr(name, '.')) != 0 && strcmp(cp, EJS_MODULE_EXT) == 0) {
        *cp = '\0';
    }
    if ((vp = strrchr(name, '-')) == 0) {
        return 0;
    }
    lastSlash = mprGetLastPathSeparator(ejs, name);
    if (lastSlash && lastSlash > vp) {
        /* There is a "-" but it is in the directory portion of the name and not in the module name */
        return 0;
    }
    *vp++ = '\0';
    return ejsParseModuleVersion(vp);
}


/*
    Extract the version from a module name
 */
static int getVersion(cchar *name)
{
    char    *vp;

    if ((vp = strrchr(name, '-')) == 0) {
        return 0;
    }
    return ejsParseModuleVersion(++vp);
}


/*
    Search for a file. If found, Return the path where the file was located. Otherwise return null.
 */
static char *probe(MprCtx ctx, cchar *path, int minVersion, int maxVersion)
{
    MprDirEntry     *dp, *best;
    MprList         *files;
    char            *dir, *base, *ext, *result;
    int             nameLen, version, next, bestVersion;

    mprAssert(ctx);
    mprAssert(path);

    mprLog(ctx, 7, "Probe for file %s", path);

    if (maxVersion == 0) {
        if (mprPathExists(ctx, path, R_OK)) {
            return mprStrdup(ctx, path);
        }
        return 0;
    }

    dir = mprGetPathDir(ctx, path);
    base = mprGetPathBase(ctx, path);
    if ((ext = strrchr(base, '.')) != 0) {
        *ext = '\0';
    }
    files = mprGetPathFiles(ctx, dir, 0);
    nameLen = strlen(base);
    bestVersion = -1;
    best = 0;

    for (next = 0; (dp = mprGetNextItem(files, &next)) != 0; ) {
        if (strncmp(dp->name, base, nameLen) != 0) {
            continue;
        }
        if ((ext = strrchr(dp->name, '.')) == 0 || strcmp(ext, EJS_MODULE_EXT) != 0) {
            continue;
        }
        if (dp->name[nameLen] == '-') {
            version = getVersion(dp->name);
        } else if (&dp->name[nameLen] == ext) {
            version = 0;
        } else {
            continue;
        }
        if (version == 0 || (minVersion <= version && version <= maxVersion)) {
            if (best == 0 || bestVersion < version) {
                bestVersion = version;
                best = dp;
            }
        }
    }
    if (best == 0) {
        result = 0;
    } else {
        result = mprJoinPath(ctx, dir, best->name);
    }
    mprFree(files);
    return result;
}


/*
    Search for a module. moduleName is a filename or path name. It MUST have a ".mod" extension.

    The search strategy is: Given a name "a.b.c", scan for:

        1. File named a.b.c
        2. File named a/b/c
        3. File named a.b.c in EJSPATH
        4. File named a/b/c in EJSPATH
        5. File named c in EJSPATH
 */
static char *searchForModule(Ejs *ejs, MprCtx ctx, cchar *moduleName, int minVersion, int maxVersion)
{
    MprCtx      *tx;
    EjsPath     *dir;
    char        *withDotMod, *path, *filename, *basename, *cp, *slash, *name, *bootSearch, *tok, *searchDir, *dp;
    int         i;

    mprAssert(moduleName && *moduleName);

    slash = 0;
    if (maxVersion <= 0) {
        maxVersion = MAXINT;
    }

    ctx = withDotMod = makeModuleName(ejs, moduleName);
    name = mprGetNormalizedPath(ctx, withDotMod);

    mprLog(ejs, 5, "Search for module \"%s\"", name);

    /*
        1. Search for path directly
     */
    if ((path = probe(ctx, name, minVersion, maxVersion)) != 0) {
        return path;
    }

    /*
        2. Search for "a/b/c"
     */
    slash = mprStrdup(ctx, name);
    for (cp = slash; *cp; cp++) {
        if (*cp == '.') {
            *cp = mprGetPathSeparator(ejs, name);
        }
    }
    if ((path = probe(ctx, slash, minVersion, maxVersion)) != 0) {
        return path;
    }

    if (ejs->search) {
        /*
            3. Search for "a.b.c" in EJSPATH
         */
        for (i = 0; i < ejs->search->length; i++) {
            dir = (EjsPath*) ejsGetProperty(ejs, (EjsVar*) ejs->search, i);
            if (!ejsIsPath(ejs, dir)) {
                continue;
            }
            filename = mprJoinPath(ctx, dir->path, name);
            if ((path = probe(ctx, filename, minVersion, maxVersion)) != 0) {
                return path;
            }
        }

        /*
            4. Search for "a/b/c" in EJSPATH
         */
        for (i = 0; i < ejs->search->length; i++) {
            dir = (EjsPath*) ejsGetProperty(ejs, (EjsVar*) ejs->search, i);
            if (!ejsIsPath(ejs, dir)) {
                continue;
            }
            filename = mprJoinPath(ctx, dir->path, slash);
            if ((path = probe(ctx, filename, minVersion, maxVersion)) != 0) {
                return path;
            }
        }

        /*
            5. Search for "c" in EJSPATH
         */
        basename = mprGetPathBase(ctx, slash);
        for (i = 0; i < ejs->search->length; i++) {
            dir = (EjsPath*) ejsGetProperty(ejs, (EjsVar*) ejs->search, i);
            if (!ejsIsPath(ejs, dir)) {
                continue;
            }
            filename = mprJoinPath(ctx, dir->path, basename);
            if ((path = probe(ctx, filename, minVersion, maxVersion)) != 0) {
                return path;
            }
        }

    } else {
        /*
            Used when bootstrapping the VM
         */
        basename = mprGetPathBase(ctx, name);
        if (ejs->bootSearch) {
            bootSearch = mprStrdup(ejs, ejs->bootSearch);
            searchDir = mprStrTok(bootSearch, MPR_SEARCH_SEP, &tok);
            while (searchDir && *searchDir) {
                filename = mprJoinPath(ctx, searchDir, basename);
                if ((path = probe(ejs, filename, minVersion, maxVersion)) != 0) {
                    mprFree(bootSearch);
                    return path;
                }
                searchDir = mprStrTok(NULL, MPR_SEARCH_SEP, &tok);
            }
            mprFree(bootSearch);

        } else {

            /* Search bin/../modules */
            dp = mprGetAppDir(ctx);
            tx = (MprCtx*) dp;
            dp = mprGetPathParent(tx, dp);
            dp = mprJoinPath(tx, dp, BLD_MOD_NAME);
            filename = mprJoinPath(ctx, dp, basename);
            mprFree(tx);
            if ((path = probe(ejs, filename, minVersion, maxVersion)) != 0) {
                return path;
            }

            /* Search bin */
            filename = mprJoinPath(ctx, mprGetAppDir(ctx), basename);
            if ((path = probe(ejs, filename, minVersion, maxVersion)) != 0) {
                return path;
            }

            /* Search "." */
            path = mprGetCurrentPath(ctx);
            filename = mprJoinPath(ctx, path, basename);
            if ((path = probe(ejs, filename, minVersion, maxVersion)) != 0) {
                return path;
            }
        }
    }
    return 0;
}


char *ejsSearchForModule(Ejs *ejs, cchar *moduleName, int minVersion, int maxVersion)
{
    MprCtx      ctx;
    char        *path, *withDotMod, *name;

    mprAssert(moduleName && *moduleName);

    if (maxVersion <= 0) {
        maxVersion = MAXINT;
    }
    ctx = withDotMod = makeModuleName(ejs, moduleName);
    name = mprGetNormalizedPath(ctx, withDotMod);

    mprLog(ejs, 5, "Search for module \"%s\"", name);
    path = searchForModule(ejs, ctx, name, minVersion, maxVersion);
    if (path) {
        mprLog(ctx, 5, "Found %s at %s", name, path);
    }
    mprFree(ctx);
    return path;
}


/*
    Ensure name has a ".mod" extension
 */
static char *makeModuleName(MprCtx ctx, cchar *name)
{
    char    *cp;

    if ((cp = strrchr(name, '.')) != NULL && strcmp(cp, EJS_MODULE_EXT) == 0) {
        return mprStrdup(ctx, name);
    }
    return mprStrcat(ctx, -1, name, EJS_MODULE_EXT, NULL);
}


static int alreadyLoaded(Ejs *ejs, cchar *name, int minVersion, int maxVersion)
{
    EjsModule   *mp;

    if ((mp = ejsLookupModule(ejs, name, minVersion, maxVersion)) == 0) {
        return 0;
    }
    if (mp->compiling && strcmp(name, EJS_DEFAULT_MODULE) != 0) {
        ejsThrowStateError(ejs, "Attempt to load module \"%s\" that is currently being compiled.", name);
        return MPR_ERR_ALREADY_EXISTS;
    }
    return 1;
}


static void createLoadState(Ejs *ejs, int flags)
{
    EjsLoadState    *ls;

    ls = ejs->loadState = mprAllocObjZeroed(ejs, EjsLoadState);
    ls->typeFixups = mprCreateList(ls);
    ls->firstModule = mprGetListCount(ejs->modules);
    ls->flags = flags;
}


/*
    Read a string constant. String constants are stored as token offsets into
    the constant pool. The pool contains null terminated UTF-8 strings.
 */
char *ejsModuleReadString(Ejs *ejs, EjsModule *mp)
{
    int     t;

    mprAssert(mp);

    if (ejsModuleReadNumber(ejs, mp, &t) < 0) {
        return 0;
    }
    return tokenToString(mp, t);
}


/*
    Read a type reference. Types are stored as either global property slot numbers or as strings (token offsets into the 
    constant pool). The lowest bit is set if the reference is a string. The type and name arguments are optional and may 
    be set to null. Return EJS_ERR for errors, otherwise 0. Return the 0 if successful, otherwise return EJS_ERR. If the 
    type could not be resolved, allocate a fixup record and return in *fixup. The caller should then call addFixup.
 */
int ejsModuleReadType(Ejs *ejs, EjsModule *mp, EjsType **typeRef, EjsTypeFixup **fixup, EjsName *typeName, int *slotNum)
{
    EjsType         *type;
    EjsName         qname;
    int             t, slot;

    mprAssert(mp);
    mprAssert(typeRef);
    mprAssert(fixup);

    *typeRef = 0;
    *fixup = 0;

    if (typeName) {
        typeName->name = 0;
        typeName->space = 0;
    }
    if (ejsModuleReadNumber(ejs, mp, &t) < 0) {
        mprAssert(0);
        return EJS_ERR;
    }

    slot = -1;
    qname.name = 0;
    qname.space = 0;
    type = 0;

    switch (t & EJS_ENCODE_GLOBAL_MASK) {
    default:
        mp->hasError = 1;
        mprAssert(0);
        return EJS_ERR;

    case EJS_ENCODE_GLOBAL_NOREF:
        return 0;

    case EJS_ENCODE_GLOBAL_SLOT:
        /*
            Type is a builtin primitive type or we are binding globals.
         */
        slot = t >> 2;
        if (0 <= slot && slot < ejsGetPropertyCount(ejs, ejs->global)) {
            type = (EjsType*) ejsGetProperty(ejs, ejs->global, slot);
            if (type && (EjsObj*) type != ejs->nullValue) {
                qname = type->qname;
            }
        }
        break;

    case EJS_ENCODE_GLOBAL_NAME:
        /*
            Type was unbound at compile time
         */
        qname.name = tokenToString(mp, t >> 2);
        if (qname.name == 0) {
            mp->hasError = 1;
            mprAssert(0);
            return EJS_ERR;
        }
        if ((qname.space = ejsModuleReadString(ejs, mp)) == 0) {
            mp->hasError = 1;
            mprAssert(0);
            return EJS_ERR;
        }
        if (qname.name) {
            slot = ejsLookupProperty(ejs, ejs->global, &qname);
            if (slot >= 0) {
                type = (EjsType*) ejsGetProperty(ejs, ejs->global, slot);
            }
        }
        break;
    }
    if ((EjsObj*) type == ejs->nullValue) {
        type = 0;
    }
    if (type) {
        if (!ejsIsType(type)) {
            mp->hasError = 1;
            mprAssert(0);
            return EJS_ERR;
        }
        *typeRef = type;

    } else if (type == 0 && fixup) {
        *fixup = createFixup(ejs, &qname, slot);
    }
    if (typeName) {
        *typeName = qname;
    }
    if (slotNum) {
        *slotNum = slot;
    }
    return 0;
}


static EjsTypeFixup *createFixup(Ejs *ejs, EjsName *qname, int slotNum)
{
    EjsTypeFixup    *fixup;

    mprAssert(ejs->loadState->typeFixups);
    fixup = mprAllocZeroed(ejs->loadState->typeFixups, sizeof(EjsTypeFixup));
    if (fixup == 0) {
        return 0;
    }
    fixup->typeName = *qname;
    fixup->typeSlotNum = slotNum;
    return fixup;
}


static int addFixup(Ejs *ejs, int kind, EjsObj *target, int slotNum, EjsTypeFixup *fixup)
{
    int     index;

    mprAssert(ejs);
    mprAssert(fixup);
    mprAssert(ejs->loadState->typeFixups);

    fixup->kind = kind;
    fixup->target = target;
    fixup->slotNum = slotNum;

    index = mprAddItem(ejs->loadState->typeFixups, fixup);
    if (index < 0) {
        mprAssert(0);
        return EJS_ERR;
    }
    return 0;
}


/*
    Convert a token index into a string.
 */
static char *tokenToString(EjsModule *mp, int token)
{
    if (token < 0 || token >= mp->constants->len) {
        mprAssert(0);
        return 0;
    }
    mprAssert(mp->constants);
    if (mp->constants == 0) {
        mprAssert(0);
        return 0;
    }
    return &mp->constants->pool[token];
}


/*
    Decode an encoded 32-bit word
 */
int ejsDecodeWord(uchar **pp)
{
    uchar   *start;
    int     value;

    start = *pp;
    value = (int) ejsDecodeNum(pp);
    *pp = start + 4;
    return value;
}


/*
    Get an encoded 64 bit number. Variable number of bytes.
 */
int64 ejsDecodeNum(uchar **pp)
{
    uchar   *pos;
    uint64  t;
    uint    c;
    int     sign, shift;

    pos = *pp;
    c = (uint) *pos++;

    /*
        Map sign bit (0,1) to 1,-1
     */
    sign = 1 - ((c & 0x1) << 1);
    t = (c >> 1) & 0x3f;
    shift = 6;

    while (c & 0x80) {
        c = *pos++;
        t |= (c & 0x7f) << shift;
        shift += 7;
    }
    *pp = pos;
    return t * sign;
}


/*
    Decode a 4 byte number from a file
 */
static int readWord(Ejs *ejs, MprFile *file, int *number)
{
    uchar   buf[4], *pp;

    mprAssert(file);
    mprAssert(number);

    if (mprRead(file, buf, 4) != 4) {
        return MPR_ERR_CANT_READ;
    }
    pp = buf;
    *number = ejsDecodeWord(&pp);
    return 0;
}


/*
    Decode a number from a file. Same as ejsDecodeNum but reading from a file.
 */
static int readNumber(Ejs *ejs, MprFile *file, int *number)
{
    uint    t, c;
    int     sign, shift;

    mprAssert(file);
    mprAssert(number);

    if ((c = mprGetc(file)) < 0) {
        return MPR_ERR_CANT_READ;
    }

    /*
        Map sign bit (0,1) to 1,-1
     */
    sign = 1 - ((c & 0x1) << 1);
    t = (c >> 1) & 0x3f;
    shift = 6;
    
    while (c & 0x80) {
        if ((c = mprGetc(file)) < 0) {
            return MPR_ERR_CANT_READ;
        }
        t |= (c & 0x7f) << shift;
        shift += 7;
    }
    *number = (int) (t * sign);
    return 0;
}


double ejsDecodeDouble(uchar **pp)
{
    double   value;

    memcpy(&value, *pp, sizeof(double));
    *pp += sizeof(double);
    return value;
}


/*
    Encode a number in a RLL encoding. Encoding is:
        Bit     0:  Sign
        Bits  1-6:  Low 6 bits (0-64)
        Bit     7:  Extension bit
        Bits 8-15:  Next 7 bits
        Bits   16:  Extension bit
        ...
 */
int ejsEncodeNum(uchar *pos, int64 number)
{
    uchar       *start;
    uint        encoded;
    uint64      unumber;

    mprAssert(pos);

    start = pos;
    if (number < 0) {
        unumber = -number;
        encoded = (uint) (((unumber & 0x3F) << 1) | 1);
    } else {
        encoded = (uint) (((number & 0x3F) << 1));
        unumber = number;
    }
    unumber >>= 6;

    while (unumber) {
        *pos++ = encoded | 0x80;
        encoded = (int) (unumber & 0x7f);
        unumber >>= 7;
    }
    *pos++ = encoded;
    mprAssert((pos - start) < 11);
    return (int) (pos - start);
}


int ejsEncodeUint(uchar *pos, uint number)
{
    uchar       *start;
    uint        encoded;

    mprAssert(pos);

    start = pos;
    encoded = (uint) (((number & 0x3F) << 1));
    number >>= 6;

    while (number) {
        *pos++ = encoded | 0x80;
        encoded = (int) (number & 0x7f);
        number >>= 7;
    }
    *pos++ = encoded;
    mprAssert((pos - start) < 11);
    return (int) (pos - start);
}


/*
    Encode a 32-bit number. Always emit exactly 4 bytes.
 */
int ejsEncodeWord(uchar *pos, int number)
{
    int         len;

    mprAssert(pos);

    if (abs(number) > EJS_ENCODE_MAX_WORD) {
        mprError(mprGetMpr(), "Code generation error. Word %d exceeds maximum %d", number, EJS_ENCODE_MAX_WORD);
        return 0;
    }
    len = ejsEncodeNum(pos, (int64) number);
    mprAssert(len <= 4);
    return 4;
}


int ejsEncodeDouble(uchar *pos, double number)
{
    double   *ptr;

    ptr = (double*) pos;
    *ptr = number;
    return sizeof(double);
}


int ejsEncodeByteAtPos(uchar *pos, int value)
{
    mprAssert(pos);

    *pos = value;
    return 0;
}


int ejsEncodeWordAtPos(uchar *pos, int value)
{
    mprAssert(pos);

    return ejsEncodeWord(pos, value);
}



//  TODO - refactor to return the number. Setting mp->hasError is sufficient
/*
    Read an encoded number. Numbers are little-endian encoded in 7 bits with
    the 0x80 bit of each byte being a continuation bit.
 */
int ejsModuleReadNumber(Ejs *ejs, EjsModule *mp, int *number)
{
    mprAssert(ejs);
    mprAssert(mp);
    mprAssert(number);

    if (readNumber(ejs, mp->file, number) < 0) {
        mp->hasError = 1;
        return -1;
    }
    return 0;
}


//  TODO - refactor to return the number. Setting mp->hasError is sufficient
int ejsModuleReadByte(Ejs *ejs, EjsModule *mp, int *number)
{
    int     c;

    mprAssert(mp);
    mprAssert(number);

    if ((c = mprGetc(mp->file)) < 0) {
        mp->hasError = 1;
        return MPR_ERR_CANT_READ;
    }
    *number = c;
    return 0;
}


static void setDoc(Ejs *ejs, EjsModule *mp, EjsObj *block, int slotNum)
{
    if (mp->doc && ejsIsBlock(block)) {
        ejsCreateDoc(ejs, (EjsBlock*) block, slotNum, mp->doc);
        mp->doc = 0;
    }
}


EjsDoc *ejsCreateDoc(Ejs *ejs, EjsBlock *block, int slotNum, cchar *docString)
{
    EjsDoc      *doc;
    char        key[32];

    doc = mprAllocZeroed(ejs, sizeof(EjsDoc));
    if (doc == 0) {
        return 0;
    }
    doc->docString = mprStrdup(doc, docString);
    if (ejs->doc == 0) {
        ejs->doc = mprCreateHash(ejs, EJS_DOC_HASH_SIZE);
    }

    /*
        This is slow, but not critical path
     */
    mprSprintf(key, sizeof(key), "%Lx %d", PTOL(block), slotNum);
    mprAddHash(ejs->doc, key, doc);
    return doc;
}


static int swapShort(Ejs *ejs, int word)
{
    if (mprGetEndian(ejs) == MPR_LITTLE_ENDIAN) {
        return word;
    }
    word = ((word & 0xFFFF) << 16) | ((word & 0xFFFF0000) >> 16);
    return ((word & 0xFF) << 8) | ((word & 0xFF00) >> 8);
}


static int swapWord(Ejs *ejs, int word)
{
    if (mprGetEndian(ejs) == MPR_LITTLE_ENDIAN) {
        return word;
    }
    return ((word & 0xFF000000) >> 24) | ((word & 0xFF0000) >> 8) | ((word & 0xFF00) << 8) | ((word & 0xFF) << 24);
}

/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2010. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2010. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    @end
 */
/************************************************************************/
/*
 *  End of file "../src/vm/ejsLoader.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../src/vm/ejsModule.c"
 */
/************************************************************************/

/**
 *  ejsModule.c - Ejscript module management
 *
 *  Copyright (c) All Rights Reserved. See details at the end of the file.
 */




EjsModule *ejsCreateModule(Ejs *ejs, cchar *name, int version)
{
    EjsModule   *mp;

    mprAssert(version >= 0);

    mp = (EjsModule*) mprAllocZeroed(ejs, sizeof(EjsModule));
    if (mp == 0) {
        mprAssert(mp);
        return 0;
    }
    mp->name = mprStrdup(mp, name);
    mp->version = version;
    if (version) {
        mp->vname = mprAsprintf(mp, -1, "%s-%d", name, version);
    } else {
        mp->vname = mp->name;
    }

    mp->constants = mprAllocZeroed(mp, sizeof(EjsConst));
    if (mp->constants == 0) {
        return 0;
    }
    mp->constants->table = mprCreateHash(mp->constants, 0);
    return mp;
}


/*
 *  Register a native module callback to be invoked when it it time to configure the module. This is used by loadable modules
 *  when they are built statically.
 */
int ejsAddNativeModule(MprCtx ctx, cchar *name, EjsNativeCallback callback, int checksum, int flags)
{
    EjsService          *es;
    EjsNativeModule     *nm;

    es = ejsGetService(ctx);

    nm = mprAllocObjZeroed(es, EjsNativeModule);
    nm->name = name;
    nm->callback = callback;
    nm->checksum = checksum;
    nm->flags = flags;

    if (mprAddHash(es->nativeModules, name, nm) == 0) {
        return EJS_ERR;
    }
    return 0;
}


EjsNativeModule *ejsLookupNativeModule(Ejs *ejs, cchar *name) 
{
    return (EjsNativeModule*) mprLookupHash(ejs->service->nativeModules, name);
}


int ejsSetModuleConstants(Ejs *ejs, EjsModule *mp, cchar *pool, int poolSize)
{
    mprStealBlock(mp, pool);
    mp->constants->pool = (char*) pool;
    mp->constants->size = poolSize;
    mp->constants->len = poolSize;
    return 0;
}


/*
 *  Lookup a module name in the set of loaded modules
 *  If minVersion is <= 0, then any version up to, but not including maxVersion is acceptable.
 *  If maxVersion is < 0, then any version greater than minVersion is acceptable.
 *  If both are zero, then match the name itself and ignore minVersion and maxVersion
 *  If both are -1, then any version is acceptable.
 *  If both are equal, then only that version is acceptable.
 */
EjsModule *ejsLookupModule(Ejs *ejs, cchar *name, int minVersion, int maxVersion)
{
    EjsModule   *mp, *best;
    int         next;

    if (maxVersion < 0) {
        maxVersion = MAXINT;
    }
    best = 0;
    for (next = 0; (mp = (EjsModule*) mprGetNextItem(ejs->modules, &next)) != 0; ) {
        if ((minVersion == 0 && maxVersion == 0) || (minVersion <= mp->version && mp->version <= maxVersion)) {
            if (strcmp(mp->name, name) == 0) {
                if (best == 0 || best->version < mp->version) {
                    best = mp;
                }
            }
        }
    }
    return best;
}


int ejsAddModule(Ejs *ejs, EjsModule *mp)
{
    mprAssert(ejs->modules);
    return mprAddItem(ejs->modules, mp);
}


int ejsRemoveModule(Ejs *ejs, EjsModule *mp)
{
    mprAssert(ejs->modules);
    return mprRemoveItem(ejs->modules, mp);
}


MprList *ejsGetModuleList(Ejs *ejs)
{
    return ejs->modules;
}


/*
 *  @copy   default
 *
 *  Copyright (c) Embedthis Software LLC, 2003-2010. All Rights Reserved.
 *  Copyright (c) Michael O'Brien, 1993-2010. All Rights Reserved.
 *
 *  This software is distributed under commercial and open source licenses.
 *  You may use the GPL open source license described below or you may acquire
 *  a commercial license from Embedthis Software. You agree to be fully bound
 *  by the terms of either license. Consult the LICENSE.TXT distributed with
 *  this software for full details.
 *
 *  This software is open source; you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by the
 *  Free Software Foundation; either version 2 of the License, or (at your
 *  option) any later version. See the GNU General Public License for more
 *  details at: http://www.embedthis.com/downloads/gplLicense.html
 *
 *  This program is distributed WITHOUT ANY WARRANTY; without even the
 *  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 *  This GPL license does NOT permit incorporating this software into
 *  proprietary programs. If you are unable to comply with the GPL, you must
 *  acquire a commercial license to use this software. Commercial licenses
 *  for this software and support services are available from Embedthis
 *  Software at http://www.embedthis.com
 *
 *  @end
 */
/************************************************************************/
/*
 *  End of file "../src/vm/ejsModule.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../src/vm/ejsScope.c"
 */
/************************************************************************/

/**
    ejsScope.c - Lookup variables in the scope chain.
  
    This modules provides scope chain management including lookup, get and set services for variables. It will 
    lookup variables using the current execution variable scope and the set of open namespaces.
  
    Copyright (c) All Rights Reserved. See details at the end of the file.
 */



/*
    Look for a variable by name in the scope chain and return the location in "lookup" and a positive slot number if found. 
    If the name.space is non-null/non-empty, then only the given namespace will be used. otherwise the set of open 
    namespaces will be used. The lookup structure will contain details about the location of the variable.
 */
int ejsLookupScope(Ejs *ejs, EjsName *name, EjsLookup *lookup)
{
    EjsFrame        *fp;
    EjsBlock        *block;
    EjsState        *state;
    int             slotNum, nth;

    mprAssert(ejs);
    mprAssert(name);
    mprAssert(lookup);

    slotNum = -1;
    state = ejs->state;
    fp = state->fp;

    /*
        Look for the name in the scope chain considering each block scope. LookupVar will consider base classes and 
        namespaces. Don't search the last scope chain entry which will be global. For cloned interpreters, global 
        will belong to the master interpreter, so we must do that explicitly below to get the right global.
     */
    for (nth = 0, block = state->bp; block->scopeChain; block = block->scopeChain) {

        if (fp->function.thisObj && block == (EjsBlock*) fp->function.thisObj->type) {
            /*
                This will lookup the instance and all base classes
             */
            if ((slotNum = ejsLookupVar(ejs, fp->function.thisObj, name, lookup)) >= 0) {
                lookup->nthBlock = nth;
                break;
            }
            
        } else {
            if ((slotNum = ejsLookupVar(ejs, (EjsObj*) block, name, lookup)) >= 0) {
                lookup->nthBlock = nth;
                break;
            }
        }
        nth++;
    }
    if (slotNum < 0 && ((slotNum = ejsLookupVar(ejs, ejs->global, name, lookup)) >= 0)) {
        lookup->nthBlock = nth;
    }
    lookup->slotNum = slotNum;
    return slotNum;
}


/*
    Find a property in an object or type and its base classes.
 */
int ejsLookupVar(Ejs *ejs, EjsObj *obj, EjsName *name, EjsLookup *lookup)
{
    EjsType     *type;
    EjsObj      *vp;
    int         slotNum;

    mprAssert(obj);
    mprAssert(obj->type);
    mprAssert(name);

    /*
        OPT - bit field initialization
     */
    lookup->nthBase = 0;
    lookup->nthBlock = 0;
    lookup->useThis = 0;
    lookup->instanceProperty = 0;
    lookup->ownerIsType = 0;
    lookup->trait = 0;
    lookup->slotNum = -1;
    vp = obj;

    /*
        Search through the inheritance chain of base classes. nthBase counts the subtypes that must be traversed. 
     */
    for (slotNum = -1, lookup->nthBase = 0; vp; lookup->nthBase++) {
        if ((slotNum = ejsLookupVarWithNamespaces(ejs, obj, vp, name, lookup)) >= 0) {
            break;
        }
        if (ejsIsFrame(vp)) break;
        vp = (vp->isType) ? (EjsObj*) ((EjsType*) vp)->baseType: (EjsObj*) vp->type;
        type = (EjsType*) vp;
        if (type == 0 || type->skipScope) {
            break;
        }
    }
    if (slotNum < 0 && obj->type->prototype) {
        vp = obj->type->prototype;
        for (lookup->nthBase = 0; vp; lookup->nthBase++) {
            if ((slotNum = ejsLookupVarWithNamespaces(ejs, obj, vp, name, lookup)) >= 0) {
                break;
            }
            //  MOB -- fix (Object prototype loops)
            if (vp == vp->type->prototype) {
                break;
            }
            vp = vp->type->prototype;
        }
    } 
    if (slotNum >= 0) {
        lookup->trait = ejsGetTrait(lookup->obj, lookup->slotNum);
    }
    return lookup->slotNum = slotNum;
}


/*
    Find a variable in a block. Scope blocks are provided by the global object, types, functions and statement blocks.
 */
int ejsLookupVarWithNamespaces(Ejs *ejs, EjsObj *originalObj, EjsObj *vp, EjsName *name, EjsLookup *lookup)
{
    EjsNamespace    *nsp;
    EjsName         qname;
    EjsBlock        *b;
    EjsObj          *owner;
    EjsFunction     *ref;
    int             slotNum, nextNsp;

    mprAssert(vp);
    mprAssert(name);
    mprAssert(name->name);
    mprAssert(name->space);
    mprAssert(lookup);

    if ((slotNum = ejsLookupProperty(ejs, vp, name)) < 0 && name->space[0] != EJS_EMPTY_NAMESPACE[0]) {
        return slotNum;
    }
    if (slotNum >= 0) {
        ref = (EjsFunction*) ejsGetProperty(ejs, vp, slotNum);
        
        if (ejsIsType(vp) && originalObj != vp && !ejsIsType(originalObj) && (!ejsIsFunction(ref) || ref->staticMethod)) {
             /* 
                Accessing a static var or static method from a sub-type of the original instance.
                i.e. Type properties should not be visible to instances.
              */
            ;
        } else {
        
            if (ejsIsFunction(ref) && !ref->staticMethod && ejsIsType(originalObj) && vp != (EjsObj*) ejs->objectType) {
                /* 
                    Accessing an instance method from a type and the method is not in Object
                    i.e. Instance methods should not be visible to Type objects.
                 */
                ;
                
            } else {
                lookup->name = *name;
                lookup->obj = vp;
                lookup->slotNum = slotNum;
                return slotNum;
            }
        }
    }
    qname = *name;
    for (b = ejs->state->bp; b; b = b->scopeChain) {
        for (nextNsp = -1; (nsp = (EjsNamespace*) ejsGetPrevItem(&b->namespaces, &nextNsp)) != 0; ) {

            if (nsp->flags & EJS_NSP_PROTECTED && vp->isType && ejs->state->fp) {
                /*
                    Protected access. See if the type containing the method we are executing is a sub class of the type 
                    containing the property ie. Can we see protected properties?
                 */
                owner = (EjsObj*) ejs->state->fp->function.owner;
                if (owner && !ejsIsA(ejs, owner, (EjsType*) vp)) {
                    continue;
                }
            }
            qname.space = nsp->uri;
            mprAssert(qname.space);
            if (qname.space) {
                slotNum = ejsLookupProperty(ejs, vp, &qname);
                if (slotNum >= 0) {
                    //  MOB -- since we need to get the trait anyway, better to determine this from the trait
                    ref = (EjsFunction*) ejsGetProperty(ejs, vp, slotNum);
                    if (ejsIsType(vp) && originalObj != vp && !ejsIsType(originalObj) && 
                            (!ejsIsFunction(ref) || ref->staticMethod)) {
                        /* Accessing static property or static method from an instance */
                        continue;
                    }
                    if (ejsIsFunction(ref) && !ref->staticMethod && ejsIsType(originalObj) && 
                            vp != (EjsObj*) ejs->objectType) {
                        mprNop();
                        continue;
                    }
                    lookup->name = qname;
                    lookup->obj = vp;
                    lookup->slotNum = slotNum;
                    return slotNum;
                }
            }
        }
    }
    return -1;
}


/*
    Get a variable by name. If vp is specified, it contains an explicit object in which to search for the variable name. 
    Otherwise, the full execution scope is consulted. The lookup fields will be set as residuals.
 */
EjsObj *ejsGetVarByName(Ejs *ejs, EjsObj *vp, EjsName *name, EjsLookup *lookup)
{
    EjsObj  *result;
    int     slotNum;

    mprAssert(ejs);
    mprAssert(name);

    //  OPT - really nice to remove this
    if (vp && vp->type->helpers->getPropertyByName) {
        result = (*vp->type->helpers->getPropertyByName)(ejs, vp, name);
        if (result) {
            return result;
        }
    }
    if (vp) {
        slotNum = ejsLookupVar(ejs, vp, name, lookup);
    } else {
        slotNum = ejsLookupScope(ejs, name, lookup);
    }
    if (slotNum < 0) {
        return 0;
    }
    return ejsGetProperty(ejs, lookup->obj, slotNum);
}


void ejsShowBlockScope(Ejs *ejs, EjsBlock *block)
{
#if BLD_DEBUG
    EjsNamespace    *nsp;
    EjsList         *namespaces;
    int             nextNsp;

    mprLog(ejs, 6, "\n  Block scope");
    for (; block; block = block->scopeChain) {
        mprLog(ejs, 6, "    Block \"%s\" 0x%08x", mprGetName(block), block);
        namespaces = &block->namespaces;
        if (namespaces) {
            for (nextNsp = 0; (nsp = (EjsNamespace*) ejsGetNextItem(namespaces, &nextNsp)) != 0; ) {
                mprLog(ejs, 6, "        \"%s\"", nsp->uri);
            }
        }
    }
#endif
}


void ejsShowCurrentScope(Ejs *ejs)
{
#if BLD_DEBUG
    EjsNamespace    *nsp;
    EjsList         *namespaces;
    EjsBlock        *block;
    int             nextNsp;

    mprLog(ejs, 6, "\n  Current scope");
    for (block = ejs->state->bp; block; block = block->scopeChain) {
        mprLog(ejs, 6, "    Block \"%s\" 0x%08x", mprGetName(block), block);
        namespaces = &block->namespaces;
        if (namespaces) {
            for (nextNsp = 0; (nsp = (EjsNamespace*) ejsGetNextItem(namespaces, &nextNsp)) != 0; ) {
                mprLog(ejs, 6, "        \"%s\"", nsp->uri);
            }
        }
    }
#endif
}


/*
    @copy   default
  
    Copyright (c) Embedthis Software LLC, 2003-2010. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2010. All Rights Reserved.
  
    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.
  
    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html
  
    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
  
    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com
  
    @end
 */
/************************************************************************/
/*
 *  End of file "../src/vm/ejsScope.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../src/vm/ejsService.c"
 */
/************************************************************************/

/**
    ejsService.c - Ejscript interpreter factory

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */




static void allocFailure(Ejs *ejs, uint size, uint total, bool granted);
static int  cloneMaster(Ejs *ejs, Ejs *master);
static int  configureEjs(Ejs *ejs);
static int  defineTypes(Ejs *ejs);
static int  destroyEjs(Ejs *ejs);
static int  loadStandardModules(Ejs *ejs, MprList *require);
static int  runSpecificMethod(Ejs *ejs, cchar *className, cchar *methodName);
static int  searchForMethod(Ejs *ejs, cchar *methodName, EjsType **typeReturn);

/*
    Global singleton for the Ejs service
 */
EjsService *_globalEjsService;

/*  
    Initialize the EJS subsystem
 */
EjsService *ejsCreateService(MprCtx ctx)
{
    EjsService  *sp;

    sp = mprAllocObjZeroed(ctx, EjsService);
    if (sp == 0) {
        return 0;
    }
    _globalEjsService = sp;
    sp->nativeModules = mprCreateHash(sp, -1);
    return sp;
}


EjsService *ejsGetService(MprCtx ctx)
{
    return _globalEjsService;
}


/*  
    Create a new interpreter
    @param master Master interpreter to clone for rapid-startup
    @param searchPath Array of paths to search for modules. Must be persistent.
    @param require List of modules to pre-load
 */
Ejs *ejsCreateVm(MprCtx ctx, Ejs *master, cchar *searchPath, MprList *require, int flags)
{
    Ejs     *ejs;

    /*  
        Create interpreter structure
     */
    ejs = mprAllocObjWithDestructorZeroed(ctx, Ejs, destroyEjs);
    if (ejs == 0) {
        return 0;
    }
    mprSetAllocCallback(ejs, (MprAllocFailure) allocFailure);
    ejs->service = _globalEjsService;
    ejs->empty = require && mprGetListCount(require) == 0;
    ejs->heap = mprAllocHeap(ejs, "Ejs Object Heap", 1, 0, NULL);
    ejs->mutex = mprCreateLock(ejs);
    if (ejs->service->http == 0) {
        ejs->service->http = httpCreate(ejs->service);
    }
    ejs->http = ejs->service->http;

    ejs->flags |= (flags & (EJS_FLAG_NO_INIT | EJS_FLAG_DOC));
    ejs->dispatcher = mprCreateDispatcher(ejs, "ejsDispatcher", 1);

    if ((ejs->bootSearch = searchPath) == 0) {
        ejs->bootSearch = getenv("EJSPATH");
    }
    if (ejsInitStack(ejs) < 0) {
        mprFree(ejs);
        return 0;
    }
    ejsCreateGCService(ejs);
    ejsSetGeneration(ejs, EJS_GEN_ETERNAL);

    if (master == 0) {
        ejs->modules = mprCreateList(ejs);
        ejs->workers = mprCreateList(ejs);
        ejs->coreTypes = mprCreateHash(ejs, 0);
        ejs->standardSpaces = mprCreateHash(ejs, 0);
        
        if (defineTypes(ejs) < 0 || loadStandardModules(ejs, require) < 0) {
            if (ejs->exception) {
                ejsReportError(ejs, "Can't initialize interpreter");
            }
            mprFree(ejs);
            return 0;
        }
    } else {
        cloneMaster(ejs, master);
    }
    ejsFreezeGlobal(ejs);
    ejsMakeEternalPermanent(ejs);

    if (mprHasAllocError(ejs)) {
        mprError(ejs, "Memory allocation error during initialization");
        mprFree(ejs);
        return 0;
    }
    ejsCollectGarbage(ejs, EJS_GEN_ETERNAL);
    ejsSetGeneration(ejs, EJS_GEN_NEW);
    return ejs;
}


static int destroyEjs(Ejs *ejs)
{
    EjsState    *state;

    ejsDestroyGCService(ejs);
    state = ejs->masterState;
    if (state->stackBase) {
        mprMapFree(state->stackBase, state->stackSize);
    }
    mprFree(ejs->heap);
	return 0;
}


EjsTypeHelpers *ejsCloneObjectHelpers(Ejs *ejs, cchar *name)
{
    EjsTypeHelpers  *helpers;

    if (ejs->objectType) {
        helpers = (EjsTypeHelpers*) mprMemdup(ejs, ejs->objectType->helpers, sizeof(EjsTypeHelpers));
        if (helpers) {
            helpers->name = name;
        }
        return helpers;
    }
    return 0;
}


EjsTypeHelpers *ejsCloneBlockHelpers(Ejs *ejs, cchar *name)
{
    EjsTypeHelpers  *helpers;

    helpers = (EjsTypeHelpers*) mprMemdup(ejs, ejs->blockType->helpers, sizeof(EjsTypeHelpers));
    if (helpers) {
        helpers->name = name;
    }
    return helpers;
}


/*  
    Create the core language types. These are native types and are created prior to loading ejs.mod.
    The loader then matches these types to the loaded definitions.
 */
static int defineTypes(Ejs *ejs)
{
    /*  
        Create the essential bootstrap types: Object, Type and the global object, these are the foundation.
        All types are instances of Type. Order matters here.
     */
    ejsCreateObjectType(ejs);
    ejsCreateBlockType(ejs);
    ejsCreateTypeType(ejs);
    ejsCreateNullType(ejs);
    ejsCreateNamespaceType(ejs);
    ejsCreateFunctionType(ejs);
    ejsCreateFrameType(ejs);
    ejsCreateGlobalBlock(ejs);

    /*
        These types are used by the compiler. Must work with an empty interpreter. Order does not matter.
     */
    ejsCreateArrayType(ejs);
    ejsCreateBooleanType(ejs);
    ejsCreateErrorType(ejs);
    ejsCreateIteratorType(ejs);
    ejsCreateVoidType(ejs);
    ejsCreateNumberType(ejs);
    ejsCreateRegExpType(ejs);
    ejsCreateStringType(ejs);
    ejsCreateXMLType(ejs);
    ejsCreateXMLListType(ejs);

    /*  
        Define the native module configuration routines.
     */
    ejsAddNativeModule(ejs->service, "ejs", configureEjs, _ES_CHECKSUM_ejs, 0);

#if BLD_FEATURE_EJS_ALL_IN_ONE || BLD_FEATURE_STATIC
#if BLD_FEATURE_SQLITE
    ejs_db_sqlite_Init(ejs);
#endif
    ejs_web_Init(ejs);
#endif
    
    if (ejs->hasError || mprHasAllocError(ejs)) {
        mprError(ejs, "Can't create core types");
        return EJS_ERR;
    }
    return 0;
}


/*  
    This will configure all the core types by defining native methods and properties
 */
static int configureEjs(Ejs *ejs)
{
    /* 
        Order matters
     */
    ejsConfigureGlobalBlock(ejs);
    ejsConfigureObjectType(ejs);
    ejsConfigureIteratorType(ejs);
    ejsConfigureErrorType(ejs);
    ejsConfigureNullType(ejs);
    ejsConfigureBooleanType(ejs);
    ejsConfigureVoidType(ejs);
    ejsConfigureNumberType(ejs);

    ejsConfigurePathType(ejs);
    ejsConfigureFileSystemType(ejs);
    ejsConfigureFileType(ejs);
    ejsConfigureAppType(ejs);
    ejsConfigureArrayType(ejs);
    ejsConfigureByteArrayType(ejs);
    ejsConfigureConfigType(ejs);
    ejsConfigureDateType(ejs);
    ejsConfigureEventType(ejs);
    ejsConfigureFunctionType(ejs);
    ejsConfigureGCType(ejs);
    ejsConfigureHttpType(ejs);
    ejsConfigureJSONType(ejs);
    ejsConfigureMathType(ejs);
    ejsConfigureMemoryType(ejs);
    ejsConfigureNamespaceType(ejs);
    ejsConfigureReflectType(ejs);
    ejsConfigureRegExpType(ejs);
    ejsConfigureSocketType(ejs);
    ejsConfigureStringType(ejs);
    ejsConfigureSystemType(ejs);
    ejsConfigureTimerType(ejs);
    ejsConfigureUriType(ejs);
    ejsConfigureWorkerType(ejs);
    ejsConfigureXMLType(ejs);
    ejsConfigureXMLListType(ejs);

    ejsInitSearchPath(ejs);
    ejs->initialized = 1;
    return 0;
}


/*  
    Preload standard modules. If require is NULL, then load the standard set.
    Otherwise only load those specified in require.
 */
static int loadStandardModules(Ejs *ejs, MprList *require)
{
    char    *name;
    int     rc, next, ver;

    rc = 0;

    ver = 0;
    if (require) {
        for (next = 0; rc == 0 && (name = mprGetNextItem(require, &next)) != 0; ) {
            rc += ejsLoadModule(ejs, name, ver, ver, EJS_LOADER_STRICT);
        }
    } else {
        rc += ejsLoadModule(ejs, "ejs", ver, ver, EJS_LOADER_STRICT);
    }
    return rc;
}


/* 
   When cloning the master interpreter, the new interpreter references the master's core types. The core types MUST
    be immutable for this to work.
 */
static int cloneMaster(Ejs *ejs, Ejs *master)
{
    EjsName     qname;
    EjsObj      *vp;
    EjsTrait    *trait;
    int         i, count;

    mprAssert(master);

    ejs->master = master;
    ejs->service = master->service;

    //  TODO - OPT

    ejs->objectType = master->objectType;
    ejs->arrayType = master->arrayType;
    ejs->blockType = master->blockType;
    ejs->booleanType = master->booleanType;
    ejs->byteArrayType = master->byteArrayType;
    ejs->dateType = master->dateType;
    ejs->errorType = master->errorType;
    ejs->eventType = master->eventType;
    ejs->errorEventType = master->errorEventType;
    ejs->functionType = master->functionType;
    ejs->iteratorType = master->iteratorType;
    ejs->namespaceType = master->namespaceType;
    ejs->nullType = master->nullType;
    ejs->numberType = master->numberType;
    ejs->objectType = master->objectType;
    ejs->pathType = master->pathType;
    ejs->requestType = master->requestType;
    ejs->regExpType = master->regExpType;
    ejs->stringType = master->stringType;
    ejs->stopIterationType = master->stopIterationType;
    ejs->typeType = master->typeType;
    ejs->voidType = master->voidType;
    ejs->webType = master->webType;
    ejs->workerType = master->workerType;

    ejs->emptyStringValue = master->emptyStringValue;
    ejs->falseValue = master->falseValue;
    ejs->infinityValue = master->infinityValue;
    ejs->minusOneValue = master->minusOneValue;
    ejs->nanValue = master->nanValue;
    ejs->negativeInfinityValue = master->negativeInfinityValue;
    ejs->nullValue = master->nullValue;
    ejs->oneValue = master->oneValue;
    ejs->trueValue = master->trueValue;
    ejs->undefinedValue = master->undefinedValue;
    ejs->zeroValue = master->zeroValue;

    ejs->emptySpace = master->emptySpace;
    ejs->ejsSpace = master->ejsSpace;
    ejs->iteratorSpace = master->iteratorSpace;
    ejs->internalSpace = master->internalSpace;
    ejs->publicSpace = master->publicSpace;

    ejs->argv = master->argv;
    ejs->argc = master->argc;
    ejs->coreTypes = master->coreTypes;
    ejs->standardSpaces = master->standardSpaces;

    ejs->modules = mprDupList(ejs, master->modules);

    ejs->xmlType = master->xmlType;
    ejs->xmlListType = master->xmlListType;

    ejs->sqlite = master->sqlite;

    ejs->globalBlock = ejsCreateBlock(ejs, master->globalBlock->obj.sizeSlots);
    ejs->global = (EjsObj*) ejs->globalBlock; 
    ejsSetDebugName(ejs->global, "global");
    ejs->global->numSlots = master->global->numSlots;

    //  TODO what about traits
    ejs->global->numSlots = master->global->numSlots;

    ejsCopyList(ejs->globalBlock, &ejs->globalBlock->namespaces, &master->globalBlock->namespaces);

    /*
        Copy global properties. If the type is immutable (!dynamic) then just copy the reference, else clone.
     */ 
    count = ejsGetPropertyCount(master, master->global);
    for (i = 0; i < count; i++) {
        vp = ejsGetProperty(ejs, master->global, i);
        if (vp) {
            if (ejsIsType(vp) && !vp->dynamic) {
                ejsSetProperty(ejs, ejs->global, i, ejsGetProperty(master, master->global, i));
            } else {
                ejsSetProperty(ejs, ejs->global, i, ejsClone(ejs, vp, 1));
            }
            qname = ejsGetPropertyName(master, master->global, i);
            ejsSetPropertyName(ejs, ejs->global, i, &qname);
            trait = ejsGetTrait(master->global, i);
            if (trait) {
                ejsSetPropertyTrait(ejs, ejs->global, i, trait->type, trait->attributes);
            }
        }
    }
    ejsSetProperty(ejs, ejs->global, ES_global, ejs->global);
    ejs->initialized = 1;
    return 0;
}


/*  
    Notifier callback function. Invoked by mprAlloc on allocation errors. This will prevent the allocation error
    bubbling up to the global memory failure handler.
 */
static void allocFailure(Ejs *ejs, uint size, uint total, bool granted)
{
    MprAlloc    *alloc;
    EjsObj      *argv[2], *thisObj;
    char        msg[MPR_MAX_STRING];
#if BLD_WIN_LIKE
    va_list     dummy = {0};
#else
    va_list     dummy = {{0}};
#endif

    alloc = mprGetAllocStats(ejs);
    if (granted) {
        if (ejs->memoryCallback) {
            argv[0] = (EjsObj*) ejsCreateNumber(ejs, size);
            argv[1] = (EjsObj*) ejsCreateNumber(ejs, total);
            thisObj = ejs->memoryCallback->thisObj ? ejs->memoryCallback->thisObj : ejs->global; 
            ejsRunFunction(ejs, ejs->memoryCallback, thisObj, 2, argv);
        }
        if (!ejs->exception) {
            mprSprintf(msg, sizeof(msg), "Low memory condition. Total mem: %d. Request for %d bytes granted.", 
                total, size);
            ejsCreateException(ejs, ES_MemoryError, msg, dummy);
        }
    } else {
        if (!ejs->exception) {
            mprSprintf(msg, sizeof(msg), "Memory depleted. Total mem: %d. Request for %d bytes denied.", total, size);
            ejsCreateException(ejs, ES_MemoryError, msg, dummy);
        }
    }
}


void ejsInitSearchPath(Ejs *ejs)
{
    if (ejs->bootSearch) {
        ejs->search = ejsCreateSearchPath(ejs, ejs->bootSearch);
    } else {
        ejs->search = ejsCreateSearchPath(ejs, NULL);
    }
}

/*
    Set the module search path
 */
void ejsSetSearchPath(Ejs *ejs, EjsArray *paths)
{
    mprAssert(ejs);
    mprAssert(paths && paths);
    mprAssert(ejsIsArray(paths));

    ejs->search = paths;
}


/*  
    Create a default module search path. For example:
        APP_EXE_DIR/../modules : APP_EXE_DIR : /usr/lib/ejs/1.0.0/modules : .
 */
EjsArray *ejsCreateSearchPath(Ejs *ejs, cchar *search)
{
    EjsObj      *ap;
    char        *dir, *next, *tok;

    ap = (EjsObj*) ejsCreateArray(ejs, 0);

    if (search) {
        next = mprStrdup(ejs, search);
        dir = mprStrTok(next, MPR_SEARCH_SEP, &tok);
        while (dir && *dir) {
            ejsSetProperty(ejs, ap, -1, (EjsObj*) ejsCreatePath(ejs, dir));
            dir = mprStrTok(NULL, MPR_SEARCH_SEP, &tok);
        }
        mprFree(next);
        return (EjsArray*) ap;
    }
#if VXWORKS
    ejsSetProperty(ejs, ap, -1, (EjsObj*) ejsCreatePathAndFree(ejs, mprGetCurrentPath(ejs)));
#elif WIN
    ejsSetProperty(ejs, ap, -1, (EjsObj*) ejsCreatePathAndFree(ejs, mprGetAppDir(ejs)));
#else
{
    char *relModDir;
    relModDir = mprAsprintf(ejs, -1, "%s/../%s", mprGetAppDir(ejs), BLD_MOD_NAME);
    ejsSetProperty(ejs, ap, -1, (EjsObj*) ejsCreatePath(ejs, "."));
    ejsSetProperty(ejs, ap, -1, (EjsObj*) ejsCreatePath(ejs, mprGetAppDir(ejs)));
    ejsSetProperty(ejs, ap, -1, (EjsObj*) ejsCreatePathAndFree(ejs, mprGetAbsPath(ejs, relModDir)));
    ejsSetProperty(ejs, ap, -1, (EjsObj*) ejsCreatePath(ejs, BLD_MOD_PREFIX));
}
#endif
    return (EjsArray*) ap;
}


EjsObj *ejsGetGlobalObject(Ejs *ejs)
{
    return (EjsObj*) ejs->global;
}


#if FUTURE
void ejsSetServiceLocks(EjsService *sp, EjsLockFn lock, EjsUnlockFn unlock, void *data)
{
    mprAssert(sp);

    sp->lock = lock;
    sp->unlock = unlock;
    sp->lockData = data;
    return 0;
}
#endif


/*  
    Evaluate a module file
 */
int ejsEvalModule(cchar *path)
{
    EjsService      *service;   
    Ejs             *ejs;
    Mpr             *mpr;

    mpr = mprCreate(0, NULL, NULL);
    if ((service = ejsCreateService(mpr)) == 0) {
        mprFree(mpr);
        return MPR_ERR_NO_MEMORY;
    }
    if ((ejs = ejsCreateVm(service, NULL, NULL, NULL, 0)) == 0) {
        mprFree(mpr);
        return MPR_ERR_NO_MEMORY;
    }
    if (ejsLoadModule(ejs, path, -1, -1, 0) < 0) {
        mprFree(mpr);
        return MPR_ERR_CANT_READ;
    }
    if (ejsRun(ejs) < 0) {
        mprFree(mpr);
        return EJS_ERR;
    }
    mprFree(mpr);
    return 0;
}


/*  
    Run a program. This is called from the dispatcher event loop.
 */
static int runProgram(Ejs *ejs, MprEvent *event)
{
    /*
        Run all module initialization code. This includes plain old scripts.
     */
    if (ejsRun(ejs) < 0) {
        return EJS_ERR;
    }
    if (ejs->className || ejs->methodName) {
        if (runSpecificMethod(ejs, ejs->className, ejs->methodName) < 0) {
            return EJS_ERR;
        }
    }
    return 0;
}


int ejsRunProgram(Ejs *ejs, cchar *className, cchar *methodName)
{
    ejs->className = className;
    ejs->methodName = methodName;
    mprRelayEvent(ejs->dispatcher, (MprEventProc) runProgram, ejs, NULL);

    if (ejs->flags & EJS_FLAG_NOEXIT) {
        /*
            If the script calls App.noexit(), this will service events until App.exit() is called.
            TODO - should deprecate noexit()
         */
        mprServiceEvents(ejs->dispatcher, -1, 0);
    }
    if (ejs->exception) {
        return -1;
    }
    return 0;
}


/*  
    Run the specified method in the named class. If methodName is null, default to "main".
    If className is null, search for the first class containing the method name.
 */
static int runSpecificMethod(Ejs *ejs, cchar *className, cchar *methodName)
{
    EjsType         *type;
    EjsFunction     *fun;
    EjsName         qname;
    EjsObj          *args;
    int             attributes, i;

    type = 0;
    if (className == 0 && methodName == 0) {
        return 0;
    }
    if (methodName == 0) {
        methodName = "main";
    }

    /*  
        Search for the first class with the given name
     */
    if (className == 0) {
        if (searchForMethod(ejs, methodName, &type) < 0) {
            return EJS_ERR;
        }
    } else {
        ejsName(&qname, EJS_PUBLIC_NAMESPACE, className);
        type = (EjsType*) ejsGetPropertyByName(ejs, ejs->global, &qname);
    }

    if (type == 0 || !ejsIsType(type)) {
        mprError(ejs, "Can't find class \"%s\"", className);
        return EJS_ERR;
    }

    ejsName(&qname, EJS_PUBLIC_NAMESPACE, methodName);
    fun = (EjsFunction*) ejsGetPropertyByName(ejs, (EjsObj*) type, &qname);
    if (fun == 0) {
        return MPR_ERR_CANT_ACCESS;
    }
    if (! ejsIsFunction(fun)) {
        mprError(ejs, "Property \"%s\" is not a function");
        return MPR_ERR_BAD_STATE;
    }

    attributes = ejsGetTypePropertyAttributes(ejs, (EjsObj*) type, fun->slotNum);
    if (!(attributes & EJS_PROP_STATIC)) {
        mprError(ejs, "Method \"%s\" is not declared static");
        return EJS_ERR;
    }
    args = (EjsObj*) ejsCreateArray(ejs, ejs->argc);
    for (i = 0; i < ejs->argc; i++) {
        ejsSetProperty(ejs, args, i, (EjsObj*) ejsCreateString(ejs, ejs->argv[i]));
    }
    if (ejsRunFunction(ejs, fun, 0, 1, &args) == 0) {
        return EJS_ERR;
    }
    return 0;
}


/*  
    Add the listener function. The event emitter is created on-demand.
 */
int ejsAddListener(Ejs *ejs, EjsObj **emitterPtr, EjsObj *name, EjsObj *listener)
{
    EjsObj      *emitter, *argv[2];
    EjsArray    *list;
    int         i;

    if (*emitterPtr == 0) {
        *emitterPtr = ejsCreateInstance(ejs, ejsGetTypeByName(ejs, EJS_EJS_NAMESPACE, "Emitter"), 0, NULL);
    }
    emitter = *emitterPtr;

    argv[1] = listener;
    if (ejsIsArray(name)) {
        list = (EjsArray*) name;
        for (i = 0; i < list->length; i++) {
            name = ejsGetProperty(ejs, (EjsObj*) list, i);
            if (!ejsIsNull(name)) {
                argv[0] = name;
                ejsRunFunctionBySlot(ejs, emitter, ES_Emitter_addListener, 2, argv);
            }
        }
    } else {
        argv[0] = name;
        ejsRunFunctionBySlot(ejs, emitter, ES_Emitter_addListener, 2, argv);
    }
    return 0;
}


#if ES_Emitter_hasListeners
int ejsHasListeners(Ejs *ejs, EjsObj *emitter)
{
    if (emitter) {
        ejsRunFunctionBySlot(ejs, emitter, ES_Emitter_hasListeners, 0, NULL);
    }
    return 0;
}
#endif


int ejsRemoveListener(Ejs *ejs, EjsObj *emitter, EjsObj *name, EjsObj *listener)
{
    EjsObj      *argv[2];
    EjsArray    *list;
    int         i;

    if (emitter) {
        argv[1] = listener;
        if (ejsIsArray(name)) {
            list = (EjsArray*) name;
            for (i = 0; i < list->length; i++) {
                name = ejsGetProperty(ejs, (EjsObj*) list, i);
                if (!ejsIsNull(name)) {
                    argv[0] = name;
                    ejsRunFunctionBySlot(ejs, emitter, ES_Emitter_removeListener, 2, argv);
                }
            }
        } else {
            argv[0] = name;
            ejsRunFunctionBySlot(ejs, emitter, ES_Emitter_removeListener, 2, argv);
        }
    }
    return 0;
}


int ejsSendEventv(Ejs *ejs, EjsObj *emitter, cchar *name, int argc, EjsObj **argv)
{
    EjsObj      **av;
    int         i;

    if (emitter) {
        av = (EjsObj**) mprAlloc(emitter, (argc + 1) * sizeof(EjsObj*));
        av[0] = (EjsObj*) ejsCreateString(ejs, name);
        for (i = 0; i < argc; i++) {
            av[i + 1] = argv[i];
        }
        //  TODO - rename fire or send()
        ejsRunFunctionBySlot(ejs, emitter, ES_Emitter_emit, argc + 1, av);
        mprFree(av);
    }
    return 0;
}


int ejsSendEvent(Ejs *ejs, EjsObj *emitter, cchar *name, EjsObj *arg)
{
    EjsObj      **argv;

    argv = &arg;
    return ejsSendEventv(ejs, emitter, name, 1, argv);
}


/*  
    Search for the named method in all types.
 */
static int searchForMethod(Ejs *ejs, cchar *methodName, EjsType **typeReturn)
{
    EjsFunction *method;
    EjsType     *type;
    EjsName     qname;
    EjsObj      *global, *vp;
    int         globalCount, slotNum, methodCount;
    int         methodSlot;

    mprAssert(methodName && *methodName);
    mprAssert(typeReturn);

    global = ejs->global;
    globalCount = ejsGetPropertyCount(ejs, global);

    /*  
        Search for the named method in all types
     */
    for (slotNum = 0; slotNum < globalCount; slotNum++) {
        vp = ejsGetProperty(ejs, global, slotNum);
        if (vp == 0 || !ejsIsType(vp)) {
            continue;
        }
        type = (EjsType*) vp;

        methodCount = ejsGetPropertyCount(ejs, (EjsObj*) type);

        for (methodSlot = 0; methodSlot < methodCount; methodSlot++) {
            method = (EjsFunction*) ejsGetProperty(ejs, (EjsObj*) type, methodSlot);
            if (method == 0) {
                continue;
            }

            qname = ejsGetPropertyName(ejs, (EjsObj*) type, methodSlot);
            if (qname.name && strcmp(qname.name, methodName) == 0) {
                *typeReturn = type;
            }
        }
    }
    return 0;
}


static void logHandler(MprCtx ctx, int flags, int level, const char *msg)
{
    Mpr         *mpr;
    MprFile     *file;
    char        *prefix;

    mpr = mprGetMpr();
    file = (MprFile*) mpr->logHandlerData;
    prefix = mpr->name;

    while (*msg == '\n') {
        mprFprintf(file, "\n");
        msg++;
    }

    if (flags & MPR_LOG_SRC) {
        mprFprintf(file, "%s: %d: %s\n", prefix, level, msg);

    } else if (flags & MPR_ERROR_SRC) {

        /*  
            Use static printing to avoid malloc when the messages are small.
            This is important for memory allocation errors.
         */
        if (strlen(msg) < (MPR_MAX_STRING - 32)) {
            mprStaticPrintfError(file, "%s: Error: %s\n", prefix, msg);
        } else {
            mprFprintf(file, "%s: Error: %s\n", prefix, msg);
        }

    } else if (flags & MPR_FATAL_SRC) {
        mprFprintf(file, "%s: Fatal: %s\n", prefix, msg);
        
    } else if (flags & MPR_RAW) {
        mprFprintf(file, "%s", msg);
    }
}


int ejsStartLogging(Mpr *mpr, char *logSpec)
{
    MprFile     *file;
    char        *levelSpec;
    int         level;

    level = 0;
    logSpec = mprStrdup(mpr, logSpec);

    if ((levelSpec = strchr(logSpec, ':')) != 0) {
        *levelSpec++ = '\0';
        level = atoi(levelSpec);
    }

    if (strcmp(logSpec, "stdout") == 0) {
        file = mpr->fileSystem->stdOutput;

    } else if (strcmp(logSpec, "stderr") == 0) {
        file = mpr->fileSystem->stdError;

    } else {
        if ((file = mprOpen(mpr, logSpec, O_CREAT | O_WRONLY | O_TRUNC | O_TEXT, 0664)) == 0) {
            mprPrintfError(mpr, "Can't open log file %s\n", logSpec);
            mprFree(logSpec);
            return EJS_ERR;
        }
    }

    mprSetLogLevel(mpr, level);
    mprSetLogHandler(mpr, logHandler, (void*) file);

    mprFree(logSpec);
    return 0;
}


/*  
    Global memory allocation handler. This is invoked when there is no notifier to handle an allocation failure.
    The interpreter has an allocFailure (see ejsService: allocFailure) and it will handle allocation errors.
 */
void ejsMemoryFailure(MprCtx ctx, int64 size, int64 total, bool granted)
{
    if (!granted) {
        mprPrintfError(ctx, "Can't allocate memory block of size %d\n", size);
        mprPrintfError(ctx, "Total memory used %d\n", total);
        exit(255);
    }
    mprPrintfError(ctx, "Memory request for %d bytes exceeds memory red-line\n", size);
    mprPrintfError(ctx, "Total memory used %d\n", total);
}


void ejsReportError(Ejs *ejs, char *fmt, ...)
{
    va_list     arg;
    const char  *msg;
    char        *buf;

    va_start(arg, fmt);
    
    /*  
        Compiler error format is:
            program:line:errorCode:SEVERITY: message
        Where program is either "ec" or "ejs"
        Where SEVERITY is either "error" or "warn"
     */
    buf = mprVasprintf(ejs, 0, fmt, arg);
    msg = ejsGetErrorMsg(ejs, 1);
    
    mprError(ejs, "%s", (msg) ? msg: buf);
    mprFree(buf);
    va_end(arg);
}


void ejsLockVm(Ejs *ejs)
{
    mprLock(ejs->mutex);
}


void ejsUnlockVm(Ejs *ejs)
{
    mprUnlock(ejs->mutex);
}

/*
    @copy   default
 
    Copyright (c) Embedthis Software LLC, 2003-2010. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2010. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    @end
 */
/************************************************************************/
/*
 *  End of file "../src/vm/ejsService.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../src/vm/ejsVar.c"
 */
/************************************************************************/

/**
    ejsVar.c - Helper methods for the ejsVar interface.

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */




static MprNumber parseNumber(Ejs *ejs, cchar *str);
static bool      parseBoolean(Ejs *ejs, cchar *s);

/*
    Get the type owning a property
    MOB -- remove this function when have tested script over native
 */
static inline EjsType *getOwningType(EjsObj *vp, int slotNum)
{
    EjsType     *type;

    type = vp->type;

#if UNUSED && MOB
    if (type->instanceSize != sizeof(EjsObject)) {
        if (vp->isType) {
            if (slotNum < type->numInherited) {
                do {
                    type = type->baseType;
                } while (slotNum < type->numInherited);
            }
        } else if (type->prototype) {
            if (slotNum < type->numPrototypeInherited) {
                do {
                    type = type->baseType;
                } while (slotNum < type->numPrototypeInherited);
            }
        }
    }
#endif
    return type;
}

/**
    Cast the variable to a given target type.
    @return Returns a variable with the result of the cast or null if an exception is thrown.
 */
EjsObj *ejsCast(Ejs *ejs, EjsObj *vp, EjsType *type)
{
    EjsFunction     *fun;

    mprAssert(ejs);
    mprAssert(type);

    if (vp == 0) {
        vp = ejs->undefinedValue;
    }
    if (vp->type == type) {
        return vp;
    }
#if FUTURE
    EjsName         qname;
    if (type->hasMeta) {
        return ejsRunFunctionByName(ejs, (EjsObj*) type, ejsName(&qname, EJS_META_NAMESPACE, "cast"), (EjsObj*) type, 1, &vp);
        if ((slotNum = ejsLookupProperty(ejs, (EjsObj*) type, ejsName(&qname, EJS_META_NAMESPACE, "cast"))) >= 0) {
            type->hasMeta
        }
    }
#endif
    if (type == ejs->stringType) {
        if (vp == 0) {
            return (EjsObj*) ejsCreateString(ejs, "undefined");
        } else if (ejsIsString(vp)) {
            return (EjsObj*) vp;
        }
        if (vp->type->block.obj.numSlots >= ES_Object_toString) {
            fun = (EjsFunction*) ejsGetProperty(ejs, (EjsObj*) vp->type, ES_Object_toString);
            if (ejsIsFunction(fun) && fun->override) {
                return (EjsObj*) ejsRunFunction(ejs, fun, vp, 0, NULL);
            }
        }
    }
    if (vp->type->helpers->cast) {
        return (vp->type->helpers->cast)(ejs, vp, type);
    }
    ejsThrowInternalError(ejs, "Cast helper not defined for type \"%s\"", vp->type->qname.name);
    return 0;
}


/*
    Create a new instance of a variable. Delegate to the type specific create.
 */
EjsObj *ejsCreate(Ejs *ejs, EjsType *type, int numSlots)
{
#if VXWORKS
    /*
     *  The VxWorks cc386 invoked linker crashes without this test. Ugh!
     */
    if (type == 0) {
        return 0;
    }
#endif
    mprAssert(type->helpers->create);
    return (type->helpers->create)(ejs, type, numSlots);
}


/**
    Copy a variable by copying all properties. If a property is a reference  type, just copy the reference.
    See ejsDeepClone for a complete recursive copy of all reference contents.
    @return Returns a variable or null if an exception is thrown.
 */
EjsObj *ejsClone(Ejs *ejs, EjsObj *vp, bool deep)
{
    EjsObj  *result;
    
    if (vp == 0) {
        return 0;
    }
    mprAssert(vp->type->helpers->clone);
    if (vp->visited == 0) {
        vp->visited = 1;
        result = (vp->type->helpers->clone)(ejs, vp, deep);
        vp->visited = 0;
    } else {
        result = vp;
    }
    return result;
}


/*
    Define a property and its traits.
    @return Return the slot number allocated for the property.
 */
int ejsDefineProperty(Ejs *ejs, EjsObj *vp, int slotNum, EjsName *name, EjsType *propType, int attributes, EjsObj *value)
{
    mprAssert(name);
    mprAssert(name->name);
    mprAssert(name->space);
    
    mprAssert(vp->type->helpers->defineProperty);
    return (vp->type->helpers->defineProperty)(ejs, vp, slotNum, name, propType, attributes, value);
}


/**
    Delete a property in an object variable. The stack is unchanged.
    @return Returns a status code.
 */
int ejsDeleteProperty(Ejs *ejs, EjsObj *vp, int slotNum)
{
    EjsType     *type;

    mprAssert(slotNum >= 0);
    
    type = getOwningType(vp, slotNum);
    mprAssert(type->helpers->deleteProperty);
    return (type->helpers->deleteProperty)(ejs, vp, slotNum);
}


/**
    Delete a property in an object variable. The stack is unchanged.
    @return Returns a status code.
 */
int ejsDeletePropertyByName(Ejs *ejs, EjsObj *vp, EjsName *qname)
{
    EjsLookup   lookup;
    int         slotNum;

    mprAssert(qname);
    mprAssert(qname->name);
    mprAssert(qname->space);
    
    if (vp->type->helpers->deletePropertyByName) {
        return (vp->type->helpers->deletePropertyByName)(ejs, vp, qname);
    } else {
        slotNum = ejsLookupVar(ejs, vp, qname, &lookup);
        if (slotNum < 0) {
            ejsThrowReferenceError(ejs, "Property \"%s\" does not exist", qname->name);
            return 0;
        }
        return ejsDeleteProperty(ejs, vp, slotNum);
    }
}


void ejsDestroy(Ejs *ejs, EjsObj *vp)
{
    EjsType     *type;

    mprAssert(vp);

    type = vp->type;
    mprAssert(type->helpers->destroy);
    (type->helpers->destroy)(ejs, vp);
}


/**
    Get a property at a given slot in a variable.
    @return Returns the requested property varaible.
 */
EjsObj *ejsGetProperty(Ejs *ejs, EjsObj *vp, int slotNum)
{
    EjsType     *type;

    mprAssert(ejs);
    mprAssert(vp);
    mprAssert(slotNum >= 0);

    type = getOwningType(vp, slotNum);
    mprAssert(type->helpers->getProperty);
    return (type->helpers->getProperty)(ejs, vp, slotNum);
}


/*
    Get a property given a name.
 */
EjsObj *ejsGetPropertyByName(Ejs *ejs, EjsObj *vp, EjsName *name)
{
    int     slotNum;

    mprAssert(ejs);
    mprAssert(vp);
    mprAssert(name);

    /*
     *  WARNING: this is not implemented by most types
     */
    if (vp->type->helpers->getPropertyByName) {
        return (vp->type->helpers->getPropertyByName)(ejs, vp, name);
    }

    /*
     *  Fall back and use a two-step lookup and get
     */
    slotNum = ejsLookupProperty(ejs, vp, name);
    if (slotNum < 0) {
        return 0;
    }
    return ejsGetProperty(ejs, vp, slotNum);
}


/**
    Return the number of properties in the variable.
    @return Returns the number of properties.
 */
int ejsGetPropertyCount(Ejs *ejs, EjsObj *vp)
{
    mprAssert(vp->type->helpers->getPropertyCount);
    return (vp->type->helpers->getPropertyCount)(ejs, vp);
}


/**
    Return the name of a property indexed by slotNum.
    @return Returns the property name.
 */
EjsName ejsGetPropertyName(Ejs *ejs, EjsObj *vp, int slotNum)
{
    EjsType     *type;

    type = getOwningType(vp, slotNum);
    mprAssert(type->helpers->getPropertyName);
    return (type->helpers->getPropertyName)(ejs, vp, slotNum);
}


/**
    Return the trait for the indexed by slotNum.
    @return Returns the property name.
 */
EjsTrait *ejsGetPropertyTrait(Ejs *ejs, EjsObj *vp, int slotNum)
{
    EjsType     *type;

    type = getOwningType(vp, slotNum);
    mprAssert(type->helpers->getPropertyTrait);
    return (type->helpers->getPropertyTrait)(ejs, vp, slotNum);
}


/**
    Get a property slot. Lookup a property name and return the slot reference. If a namespace is supplied, the property
    must be defined with the same namespace.
    @return Returns the slot number or -1 if it does not exist.
 */
int ejsLookupProperty(Ejs *ejs, EjsObj *vp, EjsName *name)
{
    mprAssert(ejs);
    mprAssert(vp);
    mprAssert(name);
    mprAssert(name->name);
    mprAssert(name->space);

    mprAssert(vp->type->helpers->lookupProperty);
    return (vp->type->helpers->lookupProperty)(ejs, vp, name);
}


/*
    Invoke an operator.
    vp is left-hand-side
    @return Return a variable with the result or null if an exception is thrown.
 */
EjsObj *ejsInvokeOperator(Ejs *ejs, EjsObj *vp, int opCode, EjsObj *rhs)
{
    mprAssert(vp);

    mprAssert(vp->type->helpers->invokeOperator);
    return (vp->type->helpers->invokeOperator)(ejs, vp, opCode, rhs);
}


/*
    ejsMark is in ejsGarbage.c
 */


/*
    Set a property and return the slot number. Incoming slot may be -1 to allocate a new slot.
 */
int ejsSetProperty(Ejs *ejs, EjsObj *vp, int slotNum, EjsObj *value)
{
    mprAssert(vp);
    if (vp == 0) {
        ejsThrowReferenceError(ejs, "Object is null");
        return EJS_ERR;
    }
    mprAssert(vp->type->helpers->setProperty);
    return (vp->type->helpers->setProperty)(ejs, vp, slotNum, value);
}


/*
    Set a property given a name.
 */
int ejsSetPropertyByName(Ejs *ejs, EjsObj *vp, EjsName *qname, EjsObj *value)
{
    int     slotNum;

    mprAssert(ejs);
    mprAssert(vp);
    mprAssert(qname);

    /*
     *  WARNING: Not all types implement this
     */
    if (vp->type->helpers->setPropertyByName) {
        return (vp->type->helpers->setPropertyByName)(ejs, vp, qname, value);
    }

    /*
        Fall back and use a two-step lookup and get
     */
    slotNum = ejsLookupProperty(ejs, vp, qname);
    if (slotNum < 0) {
        slotNum = ejsSetProperty(ejs, vp, -1, value);
        if (slotNum < 0) {
            return EJS_ERR;
        }
        if (ejsSetPropertyName(ejs, vp, slotNum, qname) < 0) {
            return EJS_ERR;
        }
        return slotNum;
    }
    return ejsSetProperty(ejs, vp, slotNum, value);
}


/*
    Set the property name and return the slot number. Slot may be -1 to allocate a new slot.
 */
int ejsSetPropertyName(Ejs *ejs, EjsObj *vp, int slot, EjsName *qname)
{
    mprAssert(vp->type->helpers->setPropertyName);
    return (vp->type->helpers->setPropertyName)(ejs, vp, slot, qname);
}


int ejsSetPropertyTrait(Ejs *ejs, EjsObj *vp, int slot, EjsType *propType, int attributes)
{
    mprAssert(vp->type->helpers->setPropertyTrait);
    return (vp->type->helpers->setPropertyTrait)(ejs, vp, slot, propType, attributes);
}


/**
    Get a string representation of a variable.
    @return Returns a string variable or null if an exception is thrown.
 */
EjsString *ejsToString(Ejs *ejs, EjsObj *vp)
{
    return (EjsString*) ejsCast(ejs, vp, ejs->stringType);
#if OLD
    EjsFunction     *fn;

    if (vp == 0) {
        return ejsCreateString(ejs, "undefined");
    } else if (ejsIsString(vp)) {
        return (EjsString*) vp;
    }
    if (vp->type->block.obj.numSlots >= ES_Object_toString) {
        fn = (EjsFunction*) ejsGetProperty(ejs, (EjsObj*) vp->type, ES_Object_toString);
        if (ejsIsFunction(fn)) {
            return (EjsString*) ejsRunFunction(ejs, fn, vp, 0, NULL);
        }
    }
    if (vp->type->helpers->cast) {
        return (EjsString*) (vp->type->helpers->cast)(ejs, vp, ejs->stringType);
    }
    ejsThrowInternalError(ejs, "CastVar helper not defined for type \"%s\"", vp->type->qname.name);
    return 0;
#endif
}


/**
    Get a numeric representation of a variable.
    @return Returns a number variable or null if an exception is thrown.
 */
EjsNumber *ejsToNumber(Ejs *ejs, EjsObj *vp)
{
    if (vp == 0 || ejsIsNumber(vp)) {
        return (EjsNumber*) vp;
    }
    if (vp->type->helpers->cast) {
        return (EjsNumber*) (vp->type->helpers->cast)(ejs, vp, ejs->numberType);
    }
    ejsThrowInternalError(ejs, "CastVar helper not defined for type \"%s\"", vp->type->qname.name);
    return 0;
}


/**
    Get a boolean representation of a variable.
    @return Returns a number variable or null if an exception is thrown.
 */
EjsBoolean *ejsToBoolean(Ejs *ejs, EjsObj *vp)
{
    if (vp == 0 || ejsIsBoolean(vp)) {
        return (EjsBoolean*) vp;
    }
    if (vp->type->helpers->cast) {
        return (EjsBoolean*) (vp->type->helpers->cast)(ejs, vp, ejs->booleanType);
    }
    ejsThrowInternalError(ejs, "CastVar helper not defined for type \"%s\"", vp->type->qname.name);
    return 0;
}


/**
    Get a serialized string representation of a variable using JSON encoding.
    @return Returns a string variable or null if an exception is thrown.
 */
EjsString *ejsToJSON(Ejs *ejs, EjsObj *vp, EjsObj *options)
{
    EjsFunction     *fn;
    EjsString       *result;
    EjsObj          *argv[1];
    int             argc;

    if (vp == 0) {
        return ejsCreateString(ejs, "undefined");
    }
    if (vp->jsonVisited) {
        return ejsCreateString(ejs, "this");
    }    
    vp->jsonVisited = 1;
    
    fn = (EjsFunction*) ejsGetProperty(ejs, (EjsObj*) vp->type, ES_Object_toJSON);
    if (ejsIsFunction(fn)) {
        if (options) {
            argc = 1;
            argv[0] = options;
        } else {
            argc = 0;
            argv[0] = NULL;
        }
        result = (EjsString*) ejsRunFunction(ejs, fn, vp, argc, argv);
    } else {
        result = ejsToString(ejs, vp);
    }
    vp->jsonVisited = 0;
    return result;
}


/*
    Fully construct a new object. We create a new instance and call all required constructors.
 */
EjsObj *ejsCreateInstance(Ejs *ejs, EjsType *type, int argc, EjsObj **argv)
{
    EjsFunction     *fun;
    EjsObj          *vp;
    int             slotNum;

    mprAssert(type);

    vp = ejsCreate(ejs, type, 0);
    if (vp == 0) {
        ejsThrowMemoryError(ejs);
        return 0;
    }
    if (type->hasConstructor) {
        slotNum = type->numInherited;
        fun = (EjsFunction*) ejsGetProperty(ejs, (EjsObj*) type, slotNum);
        if (fun == 0) {
            return 0;
        }
        if (!ejsIsFunction(fun)) {
            return 0;
        }
        vp->permanent = 1;
        ejsRunFunction(ejs, fun, vp, argc, argv);
        vp->permanent = 0;
    }
    return vp;
}



int _ejsIs(EjsObj *vp, int slot)
{
    EjsType     *tp;

    if (vp == 0) {
        return 0;
    }
    if (vp->type->id == slot) {
        return 1;
    }
    for (tp = ((EjsObj*) vp)->type->baseType; tp; tp = tp->baseType) {
        if (tp->id == slot) {
            return 1;
        }
    }
    return 0;
}


EjsName *ejsAllocName(MprCtx ctx, cchar *name, cchar *space)
{
    EjsName     *np;

    np = mprAllocObj(ctx, EjsName);
    if (np) {
        np->name = mprStrdup(np, name);
        np->space = mprStrdup(np, space);
    }
    return np;
}


EjsName ejsCopyName(MprCtx ctx, EjsName *qname)
{
    EjsName     name;

    name.name = mprStrdup(ctx, qname->name);
    name.space = mprStrdup(ctx, qname->space);
    return name;
}


EjsName *ejsDupName(MprCtx ctx, EjsName *qname)
{
    return ejsAllocName(ctx, qname->name, qname->space);
}


EjsName *ejsName(EjsName *np, cchar *space, cchar *name)
{
    np->name = name;
    np->space = space;
    return np;
}


/*
    Parse a string based on formatting instructions and intelligently create a variable.
    Number formats:
        [(+|-)][0][OCTAL_DIGITS]
        [(+|-)][0][(x|X)][HEX_DIGITS]
        [(+|-)][DIGITS]
        [+|-][DIGITS][.][DIGITS][(e|E)[+|-]DIGITS]
 */
EjsObj *ejsParse(Ejs *ejs, cchar *buf, int preferredType)
{
    int         type;

    mprAssert(buf);

    type = preferredType;

    if (preferredType == ES_Void || preferredType < 0) {
        if (*buf == '-' || *buf == '+') {
            type = ejs->numberType->id;

        } else if (*buf == '/') {
            type = ES_RegExp;

        } else if (!isdigit((int) *buf) && *buf != '.') {
            if (strcmp(buf, "true") == 0) {
                return (EjsVar*) ejs->trueValue;

            } else if (strcmp(buf, "false") == 0) {
                return (EjsVar*) ejs->falseValue;
            }
            type = ES_String;

            if (strcmp(buf, "true") == 0 || strcmp(buf, "false") == 0) {
                type = ES_Boolean;
            } else {
                type = ES_String;
            }

        } else {
            type = ES_Number;
        }
    }
    switch (type) {
    case ES_Object:
    case ES_Void:
    case ES_Null:
    default:
        break;

    case ES_Number:
        return (EjsObj*) ejsCreateNumber(ejs, parseNumber(ejs, buf));

    case ES_Boolean:
        return (EjsObj*) ejsCreateBoolean(ejs, parseBoolean(ejs, buf));

    case ES_RegExp:
        return (EjsObj*) ejsCreateRegExp(ejs, buf);

    case ES_String:
        if (strcmp(buf, "null") == 0) {
            return (EjsObj*) ejsCreateNull(ejs);

        } else if (strcmp(buf, "undefined") == 0) {
            return (EjsObj*) ejsCreateUndefined(ejs);
        }
        return (EjsObj*) ejsCreateString(ejs, buf);
    }
    return (EjsObj*) ejsCreateUndefined(ejs);
}


/*
    Convert the variable to a number type. Only works for primitive types.
 */
static bool parseBoolean(Ejs *ejs, cchar *s)
{
    if (s == 0 || *s == '\0') {
        return 0;
    }
    if (strcmp(s, "false") == 0 || strcmp(s, "FALSE") == 0) {
        return 0;
    }
    return 1;
}


/*
    Convert the string buffer to a Number.
 */
static MprNumber parseNumber(Ejs *ejs, cchar *str)
{
    MprNumber   n;
    cchar       *cp;
    int64       num;
    int         radix, c, negative;

    mprAssert(str);

    num = 0;
    negative = 0;

    if (*str == '-') {
        str++;
        negative = 1;
    } else if (*str == '+') {
        str++;
    }

    if (*str != '.' && !isdigit((int) *str)) {
        return ejs->nanValue->value;
    }

    /*
        Floatng format: [DIGITS].[DIGITS][(e|E)[+|-]DIGITS]
     */
    if (!(*str == '0' && tolower((int) str[1]) == 'x')) {
        for (cp = str; *cp; cp++) {
            if (*cp == '.' || tolower((int) *cp) == 'e') {
                n = atof(str);
                if (negative) {
                    n = (0.0 - n);
                }
                return n;
            }
        }
    }

    /*
        Parse an integer. Observe hex and octal prefixes (0x, 0).
     */
    if (*str != '0') {
        /*
         *  Normal numbers (Radix 10)
         */
        while (isdigit((int) *str)) {
            num = (*str - '0') + (num * 10);
            str++;
        }
    } else {
        str++;
        if (tolower((int) *str) == 'x') {
            str++;
            radix = 16;
            while (*str) {
                c = tolower((int) *str);
                if (isdigit(c)) {
                    num = (c - '0') + (num * radix);
                } else if (c >= 'a' && c <= 'f') {
                    num = (c - 'a' + 10) + (num * radix);
                } else {
                    break;
                }
                str++;
            }

        } else{
            radix = 8;
            while (*str) {
                c = tolower((int) *str);
                if (isdigit(c) && c < '8') {
                    num = (c - '0') + (num * radix);
                } else {
                    break;
                }
                str++;
            }
        }
    }

    if (negative) {
        return (MprNumber) (0 - num);
    }
    return (MprNumber) num;
}


MprNumber _ejsGetNumber(Ejs *ejs, EjsObj *vp)
{
    mprAssert(vp);
    if (!ejsIsNumber(vp)) {
        if ((vp = ejsCast(ejs, vp, ejs->numberType)) == 0) {
            return 0;
        }
    }
    mprAssert(ejsIsNumber(vp));
    return (vp) ? ((EjsNumber*) (vp))->value: 0;
}


int _ejsGetBoolean(Ejs *ejs, EjsObj *vp)
{
    mprAssert(vp);
    if (!ejsIsBoolean(vp)) {
        if ((vp = ejsCast(ejs, vp, ejs->booleanType)) == 0) {
            return 0;
        }
    }
    mprAssert(ejsIsBoolean(vp));
    return (vp) ? ((EjsBoolean*) (vp))->value: 0;
}


int _ejsGetInt(Ejs *ejs, EjsObj *vp)
{
    mprAssert(vp);
    if (!ejsIsNumber(vp)) {
        if ((vp = ejsCast(ejs, vp, ejs->numberType)) == 0) {
            return 0;
        }
    }
    mprAssert(ejsIsNumber(vp));
    return (vp) ? ((int) (((EjsNumber*) (vp))->value)): 0;
}


double _ejsGetDouble(Ejs *ejs, EjsObj *vp)
{
    mprAssert(vp);
    if (!ejsIsNumber(vp)) {
        if ((vp = ejsCast(ejs, vp, ejs->numberType)) == 0) {
            return 0;
        }
    }
    mprAssert(ejsIsNumber(vp));
    return (vp) ? ((double) (((EjsNumber*) (vp))->value)): 0;
}


cchar *_ejsGetString(Ejs *ejs, EjsObj *vp)
{
    mprAssert(vp);
    if (!ejsIsString(vp)) {
        if ((vp = ejsCast(ejs, vp, ejs->stringType)) == 0) {
            return "";
        }
    }
    mprAssert(ejsIs(vp, ES_String));
    return (vp) ? (((EjsString*) vp)->value): "";
}


/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2010. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2010. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    @end
 */
/************************************************************************/
/*
 *  End of file "../src/vm/ejsVar.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../src/core/src/ejsApp.c"
 */
/************************************************************************/

/*
    ejsApp.c -- App class
    Copyright (c) All Rights Reserved. See details at the end of the file.
 */



/*  
    Get the application command line arguments
    static function get args(): String
 */
static EjsObj *getArgs(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    EjsArray    *args;
    int         i;

    args = ejsCreateArray(ejs, ejs->argc);
    for (i = 0; i < ejs->argc; i++) {
        ejsSetProperty(ejs, (EjsObj*) args, i, (EjsObj*) ejsCreateString(ejs, ejs->argv[i]));
    }
    return (EjsObj*) args;
}


/*  
    Get the current working directory
    function get dir(): Path
 */
static EjsObj *currentDir(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreatePathAndFree(ejs, mprGetCurrentPath(ejs));
}


/*  
    Set the current working directory
    function chdir(value: String|Path): void
 */
static EjsObj *changeCurrentDir(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    cchar   *path;

    mprAssert(argc == 1);

    if (ejsIsPath(ejs, argv[0])) {
        path = ((EjsPath*) argv[0])->path;
    } else if (ejsIsString(argv[0])) {
        path = ejsGetString(ejs, argv[0]);
    } else {
        ejsThrowIOError(ejs, "Bad path");
        return NULL;
    }

    if (chdir((char*) path) < 0) {
        ejsThrowIOError(ejs, "Can't change the current directory");
    }
    return 0;
}

/*  
    Get an environment var
    function getenv(key: String): String
 */
static EjsObj *getEnvVar(Ejs *ejs, EjsObj *app, int argc, EjsObj **argv)
{
    cchar   *value;

    value = getenv(ejsGetString(ejs, argv[0]));
    if (value == 0) {
        return (EjsObj*) ejs->nullValue;
    }
    return (EjsObj*) ejsCreateString(ejs, value);
}


/*  
    Put an environment var
    function putenv(key: String, value: String): void
 */
static EjsObj *putEnvVar(Ejs *ejs, EjsObj *app, int argc, EjsObj **argv)
{
#if !WINCE
#if BLD_UNIX_LIKE
    char    *key, *value;

    key = mprStrdup(ejs, ejsGetString(ejs, argv[0]));
    value = mprStrdup(ejs, ejsGetString(ejs, argv[1]));
    setenv(key, value, 1);
#else
    char   *cmd;

    cmd = mprStrcat(app, -1, ejsGetString(ejs, argv[0]), "=", ejsGetString(ejs, argv[1]), NULL);
    putenv(cmd);
#endif
#endif
    return 0;
}


/*  
    Get the directory containing the application's executable file.
    static function get exeDir(): Path
 */
static EjsObj *exeDir(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreatePath(ejs, mprGetAppDir(ejs));
}


/*  
    Get the application's executable filename.
    static function get exePath(): Path
 */
static EjsObj *exePath(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreatePath(ejs, mprGetAppPath(ejs));
}


/*  
    Exit the application
    static function exit(status: Number): void
 */
static EjsObj *exitApp(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    int     status;

    status = argc == 0 ? 0 : ejsGetInt(ejs, argv[0]);
    mprBreakpoint();
    //  TODO -- Make more uniform. Zero status won't exit immediately but non-zero will????
    if (status != 0) {
        exit(status);
    } else {
        mprTerminate(mprGetMpr(), 1);
        ejsAttention(ejs);
    }
    return 0;
}


/*  
    Control if the application will exit when the last script completes.
    static function noexit(exit: Boolean): void
 */
static EjsObj *noexit(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    ejs->flags |= EJS_FLAG_NOEXIT;
    return 0;
}


/*  
    Get the ejs module search path. Does not actually read the environment.
    function get search(): Array
 */
static EjsObj *getSearch(Ejs *ejs, EjsObj *app, int argc, EjsObj **argv)
{
    return (EjsObj*) ejs->search;
}


/*  
    Set the ejs module search path. Does not actually update the environment.
    function set search(path: Array): Void
 */
static EjsObj *setSearch(Ejs *ejs, EjsObj *app, int argc, EjsObj **argv)
{
    ejsSetSearchPath(ejs, (EjsArray*) argv[0]);
    return 0;
}


/*  
    Get a default search path. NOTE: this does not modify ejs->search.
    function get createSearch(searchPaths: String): Void
 */
static EjsObj *createSearch(Ejs *ejs, EjsObj *app, int argc, EjsObj **argv)
{
    cchar   *searchPath;

    searchPath = (argc == 0) ? NULL : ejsGetString(ejs, argv[0]);
    return (EjsObj*) ejsCreateSearchPath(ejs, searchPath);
}


/*  
    Need this routine because ejs->exiting must be tested for workers
 */
void ejsServiceEvents(Ejs *ejs, int timeout, int flags)
{
    MprTime     expires;
    int         rc, remaining;

    if (timeout < 0) {
        timeout = MPR_MAX_TIMEOUT;
    }
    expires = mprGetTime(ejs) + timeout;
    remaining = timeout;
    do {
        rc = mprServiceEvents(ejs->dispatcher, remaining, MPR_SERVICE_ONE_THING);
        if (rc > 0 && flags & MPR_SERVICE_ONE_THING) {
            break;
        }
        remaining = (int) (expires - mprGetTime(ejs));
    } while (remaining >= 0 && !mprIsExiting(ejs) && !ejs->exiting);
}


/*  
    static function serviceEvents(timeout: Number = -1, oneEvent: Boolean = false): void
 */
static EjsObj *serviceEvents(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    int     timeout, oneEvent;

    timeout = (argc > 0) ? ejsGetInt(ejs, argv[0]) : MPR_MAX_TIMEOUT;
    oneEvent = (argc > 1) ? (argv[1] == ejs->trueValue) : 0;
    ejsServiceEvents(ejs, timeout, oneEvent ? MPR_SERVICE_ONE_THING: 0);
    return 0;
}


/*  
    Pause the application
    static function sleep(delay: Number = -1): void
 */
static EjsObj *sleepProc(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    int         timeout;

    timeout = (argc > 0) ? ejsGetInt(ejs, argv[0]): MPR_MAX_TIMEOUT;
    ejsServiceEvents(ejs, timeout, MPR_SERVICE_NAP);
    return 0;
}



void ejsConfigureAppType(Ejs *ejs)
{
    EjsType         *type;

    type = ejs->appType = ejsGetTypeByName(ejs, EJS_EJS_NAMESPACE, "App");
    mprAssert(type);

    ejsSetProperty(ejs, (EjsObj*) type, ES_App__inputStream,
        (EjsObj*) ejsCreateFileFromFd(ejs, 1, "stdin", O_WRONLY));
    ejsSetProperty(ejs, (EjsObj*) type, ES_App__errorStream,
        (EjsObj*) ejsCreateFileFromFd(ejs, 1, "stderr", O_WRONLY));
    ejsSetProperty(ejs, (EjsObj*) type, ES_App__outputStream,
        (EjsObj*) ejsCreateFileFromFd(ejs, 1, "stdout", O_WRONLY));

    ejsBindMethod(ejs, type, ES_App_args, (EjsProc) getArgs);
    ejsBindMethod(ejs, type, ES_App_dir, (EjsProc) currentDir);
    ejsBindMethod(ejs, type, ES_App_chdir, (EjsProc) changeCurrentDir);
    ejsBindMethod(ejs, type, ES_App_exeDir, (EjsProc) exeDir);
    ejsBindMethod(ejs, type, ES_App_exePath, (EjsProc) exePath);
    ejsBindMethod(ejs, type, ES_App_exit, (EjsProc) exitApp);
    ejsBindMethod(ejs, type, ES_App_getenv, (EjsProc) getEnvVar);
    ejsBindMethod(ejs, type, ES_App_putenv, (EjsProc) putEnvVar);
    ejsBindMethod(ejs, type, ES_App_noexit, (EjsProc) noexit);
    ejsBindMethod(ejs, type, ES_App_createSearch, (EjsProc) createSearch);
    ejsBindAccess(ejs, type, ES_App_search, (EjsProc) getSearch, (EjsProc) setSearch);
    ejsBindMethod(ejs, type, ES_App_serviceEvents, (EjsProc) serviceEvents);
    ejsBindMethod(ejs, type, ES_App_sleep, (EjsProc) sleepProc);

#if FUTURE
    (ejs, type, ES_App_permissions, (EjsProc) getPermissions,
        ES_App_set_permissions, (EjsProc) setPermissions);
#endif
}


/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2010. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2010. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    @end
 */
/************************************************************************/
/*
 *  End of file "../src/core/src/ejsApp.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../src/core/src/ejsArray.c"
 */
/************************************************************************/

/**
    ejsArray.c - Ejscript Array class

    This module implents the standard Array type. It provides the type methods and manages the special "length" property.
    The array elements with numeric indicies are stored in EjsArray.data[]. Non-numeric properties are stored in EjsArray.obj

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */




static int  checkSlot(Ejs *ejs, EjsArray *ap, int slotNum);
static bool compareArrayElement(Ejs *ejs, EjsObj *v1, EjsObj *v2);
static int growArray(Ejs *ejs, EjsArray *ap, int len);
static int lookupArrayProperty(Ejs *ejs, EjsArray *ap, EjsName *qname);
static EjsObj *pushArray(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv);
static EjsObj *spliceArray(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv);
static EjsObj *arrayToString(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv);

static EjsObj *makeIntersection(Ejs *ejs, EjsArray *lhs, EjsArray *rhs);
static EjsObj *makeUnion(Ejs *ejs, EjsArray *lhs, EjsArray *rhs);
static EjsObj *removeArrayElements(Ejs *ejs, EjsArray *lhs, EjsArray *rhs);

/*
    Create a new array
 */
static EjsArray *createArray(Ejs *ejs, EjsType *type, int numSlots)
{
    EjsArray     *ap;

    ap = (EjsArray*) ejsCreateObject(ejs, ejs->arrayType, 0);
    if (ap == 0) {
        return 0;
    }
    ap->length = 0;
#if FUTURE
    /*
        Clear isObject because we must NOT use direct slot access in the VM
     */ 
    ap->obj.isObject = 0;
#endif
    return ap;
}


/*
    Cast the object operand to a primitive type
 */
static EjsObj *castArray(Ejs *ejs, EjsArray *vp, EjsType *type)
{
    switch (type->id) {
    case ES_Boolean:
        return (EjsObj*) ejs->trueValue;

    case ES_Number:
        return (EjsObj*) ejs->zeroValue;

    case ES_String:
        return arrayToString(ejs, vp, 0, 0);

    default:
        ejsThrowTypeError(ejs, "Can't cast to this type");
        return 0;
    }
}


static EjsArray *cloneArray(Ejs *ejs, EjsArray *ap, bool deep)
{
    EjsArray    *newArray;
    EjsObj      **dest, **src;
    int         i;

    newArray = (EjsArray*) ejsCloneObject(ejs, (EjsObj*) ap, deep);
    if (newArray == 0) {
        ejsThrowMemoryError(ejs);
        return 0;
    }
    if (ap->length > 0) {
        if (growArray(ejs, newArray, ap->length) < 0) {
            ejsThrowMemoryError(ejs);
            return 0;
        }
        src = ap->data;
        dest = newArray->data;

        if (deep) {
            for (i = 0; i < ap->length; i++) {
                dest[i] = ejsClone(ejs, src[i], 1);
            }
        } else {
            memcpy(dest, src, ap->length * sizeof(EjsObj*));
        }
    }
    return newArray;
}


//  TODO - can remove as free var will do this automatically
static void destroyArray(Ejs *ejs, EjsArray *ap)
{
    mprAssert(ap);

    mprFree(ap->data);
    ap->data = 0;
    ejsFree(ejs, (EjsObj*) ap, -1);
}


/*
    Delete a property and update the length
 */
static int deleteArrayProperty(Ejs *ejs, EjsArray *ap, int slot)
{
    if (slot >= ap->length) {
        mprAssert(0);
        return EJS_ERR;
    }
    if (ejsSetProperty(ejs, (EjsObj*) ap, slot, (EjsObj*) ejs->undefinedValue) < 0) {
        return EJS_ERR;
    }
    if ((slot + 1) == ap->length) {
        ap->length--;
    }
    return 0;
}


/*
    Delete an element by name.
 */
static int deleteArrayPropertyByName(Ejs *ejs, EjsArray *ap, EjsName *qname)
{
    if (isdigit((int) qname->name[0])) {
        return deleteArrayProperty(ejs, ap, atoi(qname->name));
    }
    return (ejs->objectType->helpers->deletePropertyByName)(ejs, (EjsObj*) ap, qname);
}


/*
    Return the number of elements in the array
 */
static int getArrayPropertyCount(Ejs *ejs, EjsArray *ap)
{
    return ap->length;
}


/*
    Get an array element. Slot numbers correspond to indicies.
 */
static EjsObj *getArrayProperty(Ejs *ejs, EjsArray *ap, int slotNum)
{
    if (slotNum < 0 || slotNum >= ap->length) {
        return ejs->undefinedValue;
    }
    return ap->data[slotNum];
}


static EjsObj *getArrayPropertyByName(Ejs *ejs, EjsArray *ap, EjsName *qname)
{
    int     slotNum;

    if (isdigit((int) qname->name[0])) { 
        slotNum = atoi(qname->name);
        if (slotNum < 0 || slotNum >= ap->length) {
            return 0;
        }
        return getArrayProperty(ejs, ap, slotNum);
    }

    /* The "length" property is a method getter */
    if (strcmp(qname->name, "length") == 0) {
        return 0;
    }
    slotNum = (ejs->objectType->helpers->lookupProperty)(ejs, (EjsObj*) ap, qname);
    if (slotNum < 0) {
        return 0;
    }
    return (ejs->objectType->helpers->getProperty)(ejs, (EjsObj*) ap, slotNum);
}


/*
    Lookup an array index.
 */
static int lookupArrayProperty(Ejs *ejs, EjsArray *ap, EjsName *qname)
{
    int     index;

    if (qname == 0 || !isdigit((int) qname->name[0])) {
        return EJS_ERR;
    }
    index = atoi(qname->name);
    if (index < ap->length) {
        return index;
    }

    return EJS_ERR;
}


/*
    Cast operands as required for invokeArrayOperator
 */
static EjsObj *coerceArrayOperands(Ejs *ejs, EjsObj *lhs, int opcode,  EjsObj *rhs)
{
    switch (opcode) {
    /*
        Binary operators
     */
    case EJS_OP_ADD:
        return ejsInvokeOperator(ejs, arrayToString(ejs, (EjsArray*) lhs, 0, 0), opcode, rhs);

    case EJS_OP_AND: case EJS_OP_DIV: case EJS_OP_MUL: case EJS_OP_OR: case EJS_OP_REM:
    case EJS_OP_SHL: case EJS_OP_SHR: case EJS_OP_SUB: case EJS_OP_USHR: case EJS_OP_XOR:
        return ejsInvokeOperator(ejs, (EjsObj*) ejs->zeroValue, opcode, rhs);

    case EJS_OP_COMPARE_EQ: case EJS_OP_COMPARE_NE:
        if (ejsIsNull(rhs) || ejsIsUndefined(rhs)) {
            return (EjsObj*) ((opcode == EJS_OP_COMPARE_EQ) ? ejs->falseValue: ejs->trueValue);
        } else if (ejsIsNumber(rhs)) {
            return ejsInvokeOperator(ejs, (EjsObj*) ejsToNumber(ejs, lhs), opcode, rhs);
        }
        return ejsInvokeOperator(ejs, (EjsObj*) ejsToString(ejs, lhs), opcode, rhs);

    case EJS_OP_COMPARE_LE: case EJS_OP_COMPARE_LT:
    case EJS_OP_COMPARE_GE: case EJS_OP_COMPARE_GT:
        if (ejsIsNumber(rhs)) {
            return ejsInvokeOperator(ejs, (EjsObj*) ejsToNumber(ejs, lhs), opcode, rhs);
        }
        return ejsInvokeOperator(ejs, (EjsObj*) ejsToString(ejs, lhs), opcode, rhs);

    case EJS_OP_COMPARE_STRICTLY_NE:
    case EJS_OP_COMPARE_UNDEFINED:
    case EJS_OP_COMPARE_NOT_ZERO:
    case EJS_OP_COMPARE_NULL:
        return (EjsObj*) ejs->trueValue;

    case EJS_OP_COMPARE_STRICTLY_EQ:
    case EJS_OP_COMPARE_FALSE:
    case EJS_OP_COMPARE_TRUE:
    case EJS_OP_COMPARE_ZERO:
        return (EjsObj*) ejs->falseValue;

    /*
        Unary operators
     */
    case EJS_OP_LOGICAL_NOT: case EJS_OP_NOT: case EJS_OP_NEG:
        return 0;

    default:
        ejsThrowTypeError(ejs, "Opcode %d not valid for type %s", opcode, lhs->type->qname.name);
        return ejs->undefinedValue;
    }
    return 0;
}


static EjsObj *invokeArrayOperator(Ejs *ejs, EjsObj *lhs, int opcode,  EjsObj *rhs)
{
    EjsObj      *result;

    if (rhs == 0 || lhs->type != rhs->type) {
        if ((result = coerceArrayOperands(ejs, lhs, opcode, rhs)) != 0) {
            return result;
        }
    }

    switch (opcode) {

    case EJS_OP_COMPARE_EQ: case EJS_OP_COMPARE_STRICTLY_EQ:
    case EJS_OP_COMPARE_LE: case EJS_OP_COMPARE_GE:
        return (EjsObj*) ejsCreateBoolean(ejs, (lhs == rhs));

    case EJS_OP_COMPARE_NE: case EJS_OP_COMPARE_STRICTLY_NE:
    case EJS_OP_COMPARE_LT: case EJS_OP_COMPARE_GT:
        return (EjsObj*) ejsCreateBoolean(ejs, !(lhs == rhs));

    /*
        Unary operators
     */
    case EJS_OP_COMPARE_NOT_ZERO:
        return (EjsObj*) ejs->trueValue;

    case EJS_OP_COMPARE_UNDEFINED:
    case EJS_OP_COMPARE_NULL:
    case EJS_OP_COMPARE_FALSE:
    case EJS_OP_COMPARE_TRUE:
    case EJS_OP_COMPARE_ZERO:
        return (EjsObj*) ejs->falseValue;

    case EJS_OP_LOGICAL_NOT: case EJS_OP_NOT: case EJS_OP_NEG:
        return (EjsObj*) ejs->oneValue;

    /*
        Binary operators
     */
    case EJS_OP_DIV: case EJS_OP_MUL: case EJS_OP_REM:
    case EJS_OP_SHR: case EJS_OP_USHR: case EJS_OP_XOR:
        return (EjsObj*) ejs->zeroValue;

#if EXTENSIONS || 1
    /*
        Operator overload
     */
    case EJS_OP_ADD:
        result = (EjsObj*) ejsCreateArray(ejs, 0);
        pushArray(ejs, (EjsArray*) result, 1, (EjsObj**) &lhs);
        pushArray(ejs, (EjsArray*) result, 1, (EjsObj**) &rhs);
        return result;

    case EJS_OP_AND:
        return (EjsObj*) makeIntersection(ejs, (EjsArray*) lhs, (EjsArray*) rhs);

    case EJS_OP_OR:
        return (EjsObj*) makeUnion(ejs, (EjsArray*) lhs, (EjsArray*) rhs);

    case EJS_OP_SHL:
        return pushArray(ejs, (EjsArray*) lhs, 1, &rhs);

    case EJS_OP_SUB:
        return (EjsObj*) removeArrayElements(ejs, (EjsArray*) lhs, (EjsArray*) rhs);
#endif

    default:
        ejsThrowTypeError(ejs, "Opcode %d not implemented for type %s", opcode, lhs->type->qname.name);
        return 0;
    }

    mprAssert(0);
}


static void markArrayVar(Ejs *ejs, EjsArray *ap)
{
    EjsObj          *vp;
    int             i;

    mprAssert(ejsIsArray(ap));

    ejsMarkObject(ejs, (EjsObj*) ap);
    for (i = ap->length - 1; i >= 0; i--) {
        if ((vp = ap->data[i]) != 0) {
            ejsMark(ejs, vp);
        }
    }
}


/*
    Create or update an array elements. If slotNum is < 0, then create the next free array slot. If slotNum is greater
    than the array length, grow the array.
 */
static int setArrayProperty(Ejs *ejs, EjsArray *ap, int slotNum,  EjsObj *value)
{
    if ((slotNum = checkSlot(ejs, ap, slotNum)) < 0) {
        return EJS_ERR;
    }
    ap->data[slotNum] = value;
    return slotNum;
}


static int setArrayPropertyByName(Ejs *ejs, EjsArray *ap, EjsName *qname, EjsObj *value)
{
    int     slotNum;

    if (!isdigit((int) qname->name[0])) { 
        /* The "length" property is a method getter */
        if (strcmp(qname->name, "length") == 0) {
            return EJS_ERR;
        }
        slotNum = (ejs->objectType->helpers->lookupProperty)(ejs, (EjsObj*) ap, qname);
        if (slotNum < 0) {
            slotNum = (ejs->objectType->helpers->setProperty)(ejs, (EjsObj*) ap, slotNum, value);
            if (slotNum < 0) {
                return EJS_ERR;
            }
            if ((ejs->objectType->helpers->setPropertyName)(ejs, (EjsObj*) ap, slotNum, qname) < 0) {
                return EJS_ERR;
            }
            return slotNum;

        } else {
            return (ejs->objectType->helpers->setProperty)(ejs, (EjsObj*) ap, slotNum, value);
        }
    }

    if ((slotNum = checkSlot(ejs, ap, atoi(qname->name))) < 0) {
        return EJS_ERR;
    }
    ap->data[slotNum] = value;

    return slotNum;
}


#if EXTENSIONS || 1
static EjsObj *makeIntersection(Ejs *ejs, EjsArray *lhs, EjsArray *rhs)
{
    EjsArray    *result;
    EjsObj      **l, **r, **resultSlots;
    int         i, j, k;

    result = ejsCreateArray(ejs, 0);
    l = lhs->data;
    r = rhs->data;

    for (i = 0; i < lhs->length; i++) {
        for (j = 0; j < rhs->length; j++) {
            if (compareArrayElement(ejs, l[i], r[j])) {
                resultSlots = result->data;
                for (k = 0; k < result->length; k++) {
                    if (compareArrayElement(ejs, l[i], resultSlots[k])) {
                        break;
                    }
                }
                if (result->length == 0 || k == result->length) {
                    setArrayProperty(ejs, result, -1, l[i]);
                }
            }
        }
    }
    return (EjsObj*) result;
}


static int addUnique(Ejs *ejs, EjsArray *ap, EjsObj *element)
{
    int     i;

    for (i = 0; i < ap->length; i++) {
        if (compareArrayElement(ejs, ap->data[i], element)) {
            break;
        }
    }
    if (i == ap->length) {
        if (setArrayProperty(ejs, ap, -1, element) < 0) {
            return EJS_ERR;
        }
    }
    return 0;
}


static EjsObj *makeUnion(Ejs *ejs, EjsArray *lhs, EjsArray *rhs)
{
    EjsArray    *result;
    EjsObj      **l, **r;
    int         i;

    result = ejsCreateArray(ejs, 0);

    l = lhs->data;
    r = rhs->data;

    for (i = 0; i < lhs->length; i++) {
        addUnique(ejs, result, l[i]);
    }
    for (i = 0; i < rhs->length; i++) {
        addUnique(ejs, result, r[i]);
    }
    return (EjsObj*) result;
}


static EjsObj *removeArrayElements(Ejs *ejs, EjsArray *lhs, EjsArray *rhs)
{
    EjsObj  **l, **r;
    int     i, j, k;

    l = lhs->data;
    r = rhs->data;

    for (j = 0; j < rhs->length; j++) {
        for (i = 0; i < lhs->length; i++) {
            if (compareArrayElement(ejs, l[i], r[j])) {
                for (k = i + 1; k < lhs->length; k++) {
                    l[k - 1] = l[k];
                }
                lhs->length--;
            }
        }
    }

    return (EjsObj*) lhs;
}
#endif


static int checkSlot(Ejs *ejs, EjsArray *ap, int slotNum)
{
    if (slotNum < 0) {
        if (!ap->obj.dynamic) {
            ejsThrowTypeError(ejs, "Object is not dynamic");
            return EJS_ERR;
        }
        
        slotNum = ap->length;
        if (growArray(ejs, ap, ap->length + 1) < 0) {
            ejsThrowMemoryError(ejs);
            return EJS_ERR;
        }

    } else if (slotNum >= ap->length) {
        if (growArray(ejs, ap, slotNum + 1) < 0) {
            ejsThrowMemoryError(ejs);
            return EJS_ERR;
        }
    }
    return slotNum;
}


/*
    Array constructor.

    function Array(...args): Array

    Support the forms:

        var arr = Array();
        var arr = Array(size);
        var arr = Array(elt, elt, elt, ...);
 */

static EjsObj *arrayConstructor(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv)
{
    EjsArray    *args;
    EjsObj      *arg0, **src, **dest;
    int         size, i;

    mprAssert(argc == 1 && ejsIsArray(argv[0]));

    args = (EjsArray*) argv[0];
    
    if (args->length == 0) {
        return 0;
    }

    size = 0;
    arg0 = getArrayProperty(ejs, args, 0);

    if (args->length == 1 && ejsIsNumber(arg0)) {
        /*
            x = new Array(size);
         */
        size = ejsGetInt(ejs, arg0);
        if (size > 0 && growArray(ejs, ap, size) < 0) {
            ejsThrowMemoryError(ejs);
            return 0;
        }

    } else {

        /*
            x = new Array(element0, element1, ..., elementN):
         */
        size = args->length;
        if (size > 0 && growArray(ejs, ap, size) < 0) {
            ejsThrowMemoryError(ejs);
            return 0;
        }

        src = args->data;
        dest = ap->data;
        for (i = 0; i < size; i++) {
            dest[i] = src[i];
        }
    }
    ap->length = size;

    return (EjsObj*) ap;
}


/*
    Append an item to an array

    function append(obj: Object) : Array
 */
static EjsObj *appendArray(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv)
{
    if (setArrayProperty(ejs, ap, ap->length, argv[0]) < 0) {
        return 0;
    }
    return (EjsObj*) ap;
}


/*
    Clear an array. Remove all elements of the array.

    function clear() : void
 */
static EjsObj *clearArray(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv)
{
    ap->length = 0;
    return 0;
}


/*
    Clone an array.

    function clone(deep: Boolean = false) : Array
 */
static EjsArray *cloneArrayMethod(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv)
{
    bool    deep;

    mprAssert(argc == 0 || ejsIsBoolean(argv[0]));

    deep = (argc == 1) ? ((EjsBoolean*) argv[0])->value : 0;

    return cloneArray(ejs, ap, deep);
}


/*
    Compact an array. Remove all null elements.

    function compact() : Array
 */
static EjsArray *compactArray(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv)
{
    EjsObj      **data, **src, **dest;
    int         i;

    data = ap->data;
    src = dest = &data[0];
    for (i = 0; i < ap->length; i++, src++) {
        if (*src == 0 || *src == ejs->undefinedValue || *src == ejs->nullValue) {
            continue;
        }
        *dest++ = *src;
    }
    ap->length = (int) (dest - &data[0]);
    return ap;
}


/*
    Concatenate the supplied elements with the array to create a new array. If any arguments specify an array,
    their elements are catenated. This is a one level deep copy.

    function concat(...args): Array
 */
static EjsObj *concatArray(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv)
{
    EjsArray    *args, *newArray, *vpa;
    EjsObj      *vp, **src, **dest;
    int         i, k, next;

    mprAssert(argc == 1 && ejsIsArray(argv[0]));

    args = ((EjsArray*) argv[0]);

    /*
        Guess the new array size. May exceed this if args has elements that are themselves arrays.
     */
    newArray = ejsCreateArray(ejs, ap->length + ((EjsArray*) argv[0])->length);

    src = ap->data;
    dest = newArray->data;

    /*
        Copy the original array
     */
    for (next = 0; next < ap->length; next++) {
        dest[next] = src[next];
    }

    /*
        Copy the args. If any element is itself an array, then flatten it and copy its elements.
     */
    for (i = 0; i < args->length; i++) {
        vp = args->data[i];
        if (ejsIsArray(vp)) {
            vpa = (EjsArray*) vp;
            if (growArray(ejs, newArray, newArray->length + vpa->length - 1) < 0) {
                ejsThrowMemoryError(ejs);
                return 0;
            }
            dest = newArray->data;
            for (k = 0; k < vpa->length; k++) {
                dest[next++] = vpa->data[k];
            }

        } else {
            dest[next++] = vp;
        }
    }
    return (EjsObj*) newArray;
}


/*
    Function to iterate and return the next element name.
    NOTE: this is not a method of Array. Rather, it is a callback function for Iterator
 */
static EjsObj *nextArrayKey(Ejs *ejs, EjsIterator *ip, int argc, EjsObj **argv)
{
    EjsArray        *ap;
    EjsObj          *vp, **data;

    ap = (EjsArray*) ip->target;
    if (!ejsIsArray(ap)) {
        ejsThrowReferenceError(ejs, "Wrong type");
        return 0;
    }
    data = ap->data;

    for (; ip->index < ap->length; ip->index++) {
        vp = data[ip->index];
        if (vp == 0) {
            continue;
        }
        return (EjsObj*) ejsCreateNumber(ejs, ip->index++);
    }
    ejsThrowStopIteration(ejs);
    return 0;
}


/*
    Return the default iterator. This returns the array index names.

    iterator native function get(): Iterator
 */
static EjsObj *getArrayIterator(Ejs *ejs, EjsObj *ap, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateIterator(ejs, ap, (EjsProc) nextArrayKey, 0, NULL);
}


/*
    Function to iterate and return the next element value.
    NOTE: this is not a method of Array. Rather, it is a callback function for Iterator
 */
static EjsObj *nextArrayValue(Ejs *ejs, EjsIterator *ip, int argc, EjsObj **argv)
{
    EjsArray    *ap;
    EjsObj      *vp, **data;

    ap = (EjsArray*) ip->target;
    if (!ejsIsArray(ap)) {
        ejsThrowReferenceError(ejs, "Wrong type");
        return 0;
    }

    data = ap->data;
    for (; ip->index < ap->length; ip->index++) {
        vp = data[ip->index];
        if (vp == 0) {
            continue;
        }
        ip->index++;
        return vp;
    }
    ejsThrowStopIteration(ejs);
    return 0;
}


/*
    Return an iterator to return the next array element value.

    iterator native function getValues(): Iterator
 */
static EjsObj *getArrayValues(Ejs *ejs, EjsObj *ap, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateIterator(ejs, ap, (EjsProc) nextArrayValue, 0, NULL);
}


#if KEEP
static EjsObj *find(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv)
{
    return 0;
}


/**
    Iterate over all elements in the object and find all elements for which the matching function is true.
    The match is called with the following signature:

        function match(arrayElement: Object, elementIndex: Number, arr: Array): Boolean

    @param match Matching function
    @return Returns a new array containing all matching elements.
 */
static EjsObj *findAll(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv)
{
    EjsObj      *funArgs[3];
    EjsBoolean  *result;
    EjsArray    *elements;
    int         i;

    mprAssert(argc == 1 && ejsIsFunction(argv[0]));

    elements = ejsCreateArray(ejs, 0);
    if (elements == 0) {
        ejsThrowMemoryError(ejs);
        return 0;
    }

    for (i = 0; i < ap->length; i++) {
        funArgs[0] = ap->obj.properties.slots[i];               /* Array element */
        funArgs[1] = (EjsObj*) ejsCreateNumber(ejs, i);             /* element index */
        funArgs[2] = (EjsObj*) ap;                                  /* Array */
        result = (EjsBoolean*) ejsRunFunction(ejs, (EjsFunction*) argv[0], 0, 3, funArgs);
        if (result == 0 || !ejsIsBoolean(result) || !result->value) {
            setArrayProperty(ejs, elements, elements->length, ap->obj.properties.slots[i]);
        }
    }
    return (EjsObj*) elements;
}
#endif


static bool compareArrayElement(Ejs *ejs, EjsObj *v1, EjsObj *v2)
{
    if (v1 == v2) {
        return 1;
    }
    if (v1->type != v2->type) {
        return 0;
    }
    if (ejsIsNumber(v1)) {
        return ((EjsNumber*) v1)->value == ((EjsNumber*) v2)->value;
    }
    if (ejsIsString(v1)) {
        return strcmp(((EjsString*) v1)->value, ((EjsString*) v2)->value) == 0;
    }
    return 0;
}


/*
    Search for an item using strict equality "===". This call searches from
    the start of the array for the specified element.
    @return Returns the items index into the array if found, otherwise -1.

    function indexOf(element: Object, startIndex: Number = 0): Number
 */
static EjsObj *indexOfArray(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv)
{
    EjsObj      *element;
    int         i, start;

    mprAssert(argc == 1 || argc == 2);

    element = argv[0];
    start = (argc == 2) ? (int) ((EjsNumber*) argv[1])->value : 0;

    if (start < 0) {
        start += ap->length;
    }
    if (start >= ap->length) {
        return (EjsObj*) ejs->minusOneValue;
    }
    if (start < 0) {
        start = 0;
    }
    for (i = start; i < ap->length; i++) {
        if (compareArrayElement(ejs, ap->data[i], element)) {
            return (EjsObj*) ejsCreateNumber(ejs, i);
        }
    }
    return (EjsObj*) ejs->minusOneValue;
}


/*
    Insert elements. Insert elements at the specified position. Negative indicies are measured from the end of the array.
    @return Returns a the original array.

    function insert(pos: Number, ...args): Array
 */
static EjsObj *insertArray(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv)
{
    EjsArray    *args;
    EjsObj      **src, **dest;
    int         i, pos, delta, oldLen, endInsert;

    mprAssert(argc == 2 && ejsIsArray(argv[1]));

    pos = ejsGetInt(ejs, argv[0]);
    if (pos < 0) {
        pos += ap->length;
    }
    if (pos < 0) {
        pos = 0;
    }
    if (pos >= ap->length) {
        pos = ap->length;
    }
    args = (EjsArray*) argv[1];

    oldLen = ap->length;
    if (growArray(ejs, ap, ap->length + args->length) < 0) {
        return 0;
    }

    delta = args->length;
    dest = ap->data;
    src = args->data;

    endInsert = pos + delta;
    for (i = ap->length - 1; i >= endInsert; i--) {
        dest[i] = dest[i - delta];
    }
    for (i = 0; i < delta; i++) {
        dest[pos++] = src[i];
    }

    return (EjsObj*) ap;
}


/*
    Joins the elements in the array into a single string.
    @param sep Element separator.
    @return Returns a string.

    function join(sep: String = undefined): String
 */
static EjsObj *joinArray(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv)
{
    EjsString       *result, *sep;
    EjsObj          *vp;
    int             i;

    if (argc == 1) {
        sep = (EjsString*) argv[0];
    } else {
        sep = 0;
    }

    result = ejsCreateString(ejs, "");
    for (i = 0; i < ap->length; i++) {
        vp = ap->data[i];
        if (vp == 0 || ejsIsUndefined(vp) || ejsIsNull(vp)) {
            continue;
        }
        if (i > 0 && sep) {
            ejsStrcat(ejs, result, (EjsObj*) sep);
        }
        ejsStrcat(ejs, result, vp);
    }
    return (EjsObj*) result;
}


/*
    Search for an item using strict equality "===". This call searches from
    the end of the array for the specified element.
    @return Returns the items index into the array if found, otherwise -1.

    function lastIndexOf(element: Object, fromIndex: Number = 0): Number
 */
static EjsObj *lastArrayIndexOf(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv)
{
    EjsObj          *element;
    int             i, start;

    mprAssert(argc == 1 || argc == 2);

    element = argv[0];
    start = ((argc == 2) ? (int) ((EjsNumber*) argv[1])->value : ap->length - 1);
    if (start < 0) {
        start += ap->length;
    }
    if (start >= ap->length) {
        start = ap->length - 1;
    }
    if (start < 0) {
        return (EjsObj*) ejs->minusOneValue;
    }
    for (i = start; i >= 0; i--) {
        if (compareArrayElement(ejs, ap->data[i], element)) {
            return (EjsObj*) ejsCreateNumber(ejs, i);
        }
    }
    return (EjsObj*) ejs->minusOneValue;
}


/*
    Get the length of an array.
    @return Returns the number of items in the array

    intrinsic override function get length(): Number
 */

static EjsObj *getArrayLength(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateNumber(ejs, ap->length);
}


/*
    Set the length of an array.

    intrinsic override function set length(value: Number): void
 */

static EjsObj *setArrayLength(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv)
{
    EjsObj      **data, **dest;
    int         length;

    mprAssert(argc == 1 && ejsIsNumber(argv[0]));
    mprAssert(ejsIsArray(ap));

    length = (int) ((EjsNumber*) argv[0])->value;

    if (length > ap->length) {
        if (growArray(ejs, ap, length) < 0) {
            return 0;
        }
        data = ap->data;
        for (dest = &data[ap->length]; dest < &data[length]; dest++) {
            *dest = 0;
        }
    }

    ap->length = length;
    return 0;
}


/*
    Remove and return the last value in the array.
    @return Returns the last element in the array.

    function pop(): Object
 */
static EjsObj *popArray(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv)
{
    if (ap->length == 0) {
        return (EjsObj*) ejs->undefinedValue;
    }
    return ap->data[--ap->length];
}


/*
    Append items to the end of the array.
    @return Returns the new length of the array.

    function push(...items): Number
 */
static EjsObj *pushArray(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv)
{
    EjsArray    *args;
    EjsObj      **src, **dest;
    int         i, oldLen;

    mprAssert(argc == 1 && ejsIsArray(argv[0]));

    args = (EjsArray*) argv[0];

    oldLen = ap->length;
    if (growArray(ejs, ap, ap->length + args->length) < 0) {
        return 0;
    }
    dest = ap->data;
    src = args->data;
    for (i = 0; i < args->length; i++) {
        dest[i + oldLen] = src[i];
    }
    return (EjsObj*) ejsCreateNumber(ejs, ap->length);
}


/*
    Reverse the order of the objects in the array. The elements are reversed in the original array.
    @return Returns a reference to the array.

    function reverse(): Array
 */
static EjsObj *reverseArray(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv)
{
    EjsObj  *tmp, **data;
    int     i, j;

    if (ap->length <= 1) {
        return (EjsObj*) ap;
    }

    data = ap->data;
    i = (ap->length - 2) / 2;
    j = (ap->length + 1) / 2;

    for (; i >= 0; i--, j++) {
        tmp = data[i];
        data[i] = data[j];
        data[j] = tmp;
    }
    return (EjsObj*) ap;
}


/*
    Remove and return the first value in the array.
    @return Returns the first element in the array.

    function shift(): Object
 */
static EjsObj *shiftArray(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv)
{
    EjsObj      *result, **data;
    int         i;

    if (ap->length == 0) {
        return ejs->undefinedValue;
    }
    data = ap->data;
    result = data[0];
    for (i = 1; i < ap->length; i++) {
        data[i - 1] = data[i];
    }
    ap->length--;
    return result;
}


/*
    Create a new array by taking a slice from an array.

    function slice(start: Number, end: Number, step: Number = 1): Array
 */
static EjsObj *sliceArray(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv)
{
    EjsArray    *result;
    EjsObj      **src, **dest;
    int         start, end, step, i, j, len;

    mprAssert(1 <= argc && argc <= 3);

    start = ejsGetInt(ejs, argv[0]);
    if (argc >= 2) {
        end = ejsGetInt(ejs, argv[1]);
    } else {
        end = ap->length;
    }
    if (argc == 3) {
        step = ejsGetInt(ejs, argv[2]);
    } else {
        step = 1;
    }
    if (step == 0) {
        step = 1;
    }

    if (start < 0) {
        start += ap->length;
    }
    if (start < 0) {
        start = 0;
    } else if (start >= ap->length) {
        start = ap->length;
    }

    if (end < 0) {
        end += ap->length;
    }
    if (end < 0) {
        end = 0;
    } else if (end >= ap->length) {
        end = ap->length;
    }

    /*
        This may allocate too many elements if step is > 0, but length will still be correct.
     */
    result = ejsCreateArray(ejs, end - start);
    if (result == 0) {
        ejsThrowMemoryError(ejs);
        return 0;
    }
    src = ap->data;
    dest = result->data;

    len = 0;
    if (step > 0) {
        for (i = start, j = 0; i < end; i += step, j++) {
            dest[j] = src[i];
            len++;
        }

    } else {
        for (i = start, j = 0; i > end; i += step, j++) {
            dest[j] = src[i];
            len++;
        }
    }
    result->length = len;
    return (EjsObj*) result;
}


/*
    Quick sort partition
 */
static int partition(Ejs *ejs, EjsArray *array, EjsFunction *compare, int direction, int p, int r)
{
    EjsObj      *tmp, *x, *argv[3];
    EjsString   *sx, *so;
    EjsNumber   *result;
    int         i, j, order;

    x = array->data[r];
    sx = 0;

    if (compare) {
        if ((argv[1] = (EjsObj*) ejsCreateNumber(ejs, r)) == 0) {
            return 0;
        }
    } else {
        if ((sx = ejsToString(ejs, x)) == 0) {
            return 0;
        }
    }
    j = p - 1;

    for (i = p; i < r; i++) {
        if (compare) {
            argv[0] = (EjsObj*) array;
            argv[2] = (EjsObj*) ejsCreateNumber(ejs, i);
            result = (EjsNumber*) ejsRunFunction(ejs, compare, NULL, 3, argv);
            if (!ejsIsNumber(result)) {
                return 0;
            }
            order = ejsGetInt(ejs, result);

        } else {
            if ((so = ejsToString(ejs, array->data[i])) == 0) {
                return 0;
            }
            order = strcmp(sx->value, so->value);
        }
        order *= direction;
        if (order > 0) {
            j = j + 1;
            tmp = array->data[j];
            array->data[j] = array->data[i];
            array->data[i] = tmp;
        }
    }
    array->data[r] = array->data[j + 1];
    array->data[j + 1] = x;
    return j + 1;
}


void quickSort(Ejs *ejs, EjsArray *ap, EjsFunction *compare, int direction, int p, int r)
{
    int     q;

    if (p < r && !ejs->exception) {
        q = partition(ejs, ap, compare, direction, p, r);
        quickSort(ejs, ap, compare, direction, p, q - 1);
        quickSort(ejs, ap, compare, direction, q + 1, r);
    }
}


/**
    Sort the array using the supplied compare function
    intrinsic native function sort(compare: Function = null, direction: Number = 1): Array
    Where compare is defined as:
        function compare(a,b): Number
 */
static EjsObj *sortArray(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv)
{
    EjsFunction     *compare;
    int             direction;

    if (ap->length <= 1) {
        return (EjsObj*) ap;
    }
    compare = (EjsFunction*) ((argc == 1) ? argv[0]: NULL);
    if ((EjsObj*) compare == ejs->nullValue) {
        compare = 0;
    }
    if (compare && !ejsIsFunction(compare)) {
        ejsThrowArgError(ejs, "Compare argument is not a function");
        return 0;
    }
    direction = (argc == 2) ? ejsGetInt(ejs, argv[1]) : 1;
    quickSort(ejs, ap, compare, direction, 0, ap->length - 1);
    return (EjsObj*) ap;
}


/*
    Insert, remove or replace array elements. Return the removed elements.

    function splice(start: Number, deleteCount: Number, ...values): Array

 */
static EjsObj *spliceArray(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv)
{
    EjsArray    *result, *values;
    EjsObj      **data, **dest, **items;
    int         start, deleteCount, i, delta, endInsert, oldLen;

    mprAssert(1 <= argc && argc <= 3);
    
    start = ejsGetInt(ejs, argv[0]);
    deleteCount = ejsGetInt(ejs, argv[1]);
    values = (EjsArray*) argv[2];

    if (ap->length == 0) {
        if (deleteCount <= 0) {
            return (EjsObj*) ap;
        }
        ejsThrowArgError(ejs, "Array is empty");
        return 0;
    }
    if (start < 0) {
        start += ap->length;
    }
    if (start < 0) {
        start = 0;
    }
    if (start >= ap->length) {
        start = ap->length - 1;
    }

    if (deleteCount < 0) {
        deleteCount = ap->length - start + 1;
    }
    if (deleteCount > ap->length) {
        deleteCount = ap->length;
    }

    result = ejsCreateArray(ejs, deleteCount);
    if (result == 0) {
        ejsThrowMemoryError(ejs);
        return 0;
    }

    data = ap->data;
    dest = result->data;
    items = values->data;

    /*
        Copy removed items to the result
     */
    for (i = 0; i < deleteCount; i++) {
        dest[i] = data[i + start];
    }

    oldLen = ap->length;
    delta = values->length - deleteCount;
    
    if (delta > 0) {
        /*
            Make room for items to insert
         */
        if (growArray(ejs, ap, ap->length + delta) < 0) {
            return 0;
        }
        data = ap->data;
        endInsert = start + delta;
        for (i = ap->length - 1; i >= endInsert; i--) {
            data[i] = data[i - delta];
        }
        
    } else {
        ap->length += delta;
    }

    /*
        Copy in new values
     */
    for (i = 0; i < values->length; i++) {
        data[start + i] = items[i];
    }

    /*
        Remove holes
     */
    if (delta < 0) {
        for (i = start + values->length; i < oldLen; i++) {
            data[i] = data[i - delta];
        }
    }
    return (EjsObj*) result;
}


#if ES_Object_toLocaleString && FUTURE
/*
    Convert the array to a single localized string each member of the array
    has toString called on it and the resulting strings are concatenated.
    Currently just calls toString.

    function toLocaleString(): String
 */
static EjsObj *toLocaleString(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv)
{
    return arrayToString(ejs, ap, argc, argv);
}
#endif


/*
    Convert the array to a single string each member of the array has toString called on it and the resulting strings 
    are concatenated.

    override function toString(): String
 */
static EjsObj *arrayToString(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv)
{
    EjsString       *result;
    EjsObj          *vp;
    int             i, rc;

    result = ejsCreateString(ejs, "");
    if (result == 0) {
        ejsThrowMemoryError(ejs);
        return 0;
    }

    for (i = 0; i < ap->length; i++) {
        vp = ap->data[i];
        rc = 0;
        if (i > 0) {
            rc = ejsStrcat(ejs, result, (EjsObj*) ejsCreateString(ejs, ","));
        }
        if (vp != 0 && vp != ejs->undefinedValue && vp != ejs->nullValue) {
            rc = ejsStrcat(ejs, result, vp);
        }
        if (rc < 0) {
            ejsThrowMemoryError(ejs);
            return 0;
        }
    }
    return (EjsObj*) result;
}


/*
    Return an array with duplicate elements removed where duplicates are detected by using "==" (ie. content equality, 
    not strict equality).

    function unique(): Array
 */
static EjsObj *uniqueArray(Ejs *ejs, EjsArray *ap, int argc, EjsObj **argv)
{
    EjsObj      **data;
    int         i, j, k;

    data = ap->data;

    for (i = 0; i < ap->length; i++) {
        for (j = i + 1; j < ap->length; j++) {
            if (compareArrayElement(ejs, data[i], data[j])) {
                for (k = j + 1; k < ap->length; k++) {
                    data[k - 1] = data[k];
                }
                ap->length--;
                j--;
            }
        }
    }
    return (EjsObj*) ap;
}



static int growArray(Ejs *ejs, EjsArray *ap, int len)
{
    EjsObj      **dp;
    int         i, size, count, factor;

    mprAssert(ap);

    if (len <= 0) {
        return 0;
    }
    if (len <= ap->length) {
        return EJS_ERR;
    }
    size = mprGetBlockSize(ap->data) / sizeof(EjsObj*);

    /*
        Allocate or grow the data structures.
     */
    if (len > size) {
        if (size > EJS_LOTSA_PROP) {
            /*
                Looks like a big object so grow by a bigger chunk
             */
            factor = max(size / 4, EJS_ROUND_PROP);
            count = (len + factor) / factor * factor;
        } else {
            count = len;
        }
        count = EJS_PROP_ROUNDUP(count);
        if (ap->data == 0) {
            mprAssert(ap->length == 0);
            mprAssert(count > 0);
            ap->data = (EjsObj**) mprAllocZeroed(ap, sizeof(EjsObj*) * count);
            if (ap->data == 0) {
                return EJS_ERR;
            }
        } else {
            mprAssert(size > 0);
            ap->data = (EjsObj**) mprRealloc(ap, ap->data, sizeof(EjsObj*) * count);
            if (ap->data == 0) {
                return EJS_ERR;
            }
            dp = &ap->data[ap->length];
            for (i = ap->length; i < count; i++) {
                *dp++ = ejs->nullValue;
            }
        }
    }
    ap->length = len;
    return 0;
}



EjsArray *ejsCreateArray(Ejs *ejs, int size)
{
    EjsArray    *ap;

    /*
        No need to invoke constructor
     */
    ap = (EjsArray*) ejsCreateObject(ejs, ejs->arrayType, 0);
    if (ap != 0) {
        ap->length = 0;
        if (size > 0 && growArray(ejs, ap, size) < 0) {
            ejsThrowMemoryError(ejs);
            return 0;
        }
    }
    ejsSetDebugName(ap, "array instance");
    return ap;
}


void ejsCreateArrayType(Ejs *ejs)
{
    EjsType         *type;
    EjsTypeHelpers  *helpers;

    type = ejs->arrayType = ejsCreateNativeType(ejs, "ejs", "Array", ES_Array, sizeof(EjsArray));
    type->numericIndicies = 1;

    helpers = type->helpers;
    helpers->cast = (EjsCastHelper) castArray;
    helpers->clone = (EjsCloneHelper) cloneArray;
    helpers->create = (EjsCreateHelper) createArray;
    helpers->destroy = (EjsDestroyHelper) destroyArray;
    helpers->getProperty = (EjsGetPropertyHelper) getArrayProperty;
    helpers->getPropertyCount = (EjsGetPropertyCountHelper) getArrayPropertyCount;
    helpers->getPropertyByName = (EjsGetPropertyByNameHelper) getArrayPropertyByName;
    helpers->deleteProperty = (EjsDeletePropertyHelper) deleteArrayProperty;
    helpers->deletePropertyByName = (EjsDeletePropertyByNameHelper) deleteArrayPropertyByName;
    helpers->invokeOperator = (EjsInvokeOperatorHelper) invokeArrayOperator;
    helpers->lookupProperty = (EjsLookupPropertyHelper) lookupArrayProperty;
    helpers->mark = (EjsMarkHelper) markArrayVar;
    helpers->setProperty = (EjsSetPropertyHelper) setArrayProperty;
    helpers->setPropertyByName = (EjsSetPropertyByNameHelper) setArrayPropertyByName;
}


void ejsConfigureArrayType(Ejs *ejs)
{
    EjsType     *type;

    type = ejsGetTypeByName(ejs, "ejs", "Array");

    /*
        We override some Object methods
     */
    ejsBindMethod(ejs, type, ES_Object_get, getArrayIterator);
    ejsBindMethod(ejs, type, ES_Object_getValues, getArrayValues);
    ejsBindMethod(ejs, type, ES_Object_clone, (EjsProc) cloneArrayMethod);
    ejsBindMethod(ejs, type, ES_Object_toString, (EjsProc) arrayToString);

    /*
        Methods and Operators, including constructor.
     */
    ejsBindMethod(ejs, type, ES_Array_Array, (EjsProc) arrayConstructor);
    ejsBindMethod(ejs, type, ES_Array_append, (EjsProc) appendArray);
    ejsBindMethod(ejs, type, ES_Array_clear, (EjsProc) clearArray);
    ejsBindMethod(ejs, type, ES_Array_compact, (EjsProc) compactArray);
    ejsBindMethod(ejs, type, ES_Array_concat, (EjsProc) concatArray);

    ejsBindMethod(ejs, type, ES_Array_indexOf, (EjsProc) indexOfArray);
    ejsBindMethod(ejs, type, ES_Array_insert, (EjsProc) insertArray);
    ejsBindMethod(ejs, type, ES_Array_join, (EjsProc) joinArray);
    ejsBindMethod(ejs, type, ES_Array_lastIndexOf, (EjsProc) lastArrayIndexOf);
    ejsBindAccess(ejs, type, ES_Array_length, (EjsProc) getArrayLength, (EjsProc) setArrayLength);
    ejsBindMethod(ejs, type, ES_Array_pop, (EjsProc) popArray);
    ejsBindMethod(ejs, type, ES_Array_push, (EjsProc) pushArray);
    ejsBindMethod(ejs, type, ES_Array_reverse, (EjsProc) reverseArray);
    ejsBindMethod(ejs, type, ES_Array_shift, (EjsProc) shiftArray);
    ejsBindMethod(ejs, type, ES_Array_slice, (EjsProc) sliceArray);
    ejsBindMethod(ejs, type, ES_Array_sort, (EjsProc) sortArray);
    ejsBindMethod(ejs, type, ES_Array_splice, (EjsProc) spliceArray);
    ejsBindMethod(ejs, type, ES_Array_unique, (EjsProc) uniqueArray);

#if FUTURE
    ejsBindMethod(ejs, type, ES_Array_toLocaleString, toLocaleString);
    ejsBindMethod(ejs, type, ES_Array_toJSONString, toJSONString);
    ejsBindMethod(ejs, type, ES_Array_LBRACKET, operLBRACKET);
    ejsBindMethod(ejs, type, ES_Array_AND, operAND);
    ejsBindMethod(ejs, type, ES_Array_EQ, operEQ);
    ejsBindMethod(ejs, type, ES_Array_GT, operGT);
    ejsBindMethod(ejs, type, ES_Array_LT, operLT);
    ejsBindMethod(ejs, type, ES_Array_LSH, operLSH);
    ejsBindMethod(ejs, type, ES_Array_MINUS, operMINUS);
    ejsBindMethod(ejs, type, ES_Array_OR, operOR);
    ejsBindMethod(ejs, type, ES_Array_AND, operAND);
#endif
}


/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2010. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2010. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    @end
 */
/************************************************************************/
/*
 *  End of file "../src/core/src/ejsArray.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../src/core/src/ejsBlock.c"
 */
/************************************************************************/

/**
    ejsBlock.c - Lexical block

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */




EjsBlock *ejsCreateBlock(Ejs *ejs, int size)
{
    EjsBlock        *block;

    block = (EjsBlock*) ejsCreateObject(ejs, ejs->blockType, size);
    if (block == 0) {
        return 0;
    }
    ejsInitList(&block->namespaces);
    return block;
}


void ejsMarkBlock(Ejs *ejs, EjsBlock *block)
{
    EjsObj          *item;
    EjsBlock        *b;
    int             next;

    ejsMarkObject(ejs, (EjsObj*) block);
    if (block->prevException) {
        ejsMark(ejs, (EjsObj*) block->prevException);
    }
    if (block->namespaces.length > 0) {
        for (next = 0; ((item = (EjsObj*) ejsGetNextItem(&block->namespaces, &next)) != 0); ) {
            ejsMark(ejs, item);
        }
    }
    for (b = block->scopeChain; b; b = b->scopeChain) {
        ejsMark(ejs, (EjsObj*) b);
    }
    //  TODO MOB - this should not be required as GC in mark() follows the block caller/prev chain
    for (b = block->prev; b; b = b->prev) {
        ejsMark(ejs, (EjsObj*) b);
    }
}


EjsBlock *ejsCloneBlock(Ejs *ejs, EjsBlock *src, bool deep)
{
    EjsBlock    *dest;

    dest = (EjsBlock*) ejsCloneObject(ejs, (EjsObj*) src, deep);

    dest->nobind = src->nobind;
    dest->scopeChain = src->scopeChain;
    dest->namespaces = src->namespaces;
    return dest;
}


void ejsResetBlockNamespaces(Ejs *ejs, EjsBlock *block)
{
    ejsClearList(&block->namespaces);
}


int ejsGetNamespaceCount(EjsBlock *block)
{
    mprAssert(block);

    return ejsGetListCount(&block->namespaces);
}


void ejsPopBlockNamespaces(EjsBlock *block, int count)
{
    mprAssert(block);
    mprAssert(block->namespaces.length >= count);

    block->namespaces.length = count;
}


int ejsAddNamespaceToBlock(Ejs *ejs, EjsBlock *block, EjsNamespace *nsp)
{
    EjsFunction     *fun;
    EjsNamespace    *namespace;
    EjsList         *list;
    int             next;

    mprAssert(block);

    if (nsp == 0) {
        ejsThrowTypeError(ejs, "Not a namespace");
        return EJS_ERR;
    }
    fun = (EjsFunction*) block;
    list = &block->namespaces;

    if (ejsIsFunction(fun)) {
        if (fun->isInitializer && fun->owner) {
            block = block->scopeChain;
            list = &block->namespaces;
            /*
                If defining a namespace at the class level (outside functions) use the class itself.
                Initializers only run once so this should only happen once.
             */
            /* TODO OPT - this is only needed when classes implement other classes (Model <= Record) */
            for (next = 0; (namespace = ejsGetNextItem(list, &next)) != 0; ) {
                if (strcmp(namespace->name, nsp->name) == 0) {
                    /* Already there */
                    return 0;
                }
            }
            if (block->obj.master && ejs->master) {
                nsp = ejsCreateNamespace(ejs->master, mprStrdup(ejs->master, nsp->name), mprStrdup(ejs->master, nsp->uri));
            }
        }
    }
    ejsAddItemToSharedList(block, list, nsp);
    return 0;
}


/*
    Inherit namespaces from base types. Only inherit protected.
 */
void ejsInheritBaseClassNamespaces(Ejs *ejs, EjsType *type, EjsType *baseType)
{
    EjsNamespace    *nsp;
    EjsBlock        *block;
    EjsList         *baseNamespaces, oldNamespaces;
    int             next;

    block = &type->block;
    oldNamespaces = block->namespaces;
    ejsInitList(&block->namespaces);
    baseNamespaces = &baseType->block.namespaces;

    if (baseNamespaces) {
        for (next = 0; ((nsp = (EjsNamespace*) ejsGetNextItem(baseNamespaces, &next)) != 0); ) {
            if (strstr(nsp->name, ",protected")) {
                ejsAddItem(block, &block->namespaces, nsp);
            }
        }
    }

    if (oldNamespaces.length > 0) {
        for (next = 0; ((nsp = (EjsNamespace*) ejsGetNextItem(&oldNamespaces, &next)) != 0); ) {
            ejsAddItem(block, &block->namespaces, nsp);
        }
    }
}



void ejsCreateBlockType(Ejs *ejs)
{
    EjsType     *type;

    type = ejs->blockType = ejsCreateNativeType(ejs, "ejs", "Block", ES_Block, sizeof(EjsBlock));

    type->skipScope = 1;
    type->helpers->clone = (EjsCloneHelper) ejsCloneBlock;
    type->helpers->mark = (EjsMarkHelper) ejsMarkBlock;
}


/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2010. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2010. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    @end
 */
/************************************************************************/
/*
 *  End of file "../src/core/src/ejsBlock.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../src/core/src/ejsBoolean.c"
 */
/************************************************************************/

/**
    ejsBoolean.c - Boolean native class

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */



/*
    Cast the operand to a primitive type
 *
    intrinsic function cast(type: Type) : Object
 */

static EjsObj *castBooleanVar(Ejs *ejs, EjsBoolean *vp, EjsType *type)
{
    mprAssert(ejsIsBoolean(vp));

    switch (type->id) {

    case ES_Number:
        return (EjsObj*) ((vp->value) ? ejs->oneValue: ejs->zeroValue);

    case ES_String:
        return (EjsObj*) ejsCreateString(ejs, (vp->value) ? "true" : "false");

    default:
        ejsThrowTypeError(ejs, "Can't cast to this type");
        return 0;
    }
}


/*
    Coerce operands for invokeOperator
 */
static EjsObj *coerceBooleanOperands(Ejs *ejs, EjsObj *lhs, int opcode, EjsObj *rhs)
{
    switch (opcode) {

    case EJS_OP_ADD:
        if (ejsIsUndefined(rhs)) {
            return (EjsObj*) ejs->nanValue;
        } else if (ejsIsNull(rhs) || ejsIsNumber(rhs) || ejsIsDate(rhs)) {
            return ejsInvokeOperator(ejs, (EjsObj*) ejsToNumber(ejs, lhs), opcode, rhs);
        } else {
            return ejsInvokeOperator(ejs, (EjsObj*) ejsToString(ejs, lhs), opcode, rhs);
        }
        break;

    case EJS_OP_AND: case EJS_OP_DIV: case EJS_OP_MUL: case EJS_OP_OR: case EJS_OP_REM:
    case EJS_OP_SHL: case EJS_OP_SHR: case EJS_OP_SUB: case EJS_OP_USHR: case EJS_OP_XOR:
        return ejsInvokeOperator(ejs, (EjsObj*) ejsToNumber(ejs, lhs), opcode, rhs);

    case EJS_OP_COMPARE_LE: case EJS_OP_COMPARE_LT:
    case EJS_OP_COMPARE_GE: case EJS_OP_COMPARE_GT:
    case EJS_OP_COMPARE_EQ: case EJS_OP_COMPARE_NE:
        if (ejsIsString(rhs)) {
            return ejsInvokeOperator(ejs, (EjsObj*) ejsToString(ejs, lhs), opcode, rhs);
        }
        return ejsInvokeOperator(ejs, (EjsObj*) ejsToNumber(ejs, lhs), opcode, rhs);

    case EJS_OP_COMPARE_STRICTLY_NE:
        return (EjsObj*) ejs->trueValue;

    case EJS_OP_COMPARE_STRICTLY_EQ:
        return (EjsObj*) ejs->falseValue;

    /*
        Unary operators
     */
    case EJS_OP_LOGICAL_NOT: case EJS_OP_NOT: case EJS_OP_NEG:
        return 0;

    case EJS_OP_COMPARE_NOT_ZERO:
    case EJS_OP_COMPARE_TRUE:
        return (EjsObj*) (((EjsBoolean*) lhs)->value ? ejs->trueValue: ejs->falseValue);

    case EJS_OP_COMPARE_ZERO:
    case EJS_OP_COMPARE_FALSE:
        return (EjsObj*) (((EjsBoolean*) lhs)->value ? ejs->falseValue : ejs->trueValue);

    case EJS_OP_COMPARE_UNDEFINED:
    case EJS_OP_COMPARE_NULL:
        return (EjsObj*) ejs->falseValue;

    default:
        ejsThrowTypeError(ejs, "Opcode %d not valid for type %s", opcode, lhs->type->qname.name);
        return ejs->undefinedValue;
    }
}


/*
    Run an operator on the operands
 */
static EjsObj *invokeBooleanOperator(Ejs *ejs, EjsBoolean *lhs, int opcode, EjsBoolean *rhs)
{
    EjsObj      *result;

    if (rhs == 0 || lhs->obj.type != rhs->obj.type) {
        if (!ejsIsA(ejs, (EjsObj*) lhs, ejs->booleanType) || !ejsIsA(ejs, (EjsObj*) rhs, ejs->booleanType)) {
            if ((result = coerceBooleanOperands(ejs, (EjsObj*) lhs, opcode, (EjsObj*) rhs)) != 0) {
                return result;
            }
        }
    }

    /*
        Types now match
     */
    switch (opcode) {

    case EJS_OP_COMPARE_EQ: case EJS_OP_COMPARE_STRICTLY_EQ:
        return (EjsObj*) ((lhs->value == rhs->value) ? ejs->trueValue: ejs->falseValue);

    case EJS_OP_COMPARE_NE: case EJS_OP_COMPARE_STRICTLY_NE:
        return (EjsObj*) ((lhs->value != rhs->value) ? ejs->trueValue: ejs->falseValue);

    case EJS_OP_COMPARE_LT:
        return (EjsObj*) ((lhs->value < rhs->value) ? ejs->trueValue: ejs->falseValue);

    case EJS_OP_COMPARE_LE:
        return (EjsObj*) ((lhs->value <= rhs->value) ? ejs->trueValue: ejs->falseValue);

    case EJS_OP_COMPARE_GT:
        return (EjsObj*) ((lhs->value > rhs->value) ? ejs->trueValue: ejs->falseValue);

    case EJS_OP_COMPARE_GE:
        return (EjsObj*) ((lhs->value >= rhs->value) ? ejs->trueValue: ejs->falseValue);

    case EJS_OP_COMPARE_NOT_ZERO:
        return (EjsObj*) ((lhs->value) ? ejs->trueValue: ejs->falseValue);

    case EJS_OP_COMPARE_ZERO:
        return (EjsObj*) ((lhs->value == 0) ? ejs->trueValue: ejs->falseValue);

    case EJS_OP_COMPARE_UNDEFINED:
    case EJS_OP_COMPARE_NULL:
        return (EjsObj*) ejs->falseValue;

    case EJS_OP_COMPARE_FALSE:
        return (EjsObj*) ((lhs->value) ? ejs->falseValue: ejs->trueValue);

    case EJS_OP_COMPARE_TRUE:
        return (EjsObj*) ((lhs->value) ? ejs->trueValue: ejs->falseValue);

    /*
        Unary operators
     */
    case EJS_OP_NEG:
        return (EjsObj*) ejsCreateNumber(ejs, - lhs->value);

    case EJS_OP_LOGICAL_NOT:
        return (EjsObj*) ejsCreateBoolean(ejs, !lhs->value);

    case EJS_OP_NOT:
        return (EjsObj*) ejsCreateBoolean(ejs, ~lhs->value);

    /*
        Binary operations
     */
    case EJS_OP_ADD:
        return (EjsObj*) ejsCreateBoolean(ejs, lhs->value + rhs->value);

    case EJS_OP_AND:
        return (EjsObj*) ejsCreateBoolean(ejs, lhs->value & rhs->value);

    case EJS_OP_DIV:
        return (EjsObj*) ejsCreateBoolean(ejs, lhs->value / rhs->value);

    case EJS_OP_MUL:
        return (EjsObj*) ejsCreateBoolean(ejs, lhs->value * rhs->value);

    case EJS_OP_OR:
        return (EjsObj*) ejsCreateBoolean(ejs, lhs->value | rhs->value);

    case EJS_OP_REM:
        return (EjsObj*) ejsCreateBoolean(ejs, lhs->value % rhs->value);

    case EJS_OP_SUB:
        return (EjsObj*) ejsCreateBoolean(ejs, lhs->value - rhs->value);

    case EJS_OP_USHR:
        return (EjsObj*) ejsCreateBoolean(ejs, lhs->value >> rhs->value);

    case EJS_OP_XOR:
        return (EjsObj*) ejsCreateBoolean(ejs, lhs->value ^ rhs->value);

    default:
        ejsThrowTypeError(ejs, "Opcode %d not implemented for type %s", opcode, lhs->obj.type->qname.name);
        return 0;
    }
}


/*
    Boolean constructor.

        function Boolean(value: Boolean = null)

    If the value is omitted or 0, -1, NaN, false, null, undefined or the empty string, then set the boolean value to
    to false.
 */

static EjsObj *booleanConstructor(Ejs *ejs, EjsBoolean *bp, int argc, EjsObj **argv)
{
    mprAssert(argc == 0 || argc == 1);

    if (argc >= 1) {
        /* Change the bp value */
        bp->value = ejsToBoolean(ejs, argv[0])->value;
    }
    return (EjsObj*) bp;
}



EjsBoolean *ejsCreateBoolean(Ejs *ejs, int value)
{
    return (EjsBoolean*) ((value) ? ejs->trueValue : ejs->falseValue);
}


void ejsCreateBooleanType(Ejs *ejs)
{
    EjsType     *type;
    EjsBoolean  *vp;

    type = ejs->booleanType = ejsCreateNativeType(ejs, "ejs", "Boolean", ES_Boolean, sizeof(EjsBoolean));
    type->immutable = 1;

    type->helpers->cast = (EjsCastHelper) castBooleanVar;
    type->helpers->invokeOperator = (EjsInvokeOperatorHelper) invokeBooleanOperator;

    /*
        Pre-create the only two valid instances for boolean
     */
    vp = (EjsBoolean*) ejsCreate(ejs, type, 0);
    vp->value = 1;
    ejs->trueValue = (EjsObj*) vp;

    vp = (EjsBoolean*) ejsCreate(ejs, type, 0);
    vp->value = 0;
    ejs->falseValue = (EjsObj*) vp;

    ejsSetDebugName(ejs->falseValue, "false");
    ejsSetDebugName(ejs->trueValue, "true");
}


void ejsConfigureBooleanType(Ejs *ejs)
{
    EjsType     *type;

    type = ejsGetTypeByName(ejs, "ejs", "Boolean");

    ejsSetProperty(ejs, ejs->global, ES_boolean, (EjsObj*) type);
    ejsSetProperty(ejs, ejs->global, ES_true, (EjsObj*) ejs->trueValue);
    ejsSetProperty(ejs, ejs->global, ES_false, (EjsObj*) ejs->falseValue);

    ejsBindMethod(ejs, type, ES_Boolean_Boolean, (EjsProc) booleanConstructor);
}


/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2010. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2010. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    @end
 */
/************************************************************************/
/*
 *  End of file "../src/core/src/ejsBoolean.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../src/core/src/ejsByteArray.c"
 */
/************************************************************************/

/*
    ejsByteArray.c - Ejscript ByteArray class
    Copyright (c) All Rights Reserved. See details at the end of the file.
 */




static EjsObj *ba_flush(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv);
static EjsObj *ba_toString(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv);

static int  flushByteArray(Ejs *ejs, EjsByteArray *ap);
static int  getInput(Ejs *ejs, EjsByteArray *ap, int required);
static int  lookupByteArrayProperty(Ejs *ejs, EjsByteArray *ap, EjsName *qname);
 static bool makeRoom(Ejs *ejs, EjsByteArray *ap, int require);

static MPR_INLINE int swap16(EjsByteArray *ap, int a);
static MPR_INLINE int swap32(EjsByteArray *ap, int a);
static MPR_INLINE int64 swap64(EjsByteArray *ap, int64 a);
static MPR_INLINE double swapDouble(EjsByteArray *ap, double a);
static int putByte(EjsByteArray *ap, int value);
static int putInteger(EjsByteArray *ap, int value);
static int putLong(EjsByteArray *ap, int64 value);
static int putShort(EjsByteArray *ap, int value);
static int putString(EjsByteArray *ap, cchar *value, int len);
static int putNumber(EjsByteArray *ap, MprNumber value);
static int putDouble(EjsByteArray *ap, double value);

#define availableBytes(ap)  (((EjsByteArray*) ap)->writePosition - ((EjsByteArray*) ap)->readPosition)
#define room(ap) (ap->length - ap->writePosition)
#define adjustReadPosition(ap, amt) \
    if (1) { \
        ap->readPosition += amt; \
        if (ap->readPosition == ap->writePosition) {    \
            ap->readPosition = ap->writePosition = 0; \
        } \
    } else

/*
    Cast the object operand to a primitive type
 */
static EjsObj *castByteArrayVar(Ejs *ejs, EjsByteArray *vp, EjsType *type)
{
    switch (type->id) {
    case ES_Boolean:
        return (EjsObj*) ejs->trueValue;

    case ES_Number:
        return (EjsObj*) ejs->zeroValue;

    case ES_String:
        return ba_toString(ejs, vp, 0, 0);

    default:
        ejsThrowTypeError(ejs, "Can't cast to this type");
        return 0;
    }
}


static EjsByteArray *cloneByteArrayVar(Ejs *ejs, EjsByteArray *ap, bool deep)
{
    EjsByteArray    *newArray;
    int             i;

    newArray = ejsCreateByteArray(ejs, ap->length);
    if (newArray == 0) {
        ejsThrowMemoryError(ejs);
        return 0;
    }
    for (i = 0; i < ap->length; i++) {
        newArray->value[i] = ap->value[i];
    }
    newArray->readPosition = ap->readPosition;
    newArray->writePosition = ap->writePosition;
    return newArray;
}


/*
    Delete a property and update the length
 */
static int deleteByteArrayProperty(struct Ejs *ejs, EjsByteArray *ap, int slot)
{
    if (slot >= ap->length) {
        ejsThrowOutOfBoundsError(ejs, "Bad subscript");
        return EJS_ERR;
    }
    if ((slot + 1) == ap->length) {
        ap->length--;
        if (ap->readPosition >= ap->length) {
            ap->readPosition = ap->length - 1;
        }
        if (ap->writePosition >= ap->length) {
            ap->writePosition = ap->length - 1;
        }
    }
    if (ejsSetProperty(ejs, (EjsObj*) ap, slot, (EjsObj*) ejs->undefinedValue) < 0) {
        return EJS_ERR;
    }
    return 0;
}


/*
    Return the number of elements in the array
 */
static int getByteArrayPropertyCount(Ejs *ejs, EjsByteArray *ap)
{
    return ap->length;
}


/*
    Get an array element. Slot numbers correspond to indicies.
 */
static EjsObj *getByteArrayProperty(Ejs *ejs, EjsByteArray *ap, int slotNum)
{
    if (slotNum < 0 || slotNum >= ap->length) {
        ejsThrowOutOfBoundsError(ejs, "Bad array subscript");
        return 0;
    }
    return (EjsObj*) ejsCreateNumber(ejs, ap->value[slotNum]);
}


/*
    Lookup an array index.
 */
static int lookupByteArrayProperty(struct Ejs *ejs, EjsByteArray *ap, EjsName *qname)
{
    int     index;

    if (qname == 0 || ! isdigit((int) qname->name[0])) {
        return EJS_ERR;
    }
    index = atoi(qname->name);
    if (index < ap->length) {
        return index;
    }
    return EJS_ERR;
}


/*
    Cast operands as required for invokeOperator
 */
static EjsObj *coerceByteArrayOperands(Ejs *ejs, EjsObj *lhs, int opcode,  EjsObj *rhs)
{
    switch (opcode) {
    /*
        Binary operators
     */
    case EJS_OP_ADD:
        return ejsInvokeOperator(ejs, ba_toString(ejs, (EjsByteArray*) lhs, 0, 0), opcode, rhs);

    case EJS_OP_AND: case EJS_OP_DIV: case EJS_OP_MUL: case EJS_OP_OR: case EJS_OP_REM:
    case EJS_OP_SHL: case EJS_OP_SHR: case EJS_OP_SUB: case EJS_OP_USHR: case EJS_OP_XOR:
        return ejsInvokeOperator(ejs, (EjsObj*) ejs->zeroValue, opcode, rhs);

    case EJS_OP_COMPARE_EQ: case EJS_OP_COMPARE_NE:
        if (ejsIsNull(rhs) || ejsIsUndefined(rhs)) {
            return (EjsObj*) ((opcode == EJS_OP_COMPARE_EQ) ? ejs->falseValue: ejs->trueValue);
        } else if (ejsIsNumber(rhs)) {
            return ejsInvokeOperator(ejs, (EjsObj*) ejsToNumber(ejs, lhs), opcode, rhs);
        }
        return ejsInvokeOperator(ejs, (EjsObj*) ejsToString(ejs, lhs), opcode, rhs);

    case EJS_OP_COMPARE_LE: case EJS_OP_COMPARE_LT:
    case EJS_OP_COMPARE_GE: case EJS_OP_COMPARE_GT:
        if (ejsIsNumber(rhs)) {
            return ejsInvokeOperator(ejs, (EjsObj*) ejsToNumber(ejs, lhs), opcode, rhs);
        }
        return ejsInvokeOperator(ejs, (EjsObj*) ejsToString(ejs, lhs), opcode, rhs);

    case EJS_OP_COMPARE_STRICTLY_NE:
    case EJS_OP_COMPARE_UNDEFINED:
    case EJS_OP_COMPARE_NOT_ZERO:
    case EJS_OP_COMPARE_NULL:
        return (EjsObj*) ejs->trueValue;

    case EJS_OP_COMPARE_STRICTLY_EQ:
    case EJS_OP_COMPARE_FALSE:
    case EJS_OP_COMPARE_TRUE:
    case EJS_OP_COMPARE_ZERO:
        return (EjsObj*) ejs->falseValue;

    /*
        Unary operators
     */
    case EJS_OP_LOGICAL_NOT: case EJS_OP_NOT: case EJS_OP_NEG:
        return 0;

    default:
        ejsThrowTypeError(ejs, "Opcode %d not valid for type %s", opcode, lhs->type->qname.name);
        return ejs->undefinedValue;
    }
    return 0;
}


static EjsObj *invokeByteArrayOperator(Ejs *ejs, EjsObj *lhs, int opcode,  EjsObj *rhs)
{
    EjsObj      *result;

    if (rhs == 0 || lhs->type != rhs->type) {
        if ((result = coerceByteArrayOperands(ejs, lhs, opcode, rhs)) != 0) {
            return result;
        }
    }

    switch (opcode) {

    case EJS_OP_COMPARE_EQ: case EJS_OP_COMPARE_STRICTLY_EQ:
    case EJS_OP_COMPARE_LE: case EJS_OP_COMPARE_GE:
        return (EjsObj*) ejsCreateBoolean(ejs, (lhs == rhs));

    case EJS_OP_COMPARE_NE: case EJS_OP_COMPARE_STRICTLY_NE:
    case EJS_OP_COMPARE_LT: case EJS_OP_COMPARE_GT:
        return (EjsObj*) ejsCreateBoolean(ejs, !(lhs == rhs));

    /*
        Unary operators
     */
    case EJS_OP_COMPARE_NOT_ZERO:
        return (EjsObj*) ejs->trueValue;

    case EJS_OP_COMPARE_UNDEFINED:
    case EJS_OP_COMPARE_NULL:
    case EJS_OP_COMPARE_FALSE:
    case EJS_OP_COMPARE_TRUE:
    case EJS_OP_COMPARE_ZERO:
        return (EjsObj*) ejs->falseValue;

    case EJS_OP_LOGICAL_NOT: case EJS_OP_NOT: case EJS_OP_NEG:
        return (EjsObj*) ejs->oneValue;

    /*
        Binary operators
     */
    case EJS_OP_DIV: case EJS_OP_MUL: case EJS_OP_REM:
    case EJS_OP_SHR: case EJS_OP_USHR: case EJS_OP_XOR:
        return (EjsObj*) ejs->zeroValue;

    default:
        ejsThrowTypeError(ejs, "Opcode %d not implemented for type %s", opcode, lhs->type->qname.name);
        return 0;
    }
    mprAssert(0);
}


static void markByteArrayVar(Ejs *ejs, EjsByteArray *ap)
{
    mprAssert(ejsIsByteArray(ap));

    //  MOB -- not needed
    ejsMarkObject(ejs, (EjsObj*) ap);
    if (ap->emitter) {
        ejsMark(ejs, (EjsObj*) ap->emitter);
    }
    if (ap->listeners) {
        ejsMark(ejs, (EjsObj*) ap->listeners);
    }
}


/*
    Create or update an array elements. If slotNum is < 0, then create the next free array slot. If slotNum is greater
    than the array length, grow the array.
 */
static int setByteArrayProperty(struct Ejs *ejs, EjsByteArray *ap, int slotNum,  EjsObj *value)
{
    if (slotNum >= ap->length) {
        if (ejsGrowByteArray(ejs, ap, slotNum + 1) < 0) {
            return EJS_ERR;
        }
    }
    if (ejsIsNumber(value)) {
        ap->value[slotNum] = ejsGetInt(ejs, value);
    } else {
        ap->value[slotNum] = ejsGetInt(ejs, ejsToNumber(ejs, value));
    }

    if (slotNum >= ap->length) {
        ap->length = slotNum + 1;
    }
    return slotNum;
}


/*
    function ByteArray(size: Number = -1, growable: Boolean = true): ByteArray
 */
static EjsObj *ba_ByteArray(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    bool    growable;
    int     size;

    mprAssert(0 <= argc && argc <= 2);

    size = (argc >= 1) ? ejsGetInt(ejs, argv[0]) : MPR_BUFSIZE;
    if (size <= 0) {
        size = 1;
    }
    growable = (argc == 2) ? ejsGetBoolean(ejs, argv[1]): 1;

    if (ejsGrowByteArray(ejs, ap, size) < 0) {
        return 0;
    }
    mprAssert(ap->value);
    ap->growable = growable;
    ap->growInc = MPR_BUFSIZE;
    ap->length = size;
    ap->endian = mprGetEndian(ejs);
    return (EjsObj*) ap;
}


/**
    function get addListener(name, listener: Function): Void
 */
static EjsObj *ba_addListener(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    ejsAddListener(ejs, &ap->emitter, argv[0], argv[1]);
    return 0;
}


/**
    Determine if the byte array is in async mode
    function get async(): Boolean
 */
static EjsObj *ba_async(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    return ap->async ? (EjsObj*) ejs->trueValue : (EjsObj*) ejs->falseValue;
}


/**
    Set the async mode 
    function set async(enable: Boolean): Void
 */
static EjsObj *ba_setAsync(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    ap->async = (argv[0] == (EjsObj*) ejs->trueValue);
    return 0;
}


/**
    Get the number of bytes that are currently available on this stream for reading.
    function get available(): Number
 */
static EjsObj *ba_available(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateNumber(ejs, ap->writePosition - ap->readPosition);
}


/*
    function close(): Void
 */
static EjsObj *ba_close(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    if (ap->emitter) {
        ejsSendEvent(ejs, ap->emitter, "close", (EjsObj*) ap);
    }
    return ba_flush(ejs, ap, argc, argv);
}


/*
    Copy data down and adjust the read/write offset pointers.
    function compact(): Void
 */
static EjsObj *ba_compact(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    mprAssert(argc == 0);

    if (ap->writePosition == ap->readPosition) {
        ap->writePosition = ap->readPosition = 0;

    } else if (ap->readPosition > 0) {
        memmove(ap->value, &ap->value[ap->readPosition], ap->writePosition - ap->readPosition);
        ap->writePosition -= ap->readPosition;
        ap->readPosition = 0;
    }
    return 0;
}


/*
    Copy data into the array. Data is written at the $destOffset.
    function copyIn(destOffset: Number, src: ByteArray, srcOffset: Number = 0, count: Number = -1): Number
 */
static EjsObj *ba_copyIn(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    EjsByteArray    *src;
    int             i, destOffset, srcOffset, count;

    destOffset = ejsGetInt(ejs, argv[0]);
    src = (EjsByteArray*) argv[1];
    srcOffset = (argc > 2) ? ejsGetInt(ejs, argv[2]) : 0;
    count = (argc > 3) ? ejsGetInt(ejs, argv[3]) : MAXINT;

    if (srcOffset >= src->length) {
        ejsThrowOutOfBoundsError(ejs, "Bad source offset");
        return 0;
    }
    if (count < 0) {
        count = MAXINT;
    }
    count = min(src->length - srcOffset, count);

    makeRoom(ejs, ap, destOffset + count);
    if ((destOffset + count) > src->length) {
        ejsThrowOutOfBoundsError(ejs, "Insufficient room for data");
        return 0;
    }
    //  TODO OPT - use memmove/memcpy
    for (i = 0; i < count; i++) {
        ap->value[destOffset++] = src->value[srcOffset++];
    }
    return (EjsObj*) ejsCreateNumber(ejs, count);
}


/*
    Copy data from the array. Data is copied from the $srcOffset.
    function copyOut(srcOffset: Number, dest: ByteArray, destOffset: Number = 0, count: Number = -1): Number
 */
static EjsObj *ba_copyOut(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    EjsByteArray    *dest;
    int             i, srcOffset, destOffset, count;

    srcOffset = ejsGetInt(ejs, argv[0]);
    dest = (EjsByteArray*) argv[1];
    destOffset = (argc > 2) ? ejsGetInt(ejs, argv[2]) : 0;
    count = (argc > 3) ? ejsGetInt(ejs, argv[3]) : MAXINT;

    if (srcOffset >= ap->length) {
        ejsThrowOutOfBoundsError(ejs, "Bad source data offset");
        return 0;
    }
    count = min(ap->length - srcOffset, count);
    makeRoom(ejs, dest, destOffset + count);
    if ((destOffset + count) > dest->length) {
        ejsThrowOutOfBoundsError(ejs, "Insufficient room for data");
        return 0;
    }
    //  TODO OPT - use memmove/memcpy
    for (i = 0; i < count; i++) {
        dest->value[destOffset++] = ap->value[srcOffset++];
    }
    return (EjsObj*) ejsCreateNumber(ejs, count);
}


/*
    Determine if the system is using little endian byte ordering
    function get endian(): Number
 */
static EjsObj *endian(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateNumber(ejs, ap->endian);
}


/*
    Set the system encoding to little or big endian.
    function set endian(value: Number): Void
 */
static EjsObj *setEndian(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    int     endian;

    mprAssert(argc == 1 && ejsIsNumber(argv[0]));

    endian = ejsGetInt(ejs, argv[0]);
    if (endian != 0 && endian != 1) {
        ejsThrowArgError(ejs, "Bad endian value");
        return 0;
    }
    ap->endian = endian;
    ap->swap = (ap->endian != mprGetEndian(ejs));
    return 0;
}


/*
    Function to iterate and return the next element index.
    NOTE: this is not a method of Array. Rather, it is a callback function for Iterator
 */
static EjsObj *nextByteArrayKey(Ejs *ejs, EjsIterator *ip, int argc, EjsObj **argv)
{
    EjsByteArray    *ap;

    ap = (EjsByteArray*) ip->target;
    if (!ejsIsByteArray(ap)) {
        ejsThrowReferenceError(ejs, "Wrong type");
        return 0;
    }
    if (ip->index < ap->readPosition) {
        ip->index = ap->readPosition;
    }
    if (ip->index < ap->writePosition) {
        return (EjsObj*) ejsCreateNumber(ejs, ip->index++);
    }
    ejsThrowStopIteration(ejs);
    return 0;
}


/*
    Return the default iterator. This returns the array index names.
    iterator native function get(): Iterator
 */
static EjsObj *ba_get(Ejs *ejs, EjsObj *ap, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateIterator(ejs, ap, (EjsProc) nextByteArrayKey, 0, NULL);
}


/*
    Function to iterate and return the next element value.
    NOTE: this is not a method of Array. Rather, it is a callback function for Iterator
 */
static EjsObj *nextByteArrayValue(Ejs *ejs, EjsIterator *ip, int argc, EjsObj **argv)
{
    EjsByteArray    *ap;

    ap = (EjsByteArray*) ip->target;
    if (!ejsIsByteArray(ap)) {
        ejsThrowReferenceError(ejs, "Wrong type");
        return 0;
    }
    if (ip->index < ap->readPosition) {
        ip->index = ap->readPosition;
    }
    if (ip->index < ap->writePosition) {
        return (EjsObj*) ejsCreateNumber(ejs, ap->value[ip->index++]);
    }
    ejsThrowStopIteration(ejs);
    return 0;
}


/*  
    Return an iterator to return the next array element value.
    iterator native function getValues(): Iterator
 */
static EjsObj *ba_getValues(Ejs *ejs, EjsObj *ap, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateIterator(ejs, ap, (EjsProc) nextByteArrayValue, 0, NULL);
}


/*  
    Flush the data in the byte array and reset the read and write position pointers
    function flush(): Void
 */
static EjsObj *ba_flush(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    if (argc == 0 || argv[0] == (EjsObj*) ejs->trueValue) {
        flushByteArray(ejs, ap);
    }
    ap->writePosition = ap->readPosition = 0;
    return 0;
}


/*
    Get the length of an array.
    @return Returns the number of items in the array
    intrinsic override function get length(): Number
 */
static EjsObj *ba_getLength(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateNumber(ejs, ap->length);
}


#if KEEP
/*
    Set the length of an array.
    intrinsic override function set length(value: Number): void
 */
static EjsObj *ba_setLength(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    mprAssert(argc == 1 && ejsIsNumber(argv[0]));
    mprAssert(ejsIsByteArray(ap));

    ap->length = ejsGetInt(ejs, argv[0]);
    if (ap->readPosition >= ap->length) {
        ap->readPosition = ap->length - 1;
    }
    if (ap->writePosition >= ap->length) {
        ap->writePosition = ap->length - 1;
    }

    return 0;
}
#endif


/*
    Read data from the array into another byte array. Data is read from the current read $position pointer.
    Data is written to the write position if offset is -1. Othwise at the given offset. If offset is < 0, the 
    write position is updated.
    function read(buffer: ByteArray, offset: Number = 0, count: Number = -1): Number
 */
static EjsObj *ba_read(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    EjsByteArray    *buffer;
    int             offset, count, i;

    mprAssert(1 <= argc && argc <= 3);

    buffer = (EjsByteArray*) argv[0];
    offset = (argc == 2) ? ejsGetInt(ejs, argv[1]) : 0;
    count = (argc == 3) ? ejsGetInt(ejs, argv[2]) : buffer->length;

    if (count < 0) {
        count = buffer->length;
    }
    if (offset < 0) {
        offset = buffer->writePosition;
    } else if (offset >= buffer->length) {
        ejsThrowOutOfBoundsError(ejs, "Bad read offset value");
        return 0;
    } else {
        buffer->readPosition = 0;
        buffer->writePosition = 0;
    }
    if (getInput(ejs, ap, 1) <= 0) {
        /* eof */
        return (EjsObj*) ejs->nullValue;
    }
    count = min(availableBytes(ap), count);
    for (i = 0; i < count; i++) {
        buffer->value[offset++] = ap->value[ap->readPosition++];
    }
    buffer->writePosition += count;
    if (ap->emitter && availableBytes(ap) && !ejs->exception) {
        ejsSendEvent(ejs, ap->emitter, "writable", (EjsObj*) ap);
    }
    return (EjsObj*) ejsCreateNumber(ejs, count);
}


/*
    Read a boolean from the array.
    function readBoolean(): Boolean
 */
static EjsObj *ba_readBoolean(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    int     result;

    if (getInput(ejs, ap, 1) <= 0) {
        /* eof */
        return (EjsObj*) ejs->nullValue;
    }
    result = ap->value[ap->readPosition];
    adjustReadPosition(ap, 1);
    return (EjsObj*) ejsCreateBoolean(ejs, result);
}


/*
    Read a byte from the array.
    function readByte(): Number
 */
static EjsObj *ba_readByte(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    int     result;

    if (getInput(ejs, ap, 1) <= 0) {
        /* eof */
        return (EjsObj*) ejs->nullValue;
    }
    result = ap->value[ap->readPosition];
    adjustReadPosition(ap, 1);
    return (EjsObj*) ejsCreateNumber(ejs, result);
}


/**
    Read a date from the array.
    function readDate(): Date
 */
static EjsObj *ba_readDate(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    double  value;

    if (getInput(ejs, ap, EJS_SIZE_DOUBLE) <= 0) {
        if (availableBytes(ap) > 0) {
            ejsThrowIOError(ejs, "Premanture eof");
            return 0;
        }
        return (EjsObj*) ejs->nullValue;
    }
    value = * (double*) &ap->value[ap->readPosition];
    value = swapDouble(ap, value);
    adjustReadPosition(ap, sizeof(double));
    return (EjsObj*) ejsCreateDate(ejs, (MprTime) value);
}


/**
    Read a double from the array. The data will be decoded according to the encoding property.
    function readDouble(): Date
 */
static EjsObj *ba_readDouble(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    double  value;

    if (getInput(ejs, ap, EJS_SIZE_DOUBLE) <= 0) {
        if (availableBytes(ap) > 0) {
            ejsThrowIOError(ejs, "Premanture eof");
            return 0;
        }
        return (EjsObj*) ejs->nullValue;
    }

    value = * (double*) &ap->value[ap->readPosition];
    value = swapDouble(ap, value);
    adjustReadPosition(ap, sizeof(double));

    return (EjsObj*) ejsCreateNumber(ejs, (MprNumber) value);
}


/*
    Read a 32-bit integer from the array. The data will be decoded according to the encoding property.
    function readInteger(): Number
 */
static EjsObj *ba_readInteger(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    int     value;

    if (getInput(ejs, ap, EJS_SIZE_INT) <= 0) {
        if (availableBytes(ap) > 0) {
            ejsThrowIOError(ejs, "Premanture eof");
            return 0;
        }
        return (EjsObj*) ejs->nullValue;
    }
    value = * (int*) &ap->value[ap->readPosition];
    value = swap32(ap, value);
    adjustReadPosition(ap, sizeof(int));
    return (EjsObj*) ejsCreateNumber(ejs, value);
}


/*
    Read a 64-bit long from the array.The data will be decoded according to the encoding property.
    function readLong(): Number
 */
static EjsObj *ba_readLong(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    int64   value;

    if (getInput(ejs, ap, EJS_SIZE_LONG) <= 0) {
        if (availableBytes(ap) > 0) {
            ejsThrowIOError(ejs, "Premanture eof");
            return 0;
        }
        return (EjsObj*) ejs->nullValue;
    }
    value = * (int64*) &ap->value[ap->readPosition];
    value = swap64(ap, value);
    adjustReadPosition(ap, sizeof(int64));
    return (EjsObj*) ejsCreateNumber(ejs, (MprNumber) value);
}


/*
    Get the current read position offset
    function get readPosition(): Number
 */
static EjsObj *ba_readPosition(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateNumber(ejs, ap->readPosition);
}


/*
    Set the current read position offset
    function set readPosition(position: Number): Void
 */
static EjsObj *ba_setReadPosition(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    int     pos;

    mprAssert(argc == 1 && ejsIsNumber(argv[0]));

    pos = ejsGetInt(ejs, argv[0]);
    if (pos < 0 || pos > ap->length) {
        ejsThrowOutOfBoundsError(ejs, "Bad position value");
        return 0;
    }
    if (pos > ap->writePosition) {
        ejsThrowStateError(ejs, "Read position is greater than write position");
    } else {
        ap->readPosition = pos;
    }
    return 0;
}


/*
    Read a 16-bit short integer from the array. The data will be decoded according to the encoding property.
    function readShort(): Number
 */
static EjsObj *ba_readShort(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    int     value;

    if (getInput(ejs, ap, EJS_SIZE_SHORT) <= 0) {
        return (EjsObj*) ejs->nullValue;
    }
    value = * (short*) &ap->value[ap->readPosition];
    value = swap16(ap, value);
    adjustReadPosition(ap, sizeof(short));
    return (EjsObj*) ejsCreateNumber(ejs, value);
}


/*
    Read a UTF-8 string from the array. Read data from the read position up to the write position but not more than count characters.
    function readString(count: Number = -1): String
 */
static EjsObj *ba_readString(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    EjsObj  *result;
    int     count;

    count = (argc == 1) ? ejsGetInt(ejs, argv[0]) : -1;

    if (count < 0) {
        if (getInput(ejs, ap, 1) < 0) {
            return (EjsObj*) ejs->nullValue;
        }
        count = availableBytes(ap);

    } else if (getInput(ejs, ap, count) < 0) {
        return (EjsObj*) ejs->nullValue;
    }
    count = min(count, availableBytes(ap));
    result = (EjsObj*) ejsCreateStringWithLength(ejs, (cchar*) &ap->value[ap->readPosition], count);
    adjustReadPosition(ap, count);
    return result;
}


/*
    Reset the read and write position pointers if there is no available data.
    function reset(): Void
 */
static EjsObj *ba_reset(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    mprAssert(argc == 0);

    if (ap->writePosition == ap->readPosition) {
        ap->writePosition = ap->readPosition = 0;
    }
    return 0;
}


/**
    function get removeListener(name, listener: Function): Number
 */
static EjsObj *ba_removeListener(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    ejsRemoveListener(ejs, ap->emitter, argv[0], argv[1]);
    return 0;
}


/**
    Get the number of data bytes that the array can store from the write position till the end of the array.
    function get room(): Number
 */
static EjsObj *ba_room(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateNumber(ejs, room(ap));
}


/*
    Convert the byte array data between the read and write positions into a string.
    override function toString(): String
 */
static EjsObj *ba_toString(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateStringWithLength(ejs, (cchar*) &ap->value[ap->readPosition], availableBytes(ap));
}


/*
    Write data to the array. Data is written to the current write $position pointer.
    function write(...data): Number
 */
EjsNumber *ejsWriteToByteArray(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    EjsArray        *args;
    EjsByteArray    *bp;
    EjsString       *sp;
    EjsObj          *vp;
    int             i, len, wrote;

    mprAssert(argc == 1 && ejsIsArray(argv[0]));

    /*
        Unwrap nested arrays
     */
    args = (EjsArray*) argv[0];
    while (args && ejsIsArray(args) && args->length == 1) {
        vp = ejsGetProperty(ejs, (EjsVar*) args, 0);
        if (!ejsIsArray(vp)) {
            break;
        }
        args = (EjsArray*) vp;
    }

    if (availableBytes(ap) == 0) {
        ap->writePosition = ap->readPosition = 0;
    }
    wrote = 0;

    for (i = 0; i < args->length; i++) {
        vp = ejsGetProperty(ejs, (EjsVar*) args, i);
        if (vp == 0) {
            continue;
        }
        switch (vp->type->id) {
        case ES_Boolean:
            if (!makeRoom(ejs, ap, EJS_SIZE_BOOLEAN)) {
                return 0;
            }
            wrote += putByte(ap, ejsGetBoolean(ejs, vp));
            break;

        case ES_Date:
            if (!makeRoom(ejs, ap, EJS_SIZE_DOUBLE)) {
                return 0;
            }
            wrote += putNumber(ap, (MprNumber) ((EjsDate*) vp)->value);
            break;

        case ES_Number:
            if (!makeRoom(ejs, ap, EJS_SIZE_DOUBLE)) {
                return 0;
            }
            wrote += putNumber(ap, ejsGetNumber(ejs, vp));
            break;

        case ES_String:
            if (!makeRoom(ejs, ap, ((EjsString*) vp)->length)) {
                return 0;
            }
            sp = (EjsString*) vp;
            wrote += putString(ap, sp->value, sp->length);
            break;

        default:
            sp = ejsToString(ejs, vp);
            wrote += putString(ap, sp->value, sp->length);
            break;

        case ES_ByteArray:
            bp = (EjsByteArray*) vp;
            len = availableBytes(bp);
            if (!makeRoom(ejs, ap, len)) {
                return 0;
            }
            /*
                Note: this only copies between the read/write positions of the source byte array
             */
            ejsCopyToByteArray(ejs, ap, ap->writePosition, (char*) &bp->value[bp->readPosition], len);
            ap->writePosition += len;
            wrote += len;
            break;
        }
    }
    if (ap->emitter && wrote > 0 && availableBytes(ap) > 0) {
        ejsSendEvent(ejs, ap->emitter, "readable", (EjsObj*) ap);
    }
    return ejsCreateNumber(ejs, wrote);
}


/*
    Write a byte to the array
    function writeByte(value: Number): Void
 */
static EjsObj *ba_writeByte(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    if (!makeRoom(ejs, ap, 1)) {
        return 0;
    }
    putByte(ap, ejsGetInt(ejs, argv[0]));
    if (ap->emitter) {
        ejsSendEvent(ejs, ap->emitter, "readable", (EjsObj*) ap);
    }
    return 0;
}


/*
    Write a short to the array
    function writeShort(value: Number): Void
 */
static EjsObj *ba_writeShort(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    if (!makeRoom(ejs, ap, sizeof(short))) {
        return 0;
    }
    putShort(ap, ejsGetInt(ejs, argv[0]));
    if (ap->emitter) {
        ejsSendEvent(ejs, ap->emitter, "readable", (EjsObj*) ap);
    }
    return 0;
}


/*
    Write a double to the array
    function writeDouble(value: Number): Void
 */
static EjsObj *ba_writeDouble(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    if (!makeRoom(ejs, ap, sizeof(double))) {
        return 0;
    }
    putDouble(ap, ejsGetDouble(ejs, argv[0]));
    if (ap->emitter) {
        ejsSendEvent(ejs, ap->emitter, "readable", (EjsObj*) ap);
    }
    return 0;
}


/*
    Write an integer (32 bits) to the array
    function writeInteger(value: Number): Void
 */

static EjsObj *ba_writeInteger(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    if (!makeRoom(ejs, ap, sizeof(int))) {
        return 0;
    }
    putInteger(ap, ejsGetInt(ejs, argv[0]));
    if (ap->emitter) {
        ejsSendEvent(ejs, ap->emitter, "readable", (EjsObj*) ap);
    }
    return 0;
}


/*
    Write a long (64 bit) to the array
    function writeLong(value: Number): Void
 */
static EjsObj *ba_writeLong(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    if (!makeRoom(ejs, ap, sizeof(int))) {
        return 0;
    }
    putLong(ap, ejsGetInt(ejs, argv[0]));
    if (ap->emitter) {
        ejsSendEvent(ejs, ap->emitter, "readable", (EjsObj*) ap);
    }
    return 0;
}


/*
    Get the current write position offset
    function get writePosition(): Number
 */
static EjsObj *ba_writePosition(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateNumber(ejs, ap->writePosition);
}


/*
    Set the current write position offset
    function set writePosition(position: Number): Void
 */
static EjsObj *ba_setWritePosition(Ejs *ejs, EjsByteArray *ap, int argc, EjsObj **argv)
{
    int     pos;

    mprAssert(argc == 1 && ejsIsNumber(argv[0]));

    pos = ejsGetInt(ejs, argv[0]);
    if (pos < 0 || pos > ap->length) {
        ejsThrowStateError(ejs, "Write position is outside bounds of array");
        return 0;
    }
    if (pos < ap->readPosition) {
        ejsThrowStateError(ejs, "Write position is less than read position");
    } else {
        ap->writePosition = pos;
    }
    return 0;
}


/*
    Flush the array. Issue a "flush" event. Flushing attempts to write pending data before resetting the array.
 */
static int flushByteArray(Ejs *ejs, EjsByteArray *ap)
{
    if (ap->emitter && availableBytes(ap) && !ejs->exception) {
        ejsSendEvent(ejs, ap->emitter, "flush", (EjsObj*) ap);
    }
    ap->writePosition = ap->readPosition = 0;
    if (ap->emitter) {
        ejsSendEvent(ejs, ap->emitter, "writable", (EjsObj*) ap);
    }
    return 0;
}


int ejsGrowByteArray(Ejs *ejs, EjsByteArray *ap, int len)
{
    if (len > ap->length) {
        ap->value = mprRealloc(ap, ap->value, len);
        if (ap->value == 0) {
            ejsThrowMemoryError(ejs);
            return EJS_ERR;
        }
        memset(&ap->value[ap->length], 0, len - ap->length);
        ap->growInc = min(ap->growInc * 2, 32 * 1024);
        ap->length = len;
    }
    return 0;
}


/*
    Get more input sufficient to satisfy the rquired number of bytes. The required parameter specifies how many bytes 
    must be read. Short fills are not permitted. Return the count of bytes available or 0 if the required number of 
    bytes can't be read. Return -ve on errors.
 */
static int getInput(Ejs *ejs, EjsByteArray *ap, int required)
{
    if (availableBytes(ap) == 0) {
        ap->writePosition = ap->readPosition = 0;
    }
    if (availableBytes(ap) < required && !ejs->exception) {
        if (ap->emitter) {
            ejsSendEvent(ejs, ap->emitter, "writable", (EjsObj*) ap);
        }
    }
    if (availableBytes(ap) < required) {
        return 0;
    }
    return availableBytes(ap);
}


static bool makeRoom(Ejs *ejs, EjsByteArray *ap, int require)
{
    int     newLen;

    if (room(ap) < require) {
        if (ap->emitter) {
            ejsSendEvent(ejs, ap->emitter, "readable", (EjsObj*) ap);
        }
        if (room(ap) < require) {
            newLen = max(ap->length + require, ap->length + ap->growInc);
            if (!ap->growable || ejsGrowByteArray(ejs, ap, newLen) < 0) {
                if (!ejs->exception) {
                    ejsThrowResourceError(ejs, "Byte array is too small");
                }
                return 0;
            }
        }
    }
    return 1;
}


static MPR_INLINE int swap16(EjsByteArray *ap, int a)
{
    if (!ap->swap) {
        return a;
    }
    return (a & 0xFF) << 8 | (a & 0xFF00 >> 8);
}


static MPR_INLINE int swap32(EjsByteArray *ap, int a)
{
    if (!ap->swap) {
        return a;
    }
    return (a & 0xFF) << 24 | (a & 0xFF00 << 8) | (a & 0xFF0000 >> 8) | (a & 0xFF000000 >> 16);
}


static MPR_INLINE int64 swap64(EjsByteArray *ap, int64 a)
{
    int64   low, high;

    if (!ap->swap) {
        return a;
    }
    low = a & 0xFFFFFFFF;
    high = (a >> 32) & 0xFFFFFFFF;
    return  (low & 0xFF) << 24 | (low & 0xFF00 << 8) | (low & 0xFF0000 >> 8) | (low & 0xFF000000 >> 16) |
            ((high & 0xFF) << 24 | (high & 0xFF00 << 8) | (high & 0xFF0000 >> 8) | (high & 0xFF000000 >> 16)) << 32;
}


static MPR_INLINE double swapDouble(EjsByteArray *ap, double a)
{
    int64   low, high;

    if (!ap->swap) {
        return a;
    }
    low = ((int64) a) & 0xFFFFFFFF;
    high = (((int64) a) >> 32) & 0xFFFFFFFF;
    return  (double) ((low & 0xFF) << 24 | (low & 0xFF00 << 8) | (low & 0xFF0000 >> 8) | (low & 0xFF000000 >> 16) |
            ((high & 0xFF) << 24 | (high & 0xFF00 << 8) | (high & 0xFF0000 >> 8) | (high & 0xFF000000 >> 16)) << 32);
}


static int putByte(EjsByteArray *ap, int value)
{
    ap->value[ap->writePosition++] = (char) value;
    return sizeof(char);
}


static int putShort(EjsByteArray *ap, int value)
{
    value = swap16(ap, value);

    *((short*) &ap->value[ap->writePosition]) = (short) value;
    ap->writePosition += sizeof(short);
    return sizeof(short);
}


static int putInteger(EjsByteArray *ap, int value)
{
    value = swap32(ap, value);

    *((int*) &ap->value[ap->writePosition]) = (int) value;
    ap->writePosition += sizeof(int);
    return sizeof(int);
}


static int putLong(EjsByteArray *ap, int64 value)
{
    value = swap64(ap, value);

    *((int64*) &ap->value[ap->writePosition]) = value;
    ap->writePosition += sizeof(int64);
    return sizeof(int64);
}


static int putDouble(EjsByteArray *ap, double value)
{
    value = swapDouble(ap, value);

    *((double*) &ap->value[ap->writePosition]) = value;
    ap->writePosition += sizeof(double);
    return sizeof(double);
}


/*
    Write a number in the default number encoding
 */
static int putNumber(EjsByteArray *ap, MprNumber value)
{
    return putDouble(ap, value);
}


static int putString(EjsByteArray *ap, cchar *value, int len)
{
    mprMemcpy(&ap->value[ap->writePosition], room(ap), value, len);
    ap->writePosition += len;
    return len;
}


void ejsResetByteArray(EjsByteArray *ba)
{
    if (ba->writePosition == ba->readPosition) {
        ba->writePosition = ba->readPosition = 0;
    }
}


void ejsSetByteArrayPositions(Ejs *ejs, EjsByteArray *ba, int readPosition, int writePosition)
{
    if (readPosition >= 0) {
        ba->readPosition = readPosition;
    }
    if (writePosition >= 0) {
        ba->writePosition = writePosition;
    }
}


int ejsCopyToByteArray(Ejs *ejs, EjsByteArray *ba, int offset, char *data, int length)
{
    int     i;

    mprAssert(ba);
    mprAssert(data);

    if (!makeRoom(ejs, ba, offset + length)) {
        return EJS_ERR;
    }
    if (ba->length < (offset + length)) {
        return EJS_ERR;
    }
    for (i = 0; i < length; i++) {
        ba->value[offset++] = data[i];
    }
    return 0;
}


int ejsGetByteArrayAvailable(EjsByteArray *ba)
{
    return availableBytes(ba);
}


int ejsGetByteArrayRoom(EjsByteArray *ba)
{
    return room(ba);
}


EjsByteArray *ejsCreateByteArray(Ejs *ejs, int size)
{
    EjsByteArray    *ap;

    /*
        No need to invoke constructor
     */
    ap = (EjsByteArray*) ejsCreate(ejs, ejs->byteArrayType, 0);
    if (ap == 0) {
        return 0;
    }
    if (size <= 0) {
        size = MPR_BUFSIZE;
    }
    if (ejsGrowByteArray(ejs, ap, size) < 0) {
        return 0;
    }
    ap->length = size;
    ap->async = -1;
    ap->growable = 1;
    ap->growInc = MPR_BUFSIZE;
    ap->endian = mprGetEndian(ejs);
    ejsSetDebugName(ap, "ByteArray instance");
    return ap;
}


void ejsConfigureByteArrayType(Ejs *ejs)
{
    EjsType     *type;

    type = ejs->byteArrayType = ejsConfigureNativeType(ejs, "ejs", "ByteArray", sizeof(EjsByteArray));

    type->helpers->cast = (EjsCastHelper) castByteArrayVar;
    type->helpers->clone = (EjsCloneHelper) cloneByteArrayVar;
    type->helpers->getProperty = (EjsGetPropertyHelper) getByteArrayProperty;
    type->helpers->getPropertyCount = (EjsGetPropertyCountHelper) getByteArrayPropertyCount;
    type->helpers->deleteProperty = (EjsDeletePropertyHelper) deleteByteArrayProperty;
    type->helpers->invokeOperator = (EjsInvokeOperatorHelper) invokeByteArrayOperator;
    type->helpers->mark = (EjsMarkHelper) markByteArrayVar;
    type->helpers->lookupProperty = (EjsLookupPropertyHelper) lookupByteArrayProperty;
    type->helpers->setProperty = (EjsSetPropertyHelper) setByteArrayProperty;
    
    ejsBindMethod(ejs, type, ES_ByteArray_ByteArray, (EjsProc) ba_ByteArray);
    ejsBindMethod(ejs, type, ES_ByteArray_addListener, (EjsProc) ba_addListener);
    ejsBindMethod(ejs, type, ES_ByteArray_available, (EjsProc) ba_available);
    ejsBindAccess(ejs, type, ES_ByteArray_async, (EjsProc) ba_async, (EjsProc) ba_setAsync);
    ejsBindMethod(ejs, type, ES_ByteArray_close, (EjsProc) ba_close);
    ejsBindMethod(ejs, type, ES_ByteArray_compact, (EjsProc) ba_compact);
    ejsBindMethod(ejs, type, ES_ByteArray_copyIn, (EjsProc) ba_copyIn);
    ejsBindMethod(ejs, type, ES_ByteArray_copyOut, (EjsProc) ba_copyOut);
    ejsBindMethod(ejs, type, ES_ByteArray_flush, (EjsProc) ba_flush);
    ejsBindMethod(ejs, type, ES_ByteArray_length, (EjsProc) ba_getLength);
    ejsBindMethod(ejs, type, ES_Object_get, (EjsProc) ba_get);
    ejsBindMethod(ejs, type, ES_Object_getValues, (EjsProc) ba_getValues);
    ejsBindAccess(ejs, type, ES_ByteArray_endian, (EjsProc) endian, (EjsProc) setEndian);
    ejsBindMethod(ejs, type, ES_ByteArray_read, (EjsProc) ba_read);
    ejsBindMethod(ejs, type, ES_ByteArray_readBoolean, (EjsProc) ba_readBoolean);
    ejsBindMethod(ejs, type, ES_ByteArray_readByte, (EjsProc) ba_readByte);
    ejsBindMethod(ejs, type, ES_ByteArray_readDate, (EjsProc) ba_readDate);
    ejsBindMethod(ejs, type, ES_ByteArray_readDouble, (EjsProc) ba_readDouble);
    ejsBindMethod(ejs, type, ES_ByteArray_readInteger, (EjsProc) ba_readInteger);
    ejsBindMethod(ejs, type, ES_ByteArray_readLong, (EjsProc) ba_readLong);
    ejsBindAccess(ejs, type, ES_ByteArray_readPosition, (EjsProc) ba_readPosition,(EjsProc) ba_setReadPosition);
    ejsBindMethod(ejs, type, ES_ByteArray_readShort, (EjsProc) ba_readShort);
    ejsBindMethod(ejs, type, ES_ByteArray_readString, (EjsProc) ba_readString);
    ejsBindMethod(ejs, type, ES_ByteArray_removeListener, (EjsProc) ba_removeListener);
    ejsBindMethod(ejs, type, ES_ByteArray_reset, (EjsProc) ba_reset);
    ejsBindMethod(ejs, type, ES_ByteArray_room, (EjsProc) ba_room);
    ejsBindMethod(ejs, type, ES_Object_toString, (EjsProc) ba_toString);
    ejsBindMethod(ejs, type, ES_ByteArray_write, (EjsProc) ejsWriteToByteArray);
    ejsBindMethod(ejs, type, ES_ByteArray_writeByte, (EjsProc) ba_writeByte);
    ejsBindMethod(ejs, type, ES_ByteArray_writeShort, (EjsProc) ba_writeShort);
    ejsBindMethod(ejs, type, ES_ByteArray_writeInteger, (EjsProc) ba_writeInteger);
    ejsBindMethod(ejs, type, ES_ByteArray_writeLong, (EjsProc) ba_writeLong);
    ejsBindMethod(ejs, type, ES_ByteArray_writeDouble, (EjsProc) ba_writeDouble);
    ejsBindAccess(ejs, type, ES_ByteArray_writePosition, (EjsProc) ba_writePosition, (EjsProc) ba_setWritePosition);
}


/*
    @copy   default
  
    Copyright (c) Embedthis Software LLC, 2003-2010. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2010. All Rights Reserved.
  
    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.
  
    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html
  
    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
  
    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com
  
    @end
 */
/************************************************************************/
/*
 *  End of file "../src/core/src/ejsByteArray.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../src/core/src/ejsConfig.c"
 */
/************************************************************************/

/*
    ejsConfig.c -- Config class
  
    Copyright (c) All Rights Reserved. See details at the end of the file.
 */




void ejsConfigureConfigType(Ejs *ejs)
{
    EjsType     *type;
    EjsObj      *vp;
    char        version[16];

    type = ejsConfigureNativeType(ejs, "ejs", "Config", sizeof(EjsObj));
    vp = (EjsObj*) type;
    ejsSetProperty(ejs, vp, ES_Config_Debug, BLD_DEBUG ? (EjsObj*) ejs->trueValue: (EjsObj*) ejs->falseValue);
    ejsSetProperty(ejs, vp, ES_Config_CPU, (EjsObj*) ejsCreateString(ejs, BLD_HOST_CPU));
    ejsSetProperty(ejs, vp, ES_Config_OS, (EjsObj*) ejsCreateString(ejs, BLD_OS));
    ejsSetProperty(ejs, vp, ES_Config_Product, (EjsObj*) ejsCreateString(ejs, BLD_PRODUCT));

    ejsSetProperty(ejs, vp, ES_Config_Title, (EjsObj*) ejsCreateString(ejs, BLD_NAME));
    mprSprintf(version, sizeof(version), "%s-%s", BLD_VERSION, BLD_NUMBER);
    ejsSetProperty(ejs, vp, ES_Config_Version, (EjsObj*) ejsCreateString(ejs, version));

#if BLD_WIN_LIKE
{
    char    *path;

    path = mprGetAppDir(ejs);
    ejsSetProperty(ejs, vp, ES_Config_BinDir, (EjsObj*) ejsCreateString(ejs, path));
    ejsSetProperty(ejs, vp, ES_Config_ModDir, (EjsObj*) ejsCreateString(ejs, path));
    ejsSetProperty(ejs, vp, ES_Config_LibDir, (EjsObj*) ejsCreateString(ejs, path));
}
#else
    ejsSetProperty(ejs, vp, ES_Config_BinDir, (EjsObj*) ejsCreateString(ejs, BLD_BIN_PREFIX));
    ejsSetProperty(ejs, vp, ES_Config_ModDir, (EjsObj*) ejsCreateString(ejs, BLD_MOD_PREFIX));
    ejsSetProperty(ejs, vp, ES_Config_LibDir, (EjsObj*) ejsCreateString(ejs, BLD_LIB_PREFIX));
#endif
}


/*
    @copy   default
  
    Copyright (c) Embedthis Software LLC, 2003-2010. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2010. All Rights Reserved.
  
    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.
  
    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html
  
    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
  
    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com
  
    @end
 */
/************************************************************************/
/*
 *  End of file "../src/core/src/ejsConfig.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../src/core/src/ejsDate.c"
 */
/************************************************************************/

/**
    ejsDate.c - Date type class

    Date/time is store internally as milliseconds since 1970/01/01 GMT

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */



/*
    TODO - move to ejsNumber.h. But would have to rename fixed() to ejsFixed()
 */
#define fixed(n) ((int64) (floor(n)))

#if BLD_WIN_LIKE
#pragma warning (disable:4244)
#endif

//  TODO this is a generic need. Make an API

#define getNumber(ejs, a) ejsGetNumber(ejs, (EjsObj*) ejsToNumber(ejs, ((EjsObj*) a)))

/*
    Cast the operand to the specified type

    intrinsic function cast(type: Type) : Object
 */

static EjsObj *castDate(Ejs *ejs, EjsDate *dp, EjsType *type)
{
    struct tm   tm;

    switch (type->id) {

    case ES_Boolean:
        return (EjsObj*) ejs->trueValue;

    case ES_Number:
        return (EjsObj*) ejsCreateNumber(ejs, (MprNumber) dp->value);

    case ES_String:
        /*
            Format:  Tue Jul 15 2010 10:53:23 GMT-0700 (PDT)
         */
        mprDecodeLocalTime(ejs, &tm, dp->value);
        return (EjsObj*) ejsCreateStringAndFree(ejs, mprFormatTime(ejs, "%a %b %d %Y %T GMT%z (%Z)", &tm));

    default:
        ejsThrowTypeError(ejs, "Can't cast to this type");
        return 0;
    }
    return 0;
}


static EjsObj *cloneDate(Ejs *ejs, EjsDate *dp, int deep)
{
    if (deep) {
        return (EjsObj*) ejsCreateDate(ejs, dp->value);
    } 
    return (EjsObj*) dp;
}


/*
    TODO - this is the same as number. Should share code
 */
static EjsObj *coerceDateOperands(Ejs *ejs, EjsObj *lhs, int opcode, EjsObj *rhs)
{
    switch (opcode) {
    /*
        Binary operators
     */
    case EJS_OP_ADD:
        if (ejsIsUndefined(rhs)) {
            return (EjsObj*) ejs->nanValue;
        } else if (ejsIsNull(rhs)) {
            rhs = (EjsObj*) ejs->zeroValue;
        } else if (ejsIsBoolean(rhs) || ejsIsNumber(rhs)) {
            return ejsInvokeOperator(ejs, (EjsObj*) ejsToNumber(ejs, lhs), opcode, rhs);
        } else {
            return ejsInvokeOperator(ejs, (EjsObj*) ejsToString(ejs, lhs), opcode, rhs);
        }
        break;

    case EJS_OP_AND: case EJS_OP_DIV: case EJS_OP_MUL: case EJS_OP_OR: case EJS_OP_REM:
    case EJS_OP_SHL: case EJS_OP_SHR: case EJS_OP_SUB: case EJS_OP_USHR: case EJS_OP_XOR:
        return ejsInvokeOperator(ejs, (EjsObj*) ejsToNumber(ejs, lhs), opcode, rhs);

    case EJS_OP_COMPARE_EQ: case EJS_OP_COMPARE_NE:
    case EJS_OP_COMPARE_LE: case EJS_OP_COMPARE_LT:
    case EJS_OP_COMPARE_GE: case EJS_OP_COMPARE_GT:
        if (ejsIsString(rhs)) {
            return ejsInvokeOperator(ejs, (EjsObj*) ejsToString(ejs, lhs), opcode, rhs);
        }
        return ejsInvokeOperator(ejs, (EjsObj*) ejsToNumber(ejs, lhs), opcode, rhs);

    case EJS_OP_COMPARE_STRICTLY_NE:
        return (EjsObj*) ejs->trueValue;

    case EJS_OP_COMPARE_STRICTLY_EQ:
        return (EjsObj*) ejs->falseValue;

    /*
        Unary operators
     */
    case EJS_OP_LOGICAL_NOT: case EJS_OP_NOT: case EJS_OP_NEG:
        return 0;

    case EJS_OP_COMPARE_NOT_ZERO:
    case EJS_OP_COMPARE_TRUE:
        return (EjsObj*) (((EjsDate*) lhs)->value ? ejs->trueValue : ejs->falseValue);

    case EJS_OP_COMPARE_ZERO:
    case EJS_OP_COMPARE_FALSE:
        return (EjsObj*) (((EjsDate*) lhs)->value ? ejs->falseValue: ejs->trueValue);

    case EJS_OP_COMPARE_UNDEFINED:
    case EJS_OP_COMPARE_NULL:
        return (EjsObj*) ejs->falseValue;

    default:
        ejsThrowTypeError(ejs, "Opcode %d not valid for type %s", opcode, lhs->type->qname.name);
        return ejs->undefinedValue;
    }
    return 0;
}


static EjsObj *invokeDateOperator(Ejs *ejs, EjsDate *lhs, int opcode, EjsDate *rhs)
{
    EjsObj      *result;

    if (rhs == 0 || lhs->obj.type != rhs->obj.type) {
        if (!ejsIsA(ejs, (EjsObj*) lhs, ejs->dateType) || !ejsIsA(ejs, (EjsObj*) rhs, ejs->dateType)) {
            if ((result = coerceDateOperands(ejs, (EjsObj*) lhs, opcode, (EjsObj*) rhs)) != 0) {
                return result;
            }
        }
    }

    switch (opcode) {
    case EJS_OP_COMPARE_EQ: case EJS_OP_COMPARE_STRICTLY_EQ:
        return (EjsObj*) ejsCreateBoolean(ejs, lhs->value == rhs->value);

    case EJS_OP_COMPARE_NE: case EJS_OP_COMPARE_STRICTLY_NE:
        return (EjsObj*) ejsCreateBoolean(ejs, !(lhs->value == rhs->value));

    case EJS_OP_COMPARE_LT:
        return (EjsObj*) ejsCreateBoolean(ejs, lhs->value < rhs->value);

    case EJS_OP_COMPARE_LE:
        return (EjsObj*) ejsCreateBoolean(ejs, lhs->value <= rhs->value);

    case EJS_OP_COMPARE_GT:
        return (EjsObj*) ejsCreateBoolean(ejs, lhs->value > rhs->value);

    case EJS_OP_COMPARE_GE:
        return (EjsObj*) ejsCreateBoolean(ejs, lhs->value >= rhs->value);

    case EJS_OP_COMPARE_NOT_ZERO:
        return (EjsObj*) ((lhs->value) ? ejs->trueValue: ejs->falseValue);

    case EJS_OP_COMPARE_ZERO:
        return (EjsObj*) ((lhs->value == 0) ? ejs->trueValue: ejs->falseValue);

    case EJS_OP_COMPARE_UNDEFINED:
    case EJS_OP_COMPARE_NULL:
    case EJS_OP_COMPARE_FALSE:
    case EJS_OP_COMPARE_TRUE:
        return (EjsObj*) ejs->falseValue;

    /*
        Unary operators
     */
    case EJS_OP_NEG:
        return (EjsObj*) ejsCreateNumber(ejs, - (MprNumber) lhs->value);

    case EJS_OP_LOGICAL_NOT:
        return (EjsObj*) ejsCreateBoolean(ejs, (MprNumber) !fixed(lhs->value));

    case EJS_OP_NOT:
        return (EjsObj*) ejsCreateNumber(ejs, (MprNumber) (~fixed(lhs->value)));

    /*
        Binary operators
     */
    case EJS_OP_ADD:
        return (EjsObj*) ejsCreateDate(ejs, lhs->value + rhs->value);

    case EJS_OP_AND:
        return (EjsObj*) ejsCreateDate(ejs, (MprNumber) (fixed(lhs->value) & fixed(rhs->value)));

    case EJS_OP_DIV:
        if (rhs->value == 0) {
            ejsThrowArithmeticError(ejs, "Divisor is zero");
            return 0;
        }
        return (EjsObj*) ejsCreateDate(ejs, lhs->value / rhs->value);

    case EJS_OP_MUL:
        return (EjsObj*) ejsCreateDate(ejs, lhs->value * rhs->value);

    case EJS_OP_OR:
        return (EjsObj*) ejsCreateDate(ejs, (MprNumber) (fixed(lhs->value) | fixed(rhs->value)));

    case EJS_OP_REM:
        if (rhs->value == 0) {
            ejsThrowArithmeticError(ejs, "Divisor is zero");
            return 0;
        }
        return (EjsObj*) ejsCreateDate(ejs, (MprNumber) (fixed(lhs->value) % fixed(rhs->value)));

    case EJS_OP_SHL:
        return (EjsObj*) ejsCreateDate(ejs, (MprNumber) (fixed(lhs->value) << fixed(rhs->value)));

    case EJS_OP_SHR:
        return (EjsObj*) ejsCreateDate(ejs, (MprNumber) (fixed(lhs->value) >> fixed(rhs->value)));

    case EJS_OP_SUB:
        return (EjsObj*) ejsCreateDate(ejs, (MprNumber) (fixed(lhs->value) - fixed(rhs->value)));

    case EJS_OP_USHR:
        return (EjsObj*) ejsCreateDate(ejs, (MprNumber) (fixed(lhs->value) >> fixed(rhs->value)));

    case EJS_OP_XOR:
        return (EjsObj*) ejsCreateDate(ejs, (MprNumber) (fixed(lhs->value) ^ fixed(rhs->value)));

    default:
        ejsThrowTypeError(ejs, "Opcode %d not implemented for type %s", opcode, lhs->obj.type->qname.name);
        return 0;
    }
    /* Should never get here */
}


/*
    Date constructor
        Date()
        Date(milliseconds)
        Date(dateString)
        Date(year, month, date, hour, minute, second, msec)
        @param milliseconds Integer representing milliseconds since 1 January 1970 00:00:00 UTC.
        @param dateString String date value in a format recognized by parse().
        @param year Integer value for the year. Should be a Four digit year (e.g. 1998).
        @param month Integer month value (0-11)
        @param date Integer date of the month (1-31)
        @param hour Integer hour value (0-23)
        @param minute Integer minute value (0-59)
        @param second Integer second value (0-59)
        @param msec Integer millisecond value (0-999)
*/
static EjsObj *date_Date(Ejs *ejs, EjsDate *date, int argc, EjsObj **argv)
{
    EjsArray    *args;
    EjsObj      *vp;
    struct tm   tm;
    int         year;

    mprAssert(argc == 1 && ejsIsArray(argv[0]));

    args = (EjsArray*) argv[0];

    if (args->length == 0) {
        /* Now */
        date->value = mprGetTime(ejs);

    } else if (args->length == 1) {
        vp = ejsGetProperty(ejs, (EjsObj*) args, 0);
        if (ejsIsNumber(vp)) {
            /* Milliseconds */
            date->value = ejsGetNumber(ejs, vp);

        } else if (ejsIsString(vp)) {
            if (mprParseTime(ejs, &date->value, ejsGetString(ejs, vp), MPR_LOCAL_TIMEZONE, NULL) < 0) {
                ejsThrowArgError(ejs, "Can't parse date string: %s", ejsGetString(ejs, vp));
                return 0;
            }
        } else if (ejsIsDate(vp)) {
            date->value = ((EjsDate*) vp)->value;

        } else {
            ejsThrowArgError(ejs, "Can't construct date from this argument");
        }

    } else {
        /* Date(year, month, date, hour, minute, second, msec) or any portion thereof */
        memset(&tm, 0, sizeof(tm));
        tm.tm_isdst = -1;
        vp = ejsGetProperty(ejs, (EjsObj*) args, 0);
        year = getNumber(ejs, vp);
        if (year < 100) {
            year += 1900;
        }
        tm.tm_year = year - 1900;
        if (args->length > 1) {
            vp = ejsGetProperty(ejs, (EjsObj*) args, 1);
            tm.tm_mon = getNumber(ejs, vp);
        }
        if (args->length > 2) {
            vp = ejsGetProperty(ejs, (EjsObj*) args, 2);
            tm.tm_mday = getNumber(ejs, vp);
        }
        if (args->length > 3) {
            vp = ejsGetProperty(ejs, (EjsObj*) args, 3);
            tm.tm_hour = getNumber(ejs, vp);
        }
        if (args->length > 4) {
            vp = ejsGetProperty(ejs, (EjsObj*) args, 4);
            tm.tm_min = getNumber(ejs, vp);
        }
        if (args->length > 5) {
            vp = ejsGetProperty(ejs, (EjsObj*) args, 5);
            tm.tm_sec = getNumber(ejs, vp);
        }
        date->value = mprMakeTime(ejs, &tm);
        if (date->value == -1) {
            ejsThrowArgError(ejs, "Can't construct date from this argument");
        } else if (args->length > 6) {
            vp = ejsGetProperty(ejs, (EjsObj*) args, 6);
            date->value += getNumber(ejs, vp);
        }
    }
    return (EjsObj*) date;
}


/*
    function get day(): Number
    Range: 0-6, where 0 is Sunday
 */
static EjsObj *date_day(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;

    mprDecodeLocalTime(ejs, &tm, dp->value);
    return (EjsObj*) ejsCreateNumber(ejs, tm.tm_wday);
}


/*
    function set day(day: Number): Void
    Range: 0-6, where 0 is Sunday
*/
static EjsObj *date_set_day(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;
    int         dayDiff, day;

    day = ejsGetNumber(ejs, argv[0]);
    if (day < 0 || day > 6) {
        ejsThrowArgError(ejs, "Bad day. Range 0-6");
        return 0;
    }
    mprDecodeLocalTime(ejs, &tm, dp->value);
    dayDiff = day - tm.tm_wday;
    dp->value += dayDiff * 86400 * MPR_TICKS_PER_SEC;
    return 0;
}


/*
    function get dayOfYear(): Number
    Return day of year (0 - 365)
 */
static EjsObj *date_dayOfYear(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;

    mprDecodeLocalTime(ejs, &tm, dp->value);
    return (EjsObj*) ejsCreateNumber(ejs, tm.tm_yday);
}


/*
    function set dayOfYear(day: Number): Void
    Set the day of year (0 - 365)
 */
static EjsObj *date_set_dayOfYear(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;
    int         dayDiff, day;

    day = ejsGetNumber(ejs, argv[0]);
    if (day < 0 || day > 365) {
        ejsThrowArgError(ejs, "Bad day. Range 0-365");
        return 0;
    }
    mprDecodeLocalTime(ejs, &tm, dp->value);
    dayDiff = day - tm.tm_yday;
    dp->value += dayDiff * 86400 * MPR_TICKS_PER_SEC;
    return 0;
}


/*
    function get date(): Number
    Return day of month (1-31)
 */
static EjsObj *date_date(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;

    mprDecodeLocalTime(ejs, &tm, dp->value);
    return (EjsObj*) ejsCreateNumber(ejs, tm.tm_mday);
}


/*
    function set date(date: Number): Void
    Range day of month (1-31)
 */
static EjsObj *date_set_date(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;
    int         dayDiff, day;

    day = ejsGetNumber(ejs, argv[0]);
    if (day < 1 || day > 31) {
        ejsThrowArgError(ejs, "Bad day. Range 1-31");
        return 0;
    }
    mprDecodeLocalTime(ejs, &tm, dp->value);
    dayDiff = day - tm.tm_mday;
    dp->value += dayDiff * 86400 * MPR_TICKS_PER_SEC;
    return 0;
}


/*
    function get elapsed(): Number
    Get the elapsed time in milliseconds since the Date object was constructed
 */
static EjsObj *date_elapsed(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateNumber(ejs, mprGetElapsedTime(ejs, dp->value));
}


/*
    function format(layout: String): String
 */
static EjsObj *date_format(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;

    mprDecodeLocalTime(ejs, &tm, dp->value);
    return (EjsObj*) ejsCreateStringAndFree(ejs, mprFormatTime(ejs, ejsGetString(ejs, argv[0]), &tm));
}


/*
    function formatUTC(layout: String): String
 */
static EjsObj *date_formatUTC(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;

    mprDecodeUniversalTime(ejs, &tm, dp->value);
    return (EjsObj*) ejsCreateStringAndFree(ejs, mprFormatTime(ejs, ejsGetString(ejs, argv[0]), &tm));
}


/*
    function get fullYear(): Number
    Return year in 4 digits
 */
static EjsObj *date_fullYear(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;

    mprDecodeLocalTime(ejs, &tm, dp->value);
    return (EjsObj*) ejsCreateNumber(ejs, tm.tm_year + 1900);
}


/*
    function set fullYear(year: Number): void
    Update the year component using a 4 digit year
 */
static EjsObj *date_set_fullYear(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;
    MprNumber   value;

    mprDecodeLocalTime(ejs, &tm, dp->value);
    tm.tm_year = ejsGetNumber(ejs, argv[0]) - 1900;
    value = mprMakeTime(ejs, &tm);
    if (value == -1) {
        ejsThrowArgError(ejs, "Invalid year");
    } else {
        dp->value = value;
    }
    return 0;
}


/**
    Return the number of minutes between the local computer time and Coordinated Universal Time.
    @return Integer containing the number of minutes between UTC and local time. The offset is positive if
    local time is behind UTC and negative if it is ahead. E.g. American PST is UTC-8 so 480 will be retured.
    This value will vary if daylight savings time is in effect.

    function getTimezoneOffset(): Number
*/
static EjsObj *date_getTimezoneOffset(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateNumber(ejs, -mprGetMpr()->timezone);
}


/*
    function getUTCDate(): Number
    Range: 0-31
 */
static EjsObj *date_getUTCDate(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;

    mprDecodeUniversalTime(ejs, &tm, dp->value);
    return (EjsObj*) ejsCreateNumber(ejs, tm.tm_mday);
}


/*
    function getUTCDay(): Number
    Range: 0-6
 */
static EjsObj *date_getUTCDay(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;

    mprDecodeUniversalTime(ejs, &tm, dp->value);
    return (EjsObj*) ejsCreateNumber(ejs, tm.tm_wday);
}


/*
    function getUTCFullYear(): Number
    Range: 4 digits
 */
static EjsObj *date_getUTCFullYear(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;

    mprDecodeUniversalTime(ejs, &tm, dp->value);
    return (EjsObj*) ejsCreateNumber(ejs, tm.tm_year + 1900);
}


/*
    function getUTCHours(): Number
    Range: 0-23
 */
static EjsObj *date_getUTCHours(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;

    mprDecodeUniversalTime(ejs, &tm, dp->value);
    return (EjsObj*) ejsCreateNumber(ejs, tm.tm_hour);
}


/*
    function getUTCMilliseconds(): Number
    Range: 0-999
 */
static EjsObj *date_getUTCMilliseconds(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateNumber(ejs, ((int64) dp->value) % MPR_TICKS_PER_SEC);
}


/*
    function getUTCMinutes(): Number
    Range: 0-31
 */
static EjsObj *date_getUTCMinutes(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;

    mprDecodeUniversalTime(ejs, &tm, dp->value);
    return (EjsObj*) ejsCreateNumber(ejs, tm.tm_min);
}


/*
    function getUTCMonth(): Number
    Range: 1-12
 */
static EjsObj *date_getUTCMonth(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;

    mprDecodeUniversalTime(ejs, &tm, dp->value);
    return (EjsObj*) ejsCreateNumber(ejs, tm.tm_mon);
}


/*
    function getUTCSeconds(): Number
    Range: 0-59
 */
static EjsObj *date_getUTCSeconds(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;

    mprDecodeUniversalTime(ejs, &tm, dp->value);
    return (EjsObj*) ejsCreateNumber(ejs, tm.tm_sec);
}


/*
    function get hours(): Number
    Return hour of day (0-23)
 */
static EjsObj *date_hours(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;

    mprDecodeLocalTime(ejs, &tm, dp->value);
    return (EjsObj*) ejsCreateNumber(ejs, tm.tm_hour);
}


/*
    function set hours(hour: Number): void
    Update the hour of the day using a 0-23 hour
 */
static EjsObj *date_set_hours(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;
    MprNumber   value;

    mprDecodeLocalTime(ejs, &tm, dp->value);
    tm.tm_hour = ejsGetNumber(ejs, argv[0]);
    value = mprMakeTime(ejs, &tm);
    if (value == -1) {
        ejsThrowArgError(ejs, "Invalid hour");
    } else {
        dp->value = value;
    }
    return 0;
}


/*
    function get milliseconds(): Number
 */
static EjsObj *date_milliseconds(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateNumber(ejs, ((int64) dp->value) % MPR_TICKS_PER_SEC);
}


/*
    function set milliseconds(ms: Number): void
 */
static EjsObj *date_set_milliseconds(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    dp->value = (dp->value / MPR_TICKS_PER_SEC  * MPR_TICKS_PER_SEC) + ejsGetNumber(ejs, argv[0]);
    return 0;
}


/*
    function get minutes(): Number
 */
static EjsObj *date_minutes(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;

    mprDecodeLocalTime(ejs, &tm, dp->value);
    return (EjsObj*) ejsCreateNumber(ejs, tm.tm_min);
}


/*
    function set minutes(min: Number): void
 */
static EjsObj *date_set_minutes(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;
    MprNumber   value;

    mprDecodeLocalTime(ejs, &tm, dp->value);
    tm.tm_min = ejsGetNumber(ejs, argv[0]);
    value = mprMakeTime(ejs, &tm);
    if (value == -1) {
        ejsThrowArgError(ejs, "Invalid minutes");
    } else {
        dp->value = value;
    }
    return 0;
}


/*
    function get month(): Number
    Get the month (0-11)
 */
static EjsObj *date_month(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;

    mprDecodeLocalTime(ejs, &tm, dp->value);
    return (EjsObj*) ejsCreateNumber(ejs, tm.tm_mon);
}


/*
    function set month(month: Number): void
 */
static EjsObj *date_set_month(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;
    MprNumber   value;

    mprDecodeLocalTime(ejs, &tm, dp->value);
    tm.tm_mon = ejsGetNumber(ejs, argv[0]);
    value = mprMakeTime(ejs, &tm);
    if (value == -1) {
        ejsThrowArgError(ejs, "Invalid month");
    } else {
        dp->value = value;
    }
    return 0;
}


/*
    function nextDay(inc: Number = 1): Date
 */
static EjsObj *date_nextDay(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    int64       inc;

    if (argc == 1) {
        inc = ejsGetNumber(ejs, argv[0]);
    } else {
        inc = 1;
    }
    return (EjsObj*) ejsCreateDate(ejs, dp->value + (inc * 86400 * 1000));
}


/*
    function now(): Number
 */
static EjsObj *date_now(Ejs *ejs, EjsDate *unused, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateNumber(ejs, mprGetTime(ejs));
}


/*
    static function parse(arg: String): Date
 */
static EjsObj *date_parse(Ejs *ejs, EjsDate *unused, int argc, EjsObj **argv)
{
    MprTime     when;

    if (mprParseTime(ejs, &when, ejsGetString(ejs, argv[0]), MPR_LOCAL_TIMEZONE, NULL) < 0) {
        ejsThrowArgError(ejs, "Can't parse date string: %s", ejsGetString(ejs, argv[0]));
        return 0;
    }
    return (EjsObj*) ejsCreateNumber(ejs, when);
}


/*
    static function parseDate(arg: String, defaultDate: Date = null): Date
 */
static EjsObj *date_parseDate(Ejs *ejs, EjsDate *unused, int argc, EjsObj **argv)
{
    struct tm   tm, *defaults;
    MprTime     when;

    if (argc >= 2) {
        mprDecodeLocalTime(ejs, &tm, ((EjsDate*) argv[1])->value);
        defaults = &tm;
    } else {
        defaults = 0;
    }
    if (mprParseTime(ejs, &when, ejsGetString(ejs, argv[0]), MPR_LOCAL_TIMEZONE, defaults) < 0) {
        ejsThrowArgError(ejs, "Can't parse date string: %s", ejsGetString(ejs, argv[0]));
        return 0;
    }
    return (EjsObj*) ejsCreateDate(ejs, when);
}


/*
    static function parseUTCDate(arg: String, defaultDate: Date = null): Date
 */
static EjsObj *date_parseUTCDate(Ejs *ejs, EjsDate *unused, int argc, EjsObj **argv)
{
    struct tm   tm, *defaults;
    MprTime     when;

    if (argc >= 2) {
        mprDecodeUniversalTime(ejs, &tm, ((EjsDate*) argv[1])->value);
        defaults = &tm;
    } else {
        defaults = 0;
    }
    if (mprParseTime(ejs, &when, ejsGetString(ejs, argv[0]), MPR_UTC_TIMEZONE, defaults) < 0) {
        ejsThrowArgError(ejs, "Can't parse date string: %s", ejsGetString(ejs, argv[0]));
        return 0;
    }
    return (EjsObj*) ejsCreateDate(ejs, when);
}


/*
    function get seconds(): Number
    Get seconds (0-59)
 */
static EjsObj *date_seconds(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;

    mprDecodeLocalTime(ejs, &tm, dp->value);
    return (EjsObj*) ejsCreateNumber(ejs, tm.tm_sec);
}


/*
    function set seconds(sec: Number): void
 */
static EjsObj *date_set_seconds(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;
    MprNumber   value;

    mprDecodeLocalTime(ejs, &tm, dp->value);
    tm.tm_sec = ejsGetNumber(ejs, argv[0]);
    value = mprMakeTime(ejs, &tm);
    if (value == -1) {
        ejsThrowArgError(ejs, "Invalid seconds");
    } else {
        dp->value = value;
    }
    return 0;
}


/*
    function setUTCDate(date: Number): Void
    Range month (1-31)
 */
static EjsObj *date_setUTCDate(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;
    int         dayDiff, day;

    day = ejsGetNumber(ejs, argv[0]);
    if (day < 1 || day > 31) {
        ejsThrowArgError(ejs, "Bad day. Range 1-31");
        return 0;
    }
    mprDecodeUniversalTime(ejs, &tm, dp->value);
    dayDiff = day - tm.tm_mday;
    dp->value += dayDiff * 86400 * MPR_TICKS_PER_SEC;
    return 0;
}


/*
   function setUTCFullYear(y: Number): void
 */
static EjsObj *date_setUTCFullYear(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;

    mprDecodeUniversalTime(ejs, &tm, dp->value);
    tm.tm_year = ejsGetNumber(ejs, argv[0]) - 1900;
    dp->value = mprMakeUniversalTime(ejs, &tm);
    return 0;
}


/*
    function setUTCHours(h: Number): void
 */
static EjsObj *date_setUTCHours(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;

    mprDecodeUniversalTime(ejs, &tm, dp->value);
    tm.tm_hour = ejsGetNumber(ejs, argv[0]);
    dp->value = mprMakeUniversalTime(ejs, &tm);
    return 0;
}


/*
    function setUTCMilliseconds(ms: Number): void
 */
static EjsObj *date_setUTCMilliseconds(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    /* Same as set_milliseconds */
    dp->value = (dp->value / MPR_TICKS_PER_SEC  * MPR_TICKS_PER_SEC) + ejsGetNumber(ejs, argv[0]);
    return 0;
}


/*
    function setUTCMinutes(min: Number): void
 */
static EjsObj *date_setUTCMinutes(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;

    mprDecodeUniversalTime(ejs, &tm, dp->value);
    tm.tm_min = ejsGetNumber(ejs, argv[0]);
    dp->value = mprMakeUniversalTime(ejs, &tm);
    return 0;
}


/*
    function setUTCMonth(mon: Number): void
 */
static EjsObj *date_setUTCMonth(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;

    mprDecodeUniversalTime(ejs, &tm, dp->value);
    tm.tm_mon = ejsGetNumber(ejs, argv[0]);
    dp->value = mprMakeUniversalTime(ejs, &tm);
    return 0;
}


/*
    function setUTCSeconds(sec: Number, msec: Number = null): void
 */
static EjsObj *date_setUTCSeconds(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;

    mprDecodeUniversalTime(ejs, &tm, dp->value);
    tm.tm_sec = ejsGetNumber(ejs, argv[0]);
    dp->value = mprMakeUniversalTime(ejs, &tm);
    if (argc >= 2) {
        dp->value = (dp->value / MPR_TICKS_PER_SEC  * MPR_TICKS_PER_SEC) + ejsGetNumber(ejs, argv[1]);
    }
    return 0;
}


/*
    Get the number of millsecs since Jan 1, 1970 UTC.
    function get time(): Number
 */
static EjsObj *date_time(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateNumber(ejs, dp->value);
}


/*
    function set time(value: Number): Number
 */
static EjsObj *date_set_time(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    dp->value = ejsGetNumber(ejs, argv[0]);
    return 0;
}


/**
    Return an ISO formatted date string.
    Sample format: "2006-12-15T23:45:09.33-08:00"
    function toISOString(): String
*/
static EjsObj *date_toISOString(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    EjsObj      *vp;
    struct tm   tm;
    char        *base, *str;

    mprDecodeUniversalTime(ejs, &tm, dp->value);
    base = mprFormatTime(ejs, "%Y-%m-%dT%H:%M:%S", &tm);
    str = mprAsprintf(ejs, -1, "%s.%03dZ", base, dp->value % MPR_TICKS_PER_SEC);
    vp = (EjsObj*) ejsCreateStringAndFree(ejs, str);
    mprFree(base);
    return vp;
}


/*
    Serialize using JSON encoding. This uses the ISO date format

    function toJSON()
 */
static EjsObj *date_toJSON(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;
    char        *base, *str;

    mprDecodeUniversalTime(ejs, &tm, dp->value);
    base = mprFormatTime(ejs, "%Y-%m-%dT%H:%M:%S", &tm);
    str = mprAsprintf(ejs, -1, "\"%sZ\"", base);
    mprFree(base);
    return (EjsObj*) ejsCreateStringAndFree(ejs, str);
}


/*
    override native function toString(): String
 */
static EjsObj *date_toString(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    return castDate(ejs, dp, ejs->stringType);
}


/*
    Construct a date from UTC values
    function UTC(year, month, date, hour = 0, minute = 0, second = 0, msec = 0): Number
 */
static EjsObj *date_UTC(Ejs *ejs, EjsDate *unused, int argc, EjsObj **argv)
{
    EjsDate     *dp;
    struct tm   tm;
    int         year;

    memset(&tm, 0, sizeof(tm));
    year = getNumber(ejs, argv[0]);
    if (year < 100) {
        year += 1900;
    }
    tm.tm_year = year - 1900;
    if (argc > 1) {
        tm.tm_mon = getNumber(ejs, argv[1]);
    }
    if (argc > 2) {
        tm.tm_mday = getNumber(ejs, argv[2]);
    }
    if (argc > 3) {
        tm.tm_hour = getNumber(ejs, argv[3]);
    }
    if (argc > 4) {
        tm.tm_min = getNumber(ejs, argv[4]);
    }
    if (argc > 5) {
        tm.tm_sec = getNumber(ejs, argv[5]);
    }
    dp = ejsCreateDate(ejs, mprMakeUniversalTime(ejs, &tm));
    if (argc > 6) {
        dp->value += getNumber(ejs, argv[6]);
    }
    return (EjsObj*) ejsCreateNumber(ejs, dp->value);
}


/*
    function get year(): Number
 */
static EjsObj *date_year(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;

    mprDecodeLocalTime(ejs, &tm, dp->value);
    return (EjsObj*) ejsCreateNumber(ejs, tm.tm_year + 1900);
}


/*
    function set year(year: Number): void
 */
static EjsObj *date_set_year(Ejs *ejs, EjsDate *dp, int argc, EjsObj **argv)
{
    struct tm   tm;
    MprNumber   value;

    mprDecodeLocalTime(ejs, &tm, dp->value);
    tm.tm_year = ejsGetNumber(ejs, argv[0]) - 1900;
    dp->value = mprMakeTime(ejs, &tm);
    if (value == -1) {
        ejsThrowArgError(ejs, "Invalid year");
    } else {
        dp->value = value;
    }
    return 0;
}

/*
    Create an initialized date object. Set to the current time if value is zero.
 */

EjsDate *ejsCreateDate(Ejs *ejs, MprTime value)
{
    EjsDate *vp;

    vp = (EjsDate*) ejsCreate(ejs, ejs->dateType, 0);
    if (vp != 0) {
        vp->value = value;
    }
    return vp;
}


void ejsConfigureDateType(Ejs *ejs)
{
    EjsType     *type;

    type = ejs->dateType = ejsConfigureNativeType(ejs, "ejs", "Date", sizeof(EjsDate));

    type->helpers->cast = (EjsCastHelper) castDate;
    type->helpers->clone = (EjsCloneHelper) cloneDate;
    type->helpers->invokeOperator = (EjsInvokeOperatorHelper) invokeDateOperator;

    ejsBindMethod(ejs, type, ES_Date_Date, (EjsProc) date_Date);
    ejsBindAccess(ejs, type, ES_Date_day, (EjsProc) date_day, (EjsProc) date_set_day);
    ejsBindAccess(ejs, type, ES_Date_dayOfYear, (EjsProc) date_dayOfYear, (EjsProc) date_set_dayOfYear);
    ejsBindAccess(ejs, type, ES_Date_date, (EjsProc) date_date, (EjsProc) date_set_date);
    ejsBindMethod(ejs, type, ES_Date_elapsed, (EjsProc) date_elapsed);
    ejsBindMethod(ejs, type, ES_Date_format, (EjsProc) date_format);
    ejsBindMethod(ejs, type, ES_Date_formatUTC, (EjsProc) date_formatUTC);
    ejsBindAccess(ejs, type, ES_Date_fullYear, (EjsProc) date_fullYear, (EjsProc) date_set_fullYear);
    ejsBindMethod(ejs, type, ES_Date_getTimezoneOffset, (EjsProc) date_getTimezoneOffset); 
    ejsBindMethod(ejs, type, ES_Date_getUTCDate, (EjsProc) date_getUTCDate);
    ejsBindMethod(ejs, type, ES_Date_getUTCDay, (EjsProc) date_getUTCDay);
    ejsBindMethod(ejs, type, ES_Date_getUTCFullYear, (EjsProc) date_getUTCFullYear);
    ejsBindMethod(ejs, type, ES_Date_getUTCHours, (EjsProc) date_getUTCHours);
    ejsBindMethod(ejs, type, ES_Date_getUTCMilliseconds, (EjsProc) date_getUTCMilliseconds);
    ejsBindMethod(ejs, type, ES_Date_getUTCMinutes, (EjsProc) date_getUTCMinutes);
    ejsBindMethod(ejs, type, ES_Date_getUTCMonth, (EjsProc) date_getUTCMonth);
    ejsBindMethod(ejs, type, ES_Date_getUTCSeconds, (EjsProc) date_getUTCSeconds);
    ejsBindAccess(ejs, type, ES_Date_hours, (EjsProc) date_hours, (EjsProc) date_set_hours);
    ejsBindAccess(ejs, type, ES_Date_milliseconds, (EjsProc) date_milliseconds, (EjsProc) date_set_milliseconds);
    ejsBindAccess(ejs, type, ES_Date_minutes, (EjsProc) date_minutes, (EjsProc) date_set_minutes);
    ejsBindAccess(ejs, type, ES_Date_month, (EjsProc) date_month, (EjsProc) date_set_month);
    ejsBindMethod(ejs, type, ES_Date_nextDay, (EjsProc) date_nextDay);
    ejsBindMethod(ejs, type, ES_Date_now, (EjsProc) date_now);
    ejsBindMethod(ejs, type, ES_Date_parse, (EjsProc) date_parse);
    ejsBindMethod(ejs, type, ES_Date_parseDate, (EjsProc) date_parseDate);
    ejsBindMethod(ejs, type, ES_Date_parseUTCDate, (EjsProc) date_parseUTCDate);
    ejsBindAccess(ejs, type, ES_Date_seconds, (EjsProc) date_seconds, (EjsProc) date_set_seconds);
    ejsBindMethod(ejs, type, ES_Date_setUTCDate, (EjsProc) date_setUTCDate);
    ejsBindMethod(ejs, type, ES_Date_setUTCFullYear, (EjsProc) date_setUTCFullYear);
    ejsBindMethod(ejs, type, ES_Date_setUTCHours, (EjsProc) date_setUTCHours);
    ejsBindMethod(ejs, type, ES_Date_setUTCMilliseconds, (EjsProc) date_setUTCMilliseconds);
    ejsBindMethod(ejs, type, ES_Date_setUTCMinutes, (EjsProc) date_setUTCMinutes);
    ejsBindMethod(ejs, type, ES_Date_setUTCMonth, (EjsProc) date_setUTCMonth);
    ejsBindMethod(ejs, type, ES_Date_setUTCSeconds, (EjsProc) date_setUTCSeconds);
    ejsBindAccess(ejs, type, ES_Date_time, (EjsProc) date_time, (EjsProc) date_set_time);
    ejsBindMethod(ejs, type, ES_Date_toISOString, (EjsProc) date_toISOString);
    ejsBindMethod(ejs, type, ES_Date_UTC, (EjsProc) date_UTC);
    ejsBindAccess(ejs, type, ES_Date_year, (EjsProc) date_year, (EjsProc) date_set_year);

    ejsBindMethod(ejs, type, ES_Object_toString, (EjsProc) date_toString);
    ejsBindMethod(ejs, type, ES_Object_toJSON, (EjsProc) date_toJSON);
}

/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2010. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2010. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    @end
 */
/************************************************************************/
/*
 *  End of file "../src/core/src/ejsDate.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../src/core/src/ejsDebug.c"
 */
/************************************************************************/

/*
    ejsDebug.c - System.Debug class

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */


#if KEEP
/*
    function bool isDebugMode()
    TODO -- convert to accessor
 */

static int isDebugMode(EjsFiber *fp, EjsObj *thisObj, int argc, EjsObj **argv)
{
    ejsTrace(fp, "isDebugMode()\n");
    ejsSetReturnValueToInteger(fp, mprGetDebugMode(fp));
    return 0;
}


int ejsDefineDebugClass(EjsFiber *fp)
{
    EjsObj  *systemDebugClass;

    systemDebugClass =  ejsDefineClass(fp, "System.Debug", "Object", 0);
    if (systemDebugClass == 0) {
        return MPR_ERR_CANT_INITIALIZE;
    }
    ejsDefineCMethod(fp, systemDebugClass, "isDebugMode", isDebugMode, 0);

    return ejsObjHasErrors(systemDebugClass) ? MPR_ERR_CANT_INITIALIZE : 0;
}


#else
void __dummyEjsDebug() {}
#endif

/*
    @copy   default
    
    Copyright (c) Embedthis Software LLC, 2003-2010. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2010. All Rights Reserved.
    
    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire 
    a commercial license from Embedthis Software. You agree to be fully bound 
    by the terms of either license. Consult the LICENSE.TXT distributed with 
    this software for full details.
    
    This software is open source; you can redistribute it and/or modify it 
    under the terms of the GNU General Public License as published by the 
    Free Software Foundation; either version 2 of the License, or (at your 
    option) any later version. See the GNU General Public License for more 
    details at: http://www.embedthis.com/downloads/gplLicense.html
    
    This program is distributed WITHOUT ANY WARRANTY; without even the 
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
    
    This GPL license does NOT permit incorporating this software into 
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses 
    for this software and support services are available from Embedthis 
    Software at http://www.embedthis.com 
    
    @end
 */
/************************************************************************/
/*
 *  End of file "../src/core/src/ejsDebug.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../src/core/src/ejsError.c"
 */
/************************************************************************/

/**
    ejsError.c - Error Exception class

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */



/*
    Cast the operand to the specified type

    intrinsic function cast(type: Type) : Object
 */

static EjsObj *castError(Ejs *ejs, EjsError *vp, EjsType *type)
{
    EjsObj      *sp;
    char        *buf;

    switch (type->id) {

    case ES_Boolean:
        return (EjsObj*) ejsCreateBoolean(ejs, 1);

    case ES_String:
        if ((buf = mprAsprintf(ejs, -1,
                "%s Exception: %s\nStack:\n%s\n", vp->obj.type->qname.name, vp->message, vp->stack)) == NULL) {
            ejsThrowMemoryError(ejs);
        }
        sp = (EjsObj*) ejsCreateString(ejs, buf);
        mprFree(buf);
        return sp;

    default:
        ejsThrowTypeError(ejs, "Unknown type");
        return 0;
    }
}


/*
    Get a property.
 */
static EjsObj *getErrorProperty(Ejs *ejs, EjsError *error, int slotNum)
{
    switch (slotNum) {
    case ES_Error_stack:
        return (EjsObj*) ejsCreateString(ejs, error->stack);

    case ES_Error_message:
        return (EjsObj*) ejsCreateString(ejs, error->message);
    }
    return (ejs->objectType->helpers->getProperty)(ejs, (EjsObj*) error, slotNum);
}


/*
    Lookup a property.
 */
static int lookupErrorProperty(Ejs *ejs, EjsError *error, EjsName *qname)
{
    if (strcmp(qname->name, "message") == 0) {
        return ES_Error_message;
    }
    if (strcmp(qname->name, "stack") == 0) {
        return ES_Error_stack;
    }
    return -1;
}


/*
    Error Constructor and constructor for all the core error classes.

    public function Error(message: String = null)
 */
static EjsObj *errorConstructor(Ejs *ejs, EjsError *error, int argc,  EjsObj **argv)
{
    mprFree(error->message);
    if (argc == 0) {
        error->message = mprStrdup(error, "");
    } else {
        error->message = mprStrdup(error, ejsGetString(ejs, argv[0]));
    }
    mprFree(error->stack);
    ejsFormatStack(ejs, error);
    return (EjsObj*) error;
}


static EjsObj *getCode(Ejs *ejs, EjsError *vp, int argc,  EjsObj **argv)
{
    return (EjsObj*) ejsCreateNumber(ejs, vp->code);
}


static EjsObj *setCode(Ejs *ejs, EjsError *vp, int argc,  EjsObj **argv)
{
    vp->code = ejsGetInt(ejs, argv[0]);
    return 0;
}



static EjsType *defineType(Ejs *ejs, cchar *name, int id)
{
    EjsType     *type;

    type = ejsCreateNativeType(ejs, "ejs", name, id, sizeof(EjsError));
    type->block.nobind = 1;
    type->helpers->cast = (EjsCastHelper) castError;
    type->helpers->getProperty = (EjsGetPropertyHelper) getErrorProperty;
    type->helpers->lookupProperty = (EjsLookupPropertyHelper) lookupErrorProperty;
    return type;
}


void ejsCreateErrorType(Ejs *ejs)
{
    ejs->errorType = defineType(ejs, "Error", ES_Error);
    defineType(ejs, "ArgError", ES_ArgError);
    defineType(ejs, "ArithmeticError", ES_ArithmeticError);
    defineType(ejs, "AssertError", ES_AssertError);
    defineType(ejs, "InstructionError", ES_InstructionError);
    defineType(ejs, "IOError", ES_IOError);
    defineType(ejs, "InternalError", ES_InternalError);
    defineType(ejs, "MemoryError", ES_MemoryError);
    defineType(ejs, "OutOfBoundsError", ES_OutOfBoundsError);
    defineType(ejs, "ReferenceError", ES_ReferenceError);
    defineType(ejs, "ResourceError", ES_ResourceError);
    defineType(ejs, "SecurityError", ES_SecurityError);
    defineType(ejs, "StateError", ES_StateError);
    defineType(ejs, "SyntaxError", ES_SyntaxError);
    defineType(ejs, "TypeError", ES_TypeError);
    defineType(ejs, "URIError", ES_URIError);

}


static void configureType(Ejs *ejs, cchar *name)
{
    EjsType     *type;

    type = ejsGetTypeByName(ejs, "ejs", name);
    ejsBindMethod(ejs, type, type->numInherited, (EjsProc) errorConstructor);
}


void ejsConfigureErrorType(Ejs *ejs)
{
    configureType(ejs, "Error");
    configureType(ejs, "ArgError");
    configureType(ejs, "ArithmeticError");
    configureType(ejs, "AssertError");
    configureType(ejs, "InstructionError");
    configureType(ejs, "IOError");
    configureType(ejs, "InternalError");
    configureType(ejs, "MemoryError");
    configureType(ejs, "OutOfBoundsError");
    configureType(ejs, "ReferenceError");
    configureType(ejs, "ResourceError");
    configureType(ejs, "SecurityError");
    configureType(ejs, "StateError");
    configureType(ejs, "SyntaxError");
    configureType(ejs, "TypeError");
    configureType(ejs, "URIError");

    ejsBindAccess(ejs, ejs->errorType, ES_Error_code, (EjsProc) getCode, (EjsProc) setCode);
}


/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2010. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2010. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    @end
 */
/************************************************************************/
/*
 *  End of file "../src/core/src/ejsError.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../src/core/src/ejsEvent.c"
 */
/************************************************************************/

/**
    ejsEvent.c - Event class

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */




void ejsConfigureEventType(Ejs *ejs)
{
    ejs->eventType = ejsConfigureNativeType(ejs, "ejs", "Event", sizeof(EjsObj));
    ejs->errorEventType = ejsConfigureNativeType(ejs, "ejs", "ErrorEvent", sizeof(EjsObj));
}

/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2010. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2010. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    @end
 */
/************************************************************************/
/*
 *  End of file "../src/core/src/ejsEvent.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../src/core/src/ejsFile.c"
 */
/************************************************************************/

/**
    ejsFile.c - File class.

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */




#if BLD_WIN_LIKE
#define isDelim(fp, c)  (c == '/' || c == fp->delimiter)
#else
#define isDelim(fp, c)  (c == fp->delimiter)
#endif

#define FILE_OPEN           0x1
#define FILE_READ           0x2
#define FILE_WRITE          0x4


static int mapMode(cchar *mode);
static EjsObj *openFile(Ejs *ejs, EjsFile *fp, int argc, EjsObj **argv);
static int readData(Ejs *ejs, EjsFile *fp, EjsByteArray *ap, int offset, int count);

#if BLD_CC_MMU && FUTURE
static void *mapFile(EjsFile *fp, uint size, int mode);
static void unmapFile(EjsFile *fp);
#endif


//  MOB -- should not be required

static void destroyFile(Ejs *ejs, EjsFile *fp)
{
    mprAssert(fp);

    mprFree(fp->path);
    fp->path = 0;
    ejsFree(ejs, (EjsObj*) fp, -1);
}


/*  
    Index into a file and extract a byte. This is random access reading.
 */
static EjsObj *getFileProperty(Ejs *ejs, EjsFile *fp, int slotNum)
{
    int     c, offset;

    if (!(fp->mode & FILE_OPEN)) {
        ejsThrowIOError(ejs, "File is not open");
        return 0;
    }
#if KEEP
    if (fp->mode & FILE_READ) {
        if (slotNum >= fp->info.size) {
            ejsThrowOutOfBoundsError(ejs, "Bad file index");
            return 0;
        }
    }
    if (slotNum < 0) {
        ejsThrowOutOfBoundsError(ejs, "Bad file index");
        return 0;
    }
#endif

#if BLD_CC_MMU && FUTURE
    //  must check against mapped size here.
    c = fp->mapped[slotNum];
#else
    offset = mprSeek(fp->file, SEEK_CUR, 0);
    if (offset != slotNum) {
        if (mprSeek(fp->file, SEEK_SET, slotNum) != slotNum) {
            ejsThrowIOError(ejs, "Can't seek to file offset");
            return 0;
        }
    }
    c = mprPeekc(fp->file);
    if (c < 0) {
        ejsThrowIOError(ejs, "Can't read file");
        return 0;
    }
#endif
    return (EjsObj*) ejsCreateNumber(ejs, c);
}


/*  
    Set a byte in the file at the offset designated by slotNum.
 */
static int setFileProperty(Ejs *ejs, EjsFile *fp, int slotNum, EjsObj *value)
{
    int     c, offset;

    if (!(fp->mode & FILE_OPEN)) {
        ejsThrowIOError(ejs, "File is not open");
        return 0;
    }
    if (!(fp->mode & FILE_WRITE)) {
        ejsThrowIOError(ejs, "File is not opened for writing");
        return 0;
    }
    c = ejsIsNumber(value) ? ejsGetInt(ejs, value) : ejsGetInt(ejs, ejsToNumber(ejs, value));

    offset = mprSeek(fp->file, SEEK_CUR, 0);
    if (slotNum < 0) {
        //  could have an mprGetPosition(file) API
        slotNum = offset;
    }

#if BLD_CC_MMU && FUTURE
    fp->mapped[slotNum] = c;
#else
    if (offset != slotNum && mprSeek(fp->file, SEEK_SET, slotNum) != slotNum) {
        ejsThrowIOError(ejs, "Can't seek to file offset");
        return 0;
    }
    if (mprPutc(fp->file, c) < 0) {
        ejsThrowIOError(ejs, "Can't write file");
        return 0;
    }
#endif
    return slotNum;
}



int ejsGetNumOption(Ejs *ejs, EjsObj *options, cchar *field, int defaultValue, bool optional)
{
    EjsObj      *vp;
    EjsName     qname;
    EjsNumber   *num;

    vp = ejsGetPropertyByName(ejs, options, ejsName(&qname, "", field));
    if (vp == 0) {
        if (optional) {
            return defaultValue;
        }
        ejsThrowArgError(ejs, "Required option \"%s\" is missing", field);
        return 0;
    }
    num = ejsToNumber(ejs, vp);
    if (!ejsIsNumber(num)) {
        ejsThrowArgError(ejs, "Bad option type for field \"%s\"", field);
        return 0;
    }
    return (int) num->value;
}


cchar *ejsGetStrOption(Ejs *ejs, EjsObj *options, cchar *field, cchar *defaultValue, bool optional)
{
    EjsObj      *vp;
    EjsName     qname;
    EjsString   *str;

    vp = ejsGetPropertyByName(ejs, options, ejsName(&qname, "", field));
    if (vp == 0) {
        if (optional) {
            return defaultValue;
        }
        ejsThrowArgError(ejs, "Required option %s is missing", field);
        return 0;
    }
    str = ejsToString(ejs, vp);
    if (!ejsIsString(str)) {
        ejsThrowArgError(ejs, "Bad option type for field \"%s\"", field);
        return 0;
    }
    return str->value;
}


/*  
    Constructor
    function File(path: Object, options: Object = null)
 */
static EjsObj *fileConstructor(Ejs *ejs, EjsFile *fp, int argc, EjsObj **argv)
{
    EjsObj  *pp;
    cchar   *path;

    if (argc < 1 || argc > 2) {
        ejsThrowArgError(ejs, "Bad args");
        return 0;
    }
    pp = argv[0];
    if (ejsIsPath(ejs, pp)) {
        path = ((EjsPath*) pp)->path;
    } else if (ejsIsString(pp)) {
        path = ejsGetString(ejs, pp);
    } else {
        ejsThrowIOError(ejs, "Bad path");
        return NULL;
    }
    fp->path = mprGetNormalizedPath(fp, path);
    if (argc == 2) {
        openFile(ejs, fp, 1, &argv[1]);
    }
    return (EjsObj*) fp;
}


/*  
    function get canRead(): Boolean
 */
static EjsObj *canReadFile(Ejs *ejs, EjsFile *fp, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateBoolean(ejs, fp->mode & FILE_OPEN && (fp->mode & FILE_READ));
}


/*  
    function get canRead(): Boolean
 */
static EjsObj *canWriteFile(Ejs *ejs, EjsFile *fp, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateBoolean(ejs, fp->mode & FILE_OPEN && (fp->mode & FILE_WRITE));
}

/*  
    Close the file and free up all associated resources.
    function close(): void
 */
static EjsObj *closeFile(Ejs *ejs, EjsFile *fp, int argc, EjsObj **argv)
{
    if (fp->mode & FILE_OPEN && fp->mode & FILE_WRITE) {
        if (mprFlush(fp->file) < 0) {
            ejsThrowIOError(ejs, "Can't flush file data");
            return 0;
        }
    }
    if (fp->file) {
        mprFree(fp->file);
        fp->file = 0;
    }
#if BLD_CC_MMU && FUTURE
    if (fp->mapped) {
        unmapFile(fp);
        fp->mapped = 0;
    }
#endif
    fp->mode = 0;
    mprFree(fp->modeString);
    fp->modeString = 0;
    return 0;
}


/*  
    Function to iterate and return the next element index.
    NOTE: this is not a method of Array. Rather, it is a callback function for Iterator
 */
static EjsObj *nextKey(Ejs *ejs, EjsIterator *ip, int argc, EjsObj **argv)
{
    EjsFile     *fp;

    fp = (EjsFile*) ip->target;
    if (!ejsIsFile(ejs, fp)) {
        ejsThrowReferenceError(ejs, "Wrong type");
        return 0;
    }
    if (ip->index < fp->info.size) {
        return (EjsObj*) ejsCreateNumber(ejs, ip->index++);
    }
    ejsThrowStopIteration(ejs);
    return 0;
}


/*  
    Return the default iterator for use with "for ... in". This returns byte offsets in the file.
    iterator native function get(): Iterator
 */
static EjsObj *getFileIterator(Ejs *ejs, EjsFile *fp, int argc, EjsObj **argv)
{
    mprGetPathInfo(ejs, fp->path, &fp->info);
    return (EjsObj*) ejsCreateIterator(ejs, (EjsObj*) fp, (EjsProc) nextKey, 0, NULL);
}


/*  
    Function to iterate and return the next element value.
    NOTE: this is not a method of Array. Rather, it is a callback function for Iterator
 */
static EjsObj *nextValue(Ejs *ejs, EjsIterator *ip, int argc, EjsObj **argv)
{
    EjsFile     *fp;

    fp = (EjsFile*) ip->target;
    if (!ejsIsFile(ejs, fp)) {
        ejsThrowReferenceError(ejs, "Wrong type");
        return 0;
    }

    if (ip->index < fp->info.size) {
#if !BLD_CC_MMU || 1
        if (mprSeek(fp->file, SEEK_CUR, 0) != ip->index) {
            if (mprSeek(fp->file, SEEK_SET, ip->index) != ip->index) {
                ejsThrowIOError(ejs, "Can't seek to %d", ip->index);
                return 0;
            }
        }
        ip->index++;
        return (EjsObj*) ejsCreateNumber(ejs, mprGetc(fp->file));
#else
        return (EjsObj*) ejsCreateNumber(ejs, fp->mapped[ip->index++]);
#endif
    }

#if BLD_CC_MMU && FUTURE
    unmapFile(fp);
    fp->mapped = 0;
#endif

    ejsThrowStopIteration(ejs);
    return 0;
}


/*  
    Return an iterator to enumerate the bytes in the file. For use with "for each ..."
    iterator native function getValues(): Iterator
 */
static EjsObj *getFileValues(Ejs *ejs, EjsFile *fp, int argc, EjsObj **argv)
{
    mprGetPathInfo(ejs, fp->path, &fp->info);

    return (EjsObj*) ejsCreateIterator(ejs, (EjsObj*) fp, (EjsProc) nextValue, 0, NULL);
}


/*  
    Get a path object for the file
    function get path(): Path
 */
static EjsObj *getFilePath(Ejs *ejs, EjsFile *fp, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreatePath(ejs, fp->path);
}


/*  
    Get the current I/O position in the file.
    function get position(): Number
 */
static EjsObj *getFilePosition(Ejs *ejs, EjsFile *fp, int argc, EjsObj **argv)
{
    if (fp->file == 0) {
        ejsThrowStateError(ejs, "File not opened");
        return 0;
    }
    return (EjsObj*) ejsCreateNumber(ejs, (MprNumber) mprGetFilePosition(fp->file));
}


/*  
    Seek to a new location in the file and set the File marker to a new read/write position.
    function set position(value: Number): void
 */
static EjsObj *setFilePosition(Ejs *ejs, EjsFile *fp, int argc, EjsObj **argv)
{
    long        pos;

    mprAssert(argc == 1 && ejsIsNumber(argv[0]));
    pos = ejsGetInt(ejs, argv[0]);

    if (fp->file == 0) {
        ejsThrowStateError(ejs, "File not opened");
        return 0;
    }
    pos = ejsGetInt(ejs, argv[0]);
    if (mprSeek(fp->file, SEEK_SET, pos) != pos) {
        ejsThrowIOError(ejs, "Can't seek to %ld", pos);
    }
    return 0;
}


/*  
    function get isOpen(): Boolean
 */
static EjsObj *isFileOpen(Ejs *ejs, EjsFile *fp, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateBoolean(ejs, fp->mode & FILE_OPEN);
}


/*  
    Constructor
    function open(options: Object = null): File
    NOTE: options can be an options hash or as mode string
 */
static EjsObj *openFile(Ejs *ejs, EjsFile *fp, int argc, EjsObj **argv)
{
    EjsObj  *options;
    cchar   *mode;
    int     perms, omode;

    if (argc < 0 || argc > 1) {
        ejsThrowArgError(ejs, "Bad args");
        return 0;
    }
    options = argv[0];
    if (argc == 0 || ejsIsNull(options) || ejsIsUndefined(options)) {
        omode = O_RDONLY | O_BINARY;
        perms = EJS_FILE_PERMS;
        fp->mode = FILE_READ;
        mode = "r";
    } else {
        if (ejsIsString(options)) {
            mode = ejsGetString(ejs, options);
            perms = EJS_FILE_PERMS;
        } else {
            perms = ejsGetNumOption(ejs, options, "permissions", EJS_FILE_PERMS, 1);
            mode = ejsGetStrOption(ejs, options, "mode", "r", 1);
            if (ejs->exception) {
                return 0;
            }
        }
        omode = mapMode(mode);
        if (!(omode & O_WRONLY)) {
            fp->mode |= FILE_READ;
        }
        if (omode & (O_WRONLY | O_RDWR)) {
            fp->mode |= FILE_WRITE;
        }
    }

    if (fp->file) {
        mprFree(fp->file);
    }
    fp->modeString = mprStrdup(fp, mode);
    fp->perms = perms;

    fp->file = mprOpen(fp, fp->path, omode, perms);
    if (fp->file == 0) {
        ejsThrowIOError(ejs, "Can't open %s", fp->path);
        return 0;
    }

#if BLD_CC_MMU && FUTURE
    mprGetPathInfo(ejs, &fp->info);
    fp->mapped = mapFile(fp, fp->info.size, MPR_MAP_READ | MPR_MAP_WRITE);
#endif
    fp->mode |= FILE_OPEN;
    return (EjsObj*) fp;
}


static EjsObj *getFileOptions(Ejs *ejs, EjsFile *fp, int argc, EjsObj **argv)
{
    EjsName     qname;
    EjsObj      *options;

    options = (EjsObj*) ejsCreateSimpleObject(ejs);
    ejsSetPropertyByName(ejs, options, ejsName(&qname, "", "mode"), (EjsObj*) ejsCreateString(ejs, fp->modeString));
    ejsSetPropertyByName(ejs, options, ejsName(&qname, "", "permissions"), (EjsObj*) ejsCreateNumber(ejs, fp->perms));
    return options;
}

/*  
    Read data bytes from a file
    function readBytes(count: Number = -1): ByteArray
 */
static EjsObj *readFileBytes(Ejs *ejs, EjsFile *fp, int argc, EjsObj **argv)
{
    EjsByteArray    *result;
    MprPath         info;
    int             count, totalRead;

    if (argc == 0) {
        count = -1;
    } else if (argc != 1) {
        count = 0;
        ejsThrowArgError(ejs, "Bad args");
        return 0;
    } else {
        mprAssert(argc == 1 && ejsIsNumber(argv[0]));
        count = ejsGetInt(ejs, argv[0]);
    }
    if (fp->file == 0) {
        ejsThrowStateError(ejs, "File not open");
        return 0;
    }
    if (!(fp->mode & FILE_READ)) {
        ejsThrowStateError(ejs, "File not opened for reading");
        return 0;
    }
    if (count < 0) {
        //  TODO OPT could this be cached in fp->info 
        if (mprGetPathInfo(fp, fp->path, &info) == 0) {
            count = (int) info.size;
            count -= (int) mprGetFilePosition(fp->file);
        } else {
            count = MPR_BUFSIZE;
        }
        mprAssert(count >= 0);
    }
    result = ejsCreateByteArray(ejs, count);
    if (result == 0) {
        ejsThrowMemoryError(ejs);
        return 0;
    }
    totalRead = readData(ejs, fp, result, 0, count);
    if (totalRead < 0) {
        ejsThrowIOError(ejs, "Can't read from file: %s", fp->path);
        return 0;
    } else if (totalRead == 0) {
        return ejs->nullValue;
    }
    ejsSetByteArrayPositions(ejs, result, 0, totalRead);
    return (EjsObj*) result;
}


/*  
    Read data as a string
    function readString(count: Number = -1): String
 */
static EjsObj *readFileString(Ejs *ejs, EjsFile *fp, int argc, EjsObj **argv)
{
    EjsString       *result;
    MprPath         info;
    int             count, totalRead;

    if (argc == 0) {
        count = -1;
    } else if (argc != 1) {
        count = 0;
        ejsThrowArgError(ejs, "Bad args");
        return 0;
    } else {
        mprAssert(argc == 1 && ejsIsNumber(argv[0]));
        count = ejsGetInt(ejs, argv[0]);
    }
    if (fp->file == 0) {
        ejsThrowStateError(ejs, "File not open");
        return 0;
    }
    if (!(fp->mode & FILE_READ)) {
        ejsThrowStateError(ejs, "File not opened for reading");
        return 0;
    }
    if (count < 0) {
        //  TODO OPT could this be cached in fp->info 
        if (mprGetPathInfo(fp, fp->path, &info) == 0) {
            count = (int) info.size;
            count -= (int) mprGetFilePosition(fp->file);
        } else {
            count = MPR_BUFSIZE;
        }
        mprAssert(count >= 0);
    }
    result = ejsCreateBareString(ejs, count);
    if (result == 0) {
        ejsThrowMemoryError(ejs);
        return 0;
    }
    totalRead = mprRead(fp->file, result->value, count);
    if (totalRead != count) {
        ejsThrowIOError(ejs, "Can't read from file: %s", fp->path);
        return 0;
    }
    return (EjsObj*) result;
}


/*  
    Read data bytes from a file. If offset is < 0, then append to the write position.
    function read(buffer: ByteArray, offset: Number = 0, count: Number = -1): Number
 */
static EjsObj *readFile(Ejs *ejs, EjsFile *fp, int argc, EjsObj **argv)
{
    EjsByteArray    *buffer;
    MprPath         info;
    int             count, offset, totalRead;

    mprAssert(1 <= argc && argc <= 3);

    buffer = (EjsByteArray*) argv[0];
    offset = (argc >= 2) ? ejsGetInt(ejs, argv[1]): 0;
    count = (argc >= 3) ? ejsGetInt(ejs, argv[2]): -1;

    if (fp->file == 0) {
        ejsThrowStateError(ejs, "File not open");
        return 0;
    }
    if (!(fp->mode & FILE_READ)) {
        ejsThrowStateError(ejs, "File not opened for reading");
        return 0;
    }
    if (offset >= buffer->length) {
        ejsThrowOutOfBoundsError(ejs, "Bad read offset value");
        return 0;
    }
    if (offset < 0) {
        offset = buffer->writePosition;
    } else if (offset == 0) {
        ejsSetByteArrayPositions(ejs, buffer, 0, 0);
    }
    if (count < 0) {
        //  TODO OPT could this be cached in fp->info 
        if (mprGetPathInfo(fp, fp->path, &info) == 0) {
            count = (int) info.size;
            count -= (int) mprGetFilePosition(fp->file);
        } else {
            count = MPR_BUFSIZE;
        }
        mprAssert(count >= 0);
    }
    totalRead = readData(ejs, fp, buffer, offset, count);
    if (totalRead < 0) {
        return 0;
    } else if (totalRead == 0) {
        return (EjsObj*) ejs->zeroValue;
    }
    ejsSetByteArrayPositions(ejs, buffer, -1, offset + totalRead);
    return (EjsObj*) ejsCreateNumber(ejs, totalRead);
}


/*  
    Get the size of the file associated with this File object.
    override intrinsic function get size(): Number
 */
static EjsObj *getFileSize(Ejs *ejs, EjsFile *fp, int argc, EjsObj **argv)
{
    MprPath     info;

#if UNUSED
    if (fp->mode & FILE_OPEN) {
        /*
         *  GetFileSize is not accurate
         */
        return (EjsObj*) ejsCreateNumber(ejs, (MprNumber) mprGetFileSize(fp->file));
    } else {
#endif
    if (mprGetPathInfo(ejs, fp->path, &info) < 0) {
        return (EjsObj*) ejs->minusOneValue;
    }
    return (EjsObj*) ejsCreateNumber(ejs, (MprNumber) info.size);
}


/*  
    function truncate(size: Number): Void
 */
EjsObj *truncateFile(Ejs *ejs, EjsFile *fp, int argc, EjsObj **argv)
{
    int     size;

    size = ejsGetInt(ejs, argv[0]);
    if (mprTruncatePath(ejs, fp->path, size) < 0) {
        ejsThrowIOError(ejs, "Cant truncate %s", fp->path);
    }
    return 0;
}


/*  
    Write data to the file
    function write(data: Object): Number
 */
EjsObj *writeFile(Ejs *ejs, EjsFile *fp, int argc, EjsObj **argv)
{
    EjsArray        *args;
    EjsByteArray    *ap;
    EjsObj          *vp;
    EjsString       *str;
    cchar            *buf;
    int             i, len, written;

    mprAssert(argc == 1 && ejsIsArray(argv[0]));

    args = (EjsArray*) argv[0];

    if (!(fp->mode & FILE_WRITE)) {
        ejsThrowStateError(ejs, "File not opened for writing");
        return 0;
    }
    written = 0;

    for (i = 0; i < args->length; i++) {
        vp = ejsGetProperty(ejs, (EjsObj*) args, i);
        mprAssert(vp);
        switch (vp->type->id) {
        case ES_ByteArray:
            ap = (EjsByteArray*) vp;
            buf = (cchar*) &ap->value[ap->readPosition];
            len = ap->writePosition - ap->readPosition;
            break;

        case ES_String:
            buf = ((EjsString*) vp)->value;
            len = ((EjsString*) vp)->length;
            break;

        default:
            str = ejsToString(ejs, vp);
            buf = ejsGetString(ejs, str);
            len = str->length;
            break;
        }
        if (mprWrite(fp->file, buf, len) != len) {
            ejsThrowIOError(ejs, "Can't write to %s", fp->path);
            return 0;
        }
        written += len;
    }
    return (EjsObj*) ejsCreateNumber(ejs, written);
}



/*  
    Read the specified count of bytes into the byte array. Grow the array if required and growable
 */
static int readData(Ejs *ejs, EjsFile *fp, EjsByteArray *ap, int offset, int count)
{
    int     len, bytes;

    if (count <= 0) {
        return 0;
    }
    len = ap->length - offset;
    if (len < count) {
        ejsGrowByteArray(ejs, ap, ap->length + (count - len));
        len = ap->length - offset;
    }
    bytes = mprRead(fp->file, &ap->value[offset], len);
    if (bytes < 0) {
        ejsThrowIOError(ejs, "Error reading from %s", fp->path);
    }
    return bytes;
}


#if BLD_CC_MMU && FUTURE
static void *mapFile(EjsFile *fp, uint size, int mode)
{
    Mpr         *mpr;
    void        *ptr;
    int x;

    mpr = mprGetMpr();
    x = ~(mpr->alloc.pageSize - 1);
    size = (size + mpr->alloc.pageSize - 1) & ~(mpr->alloc.pageSize - 1);
#if MACOSX || LINUX || FREEBSD
    //  USE MAP_SHARED instead of MAP_PRIVATE if opened for write
    ptr = mmap(0, size, mode, MAP_FILE | MAP_PRIVATE, fp->file->fd, 0);
    x = errno;
#else
    ptr = VirtualAlloc(0, size, MEM_RESERVE | MEM_COMMIT, mapProt(mode));
#endif

    if (ptr == 0) {
        mprSetAllocError(mpr);
        return 0;
    }
    return ptr;
}


static void unmapFile(EjsFile *fp)
{
#if MACOSX || LINUX || FREEBSD
    munmap(fp->mapped, fp->info.size);
#else
    VirtualFree(file->mapped, 0, MEM_RELEASE);
#endif
}
#endif

static int mapMode(cchar *mode)
{
    int     omode;

    omode = O_BINARY;
    if (strchr(mode, 'r')) {
        omode |= O_RDONLY;
    }
    if (strchr(mode, 'w')) {
        if (omode & O_RDONLY) {
            omode &= ~O_RDONLY;
            omode |= O_RDWR;
        } else {
            omode |= O_CREAT | O_WRONLY | O_TRUNC;
        }
    }
    if (strchr(mode, 'a')) {
        omode |= O_WRONLY | O_APPEND;
    }
    if (strchr(mode, '+')) {
        omode &= ~O_TRUNC;
    }
    if (strchr(mode, 't')) {
        omode &= ~O_BINARY;
    }
    return omode;
}



EjsFile *ejsCreateFile(Ejs *ejs, cchar *path)
{
    EjsFile     *fp;
    EjsObj      *arg;

    mprAssert(path && *path);

    fp = (EjsFile*) ejsCreate(ejs, ejs->fileType, 0);
    if (fp == 0) {
        return 0;
    }
    arg = (EjsObj*) ejsCreateString(ejs, path);
    fileConstructor(ejs, fp, 1, (EjsObj**) &arg);
    return fp;
}


EjsFile *ejsCreateFileFromFd(Ejs *ejs, int fd, cchar *name, int mode)
{
    EjsFile     *fp;

    mprAssert(fd >= 0);
    mprAssert(name);

    fp = (EjsFile*) ejsCreate(ejs, ejs->fileType, 0);
    if (fp == 0) {
        return 0;
    }
    fp->perms = EJS_FILE_PERMS;
    fp->mode = FILE_OPEN;
    if (!(mode & O_WRONLY)) {
        fp->mode |= FILE_READ;
    }
    if (mode & (O_WRONLY | O_RDWR)) {
        fp->mode |= FILE_WRITE;
    }
    fp->file = mprAttachFd(fp, fd, name, mode);
    if (fp->file == 0) {
        return 0;
    }
    fp->path = mprStrdup(fp, "");
    return fp;
}


void ejsConfigureFileType(Ejs *ejs)
{
    EjsType     *type;

    type = ejs->fileType = ejsConfigureNativeType(ejs, EJS_EJS_NAMESPACE, "File", sizeof(EjsFile));
    type->numericIndicies = 1;

    type->helpers = ejsCloneObjectHelpers(ejs, "file-helpers");
    type->helpers->destroy = (EjsDestroyHelper) destroyFile;
    type->helpers->getProperty = (EjsGetPropertyHelper) getFileProperty;
    type->helpers->setProperty = (EjsSetPropertyHelper) setFileProperty;

    ejsBindMethod(ejs, type, ES_File_File, (EjsProc) fileConstructor);
    ejsBindMethod(ejs, type, ES_File_canRead, (EjsProc) canReadFile);
    ejsBindMethod(ejs, type, ES_File_canWrite, (EjsProc) canWriteFile);
    ejsBindMethod(ejs, type, ES_File_close, (EjsProc) closeFile);
    ejsBindMethod(ejs, type, ES_Object_get, (EjsProc) getFileIterator);
    ejsBindMethod(ejs, type, ES_Object_getValues, (EjsProc) getFileValues);
    ejsBindMethod(ejs, type, ES_File_isOpen, (EjsProc) isFileOpen);
    ejsBindMethod(ejs, type, ES_File_open, (EjsProc) openFile);
    ejsBindMethod(ejs, type, ES_File_options, (EjsProc) getFileOptions);
    ejsBindMethod(ejs, type, ES_File_path, (EjsProc) getFilePath);
    ejsBindAccess(ejs, type, ES_File_position, (EjsProc) getFilePosition, (EjsProc) setFilePosition);
    ejsBindMethod(ejs, type, ES_File_readBytes, (EjsProc) readFileBytes);
    ejsBindMethod(ejs, type, ES_File_readString, (EjsProc) readFileString);
    ejsBindMethod(ejs, type, ES_File_read, (EjsProc) readFile);
    ejsBindMethod(ejs, type, ES_File_size, (EjsProc) getFileSize);
    ejsBindMethod(ejs, type, ES_File_truncate, (EjsProc) truncateFile);
    ejsBindMethod(ejs, type, ES_File_write, (EjsProc) writeFile);
}

/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2010. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2010. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    @end
 */
/************************************************************************/
/*
 *  End of file "../src/core/src/ejsFile.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../src/core/src/ejsFileSystem.c"
 */
/************************************************************************/

/**
    ejsFileSystem.c - FileSystem class.

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */



/*
    Constructor

    function FileSystem(path: String)
 */
static EjsObj *fileSystemConstructor(Ejs *ejs, EjsFileSystem *fp, int argc, EjsObj **argv)
{
    cchar   *path;

    mprAssert(argc == 1 && ejsIsString(argv[0]));

    path = ejsGetString(ejs, argv[0]);
    fp->path = mprGetNormalizedPath(fp, path);
    fp->fs = mprLookupFileSystem(ejs, path);
    return (EjsObj*) fp;
}


#if ES_space
/*
    Return the amount of free space in the file system that would contain the given path.

    function freeSpace(path: String = null): Number
 */
static EjsObj *fileSystemSpace(Ejs *ejs, EjsFileSystem *fp, int argc, EjsObj **argv)
{
#if BREW
    Mpr     *mpr;
    uint    space;

    mpr = mprGetMpr();
    space = IFILEMGR_GetFreeSpace(mpr->fileMgr, 0);
    ejsSetReturnValueToInteger(ejs, space);
#endif
    return 0;
}
#endif


/*
    Determine if the file system has a drive specs (C:) in paths

    static function hasDrives(): Boolean
 */
static EjsObj *hasDrives(Ejs *ejs, EjsFileSystem *fp, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateBoolean(ejs, fp->fs->hasDriveSpecs);
}


#if ES_isReady
/*
    Determine if the file system is ready for I/O

    function get isReady(): Boolean
 */
static EjsObj *isReady(Ejs *ejs, EjsFileSystem *fp, int argc, EjsObj **argv)
{
    MprPath     info;
    int         rc;

    rc = mprGetPathInfo(ejs, fp->path, &info);
    return (EjsObj*) ejsCreateBoolean(ejs, rc == 0 && info.isDir);
}
#endif


#if ES_isWritable
static EjsObj *isWritable(Ejs *ejs, EjsFileSystem *fp, int argc, EjsObj **argv)
{
    MprPath     info;
    int         rc;

    rc = mprGetPathInfo(ejs, fp->path, &info);
    return (EjsObj*) ejsCreateBoolean(ejs, rc == 0 && info.isDir);
}
#endif


/*
    Get the newline characters

    function get newline(): String
 */
static EjsObj *getNewline(Ejs *ejs, EjsFileSystem *fp, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateString(ejs, mprGetPathNewline(ejs, fp->path));
}


/*
    set the newline characters

    function set newline(terminator: String): Void
 */
static EjsObj *setNewline(Ejs *ejs, EjsFileSystem *fp, int argc, EjsObj **argv)
{
    mprAssert(ejsIsString(argv[0]));
    mprSetPathNewline(ejs, fp->path, ((EjsString*) argv[0])->value);
    return 0;
}


static EjsObj *root(Ejs *ejs, EjsFileSystem *fp, int argc, EjsObj **argv)
{
    char    *path, *cp;
    int     sep;

    sep = mprGetPathSeparator(fp, fp->path);
    path = mprGetAbsPath(ejs, fp->path);
    if ((cp = strchr(path, sep)) != 0) {
        *++cp = '\0';
    }
    return (EjsObj*) ejsCreatePathAndFree(ejs, path);
}


/*
    Return the path directory separators

    static function get separators(): String
 */
static EjsObj *getSeparators(Ejs *ejs, EjsFileSystem *fp, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateString(ejs, fp->fs->separators);
}


/*
    Set the path directory separators

    static function set separators(value: String): void
 */
static EjsObj *setSeparators(Ejs *ejs, EjsFileSystem *fp, int argc, EjsObj **argv)
{
    mprAssert(argc == 1 && ejsIsString(argv[0]));
    mprSetPathSeparators(ejs, fp->path, ejsGetString(ejs, argv[0]));
    return 0;
}


#if ES_size
static EjsObj *size(Ejs *ejs, EjsFileSystem *fp, int argc, EjsObj **argv)
{
    return 0;
}
#endif


EjsFileSystem *ejsCreateFileSystem(Ejs *ejs, cchar *path)
{
    EjsFileSystem   *fs;
    EjsType         *type;
    EjsObj          *arg;

    type = ejsConfigureNativeType(ejs, EJS_EJS_NAMESPACE, "FileSystem", sizeof(EjsFileSystem));
    mprAssert(type);
    fs = (EjsFileSystem*) ejsCreate(ejs, type, 0);
    if (fs == 0) {
        return 0;
    }
    arg = (EjsObj*) ejsCreateString(ejs, path);
    fileSystemConstructor(ejs, fs, 1, (EjsObj**) &arg);
    return fs;
}


void ejsConfigureFileSystemType(Ejs *ejs)
{
    EjsType     *type;

    type = ejsConfigureNativeType(ejs, EJS_EJS_NAMESPACE, "FileSystem", sizeof(EjsFileSystem));

    ejsBindMethod(ejs, type, ES_FileSystem_FileSystem, (EjsProc) fileSystemConstructor);
#if ES_space
    ejsBindMethod(ejs, type, ES_FileSystem_space, (EjsProc) fileSystemSpace);
#endif
    ejsBindMethod(ejs, type, ES_FileSystem_hasDrives, (EjsProc) hasDrives);
#if ES_isReady
    ejsBindMethod(ejs, type, ES_FileSystem_isReady, (EjsProc) isReady);
#endif
#if ES_isWritable
    ejsBindMethod(ejs, type, ES_FileSystem_isWritable, (EjsProc) isWritable);
#endif
    ejsBindAccess(ejs, type, ES_FileSystem_newline, (EjsProc) getNewline, (EjsProc) setNewline);
    ejsBindMethod(ejs, type, ES_FileSystem_root, (EjsProc) root);
    ejsBindAccess(ejs, type, ES_FileSystem_separators, (EjsProc) getSeparators, (EjsProc) setSeparators);
#if ES_size
    ejsBindMethod(ejs, type, ES_FileSystem_size, (EjsProc) size);
#endif
}

/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2010. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2010. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    @end
 */
/************************************************************************/
/*
 *  End of file "../src/core/src/ejsFileSystem.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../src/core/src/ejsFrame.c"
 */
/************************************************************************/

/**
    ejsFrame.c - Activation frame class

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */




static void destroyFrame(Ejs *ejs, EjsFrame *frame)
{
    //  MOB -- does this now mean that the last arg can be deleted?
    ejsFree(ejs, (EjsObj*) frame, ES_Frame);
}


static void markFrame(Ejs *ejs, EjsFrame *frame)
{
    ejsMarkFunction(ejs, (EjsFunction*) frame);
    if (frame->caller) {
        ejsMark(ejs, (EjsObj*) frame->caller);
    }
    /* Marking the stack is done in ejsGarbage.c:mark() */
}



static EjsFrame *allocFrame(Ejs *ejs, int numSlots)
{
    EjsObj      *obj;
    uint        size;

    mprAssert(ejs);

    size = numSlots * sizeof(EjsSlot) + sizeof(EjsFrame);
    if ((obj = (EjsObj*) mprAllocZeroed(ejsGetAllocCtx(ejs), size)) == 0) {
        ejsThrowMemoryError(ejs);
        return 0;
    }
    obj->type = ejs->frameType;
    obj->master = (ejs->master == 0);
    ejsAddToGcStats(ejs, obj, ES_Frame);
    return (EjsFrame*) obj;
}


/*
    Create an activation frame
 */
EjsFrame *ejsCreateFrame(Ejs *ejs, EjsFunction *fun, EjsObj *thisObj, int argc, EjsObj **argv)
{
    EjsFrame    *frame;
    EjsObj      *obj, *activation;
    int         numSlots, sizeSlots, i;

    activation = fun->activation;
    numSlots = (activation) ? activation->numSlots : 0;
    sizeSlots = max(numSlots, EJS_MIN_FRAME_SLOTS);

    if (sizeSlots > EJS_MIN_FRAME_SLOTS || (frame = (EjsFrame*) ejsAllocPooled(ejs, ES_Frame)) == 0) {
        frame = allocFrame(ejs, sizeSlots);
    }
    obj = (EjsObj*) frame;
    obj->slots = (EjsSlot*) &(((char*) obj)[sizeof(EjsFrame)]);
    obj->sizeSlots = sizeSlots;
    obj->numSlots = numSlots;
    if (activation) {
        //  MOB -- assumes that the function is sealed
        memcpy(obj->slots, activation->slots, numSlots * sizeof(EjsSlot));
        ejsMakeObjHash(obj);
    }
    ejsZeroSlots(ejs, &obj->slots[numSlots], sizeSlots - numSlots);
    obj->dynamic = 1;

    frame->function.block.namespaces = fun->block.namespaces;
    frame->function.block.scopeChain = fun->block.scopeChain;
    frame->function.block.prev = fun->block.prev;
    frame->function.block.breakCatch = fun->block.breakCatch;
    frame->function.block.nobind = fun->block.nobind;

#if BLD_HAS_UNNAMED_UNIONS
    frame->function.bits = fun->bits;
#else
    frame->function.numArgs = fun->numArgs;
    frame->function.numDefault = fun->numDefault;
    frame->function.castNulls = fun->castNulls;
    frame->function.constructor = fun->constructor;
    frame->function.fullScope = fun->fullScope;
    frame->function.hasReturn = fun->hasReturn;
#if NOT_NEEDED && KEEP
    frame->function.inCatch = fun->inCatch;
    frame->function.inException = fun->inException;
#endif
    frame->function.isInitializer = fun->isInitializer;
    frame->function.nativeProc = fun->nativeProc;
    frame->function.override = fun->override;
    frame->function.rest = fun->rest;
    frame->function.staticMethod = fun->staticMethod;
    frame->function.strict = fun->strict;
    frame->function.throwNulls = fun->throwNulls;
#endif
    frame->function.thisObj = thisObj;
    frame->function.resultType = fun->resultType;
    frame->function.slotNum = fun->slotNum;
    frame->function.owner = fun->owner;
    frame->function.body = fun->body;
    frame->pc = fun->body.code.byteCode;

    if (argc > 0) {
        frame->argc = argc;
        if ((uint) argc < (fun->numArgs - fun->numDefault) || (uint) argc > fun->numArgs) {
            ejsThrowArgError(ejs, "Incorrect number of arguments");
            return 0;
        }
        for (i = 0; i < argc; i++) {
            frame->function.block.obj.slots[i].value.ref = argv[i];
        }
    }
    ejsSetDebugName(frame, ejsGetDebugName(fun));
    return frame;
}


void ejsCreateFrameType(Ejs *ejs)
{
    EjsType         *type;
    EjsTypeHelpers  *helpers;

    type = ejs->frameType = ejsCreateNativeType(ejs, "ejs", "Frame", ES_Frame, sizeof(EjsFrame));

    helpers = type->helpers;
    helpers->destroy = (EjsDestroyHelper) destroyFrame;
    helpers->mark    = (EjsMarkHelper) markFrame;
}


/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2010. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2010. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    @end
 */
/************************************************************************/
/*
 *  End of file "../src/core/src/ejsFrame.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../src/core/src/ejsFunction.c"
 */
/************************************************************************/

/**
    ejsFunction.c - Function class

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */



/*
    Create a function object.
 */
static EjsFunction *createFunction(Ejs *ejs, EjsType *type, int numSlots)
{
    EjsFunction     *fun;

    /*
        Note: Functions are not pooled, frames are.
     */
    fun = (EjsFunction*) ejsCreateObject(ejs, ejs->functionType, 0);
    if (fun == 0) {
        return 0;
    }
    //  MOB -- get rid of owner+slotNum
    fun->slotNum = -1;
    fun->block.obj.isFunction = 1;
    fun->block.obj.dynamic = 1;
    return fun;
}


/*
    Cast the operand to the specified type

    intrinsic function cast(type: Type) : Object
 */
static EjsObj *castFunction(Ejs *ejs, EjsFunction *vp, EjsType *type)
{
    switch (type->id) {
    case ES_String:
        return (EjsObj*) ejsCreateString(ejs, "[function Function]");

    case ES_Number:
        return (EjsObj*) ejs->nanValue;

    case ES_Boolean:
        return (EjsObj*) ejs->trueValue;
            
    default:
        ejsThrowTypeError(ejs, "Can't cast type \"%s\"", type->qname.name);
        return 0;
    }
    return 0;
}


EjsFunction *ejsCloneFunction(Ejs *ejs, EjsFunction *src, int deep)
{
    EjsFunction     *dest;

    dest = (EjsFunction*) ejsCloneBlock(ejs, &src->block, deep);
    if (dest == 0) {
        return 0;
    }
    dest->body.code = src->body.code;
    dest->resultType = src->resultType;
    dest->thisObj = src->thisObj;
    dest->owner = src->owner;
    dest->slotNum = src->slotNum;
    dest->numArgs = src->numArgs;
    dest->numDefault = src->numDefault;

    /*
        OPT
     */
    dest->staticMethod = src->staticMethod;
    dest->constructor = src->constructor;
    dest->hasReturn = src->hasReturn;
    dest->isInitializer = src->isInitializer;
    dest->override = src->override;
    dest->rest = src->rest;
    dest->fullScope = src->fullScope;
    dest->nativeProc = src->nativeProc;
    dest->strict = src->strict;

    if (src->activation) {
        dest->activation = ejsCloneObject(ejs, src->activation, 0);
    }
    return dest;
}


static void destroyFunction(Ejs *ejs, EjsFunction *fun)
{
    ejsFree(ejs, (EjsObj*) fun, ES_Function);
}


static EjsObj *getFunctionProperty(Ejs *ejs, EjsObj *obj, int slotNum)
{
    EjsObj      *vp;

    mprAssert(obj);
    mprAssert(obj->slots);
    mprAssert(slotNum >= 0);

    if (slotNum < 0 || slotNum >= obj->numSlots) {
        ejsThrowReferenceError(ejs, "Property at slot \"%d\" is not found", slotNum);
        return 0;
    }
    vp = obj->slots[slotNum].value.ref;
#if ES_Function_prototype
    if (slotNum == ES_Function_prototype && vp == ejs->nullValue) {
        vp = ejsCreateObject(ejs, ejs->objectType, 0);
        vp->isPrototype = 1;
        ejsSetProperty(ejs, obj, ES_Function_prototype, vp);
    }
#endif
    return vp;
}


/*
    Lookup a property with a namespace qualifier in an object and return the slot if found. Return EJS_ERR if not found.
 */
static int lookupFunctionProperty(struct Ejs *ejs, EjsFunction *fun, EjsName *qname)
{
#if UNUSED
    EjsName     name;
    EjsObj      *prototype;
#endif
    int         slotNum;

    slotNum = (ejs->objectType->helpers->lookupProperty)(ejs, (EjsObj*) fun, qname);

#if UNUSED
    if (slotNum < 0 && qname->name[0] == 'p' && strcmp(qname->name, "prototype") == 0 && qname->space[0] == '\0') {
        prototype = ejsCreatePrototype(ejs, type, 0);
        ejsDefineProperty(ejs, (EjsObj*) fun, ES_Object_prototype, ejsName(&name, "", "prototype"),
            ejs->objectType, 0, prototype);
    }
#endif
    return slotNum;
}


void ejsMarkFunction(Ejs *ejs, EjsFunction *fun)
{
    ejsMarkBlock(ejs, (EjsBlock*) fun);
    if (fun->activation) {
        ejsMark(ejs, (EjsObj*) fun->activation);
    }
    if (fun->setter) {
        ejsMark(ejs, (EjsObj*) fun->setter);
    }
    if (fun->creator) {
        ejsMark(ejs, (EjsObj*) fun->creator);
    }
    if (fun->owner) {
        ejsMark(ejs, fun->owner);
    }
    if (fun->thisObj) {
        ejsMark(ejs, fun->thisObj);
    }
    if (fun->resultType) {
        ejsMark(ejs, (EjsObj*) fun->resultType);
    }
}


/*
    function apply(thisObj: Object, args: Array)
 */
static EjsObj *fun_applyFunction(Ejs *ejs, EjsFunction *fun, int argc, EjsObj **argv)
{
    EjsArray        *args;
    EjsObj          *save, *result, *thisObj;
    
    mprAssert(argc > 1);
    args = (EjsArray*) argv[1];
    mprAssert(ejsIsArray(args));

    save = fun->thisObj;
    thisObj = (argv[0] == ejs->nullValue) ? fun->thisObj: argv[0];
    result =  ejsRunFunction(ejs, fun, thisObj, args->length, args->data);
    fun->thisObj = save;
    return result;
}


/*
    function bind(thisObj: Object, overwrite: Boolean = true): Void
 */
static EjsObj *fun_bindFunction(Ejs *ejs, EjsFunction *fun, int argc, EjsObj **argv)
{
    int     overwrite;
    
    mprAssert(argc >= 1);
    overwrite = (argc < 2 || (argv[1] == (EjsObj*) ejs->trueValue));
    if (overwrite || !fun->thisObj) {
        fun->thisObj = argv[0];
    }
    return 0;
}


/*
    function boundThis(): Function
 */
static EjsObj *fun_boundThis(Ejs *ejs, EjsFunction *fun, int argc, EjsObj **argv)
{
    return fun->thisObj;
}


/*
    function call(thisObj, ...args)
 */
static EjsObj *fun_call(Ejs *ejs, EjsFunction *fun, int argc, EjsObj **argv)
{
    mprAssert(argc > 1);
    return fun_applyFunction(ejs, fun, argc, argv);
}


#if UNUSED
/*
    function get prototype(): Object
 */
static EjsObj *fun_prototype(Ejs *ejs, EjsFunction *fun, int argc, EjsObj **argv)
{
    EjsObj      *prototype;
    EjsTrait    *trait;

    mprAssert(ejsIsFunction(fun));

    if ((prototype = ejsCreateObject(ejs, ejs->objectType, 0)) == 0) {
        return 0;
    }
    prototype->isPrototype = 1;
    ejsSetProperty(ejs, (EjsObj*) fun, ES_Function_prototype, prototype);
    if ((trait = ejsGetTrait((EjsObj*) fun, ES_Function_prototype)) != 0) {
        trait->attributes &= ~(EJS_TRAIT_GETTER);
    }
    return prototype;
}
#endif


/*
    function setScope(obj): Void
 */
static EjsObj *fun_setScope(Ejs *ejs, EjsFunction *fun, int argc, EjsObj **argv)
{
    EjsBlock    *scope;

    scope = (EjsBlock*) argv[0];
    if (!ejsIsBlock(scope)) {
        scope = (EjsBlock*) scope->obj.type;
        if (!ejsIsBlock(scope)) {
            ejsThrowArgError(ejs, "scope object must be a class or function");
            return 0;
        }
    }
    fun->block.scopeChain = scope;
    return 0;
}


/*
    Create a script function. This defines the method traits. It does not create a  method slot. ResultType may
    be null to indicate untyped. NOTE: untyped functions may return a result at their descretion.
 */
EjsFunction *ejsCreateFunction(Ejs *ejs, cuchar *byteCode, int codeLen, int numArgs, int numDefault, int numExceptions, 
    EjsType *resultType, int attributes, EjsConst *constants, EjsBlock *scopeChain, int strict)
{
    EjsFunction     *fun;
    EjsCode         *code;

    fun = (EjsFunction*) ejsCreate(ejs, ejs->functionType, 0);
    if (fun == 0) {
        return 0;
    }
    if (scopeChain) {
        fun->block.scopeChain = scopeChain;
    }
    fun->numArgs = numArgs;
    fun->numDefault = numDefault;
    fun->resultType = resultType;
    fun->strict = strict;

    //  MOB -- convert these all back to a simple bit mask
    if (attributes & EJS_FUN_CONSTRUCTOR) {
        fun->constructor = 1;
    }
    if (attributes & EJS_FUN_REST_ARGS) {
        fun->rest = 1;
    }
    if (attributes & EJS_FUN_INITIALIZER) {
        fun->isInitializer = 1;
    }
    if (attributes & EJS_PROP_STATIC) {
        fun->staticMethod = 1;
    }
    if (attributes & EJS_FUN_OVERRIDE) {
        fun->override = 1;
    }
    if (attributes & EJS_PROP_NATIVE) {
        fun->nativeProc = 1;
    }
    if (attributes & EJS_FUN_FULL_SCOPE) {
        fun->fullScope = 1;
    }
    if (attributes & EJS_FUN_HAS_RETURN) {
        fun->hasReturn = 1;
    }
    if (attributes & EJS_TRAIT_CAST_NULLS) {
        fun->castNulls = 1;
    }
    if (attributes & EJS_TRAIT_THROW_NULLS) {
        fun->throwNulls = 1;
    }
    code = &fun->body.code;
    code->codeLen = codeLen;
    code->byteCode = (uchar*) byteCode;
    code->numHandlers = numExceptions;
    code->constants = constants;
    return fun;
}


void ejsSetFunctionLocation(EjsFunction *fun, EjsObj *obj, int slotNum)
{
    mprAssert(fun);
    mprAssert(obj);

    fun->owner = obj;
    fun->slotNum = slotNum;
}


EjsEx *ejsAddException(EjsFunction *fun, uint tryStart, uint tryEnd, EjsType *catchType, uint handlerStart,
        uint handlerEnd, int numBlocks, int numStack, int flags, int preferredIndex)
{
    EjsEx           *exception;
    EjsCode         *code;
    int             size;

    mprAssert(fun);

    code = &fun->body.code;

    exception = mprAllocObjZeroed(fun, EjsEx);
    if (exception == 0) {
        mprAssert(0);
        return 0;
    }
    exception->flags = flags;
    exception->tryStart = tryStart;
    exception->tryEnd = tryEnd;
    exception->catchType = catchType;
    exception->handlerStart = handlerStart;
    exception->handlerEnd = handlerEnd;
    exception->numBlocks = numBlocks;
    exception->numStack = numStack;

    if (preferredIndex < 0) {
        preferredIndex = code->numHandlers++;
    }

    if (preferredIndex >= code->sizeHandlers) {
        size = code->sizeHandlers + EJS_EX_INC;
        code->handlers = (EjsEx**) mprRealloc(fun, code->handlers, size * sizeof(EjsEx));
        if (code->handlers == 0) {
            mprAssert(0);
            return 0;
        }
        memset(&code->handlers[code->sizeHandlers], 0, EJS_EX_INC * sizeof(EjsEx)); 
        code->sizeHandlers = size;
    }
    code->handlers[preferredIndex] = exception;
    return exception;
}


void ejsOffsetExceptions(EjsFunction *fun, int offset)
{
    EjsEx           *ex;
    int             i;

    mprAssert(fun);

    for (i = 0; i < fun->body.code.numHandlers; i++) {
        ex = fun->body.code.handlers[i];
        ex->tryStart += offset;
        ex->tryEnd += offset;
        ex->handlerStart += offset;
        ex->handlerEnd += offset;
    }
}


/*
    Set the byte code for a script function
 */
int ejsSetFunctionCode(EjsFunction *fun, uchar *byteCode, int len)
{
    mprAssert(fun);
    mprAssert(byteCode);
    mprAssert(len >= 0);

    byteCode = (uchar*) mprMemdup(fun, byteCode, len);
    if (byteCode == 0) {
        return EJS_ERR;
    }
    fun->body.code.codeLen = len;
    mprFree(fun->body.code.byteCode);
    fun->body.code.byteCode = (uchar*) byteCode;
    return 0;
}


static EjsObj *nopFunction(Ejs *ejs, EjsObj *obj, int argc, EjsObj **argv)
{
    return ejs->undefinedValue;
}


void ejsCompleteFunction(Ejs *ejs, EjsFunction *fun)
{
    int     numSlots;

    numSlots = fun->block.obj.numSlots;
    if (numSlots > 0 && fun->activation == 0) {
        fun->activation = ejsCreateActivation(ejs, fun, numSlots);
        ejsCopySlots(ejs, (EjsObj*) fun, fun->activation->slots, fun->block.obj.slots, numSlots, 0);
        ejsZeroSlots(ejs, fun->block.obj.slots, numSlots);
        ejsClearObjHash((EjsObj*) fun);
        fun->block.obj.numSlots = 0;
    }
}


void ejsUseActivation(Ejs *ejs, EjsFunction *fun)
{
    EjsObj  *activation;
    int     numSlots;

    if ((activation = fun->activation) == 0) {
        return;
    }
    numSlots = activation->numSlots;
    if (numSlots > 0) {
        ejsGrowObject(ejs, (EjsObj*) fun, numSlots);
        ejsCopySlots(ejs, (EjsObj*) fun, fun->block.obj.slots, fun->activation->slots, numSlots, 0);
        fun->block.obj.numSlots = numSlots;
    }
}


EjsObj *ejsCreateActivation(Ejs *ejs, EjsFunction *fun, int numSlots)
{
    EjsObj  *activation;

    activation = ejsCreateObject(ejs, ejs->objectType, numSlots);
    ejsSetDebugName(activation, ejsGetDebugName(fun));
    return activation;
}



void ejsCreateFunctionType(Ejs *ejs)
{
    EjsType         *type;
    EjsTypeHelpers  *helpers;
    EjsFunction     *nop;

    type = ejs->functionType = ejsCreateNativeType(ejs, "ejs", "Function", ES_Function, sizeof(EjsFunction));

    helpers = type->helpers;
    helpers->create         = (EjsCreateHelper) createFunction;
    helpers->cast           = (EjsCastHelper) castFunction;
    helpers->clone          = (EjsCloneHelper) ejsCloneFunction;
    helpers->destroy        = (EjsDestroyHelper) destroyFunction;
    helpers->getProperty    = (EjsGetPropertyHelper) getFunctionProperty;
    helpers->mark           = (EjsMarkHelper) ejsMarkFunction;
    helpers->lookupProperty = (EjsLookupPropertyHelper) lookupFunctionProperty;

    /*
        Utility nop function
     */
    nop = ejs->nopFunction = ejsCreateFunction(ejs, NULL, 0, -1, 0, 0, NULL, EJS_PROP_NATIVE, NULL, NULL, 0);
    nop->body.proc = nopFunction;
    nop->nativeProc = 1;
}


void ejsConfigureFunctionType(Ejs *ejs)
{
    EjsType     *type;

    type = ejs->functionType;
    ejsBindMethod(ejs, type, ES_Function_apply, (EjsProc) fun_applyFunction);
    ejsBindMethod(ejs, type, ES_Function_bind, (EjsProc) fun_bindFunction);
    ejsBindMethod(ejs, type, ES_Function_boundThis, (EjsProc) fun_boundThis);
#if UNUSED
    ejsBindMethod(ejs, type, ES_Function_prototype, (EjsProc) fun_prototype);
#endif
    ejsBindMethod(ejs, type, ES_Function_setScope, (EjsProc) fun_setScope);
    ejsBindMethod(ejs, type, ES_Function_call, (EjsProc) fun_call);
}


/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2010. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2010. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    @end
 */
/************************************************************************/
/*
 *  End of file "../src/core/src/ejsFunction.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../src/core/src/ejsGC.c"
 */
/************************************************************************/

/**
    ejsGC.c - Garbage collector class for the EJS Object Model

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */



/*
    native static function get enabled(): Boolean
 */
static EjsObj *getEnable(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv)
{
    return (EjsObj*) ((ejs->gc.enabled) ? ejs->trueValue: ejs->falseValue);
}


/*
    native static function set enabled(on: Boolean): Void
 */
static EjsObj *setEnable(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv)
{
    mprAssert(argc == 1 && ejsIsBoolean(argv[0]));
    ejs->gc.enabled = ejsGetBoolean(ejs, argv[0]);
    return 0;
}


/*
    run(deep: Boolean = false)
    Note: deep currently is not implemented
 */
static EjsObj *runGC(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv)
{
    int     deep;

    deep = ((argc == 1) && ejsIsBoolean(argv[1]));
    ejsCollectGarbage(ejs, EJS_GEN_NEW);
    return 0;
}


/*
    native static function get workQuota(): Number
 */
static EjsObj *getWorkQuota(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateNumber(ejs, ejs->workQuota);
}


/*
    native static function set workQuota(quota: Number): Void
 */
static EjsObj *setWorkQuota(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv)
{
    int     quota;

    mprAssert(argc == 1 && ejsIsNumber(argv[0]));
    quota = ejsGetInt(ejs, argv[0]);

    if (quota < EJS_SHORT_WORK_QUOTA && quota != 0) {
        ejsThrowArgError(ejs, "Bad work quota");
        return 0;
    }
    ejs->workQuota = quota;
    return 0;
}


void ejsConfigureGCType(Ejs *ejs)
{
    EjsType         *type;

    if ((type = ejsGetTypeByName(ejs, EJS_EJS_NAMESPACE, "GC")) == 0) {
        mprError(ejs, "Can't find GC type");
        return;
    }
    ejsBindAccess(ejs, type, ES_GC_enabled, (EjsProc) getEnable, (EjsProc) setEnable);
    ejsBindAccess(ejs, type, ES_GC_workQuota, (EjsProc) getWorkQuota, (EjsProc) setWorkQuota);
    ejsBindMethod(ejs, type, ES_GC_run, (EjsProc) runGC);
}

/*
    @copy   default
    
    Copyright (c) Embedthis Software LLC, 2003-2010. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2010. All Rights Reserved.
    
    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire 
    a commercial license from Embedthis Software. You agree to be fully bound 
    by the terms of either license. Consult the LICENSE.TXT distributed with 
    this software for full details.
    
    This software is open source; you can redistribute it and/or modify it 
    under the terms of the GNU General Public License as published by the 
    Free Software Foundation; either version 2 of the License, or (at your 
    option) any later version. See the GNU General Public License for more 
    details at: http://www.embedthis.com/downloads/gplLicense.html
    
    This program is distributed WITHOUT ANY WARRANTY; without even the 
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
    
    This GPL license does NOT permit incorporating this software into 
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses 
    for this software and support services are available from Embedthis 
    Software at http://www.embedthis.com 
    
    @end
 */
/************************************************************************/
/*
 *  End of file "../src/core/src/ejsGC.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../src/core/src/ejsGlobal.c"
 */
/************************************************************************/

/**
    ejsGlobal.c - Global functions and variables

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */




static int blendObjects(Ejs *ejs, EjsObj *dest, EjsObj *src, int overwrite);

/*  
    Assert a condition is true.
    static function assert(condition: Boolean): Boolean
 */
static EjsObj *assertMethod(Ejs *ejs, EjsObj *vp, int argc, EjsObj **argv)
{
    EjsFrame        *fp;
    EjsBoolean      *b;

    mprAssert(argc == 1);

    if (! ejsIsBoolean(argv[0])) {
        b = (EjsBoolean*) ejsCast(ejs, argv[0], ejs->booleanType);
    } else {
        b = (EjsBoolean*) argv[0];
    }
    mprAssert(b);

    if (b == 0 || !b->value) {
        fp = ejs->state->fp;
        if (fp->currentLine) {
            mprLog(ejs, 0, "Assertion error: %s", fp->currentLine);
            ejsThrowAssertError(ejs, "Assertion error: %s", fp->currentLine);
        } else {
            ejsThrowAssertError(ejs, "Assertion error");
        }
        return 0;
    }
    return vp;
}


#if MOVE_TO_DEBUG_CLASS || 1
/*  
    Trap to the debugger
    static function breakpoint(): Void
 */
static EjsObj *breakpoint(Ejs *ejs, EjsObj *vp, int argc, EjsObj **argv)
{
    mprBreakpoint();
    return 0;
}
#endif


/*  
    function blend(dest: Object, src: Object, overwrite: Boolean = true): void
 */
static EjsObj *blend(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    EjsObj      *src, *dest;
    int         overwrite;

    overwrite = (argc == 3) ? (argv[2] == (EjsObj*) ejs->trueValue) : 1;
    dest = argv[0];
    src = argv[1];
    blendObjects(ejs, dest, src, overwrite);
    return dest;
}


/*  
    Clone the base class. Used by Record.es
    static function cloneBase(klass: Type): Void
 */
static EjsObj *cloneBase(Ejs *ejs, EjsObj *ignored, int argc, EjsObj **argv)
{
    EjsType     *type;
    
    mprAssert(argc == 1);
    
    type = (EjsType*) argv[0];
    type->baseType = (EjsType*) ejsClone(ejs, (EjsObj*) type->baseType, 0);
    return 0;
}


/** DEPRECATED
    
    Print the arguments to the standard error with a new line.
    static function error(...args): void
 */
static EjsObj *error(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    EjsString   *s;
    EjsObj      *args, *vp;
    int         i, count;

    mprAssert(argc == 1 && ejsIsArray(argv[0]));

    args = argv[0];
    count = ejsGetPropertyCount(ejs, args);

    for (i = 0; i < count; i++) {
        if ((vp = ejsGetProperty(ejs, args, i)) != 0) {
            if (!ejsIsString(vp)) {
                vp = (EjsObj*) ejsToJSON(ejs, vp, NULL);
            }
            if (ejs->exception) {
                return 0;
            }
            if (vp) {
                s = (EjsString*) vp;
                write(2, s->value, s->length);
            }
        }
    }
    write(2, "\n", 1);
    return 0;
}


//  MOB -- move
/*  
    HTML escape a string
    function escape(str: String): String
 */
static EjsObj *escape(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    EjsString   *str;

    str = (EjsString*) argv[0];
    return (EjsObj*) ejsCreateStringAndFree(ejs, mprEscapeHtml(ejs, str->value));
}


/*  
    function eval(script: String, cache: String = null): String
 */
static EjsObj *eval(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    cchar       *script, *cache;

    script = ejsGetString(ejs, argv[0]);
    if (argc < 2 || argv[1] == ejs->nullValue) {
        cache = 0;
    } else {
        cache = ejsGetString(ejs, argv[1]);
    }
    if (ejs->service->loadScriptLiteral) {
        return (ejs->service->loadScriptLiteral)(ejs, script, cache);
    }
    ejsThrowStateError(ejs, "Ability to compile scripts not available");
    return 0;
}


/*
    Format the stack
    function formatStack(): String
 */
static EjsObj *formatStackMethod(Ejs *ejs, EjsObj *vp, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateString(ejs, ejsFormatStack(ejs, NULL));
}


#if ES_hashcode
/*  Get the hash code for the object.
    intrinsic function hashcode(o: Object): Number
 */
static EjsObj *hashcode(Ejs *ejs, EjsObj *vp, int argc, EjsObj **argv)
{
    mprAssert(argc == 1);
    return (EjsObj*) ejsCreateNumber(ejs, (MprNumber) PTOL(argv[0]));
}
#endif


/** 
    DEPREACATED
    Read a line of input
    static function input(): String
 */
static EjsObj *input(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    MprFileSystem   *fs;
    MprBuf          *buf;
    EjsObj          *result;
    int             c;

    fs = mprGetMpr()->fileSystem;

    buf = mprCreateBuf(ejs, -1, -1);
    while ((c = getchar()) != EOF) {
#if BLD_WIN_LIKE
        if (c == fs->newline[0]) {
            continue;
        } else if (c == fs->newline[1]) {
            break;
        }
#else
        if (c == fs->newline[0]) {
            break;
        }
#endif
        mprPutCharToBuf(buf, c);
    }
    if (c == EOF && mprGetBufLength(buf) == 0) {
        return (EjsObj*) ejs->nullValue;
    }
    mprAddNullToBuf(buf);
    result = (EjsObj*) ejsCreateString(ejs, mprGetBufStart(buf));
    mprFree(buf);
    return result;
}


/*  
    Load a script or module. Name should have an extension. Name will be located according to the EJSPATH search strategy.
    static function load(filename: String, cache: String): void
 */
static EjsObj *load(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    cchar       *path, *cache, *cp;

    path = ejsGetString(ejs, argv[0]);
    cache = (argc < 2) ? 0 : ejsGetString(ejs, argv[1]);

    if ((cp = strrchr(path, '.')) != NULL && strcmp(cp, EJS_MODULE_EXT) != 0) {
        if (ejs->service->loadScriptFile == 0) {
            ejsThrowIOError(ejs, "load: Compiling is not enabled for %s", path);
        } else {
            return (ejs->service->loadScriptFile)(ejs, path, cache);
        }
    } else {
        ejsLoadModule(ejs, path, -1, -1, 0);
        return (ejs->exception) ? 0 : ejs->result;
    }
    return 0;
}


/*  
    Compute an MD5 checksum
    static function md5(name: String): void
 */
static EjsObj *md5(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    EjsString   *str;

    str = (EjsString*) argv[0];
    return (EjsObj*) ejsCreateStringAndFree(ejs, mprGetMD5Hash(ejs, str->value, str->length, NULL));
}


/*  
    Merge one object into another. This is useful for inheriting and optionally overwriting option hashes (among other
    things). The blendObjects is done at the primitive property level. If overwrite is true, the property is replaced. If
    overwrite is false, the property will be added if it does not already exist
 */
static int blendObjects(Ejs *ejs, EjsObj *dest, EjsObj *src, int overwrite)
{
    EjsObj      *vp, *dp;
    EjsName     name;
    int         i, count;

    count = ejsGetPropertyCount(ejs, src);
    for (i = 0; i < count; i++) {
        vp = ejsGetProperty(ejs, src, i);
        if (vp == 0) {
            continue;
        }
        name = ejsGetPropertyName(ejs, src, i);
        /* NOTE: treats arrays as primitive types */
        if (!ejsIsArray(vp) && !ejsIsXML(ejs, vp) && ejsGetPropertyCount(ejs, vp) > 0) {
            if ((dp = ejsGetPropertyByName(ejs, dest, &name)) == 0 || ejsGetPropertyCount(ejs, dp) == 0) {
                name.name = mprStrdup(dest, name.name);
                name.space = mprStrdup(dest, name.space);
                ejsSetPropertyByName(ejs, dest, &name, (EjsObj*) ejsCloneObject(ejs, (EjsObj*) vp, 1));
            } else {
                blendObjects(ejs, dp, vp, overwrite);
            }

        } else {
            /* Primitive type (including arrays) */
            if (overwrite) {
                name.name = mprStrdup(dest, name.name);
                name.space = mprStrdup(dest, name.space);
                ejsSetPropertyByName(ejs, dest, &name, vp);
            } else {
                if (ejsLookupProperty(ejs, dest, &name) < 0) {
                    name.name = mprStrdup(dest, name.name);
                    name.space = mprStrdup(dest, name.space);
                    ejsSetPropertyByName(ejs, dest, &name, vp);
                }
            }
        }
    }
    return 0;
}


/*     
    Parse the input and convert to a primitive type
    static function parse(input: String, preferredType: Type = null): void
 */
static EjsObj *parse(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    cchar       *str;
    int         preferred;

    str = ejsGetString(ejs, argv[0]);

    if (argc == 2 && !ejsIsType(argv[1])) {
        ejsThrowArgError(ejs, "PreferredType argument is not a type");
        return 0;
    }
    while (isspace((int) *str)) {
        str++;
    }    
    preferred = (argc == 2) ? ((EjsType*) argv[1])->id : -1;
    return ejsParse(ejs, str, preferred);
}


/*
    Parse the input as an integer
    static function parseInt(input: String, radix: Number = 10): void
    Formats:
        [(+|-)][0][OCTAL_DIGITS]
        [(+|-)][0][(x|X)][HEX_DIGITS]
        [(+|-)][DIGITS]
 */
static EjsObj *parseInt(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    MprNumber   n;
    cchar       *str;
    int         radix, err;

    str = ejsGetString(ejs, argv[0]);
    radix = (argc >= 2) ? ejsGetInt(ejs, argv[1]) : 0;
    while (isspace((int) *str)) {
        str++;
    }
    if (*str == '-' || *str == '+' || isdigit((int) *str)) {
        n = (MprNumber) mprParseNumber(str, radix, &err);
        if (err) {
            return (EjsObj*) ejs->nanValue;
        }
        return (EjsObj*) ejsCreateNumber(ejs, n);
    }
    return (EjsObj*) ejs->nanValue;
}


/*  
    Print the arguments to the standard output with a new line.
    static function print(...args): void
    DEPRECATED static function output(...args): void
 */
static EjsObj *printLine(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    EjsString   *s;
    EjsObj      *args, *vp;
    char        *cp;
    int         i, count;

    mprAssert(argc == 1 && ejsIsArray(argv[0]));

    args = argv[0];
    count = ejsGetPropertyCount(ejs, args);

    for (i = 0; i < count; i++) {
        if ((vp = ejsGetProperty(ejs, args, i)) != 0) {
            if (ejsIsString(vp)) {
                s = (EjsString*) vp;
            } else {
                s  = (EjsString*) ejsToString(ejs, vp);
            }
            if (ejs->exception) {
                return 0;
            }
            if (vp && s) {
                if (s->length > 0 && s->value[0] == '"') {
                    cp = mprStrdup(ejs, s->value);
                    // cp = mprStrTrim(tmp, "\"");
                    write(1, cp, strlen(cp));
                    mprFree(cp);
                } else {
                    write(1, s->value, s->length);
                }
            }
        }
    }
    write(1, "\n", 1);
    return 0;
}


static EjsNamespace *addNamespace(Ejs *ejs, EjsBlock *block, cchar *space)
{
    EjsNamespace    *ns;

    ns = ejsDefineReservedNamespace(ejs, block, 0, space);
    mprAddHash(ejs->standardSpaces, space, ns);
    return ns;
}


void ejsFreezeGlobal(Ejs *ejs)
{
    EjsTrait    *trait;
    int         i;

    for (i = 0; i < ES_global_NUM_CLASS_PROP; i++) {
        if ((trait = ejsGetTrait(ejs->global, i)) != 0) {
            trait->attributes |= EJS_TRAIT_READONLY | EJS_TRAIT_FIXED;
        }
    }
}


void ejsCreateGlobalBlock(Ejs *ejs)
{
    EjsBlock    *block;
    int         sizeSlots;

    sizeSlots = (ejs->empty) ? 0 : max(ES_global_NUM_CLASS_PROP, EJS_NUM_GLOBAL);
    ejs->globalBlock = ejsCreateBlock(ejs, sizeSlots);
    ejs->globalBlock->isGlobal = 1;
    ejs->global = (EjsObj*) ejs->globalBlock;
    ejs->global->numSlots = (ejs->empty) ? 0: ES_global_NUM_CLASS_PROP;
    ejs->global->dynamic = 1;
    ejsSetDebugName(ejs->global, "global");
    
    /*  
        Create the standard namespaces. Order matters here. This is the (reverse) order of lookup.
        Empty is first intrinsic is last. TODO - OPT Optimize this ordering.
     */
    block = (EjsBlock*) ejs->global;
    ejs->iteratorSpace =    addNamespace(ejs, block, EJS_ITERATOR_NAMESPACE);
    ejs->ejsSpace =         addNamespace(ejs, block, EJS_EJS_NAMESPACE);
    ejs->publicSpace =      addNamespace(ejs, block, EJS_PUBLIC_NAMESPACE);
    ejs->emptySpace =       addNamespace(ejs, block, EJS_EMPTY_NAMESPACE);
}


void ejsConfigureGlobalBlock(Ejs *ejs)
{
    EjsBlock    *block;

    block = ejs->globalBlock;
    mprAssert(block);
    
//  MOB -- prefix these functions to be more unique need g_ prefix

    ejsBindFunction(ejs, block, ES_assert, assertMethod);
    ejsBindFunction(ejs, block, ES_breakpoint, breakpoint);
    ejsBindFunction(ejs, block, ES_cloneBase, (EjsProc) cloneBase);
    ejsBindFunction(ejs, block, ES_escape, escape);
    ejsBindFunction(ejs, block, ES_eval, eval);
    ejsBindFunction(ejs, block, ES_formatStack, formatStackMethod);
    ejsBindFunction(ejs, block, ES_hashcode, hashcode);
    ejsBindFunction(ejs, block, ES_load, load);
    ejsBindFunction(ejs, block, ES_md5, md5);
    ejsBindFunction(ejs, block, ES_blend, blend);
    ejsBindFunction(ejs, block, ES_parse, parse);
    ejsBindFunction(ejs, block, ES_parseInt, parseInt);
    ejsBindFunction(ejs, block, ES_print, printLine);

    /* DEPRECATED */
    ejsBindFunction(ejs, block, ES_error, error);
    ejsBindFunction(ejs, block, ES_input, input);
    ejsBindFunction(ejs, block, ES_output, printLine);

    ejsSetProperty(ejs, ejs->global, ES_global, ejs->global);
}


/*
    @copy   default
 
    Copyright (c) Embedthis Software LLC, 2003-2010. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2010. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    @end
 */
/************************************************************************/
/*
 *  End of file "../src/core/src/ejsGlobal.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../src/core/src/ejsHttp.c"
 */
/************************************************************************/

/**
    ejsHttp.c - Http client class
    Copyright (c) All Rights Reserved. See details at the end of the file.
 */




static EjsObj   *getDateHeader(Ejs *ejs, EjsHttp *hp, cchar *key);
static EjsObj   *getStringHeader(Ejs *ejs, EjsHttp *hp, cchar *key);
static int      httpCallback(EjsHttp *hp, MprEvent *event);
static void     httpNotify(HttpConn *conn, int state, int notifyFlags);
static void     prepForm(Ejs *ejs, EjsHttp *hp, char *prefix, EjsObj *data);
static int      readTransfer(Ejs *ejs, EjsHttp *hp, int count);
static EjsObj   *startHttpRequest(Ejs *ejs, EjsHttp *hp, char *method, int argc, EjsObj **argv);
static bool     waitForResponseHeaders(EjsHttp *hp, int timeout);
static bool     waitForState(EjsHttp *hp, int state, int timeout, int throw);
static int      writeHttpData(Ejs *ejs, EjsHttp *hp);

/*  
    function Http(uri: Uri = null)
 */
static EjsObj *httpConstructor(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    hp->ejs = ejs;
    hp->conn = httpCreateClient(ejs->http, ejs->dispatcher);
    if (hp->conn == 0) {
        ejsThrowMemoryError(ejs);
    }
    httpSetConnNotifier(hp->conn, httpNotify);
    httpSetConnContext(hp->conn, hp);
    if (argc == 1 && argv[0] != ejs->nullValue) {
        hp->uri = httpUriToString(hp, ((EjsUri*) argv[0])->uri, 1);
    }
    hp->method = mprStrdup(hp, "GET");
    hp->requestContent = mprCreateBuf(hp, HTTP_BUFSIZE, -1);
    hp->responseContent = mprCreateBuf(hp, HTTP_BUFSIZE, -1);
    return (EjsObj*) hp;
}


/*  
    function addListener(name, listener: function): Void
 */
EjsObj *http_addListener(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    ejsAddListener(ejs, &hp->emitter, argv[0], argv[1]);
    return 0;
}


/*  
    function get async(): Boolean
 */
EjsObj *http_async(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    return httpGetAsync(hp->conn) ? (EjsObj*) ejs->trueValue : (EjsObj*) ejs->falseValue;
}


/*  
    function set async(enable: Boolean): Void
 */
EjsObj *http_set_async(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    HttpConn    *conn;
    int         async;

    conn = hp->conn;
    async = (argv[0] == (EjsObj*) ejs->trueValue);
    httpSetCallback(conn, (HttpCallback) httpCallback, hp);
    httpSetAsync(conn, async);
    return 0;
}


/*  
    function get available(): Number
    DEPRECATED 1.0.0B3 (11/09)
 */
EjsObj *http_available(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    int     len;

    if (!waitForResponseHeaders(hp, -1)) {
        return 0;
    }
    len = httpGetContentLength(hp->conn);
    if (len > 0) {
        return (EjsObj*) ejsCreateNumber(ejs, len);
    }
    return (EjsObj*) ejs->minusOneValue;
}


/*  
    function close(): Void
 */
static EjsObj *http_close(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    ejsSendEvent(ejs, hp->emitter, "close", (EjsObj*) hp);
    if (hp->conn) {
        httpCloseConn(hp->conn);
        mprFree(hp->conn);
        hp->conn = httpCreateClient(ejs->http, ejs->dispatcher);
        httpSetConnNotifier(hp->conn, httpNotify);
        httpSetConnContext(hp->conn, hp);
    }
    return 0;
}


/*  
    function connect(url = null, data ...): Void
 */
static EjsObj *http_connect(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    return startHttpRequest(ejs, hp, NULL, argc, argv);
}


//  TODO
/*  
    function get certificate(): String
 */
static EjsObj *http_certificate(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    if (hp->certFile) {
        return (EjsObj*) ejsCreateString(ejs, hp->certFile);
    }
    return ejs->nullValue;
}


/*  
    function set setCertificate(value: String): Void
 */
static EjsObj *http_set_certificate(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    mprFree(hp->certFile);
    hp->certFile = mprStrdup(hp, ejsGetString(ejs, argv[0]));
    return 0;
}


/*  
    function get chunkSize(): Boolean
 */
static EjsObj *http_chunkSize(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateNumber(ejs, httpGetChunkSize(hp->conn));
}


/*  
    function set chunkSize(size: Number): Void
 */
static EjsObj *http_set_chunkSize(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    mprAssert(hp->conn);
    httpSetChunkSize(hp->conn, ejsGetInt(ejs, argv[0]));
    return 0;
}


/*  
    function get contentLength(): Number
 */
static EjsObj *http_contentLength(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    int     length;

    if (!waitForResponseHeaders(hp, -1)) {
        return 0;
    }
    length = httpGetContentLength(hp->conn);
    return (EjsObj*) ejsCreateNumber(ejs, length);
}


/*  
    function get contentType(): String
 */
static EjsObj *http_contentType(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    return getStringHeader(ejs, hp, "CONTENT-TYPE");
}


/*  
    function get date(): Date
 */
static EjsObj *http_date(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    return getDateHeader(ejs, hp, "DATE");
}


/*  
    function del(uri: String = null): Void
 */
static EjsObj *http_del(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    return startHttpRequest(ejs, hp, "DELETE", argc, argv);
}


/*  
    function get expires(): Date
 */
static EjsObj *http_expires(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    return getDateHeader(ejs, hp, "EXPIRES");
}


/*  
    function finalize(): Void
 */
static EjsObj *http_finalize(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    httpFinalize(hp->conn);
    return 0;
}


/*  
    function form(uri: String = null, formData: Object = null): Void
    Issue a POST method with form data
 */
static EjsObj *http_form(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    if (argc == 2 && argv[1] != ejs->nullValue) {
        httpPrepClientConn(hp->conn, HTTP_NEW_REQUEST);
        mprFlushBuf(hp->requestContent);
        prepForm(ejs, hp, NULL, argv[1]);
        mprAddNullToBuf(hp->requestContent);
        httpSetHeader(hp->conn, "Content-Type", "application/x-www-form-urlencoded");
    }
    return startHttpRequest(ejs, hp, "POST", argc, argv);
}


/*  
    function get followRedirects(): Boolean
 */
static EjsObj *http_followRedirects(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateBoolean(ejs, hp->conn->followRedirects);
}


/*  
    function set followRedirects(flag: Boolean): Void
 */
static EjsObj *http_set_followRedirects(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    httpFollowRedirects(hp->conn, ejsGetBoolean(ejs, argv[0]));
    return 0;
}


/*  
    function get(uri: String = null, ...data): Void
    The spec allows GET methods to have body data, but is rarely, if ever, used.
 */
static EjsObj *http_get(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    return startHttpRequest(ejs, hp, "GET", argc, argv);
}


/*  
    Return the (proposed) request headers
    function getRequestHeaders(): Object
 */
static EjsObj *http_getRequestHeaders(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    MprHash         *p;
    HttpConn        *conn;
    EjsObj          *headers;
    EjsName         n;

    conn = hp->conn;
    headers = (EjsObj*) ejsCreateSimpleObject(ejs);
    for (p = 0; (p = mprGetNextHash(conn->transmitter->headers, p)) != 0; ) {
        ejsSetPropertyByName(ejs, headers, EN(&n, p->key), (EjsObj*) ejsCreateString(ejs, p->data));
    }
    return (EjsObj*) headers;
}


/*  
    function head(uri: String = null): Void
 */
static EjsObj *http_head(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    return startHttpRequest(ejs, hp, "HEAD", argc, argv);
}


/*  
    function header(key: String): String
 */
static EjsObj *http_header(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    EjsObj   *result;
    char     *str;

    if (!waitForResponseHeaders(hp, -1)) {
        return 0;
    }
    str = (char*) ejsGetString(ejs, argv[0]);
    str = mprStrdup(ejs, str);
    mprStrLower(str);
    result = (EjsObj*) ejsCreateString(ejs, httpGetHeader(hp->conn, str));
    mprFree(str);
    return result;
}


/*  
    function get headers(): Object
 */
static EjsObj *http_headers(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    MprHashTable    *hash;
    MprHash         *p;
    EjsObj       *results;
    EjsName         qname;
    int             i;

    if (!waitForResponseHeaders(hp, -1)) {
        return 0;
    }
    results = ejsCreateSimpleObject(ejs);
    hash = httpGetHeaderHash(hp->conn);
    if (hash == 0) {
        return (EjsObj*) results;
    }
    for (i = 0, p = mprGetFirstHash(hash); p; p = mprGetNextHash(hash, p), i++) {
        ejsName(&qname, "", p->key);
        ejsSetPropertyByName(ejs, (EjsObj*) results, &qname, (EjsObj*) ejsCreateString(ejs, p->data));
    }
    return (EjsObj*) results;
}


/*  
    function get isSecure(): Boolean
 */
static EjsObj *http_isSecure(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateBoolean(ejs, hp->conn->secure);
}


/*  
    function get key(): String
 */
static EjsObj *http_key(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    if (hp->keyFile) {
        return (EjsObj*) ejsCreateString(ejs, hp->keyFile);
    }
    return ejs->nullValue;
}


/*  
    function set key(keyFile: String): Void
 */
static EjsObj *http_set_key(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    mprFree(hp->keyFile);
    hp->keyFile = mprStrdup(hp, ejsGetString(ejs, argv[0]));
    return 0;
}


/*  
    function get lastModified(): Date
 */
static EjsObj *http_lastModified(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    return getDateHeader(ejs, hp, "LAST-MODIFIED");
}


/*  
    function get method(): String
 */
static EjsObj *http_method(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateString(ejs, hp->method);
}


/*  
    function set method(value: String): Void
 */
static EjsObj *http_set_method(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    cchar    *method;

    method = ejsGetString(ejs, argv[0]);
    if (strcmp(method, "DELETE") != 0 && strcmp(method, "GET") != 0 &&  strcmp(method, "HEAD") != 0 &&
            strcmp(method, "OPTIONS") != 0 && strcmp(method, "POST") != 0 && strcmp(method, "PUT") != 0 &&
            strcmp(method, "TRACE") != 0) {
        ejsThrowArgError(ejs, "Unknown HTTP method");
        return 0;
    }
    mprFree(hp->method);
    hp->method = mprStrdup(hp, ejsGetString(ejs, argv[0]));
    return 0;
}


/*  
    function options(uri: String = null, ...data): Void
 */
static EjsObj *http_options(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    return startHttpRequest(ejs, hp, "OPTIONS", argc, argv);
}


/*  
    function post(uri: String = null, ...requestContent): Void
 */
static EjsObj *http_post(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    return startHttpRequest(ejs, hp, "POST", argc, argv);
}


/*  
    function put(uri: String = null, form object): Void
 */
static EjsObj *http_put(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    return startHttpRequest(ejs, hp, "PUT", argc, argv);
}


/*  
    function read(buffer: ByteArray, offset: Number = 0, count: Number = -1): Number
    Returns a count of bytes read. Non-blocking if a callback is defined. Otherwise, blocks.
 */
static EjsObj *http_read(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    EjsByteArray    *buffer;
    HttpConn        *conn;
    int             offset, count, contentLength;

    conn = hp->conn;
    buffer = (EjsByteArray*) argv[0];
    offset = (argc >= 2) ? ejsGetInt(ejs, argv[1]) : 0;
    count = (argc >= 3) ? ejsGetInt(ejs, argv[2]): -1;

    if (!waitForResponseHeaders(hp, -1)) {
        return 0;
    }
    contentLength = httpGetContentLength(conn);
    if (conn->state >= HTTP_STATE_PARSED && contentLength == hp->readCount) {
        return (EjsObj*) ejs->nullValue;
    }
    if (offset < 0) {
        offset = buffer->writePosition;
    } else if (offset >= buffer->length) {
        ejsThrowOutOfBoundsError(ejs, "Bad read offset value");
        return 0;
    } else {
        ejsSetByteArrayPositions(ejs, buffer, 0, 0);
    }
    if ((count = readTransfer(ejs, hp, count)) < 0) {
        mprAssert(ejs->exception);
        return 0;
    } 
    hp->readCount += count;
    ejsCopyToByteArray(ejs, buffer, buffer->writePosition, (char*) mprGetBufStart(hp->responseContent), count);
    ejsSetByteArrayPositions(ejs, buffer, -1, buffer->writePosition + count);
    mprAdjustBufStart(hp->responseContent, count);
    return (EjsObj*) ejsCreateNumber(ejs, count);
}


/*  
    function readString(count: Number = -1): String
    Read count bytes (default all) of content as a string. This always starts at the first character of content.
 */
static EjsObj *http_readString(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    EjsObj      *result;
    HttpConn    *conn;
    int         count;
    
    count = (argc == 1) ? ejsGetInt(ejs, argv[0]) : -1;
    conn = hp->conn;

    if (!waitForState(hp, HTTP_STATE_CONTENT, conn->async ? 0 : conn->timeout, 0)) {
        return 0;
    }
    if ((count = readTransfer(ejs, hp, count)) < 0) {
        return 0;
    }
    result = (EjsObj*) ejsCreateStringWithLength(ejs, mprGetBufStart(hp->responseContent), count);
    mprAdjustBufStart(hp->responseContent, count);
    return result;
}


/*  
    function removeListener(name, listener: function): Void
 */
EjsObj *http_removeListener(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    ejsRemoveListener(ejs, hp->emitter, argv[0], argv[1]);
    return 0;
}


/*  
    function response(): Stream
 */
static EjsObj *http_response(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    if (hp->responseCache) {
        return hp->responseCache;
    }
    hp->responseCache = http_readString(ejs, hp, argc, argv);
    return (EjsObj*) hp->responseCache;
}


/*  
    function setCredentials(username: String, password: String): Void
 */
static EjsObj *http_setCredentials(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    httpSetCredentials(hp->conn, ejsGetString(ejs, argv[0]), ejsGetString(ejs, argv[1]));
    return 0;
}


/*  
    function setHeader(key: String, value: String, overwrite: Boolean = true): Void
 */
EjsObj *http_setHeader(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    cchar   *key, *value;
    bool    overwrite;

    mprAssert(argc >= 2);

    httpPrepClientConn(hp->conn, HTTP_NEW_REQUEST);

    key = ejsGetString(ejs, argv[0]);
    value = ejsGetString(ejs, argv[1]);
    overwrite = (argc == 3) ? ejsGetBoolean(ejs, argv[2]) : 1;
    if (overwrite) {
        httpSetSimpleHeader(hp->conn, key, value);
    } else {
        httpAppendHeader(hp->conn, key, "%s", value);
    }
    return 0;
}


/*  
    function get timeout(): Number
 */
static EjsObj *http_timeout(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateNumber(ejs, hp->conn->timeout);
}


/*  
    function set timeout(value: Number): Void
 */
static EjsObj *http_set_timeout(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    httpSetTimeout(hp->conn, (int) ejsGetNumber(ejs, argv[0]));
    return 0;
}


/*  
    function trace(uri: String = null, ...data): Void
 */
static EjsObj *http_trace(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    return startHttpRequest(ejs, hp, "TRACE", argc, argv);
}


/*  
    function get uri(): String
 */
static EjsObj *http_uri(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateUri(ejs, hp->uri);
}


/*  
    function set uri(newUri: Uri): Void
 */
static EjsObj *http_set_uri(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    mprFree(hp->uri);
    hp->uri = httpUriToString(hp, ((EjsUri*) argv[0])->uri, 1);
    return 0;
}


/*  
    function get status(): Number
 */
static EjsObj *http_status(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    int     code;

    if (!waitForResponseHeaders(hp, -1)) {
// MOB print("STATUS WAIT RESPONSE FAILED");
        return 0;
    }
    code = httpGetStatus(hp->conn);
    if (code <= 0) {
// MOB print("STATUS CODE %d, state %d", code, hp->conn->state);
        return ejs->nullValue;
    }
    return (EjsObj*) ejsCreateNumber(ejs, code);
}


/*  
    function get statusMessage(): String
 */
static EjsObj *http_statusMessage(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    HttpConn    *conn;

    if (!waitForResponseHeaders(hp, -1)) {
        return 0;
    }
    conn = hp->conn;
    if (conn->errorMsg) {
        return (EjsObj*) ejsCreateString(ejs, conn->errorMsg);
    } else {
        return (EjsObj*) ejsCreateString(ejs, httpGetStatusMessage(hp->conn));
    }
}


/*  
    function wait(timeout: Number = -1): Boolean
    Wait for a request to complete
 */
static EjsObj *http_wait(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    MprTime     mark;
    int         timeout;

    timeout = (argc == 1) ? ejsGetInt(ejs, argv[0]) : hp->conn->timeout;
    if (timeout < 0) {
        timeout = MAXINT;
    }
    mark = mprGetTime(ejs);

    if (!waitForState(hp, HTTP_STATE_COMPLETE, timeout, 0)) {
        return (EjsObj*) ejs->falseValue;
    }
    return (EjsObj*) ejs->trueValue;
}


static EjsObj *http_write(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)
{
    int     nbytes;

    hp->data = ejsCreateByteArray(ejs, -1);
    if (ejsWriteToByteArray(ejs, hp->data, 1, &argv[0]) < 0) {
        return 0;
    }
    if ((nbytes = writeHttpData(ejs, hp)) < 0) {
        return 0;
    }
    hp->writeCount += nbytes;
    if (hp->conn->async) {
        if (ejsGetByteArrayAvailable(hp->data) > 0) {
            httpEnableConnEvents(hp->conn);
        }
    }
    return (EjsObj*) ejsCreateNumber(ejs, nbytes);
}


/*
    function [get|put|delete|post...](uri = null, ...data): Void
 */
static EjsObj *startHttpRequest(Ejs *ejs, EjsHttp *hp, char *method, int argc, EjsObj **argv)
{
    EjsArray        *args;
    EjsByteArray    *data;
    EjsNumber       *written;
    EjsUri          *uriObj;
    HttpConn        *conn;
    int             length, nbytes;

    conn = hp->conn;
    hp->responseCache = 0;
    hp->requestContentCount = 0;
    mprFlushBuf(hp->responseContent);

    if (argc >= 1 && argv[0] != ejs->nullValue) {
        mprFree(hp->uri);
        uriObj = (EjsUri*) argv[0];
        hp->uri = httpUriToString(hp, uriObj->uri, 1);
    }
    if (argc == 2 && ejsIsArray(argv[1])) {
        args = (EjsArray*) argv[1];
        if (args->length > 0) {
            data = ejsCreateByteArray(ejs, -1);
            written = ejsWriteToByteArray(ejs, data, 1, &argv[1]);
            mprPutBlockToBuf(hp->requestContent, (char*) data->value, (int) written->value);
            mprAddNullToBuf(hp->requestContent);
            mprAssert(written > 0);
        }
    }
    if (hp->uri == 0) {
        ejsThrowArgError(ejs, "URL is not defined");
        return 0;
    }
    if (method && strcmp(hp->method, method) != 0) {
        mprFree(hp->method);
        hp->method = mprStrdup(hp, method);
    }
    if (hp->method == 0) {
        ejsThrowArgError(ejs, "HTTP Method is not defined");
        return 0;
    }
    if (httpConnect(conn, hp->method, hp->uri) < 0) {
        ejsThrowIOError(ejs, "Can't issue request for \"%s\"", hp->uri);
        return 0;
    }
    if (mprGetBufLength(hp->requestContent) > 0) {
        nbytes = httpWriteBlock(conn->writeq, mprGetBufStart(hp->requestContent), mprGetBufLength(hp->requestContent),
            conn->async ? 0 : 1); 
        if (nbytes < 0) {
            ejsThrowIOError(ejs, "Can't write request data for \"%s\"", hp->uri);
            return 0;
        } else if (nbytes > 0) {
            mprAdjustBufStart(hp->requestContent, nbytes);
            hp->requestContentCount += nbytes;
        }
    }
    length = hp->conn->transmitter->length;
    ejsSendEvent(ejs, hp->emitter, "writable", (EjsObj*) hp);
    if (conn->async) {
        httpEnableConnEvents(hp->conn);
    }
    return 0;
}


static void httpNotify(HttpConn *conn, int state, int notifyFlags)
{
    Ejs             *ejs;
    EjsHttp         *hp;

    hp = httpGetConnContext(conn);
    ejs = hp->ejs;

    switch (state) {
    case HTTP_STATE_BEGIN:
        break;

    case HTTP_STATE_PARSED:
        if (hp->emitter) {
            ejsSendEvent(ejs, hp->emitter, "headers", (EjsObj*) hp);
        }
        break;

    case HTTP_STATE_CONTENT:
    case HTTP_STATE_PROCESS:
    case HTTP_STATE_RUNNING:
        break;

    case HTTP_STATE_ERROR:
        if (hp->emitter) {
            ejsSendEvent(ejs, hp->emitter, "error", (EjsObj*) hp);
        }
        break;

    case HTTP_STATE_COMPLETE:
        if (hp->emitter) {
            ejsSendEvent(ejs, hp->emitter, "complete", (EjsObj*) hp);
        }
        break;

    case 0:
        if (hp && hp->emitter) {
            if (notifyFlags & HTTP_NOTIFY_READABLE) {
                ejsSendEvent(ejs, hp->emitter, "readable", (EjsObj*) hp);
            } 
            if (notifyFlags & HTTP_NOTIFY_WRITABLE) {
                ejsSendEvent(ejs, hp->emitter, "writable", (EjsObj*) hp);
            }
        }
        break;
    }
}


/*  
    Read the required number of bytes into the response content buffer. Count < 0 means transfer the entire content.
    Returns the number of bytes read.
 */ 
static int readTransfer(Ejs *ejs, EjsHttp *hp, int count)
{
    MprBuf      *buf;
    HttpConn    *conn;
    int         len, space, nbytes;

    conn = hp->conn;

    //  MOB -- does this block in sync mode?
    buf = hp->responseContent;
    while (count < 0 || mprGetBufLength(buf) < count) {
        len = (count < 0) ? HTTP_BUFSIZE : (count - mprGetBufLength(buf));
        space = mprGetBufSpace(buf);
        if (space < len) {
            mprGrowBuf(buf, len - space);
        }
        if ((nbytes = httpRead(conn, mprGetBufEnd(buf), len)) < 0) {
            ejsThrowIOError(ejs, "Can't read required data");
            return MPR_ERR_CANT_READ;
        }
        mprAdjustBufEnd(buf, nbytes);
        if (hp->conn->async || (nbytes == 0 && conn->state >= HTTP_STATE_COMPLETE)) {
            break;
        }
    }
    if (count < 0) {
        return mprGetBufLength(buf);
    }
    return min(count, mprGetBufLength(buf));
}


/* 
    Write another block of write data
 */
static int writeHttpData(Ejs *ejs, EjsHttp *hp)
{
    EjsByteArray    *ba;
    HttpConn        *conn;
    int             count, nbytes;

    conn = hp->conn;
    if (conn->transmitter->finalized) {
        ejsThrowIOError(ejs, "Can't write to socket");
        return 0;
    }
    ba = hp->data;
    nbytes = 0;
    if (ba && (count = ejsGetByteArrayAvailable(ba)) > 0) {
        nbytes = httpWriteBlock(conn->writeq, (cchar*) &ba->value[ba->readPosition], count, 0);
        if (nbytes < 0) {
            ejsThrowIOError(ejs, "Can't write to socket");
            return 0;
        }
        ba->readPosition += nbytes;
    }
    httpServiceQueues(conn);
    return nbytes;
}


/*  
    Respond to an IO event
 */
static int httpCallback(EjsHttp *hp, MprEvent *event)
{
    HttpConn    *conn;
    Ejs         *ejs;

    mprAssert(hp->conn->async);
    conn = hp->conn;
    ejs = hp->ejs;

    //  MOB -- what if this is deleted?
    httpEvent(conn, event);

    if (event->mask & MPR_WRITABLE) {
        if (hp->data) {
            writeHttpData(ejs, hp);
        }
    }
    if (event->mask & MPR_READABLE) {
        if (conn->state >= HTTP_STATE_COMPLETE || 
                (conn->state >= HTTP_STATE_CONTENT && mprGetBufLength(hp->responseContent) > 0)) {
            //  MOB -- remove if notifier works better
            ejsSendEvent(ejs, hp->emitter, "MOBreadable", (EjsObj*) hp);
        }
    } 
    return 0;
}


static EjsObj *getDateHeader(Ejs *ejs, EjsHttp *hp, cchar *key)
{
    MprTime     when;
    cchar       *value;

    if (!waitForResponseHeaders(hp, -1)) {
        return 0;
    }
    value = httpGetHeader(hp->conn, key);
    if (value == 0) {
        return (EjsObj*) ejs->nullValue;
    }
    if (mprParseTime(ejs, &when, value, MPR_UTC_TIMEZONE, NULL) < 0) {
        value = 0;
    }
    return (EjsObj*) ejsCreateDate(ejs, when);
}


static EjsObj *getStringHeader(Ejs *ejs, EjsHttp *hp, cchar *key)
{
    cchar       *value;

    if (!waitForResponseHeaders(hp, -1)) {
        return 0;
    }
    value = httpGetHeader(hp->conn, key);
    if (value == 0) {
        return (EjsObj*) ejs->nullValue;
    }
    return (EjsObj*) ejsCreateString(ejs, value);
}


/*  
    Prepare form data as a series of key-value pairs. Data is formatted according to www-url-encoded specs by 
    mprSetHttpFormData. Objects are flattened into a one level key/value pairs. Keys can have embedded "." separators.
    E.g.  name=value&address=77%20Park%20Lane
 */
static void prepForm(Ejs *ejs, EjsHttp *hp, char *prefix, EjsObj *data)
{
    EjsName     qname;
    EjsObj      *vp;
    EjsString   *value;
    cchar       *key, *sep;
    char        *encodedKey, *encodedValue, *newPrefix, *newKey;
    int         i, count;

    count = ejsGetPropertyCount(ejs, data);
    for (i = 0; i < count; i++) {
        qname = ejsGetPropertyName(ejs, data, i);
        key = qname.name;

        vp = ejsGetProperty(ejs, data, i);
        if (vp == 0) {
            continue;
        }
        if (ejsGetPropertyCount(ejs, vp) > 0) {
            if (prefix) {
                newPrefix = mprAsprintf(hp, -1, "%s.%s", prefix, qname.name);
                prepForm(ejs, hp, newPrefix, vp);
                mprFree(newPrefix);
            } else {
                prepForm(ejs, hp, (char*) qname.name, vp);
            }
        } else {
            value = ejsToString(ejs, vp);
            sep = (mprGetBufLength(hp->requestContent) > 0) ? "&" : "";
            if (prefix) {
                newKey = mprStrcat(hp, -1, prefix, ".", key, NULL);
                encodedKey = mprUriEncode(hp, newKey, MPR_ENCODE_URI_COMPONENT); 
                mprFree(newKey);
            } else {
                encodedKey = mprUriEncode(hp, key, MPR_ENCODE_URI_COMPONENT);
            }
            encodedValue = mprUriEncode(hp, value->value, MPR_ENCODE_URI_COMPONENT);
            mprPutFmtToBuf(hp->requestContent, "%s%s=%s", sep, encodedKey, encodedValue);
            mprFree(encodedKey);
            mprFree(encodedValue);
        }
    }
}


/*  
    Mark the object properties for the garbage collector
 */
void markHttp(Ejs *ejs, EjsHttp *http)
{
    //  MOB -- not needed
    ejsMarkObject(ejs, (EjsObj*) http);

    if (http->responseCache) {
        ejsMark(ejs, (EjsObj*) http->responseCache);
    }
    if (http->emitter) {
        ejsMark(ejs, (EjsObj*) http->emitter);
    }
    if (http->data) {
        ejsMark(ejs, (EjsObj*) http->data);
    }
}


/*  
    Wait for the connection to acheive a requested state
 */
static bool waitForState(EjsHttp *hp, int state, int timeout, int throw)
{
    Ejs             *ejs;
    MprTime         mark;
    HttpConn        *conn;
    HttpUri         *uri;
    char            *url;
    int             count, redirectCount, success, rc;

    mprAssert(state >= HTTP_STATE_PARSED);

    ejs = hp->ejs;
    conn = hp->conn;
    mprAssert(conn->state >= HTTP_STATE_STARTED);

    if  (conn->state >= state) {
        return 1;
    }
    if (conn->state < HTTP_STATE_STARTED) {
        return 0;
    }
    if (timeout < 0) {
        timeout = MAXINT;
    }
    mark = mprGetTime(hp);
    redirectCount = 0;
    success = count = 0;
    httpFinalize(conn);

    while (conn->state < state && count < conn->retries && redirectCount < 16 && !ejs->exiting && !mprIsExiting(conn) && 
            mprGetElapsedTime(hp, mark) < timeout) {
        count++;
        if ((rc = httpWait(conn, HTTP_STATE_PARSED, timeout)) == 0) {
            if (httpNeedRetry(conn, &url)) {
                if (url) {
                    mprFree(hp->uri);
                    uri = httpCreateUri(hp, url, 0);
                    hp->uri = httpUriToString(hp, uri, 1);
                    httpPrepClientConn(conn, HTTP_NEW_REQUEST);
                }
                count--; 
                redirectCount++;
            } else if (httpWait(conn, state, timeout) == 0) {
                success = 1;
                break;
            }
        } else {
            if (rc == MPR_ERR_CONNECTION) {
                httpFormatError(conn, HTTP_CODE_COMMS_ERROR, "Connection error");
            } else if (rc == MPR_ERR_TIMEOUT) {
                httpFormatError(conn, HTTP_CODE_REQUEST_TIME_OUT, "Request timed out");
            } else {
                httpFormatError(conn, HTTP_CODE_CLIENT_ERROR, "Client request error");
            }
            break;
        }
        if (conn->status == HTTP_CODE_REQUEST_TOO_LARGE || conn->status == HTTP_CODE_REQUEST_URL_TOO_LARGE) {
            /* No point retrying */
            break;
        }
        if (hp->writeCount > 0) {
            /* Can't auto-retry with manual writes */
            break;
        }
        if (hp->requestContentCount > 0) {
            mprAdjustBufStart(hp->requestContent, -hp->requestContentCount);
        }
        /* Force a new connection */
        if (conn->receiver == 0 || conn->receiver->status != HTTP_CODE_UNAUTHORIZED) {
            httpSetKeepAliveCount(conn, -1);
        }
        httpPrepClientConn(conn, HTTP_RETRY_REQUEST);
        if (startHttpRequest(ejs, hp, NULL, 0, NULL) < 0) {
            return 0;
        }
        httpFinalize(conn);
    }
    if (!success) {
        if (throw && ejs->exception == 0) {
            ejsThrowIOError(ejs, "Http request failed: %s", (conn->errorMsg) ? conn->errorMsg : "");
        }
        return 0;
    }
    return 1;
}


/*  
    Wait till the response headers have been received. Safe in sync and async mode. Async mode never blocks.
 */
static bool waitForResponseHeaders(EjsHttp *hp, int timeout)
{
    mprAssert(hp->conn->state >= HTTP_STATE_STARTED);

    if (hp->conn->async) {
        timeout = 0;
    }
    if (timeout < 0) {
        timeout = hp->conn->timeout;
    }
    if (hp->conn->state < HTTP_STATE_STARTED) {
// MOB print("WFR state %d, return zero", hp->conn->state);
        return 0;
    }
    if (hp->conn->state < HTTP_STATE_PARSED && !waitForState(hp, HTTP_STATE_PARSED, timeout, 1)) {
// MOB print("WFR2 state %d, return zero", hp->conn->state);
        return 0;
    }
    return 1;
}


/*
    Need a destructor because the connection object is owned by ejs->http and won't be automatically freed.
 */
static void destroyHttp(Ejs *ejs, EjsHttp *hp)
{
    mprAssert(hp);

    mprFree(hp->conn);
    hp->conn = 0;
    ejsFree(ejs, (EjsObj*) hp, -1);
}



void ejsConfigureHttpType(Ejs *ejs)
{
    EjsType     *type;

    type = ejsConfigureNativeType(ejs, EJS_EJS_NAMESPACE, "Http", sizeof(EjsHttp));
    type->needFinalize = 1;

    type->helpers = ejsCloneObjectHelpers(ejs, "http-helpers");
    type->helpers->mark = (EjsMarkHelper) markHttp;
    type->helpers->destroy = (EjsDestroyHelper) destroyHttp;

    ejsBindMethod(ejs, type, ES_Http_Http, (EjsProc) httpConstructor);
    ejsBindMethod(ejs, type, ES_Http_addListener, (EjsProc) http_addListener);
    ejsBindAccess(ejs, type, ES_Http_async, (EjsProc) http_async, (EjsProc) http_set_async);
    ejsBindMethod(ejs, type, ES_Http_available, (EjsProc) http_available);
    ejsBindAccess(ejs, type, ES_Http_chunkSize, (EjsProc) http_chunkSize, (EjsProc) http_set_chunkSize);
    ejsBindMethod(ejs, type, ES_Http_close, (EjsProc) http_close);
    ejsBindMethod(ejs, type, ES_Http_connect, (EjsProc) http_connect);
    ejsBindAccess(ejs, type, ES_Http_certificate, (EjsProc) http_certificate, (EjsProc) http_set_certificate);
    ejsBindMethod(ejs, type, ES_Http_contentLength, (EjsProc) http_contentLength);
    ejsBindMethod(ejs, type, ES_Http_contentType, (EjsProc) http_contentType);
    ejsBindMethod(ejs, type, ES_Http_date, (EjsProc) http_date);
    ejsBindMethod(ejs, type, ES_Http_del, (EjsProc) http_del);
    ejsBindMethod(ejs, type, ES_Http_expires, (EjsProc) http_expires);
    ejsBindMethod(ejs, type, ES_Http_finalize, (EjsProc) http_finalize);
    ejsBindAccess(ejs, type, ES_Http_followRedirects, (EjsProc) http_followRedirects, 
        (EjsProc) http_set_followRedirects);
    ejsBindMethod(ejs, type, ES_Http_form, (EjsProc) http_form);
    ejsBindMethod(ejs, type, ES_Http_get, (EjsProc) http_get);
    ejsBindMethod(ejs, type, ES_Http_getRequestHeaders, (EjsProc) http_getRequestHeaders);
    ejsBindMethod(ejs, type, ES_Http_head, (EjsProc) http_head);
    ejsBindMethod(ejs, type, ES_Http_header, (EjsProc) http_header);
    ejsBindMethod(ejs, type, ES_Http_headers, (EjsProc) http_headers);
    ejsBindMethod(ejs, type, ES_Http_isSecure, (EjsProc) http_isSecure);
    ejsBindAccess(ejs, type, ES_Http_key, (EjsProc) http_key, (EjsProc) http_set_key);
    ejsBindMethod(ejs, type, ES_Http_lastModified, (EjsProc) http_lastModified);
    ejsBindAccess(ejs, type, ES_Http_method, (EjsProc) http_method, (EjsProc) http_set_method);
    ejsBindMethod(ejs, type, ES_Http_post, (EjsProc) http_post);
    ejsBindMethod(ejs, type, ES_Http_put, (EjsProc) http_put);
    ejsBindMethod(ejs, type, ES_Http_read, (EjsProc) http_read);
    ejsBindMethod(ejs, type, ES_Http_readString, (EjsProc) http_readString);
    ejsBindMethod(ejs, type, ES_Http_removeListener, (EjsProc) http_removeListener);
    ejsBindMethod(ejs, type, ES_Http_response, (EjsProc) http_response);
    ejsBindMethod(ejs, type, ES_Http_options, (EjsProc) http_options);
    ejsBindMethod(ejs, type, ES_Http_setCredentials, (EjsProc) http_setCredentials);
    ejsBindMethod(ejs, type, ES_Http_setHeader, (EjsProc) http_setHeader);
    ejsBindMethod(ejs, type, ES_Http_status, (EjsProc) http_status);
    ejsBindMethod(ejs, type, ES_Http_statusMessage, (EjsProc) http_statusMessage);
    ejsBindAccess(ejs, type, ES_Http_timeout, (EjsProc) http_timeout, (EjsProc) http_set_timeout);
    ejsBindMethod(ejs, type, ES_Http_trace, (EjsProc) http_trace);
    ejsBindAccess(ejs, type, ES_Http_uri, (EjsProc) http_uri, (EjsProc) http_set_uri);
    ejsBindMethod(ejs, type, ES_Http_write, (EjsProc) http_write);
    ejsBindMethod(ejs, type, ES_Http_wait, (EjsProc) http_wait);
}

/*
    @copy   default
  
    Copyright (c) Embedthis Software LLC, 2003-2010. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2010. All Rights Reserved.
  
    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.
  
    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html
  
    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
  
    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com
  
    @end
 */
/************************************************************************/
/*
 *  End of file "../src/core/src/ejsHttp.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../src/core/src/ejsIterator.c"
 */
/************************************************************************/

/**
    ejsIterator.c - Iterator class

    This provides a high performance iterator construction for native classes.

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */




static void markIteratorVar(Ejs *ejs, EjsIterator *ip)
{
    /* MOB - not used or needed */
    ejsMarkObject(ejs, (EjsObj*) ip);

    if (ip->target) {
        ejsMark(ejs, ip->target);
    }
    if (ip->namespaces) {
        ejsMark(ejs, (EjsObj*) ip->namespaces);
    }
    if (ip->indexVar) {
        ejsMark(ejs, ip->indexVar);
    }
}


/*
    Call the supplied next() function to return the next enumerable item
 */
static EjsObj *nextIterator(Ejs *ejs, EjsIterator *ip, int argc, EjsObj **argv)
{
    if (ip->nativeNext) {
        return (ip->nativeNext)(ejs, (EjsObj*) ip, argc, argv);
    } else {
        ejsThrowStopIteration(ejs);
        return 0;
    }
}


EjsObj *ejsThrowStopIteration(Ejs *ejs)
{
#if FUTURE
    ejs->exception = (EjsObj*) ejs->iterator;
#else
    ejs->exception = (EjsObj*) ejs->stopIterationType;
#endif
    ejsAttention(ejs);
    return 0;
}


#if KEEP
/*
    Constructor to create an iterator using a scripted next().

    public function Iterator(obj, f, deep, ...namespaces)
 */
static EjsObj *iteratorConstructor(Ejs *ejs, EjsIterator *ip, int argc, EjsObj **argv)
{
    if (argc != 2 || !ejsIsFunction(argv[1])) {
        ejsThrowArgError(ejs, "usage: Iterator(obj, function)");
        return 0;
    }
    ip->target = argv[0];
    ip->next = (EjsFunction*) argv[1];
    mprAssert(ip->nativeNext == 0);

    return (EjsObj*) ip;
}
#endif


/*
    Create an iterator.
 */
EjsIterator *ejsCreateIterator(Ejs *ejs, EjsObj *obj, EjsProc nativeNext, bool deep, EjsArray *namespaces)
{
    EjsIterator     *ip;

    ip = (EjsIterator*) ejsCreate(ejs, ejs->iteratorType, 0);
    if (ip) {
        ip->index = 0;
        ip->indexVar = 0;
        ip->nativeNext = nativeNext;
        ip->target = obj;
        ip->deep = deep;
        ip->namespaces = namespaces;
        ejsSetDebugName(ip, "iterator");
    }
    return ip;
}


/*
    Create the Iterator and StopIteration types
 */
void ejsCreateIteratorType(Ejs *ejs)
{
    EjsType     *type;

    type = ejs->iteratorType = ejsCreateNativeType(ejs, EJS_ITERATOR_NAMESPACE, "Iterator", 
        ES_Iterator, sizeof(EjsIterator));
    ejs->iterator = (EjsIterator*) ejsCreate(ejs, type, 0);

    type->helpers->mark  = (EjsMarkHelper) markIteratorVar;

    type = ejs->stopIterationType = ejsCreateNativeType(ejs, EJS_ITERATOR_NAMESPACE, "StopIteration", 
        ES_StopIteration, sizeof(EjsObj));
}


void ejsConfigureIteratorType(Ejs *ejs)
{
    EjsType     *type;

    type = ejsGetTypeByName(ejs, EJS_ITERATOR_NAMESPACE, "Iterator");
    ejsBindMethod(ejs, ejs->iteratorType, ES_Iterator_next, (EjsProc) nextIterator);
}


/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2010. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2010. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    @end
 */
/************************************************************************/
/*
 *  End of file "../src/core/src/ejsIterator.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../src/core/src/ejsJSON.c"
 */
/************************************************************************/

/**
    ejsJSON.c - JSON encoding and decoding

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */




typedef struct JsonState {
    char    *data;
    char    *end;
    char    *next;
    char    *error;
} JsonState;


static EjsObj *parseLiteral(Ejs *ejs, JsonState *js);
static EjsObj *parseLiteralInner(Ejs *ejs, MprBuf *buf, JsonState *js);

/*
    Convert a string into an object.
    function deserialize(obj: String, options: Object): Object
 */
EjsObj *deserialize(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    mprAssert(argc >=1 && ejsIsString(argv[0]));
    return ejsDeserialize(ejs, (EjsString*) argv[0]);
}


EjsObj *ejsDeserialize(Ejs *ejs, EjsString *str)
{
    EjsObj      *obj;
    JsonState   js;
    cchar       *data;

    if (!ejsIsString(str)) {
        return 0;
    }
    data = ejsGetString(ejs, str);
    if (data == 0) {
        return 0;
    } else if (*data == '\0') {
        return (EjsObj*) ejs->emptyStringValue;
    }

    //  MOB -- check that js.data never modifies this
    js.next = js.data = (char*) data;
    js.end = &js.data[str->length];
    js.error = 0;
    if ((obj = parseLiteral(ejs, &js)) == 0) {
        if (js.error) {
            ejsThrowSyntaxError(ejs, 
                "Can't parse object literal. Error at position %d.\n"
                "===========================\n"
                "Offending text: %s\n"
                "===========================\n"
                "In literal %s"
                "\n===========================\n",
                (int) (js.error - js.data), js.error, js.data);
        } else {
            ejsThrowSyntaxError(ejs, "Can't parse object literal. Undefined error");
        }
        return 0;
    }
    return obj;
}


static EjsObj *parseLiteral(Ejs *ejs, JsonState *js)
{
    MprBuf      *buf;
    EjsObj      *vp;

    mprAssert(js);

    buf = mprCreateBuf(ejs, 0, 0);
    vp = parseLiteralInner(ejs, buf, js);
    mprFree(buf);
    return vp;
}


typedef enum Token {
    TOK_ERR,            /* Error */
    TOK_EOF,            /* End of input */
    TOK_LBRACE,         /* { */
    TOK_LBRACKET,       /* [ */
    TOK_RBRACE,         /* } */
    TOK_RBRACKET,       /* ] */
    TOK_COLON,          /* : */
    TOK_COMMA,          /* , */
    TOK_ID,             /* Unquoted ID */
    TOK_QID,            /* Quoted ID */
} Token;


static uchar *skipComments(uchar *cp, uchar *end)
{
    int     inComment;

    for (; cp < end && isspace((int) *cp); cp++) {}

    while (cp < &end[-1]) {
        if (cp < &end[-1] && *cp == '/' && cp[1] == '*') {
            inComment = 1;
            for (cp += 2; cp < &end[-1]; cp++) {
                if (*cp == '*' && cp[1] == '/') {
                    inComment = 0;
                    cp += 2;
                    break;
                }
            }
            if (inComment) {
                return 0;
            }
            while (cp < end && isspace((int) *cp)) cp++;

        } else  if (cp < &end[-1] && *cp == '/' && cp[1] == '/') {
            inComment = 1;
            for (cp += 2; cp < end; cp++) {
                if (*cp == '\n') {
                    inComment = 0;
                    cp++;
                    break;
                }
            }
            if (inComment) {
                return 0;
            }
            while (cp < end && isspace((int) *cp)) cp++;

        } else {
            break;
        }
    }
    return cp;
}


Token getNextJsonToken(MprBuf *buf, char **token, JsonState *js)
{
    uchar   *start, *cp, *end, *next;
    char    *src, *dest;
    int     quote, tid, c;

    //  MOB -- buf is always set?
    if (buf) {
        mprFlushBuf(buf);
    }
    cp = (uchar*) js->next;
    end = (uchar*) js->end;
    cp = skipComments(cp, end);
    next = cp + 1;
    quote = -1;

    if (*cp == '\0') {
        tid = TOK_EOF;

    } else  if (*cp == '{') {
        tid = TOK_LBRACE;

    } else if (*cp == '[') {
        tid = TOK_LBRACKET;

    } else if (*cp == '}' || *cp == ']') {
        tid = *cp == '}' ? TOK_RBRACE: TOK_RBRACKET;
        while (*++cp && isspace((int) *cp)) ;
        if (*cp == ',' || *cp == ':') {
            cp++;
        }
        next = cp;

    } else {
        if (*cp == '"' || *cp == '\'') {
            tid = TOK_QID;
            quote = *cp++;
            for (start = cp; cp < end; cp++) {
                if (*cp == '\\') {
                    if (cp[1] == quote) {
                        cp++;
                    }
                    continue;
                }
                if (*cp == quote) {
                    break;
                }
            }
            if (*cp != quote) {
                js->error = (char*) cp;
                return TOK_ERR;
            }
            if (buf) {
                mprPutBlockToBuf(buf, (char*) start, cp - start);
            }
            cp++;

        } else if (*cp == '/') {
            tid = TOK_ID;
            for (start = cp++; cp < end; cp++) {
                if (*cp == '\\') {
                    if (cp[1] == '/') {
                        cp++;
                    }
                    continue;
                }
                if (*cp == '/') {
                    break;
                }
            }
            if (*cp != '/') {
                js->error = (char*) cp;
                return TOK_ERR;
            }
            if (buf) {
                mprPutBlockToBuf(buf, (char*) start, cp - start);
            }
            
            cp++;

        } else {
            tid = TOK_ID;
            for (start = cp; cp < end; cp++) {
                if (*cp == '\\') {
                    continue;
                }
                /* Not an allowable character outside quotes */
                if (!(isalnum((int) *cp) || *cp == '_' || *cp == ' ' || *cp == '-' || *cp == '+' || *cp == '.')) {
                    break;
                }
            }
            if (buf) {
                mprPutBlockToBuf(buf, (char*) start, cp - start);
            }
        }
        if (buf) {
            mprAddNullToBuf(buf);
        }
        if (*cp == ',' || *cp == ':') {
            cp++;
        } else if (*cp != '}' && *cp != ']' && *cp != '\0' && *cp != '\n' && *cp != '\r' && *cp != ' ') {
            js->error = (char*) cp;
            return TOK_ERR;
        }
        next = cp;

        if (buf) {
            for (dest = src = buf->start; src < buf->end; ) {
                c = *src++;
                if (c == '\\') {
                    c = *src++;
                    if (c == 'r') {
                        c = '\r';
                    } else if (c == 'n') {
                        c = '\n';
                    } else if (c == 'b') {
                        c = '\b';
                    }
                }
                *dest++ = c;
            }
            *dest = '\0';
            *token = mprGetBufStart(buf);
        }
    }
    js->next = (char*) next;
    return tid;
}


Token peekNextJsonToken(JsonState *js)
{
    JsonState   discard = *js;
    return getNextJsonToken(NULL, NULL, &discard);
}


/*
    Parse an object literal string pointed to by js->next into the given buffer. Update js->next to point
    to the next input token in the object literal. Supports nested object literals.
 */
static EjsObj *parseLiteralInner(Ejs *ejs, MprBuf *buf, JsonState *js)
{
    EjsName     qname;
    EjsObj      *obj, *vp;
    MprBuf      *valueBuf;
    char        *token, *key, *value;
    int         tid, isArray;

    isArray = 0;

    tid = getNextJsonToken(buf, &token, js);
    if (tid == TOK_ERR || tid == TOK_EOF) {
        return 0;
    }
    if (tid == TOK_LBRACKET) {
        isArray = 1;
        obj = (EjsObj*) ejsCreateArray(ejs, 0);
    } else if (tid == TOK_LBRACE) {
        obj = (EjsObj*) ejsCreateSimpleObject(ejs);
    } else {
        return ejsParse(ejs, token, ES_String);
    }
    if (obj == 0) {
        ejsThrowMemoryError(ejs);
        return 0;
    }

    while (1) {
        vp = 0;
        tid = peekNextJsonToken(js);
        if (tid == TOK_ERR) {
            return 0;
        } else if (tid == TOK_EOF) {
            break;
        } else if (tid == TOK_RBRACE || tid == TOK_RBRACKET) {
            getNextJsonToken(buf, &key, js);
            break;
        }
        if (tid == TOK_LBRACKET) {
            /* For array values */
            vp = parseLiteral(ejs, js);
            mprAssert(vp);
            
        } else if (tid == TOK_LBRACE) {
            /* For object values */
            vp = parseLiteral(ejs, js);
            mprAssert(vp);
            
        } else if (isArray) {
            tid = getNextJsonToken(buf, &value, js);
            vp = ejsParse(ejs, value, (tid == TOK_QID) ? ES_String: -1);
            mprAssert(vp);
            
        } else {
            getNextJsonToken(buf, &key, js);
            tid = peekNextJsonToken(js);
            if (tid == TOK_ERR) {
                return 0;
            } else if (tid == TOK_EOF) {
                break;
            } else if (tid == TOK_LBRACE || tid == TOK_LBRACKET) {
                vp = parseLiteral(ejs, js);

            } else if (tid == TOK_ID || tid == TOK_QID) {
                valueBuf = mprCreateBuf(ejs, 0, 0);
                getNextJsonToken(valueBuf, &value, js);
                if (tid == TOK_QID) {
                    vp = (EjsObj*) ejsCreateString(ejs, value);
                } else {
                    if (strcmp(value, "null") == 0) {
                        vp = ejs->nullValue;
                    } else if (strcmp(value, "undefined") == 0) {
                        vp = ejs->undefinedValue;
                    } else {
                        vp = ejsParse(ejs, value, -1);
                    }
                }
                mprAssert(vp);
                mprFree(valueBuf);
            } else {
                getNextJsonToken(buf, &value, js);
                js->error = js->next;
                return 0;
            }
        }
        if (vp == 0) {
            js->error = js->next;
            return 0;
        }
        if (isArray) {
            if (ejsSetProperty(ejs, obj, -1, vp) < 0) {
                ejsThrowMemoryError(ejs);
                return 0;
            }
        } else {
            key = mprStrdup(obj, key);
            ejsName(&qname, EJS_EMPTY_NAMESPACE, key);
            if (ejsSetPropertyByName(ejs, obj, &qname, vp) < 0) {
                ejsThrowMemoryError(ejs);
                return 0;
            }
        }
    }
    return obj;
}


/*
    Global function to convert the object to a source code string in JSON format. This is the actual work-horse.
  
    intrinsic function serialize(obj: Object, options: Object = null)
 */
static EjsObj *serialize(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsToJSON(ejs, argv[0], (argc == 2) ? argv[1] : NULL);
}


void ejsConfigureJSONType(Ejs *ejs)
{
    EjsBlock    *block;

    block = ejs->globalBlock;
    mprAssert(block);

    ejsBindFunction(ejs, block, ES_deserialize, deserialize);
    ejsBindFunction(ejs, block, ES_serialize, serialize);
}


/*
    @copy   default
 
    Copyright (c) Embedthis Software LLC, 2003-2010. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2010. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com
 */
/************************************************************************/
/*
 *  End of file "../src/core/src/ejsJSON.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../src/core/src/ejsMath.c"
 */
/************************************************************************/

/**
    ejsMath.c - Math type class

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */


#include     <math.h>


#define fixed(n) ((int64) (floor(n)))

/*
    function abs(value: Number): Number
 */
static EjsObj *math_abs(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    //  TODO - can a null slip through?
    return (EjsObj*) ejsCreateNumber(ejs, (MprNumber) fabs(ejsGetNumber(ejs, argv[0])));
}


/*
    function acos(value: Number): Number
 */
static EjsObj *math_acos(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    MprNumber   value;
    
    value = ejsGetNumber(ejs, argv[0]);
    return (EjsObj*) ejsCreateNumber(ejs, (MprNumber) acos(ejsGetNumber(ejs, argv[0])));
}


/*
    function asin(value: Number): Number
 */
static EjsObj *math_asin(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateNumber(ejs, (MprNumber) asin(ejsGetNumber(ejs, argv[0])));
}


/*
    function atan(value: Number): Number
 */
static EjsObj *math_atan(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateNumber(ejs, (MprNumber) atan(ejsGetNumber(ejs, argv[0])));
}


/*
    function atan2(x: Number, y: Number): Number
 */
static EjsObj *math_atan2(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateNumber(ejs, (MprNumber) atan2(ejsGetNumber(ejs, argv[0]), ejsGetNumber(ejs, argv[1])));
}


/*
    function ceil(value: Number): Number
 */
static EjsObj *math_ceil(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateNumber(ejs, (MprNumber) ceil(ejsGetNumber(ejs, argv[0])));
}


/*
    function cos(value: Number): Number
 */
static EjsObj *math_cos(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateNumber(ejs, (MprNumber) cos(ejsGetNumber(ejs, argv[0])));
}


/*
    function exp(value: Number): Number
 */
static EjsObj *math_exp(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateNumber(ejs, (MprNumber) exp(ejsGetNumber(ejs, argv[0])));
}


/*
    function floor(value: Number): Number
 */
static EjsObj *math_floor(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateNumber(ejs, (MprNumber) floor(ejsGetNumber(ejs, argv[0])));
}


/*
    function log10(value: Number): Number
 */
static EjsObj *math_log10(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateNumber(ejs, (MprNumber) log10(ejsGetNumber(ejs, argv[0])));
}


/*
    function log(value: Number): Number
 */
static EjsObj *math_log(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateNumber(ejs, (MprNumber) log(ejsGetNumber(ejs, argv[0])));
}


/*
    function max(x: Number, y: Number): Number
 */
static EjsObj *math_max(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    MprNumber   x, y;
    
    x = ejsGetNumber(ejs, argv[0]);
    y = ejsGetNumber(ejs, argv[1]);
    if (x > y) {
        return argv[0];
    }
    return argv[1];
}


/*
    function min(value: Number): Number
 */
static EjsObj *math_min(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    MprNumber   x, y;
    
    x = ejsGetNumber(ejs, argv[0]);
    y = ejsGetNumber(ejs, argv[1]);
    if (x < y) {
        return argv[0];
    }
    return argv[1];
}


/*
    function pow(x: Number, y: Number): Number
 */
static EjsObj *math_pow(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    MprNumber   x, y;
    
    x = ejsGetNumber(ejs, argv[0]);
    y = ejsGetNumber(ejs, argv[1]);
    return (EjsObj*) ejsCreateNumber(ejs, (MprNumber) pow(x,y));
}


/*
    function random(value: Number): Number
 */
static EjsObj *math_random(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    MprNumber   value;
    uint        uvalue;
    static int  initialized = 0;
    
    if (!initialized) {
#if WIN
        uint seed = (uint) time(0);
        srand(seed);
#elif !MACOSX && !VXWORKS
        srandom(time(0));
#endif
        initialized = 1;
    }
    
#if WIN
{
    errno_t rand_s(uint *value);
    rand_s(&uvalue);
}
#elif LINUX
    uvalue = random();
#elif MACOSX
    uvalue = arc4random();
#else
{
    int64   data[16];
    int     i;
    mprGetRandomBytes(ejs, (char*) data, sizeof(data), 0);
    uvalue = 0;
    for (i = 0; i < sizeof(data) / sizeof(int64); i++) {
        uvalue += data[i];
    }
}
#endif
    value = ((MprNumber) (uvalue & 0x7FFFFFFF)) / INT_MAX;
    return (EjsObj*) ejsCreateNumber(ejs, value);
}


/*
    function round(value: Number): Number
 */
static EjsObj *math_round(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    MprNumber   n;

    n = ejsGetNumber(ejs, argv[0]);
    if (-0.5 <= n && n < 0) {
        n = -0.0;
    } else {
        n += 0.5;
    }
    return (EjsObj*) ejsCreateNumber(ejs, floor(n));
}


/*
    function sin(value: Number): Number
 */
static EjsObj *math_sin(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateNumber(ejs, (MprNumber) sin(ejsGetNumber(ejs, argv[0])));
}


/*
    function sqrt(value: Number): Number
 */
static EjsObj *math_sqrt(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateNumber(ejs, (MprNumber) sqrt(ejsGetNumber(ejs, argv[0])));
}


/*
    function tan(value: Number): Number
 */
static EjsObj *math_tan(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateNumber(ejs, (MprNumber) tan(ejsGetNumber(ejs, argv[0])));
}



void ejsConfigureMathType(Ejs *ejs)
{
    EjsType     *type;

    type = ejs->mathType = ejsConfigureNativeType(ejs, "ejs", "Math", sizeof(EjsObj));

    ejsBindMethod(ejs, type, ES_Math_abs, (EjsProc) math_abs);
    ejsBindMethod(ejs, type, ES_Math_acos, (EjsProc) math_acos);
    ejsBindMethod(ejs, type, ES_Math_asin, (EjsProc) math_asin);
    ejsBindMethod(ejs, type, ES_Math_atan, (EjsProc) math_atan);
    ejsBindMethod(ejs, type, ES_Math_atan2, (EjsProc) math_atan2);
    ejsBindMethod(ejs, type, ES_Math_ceil, (EjsProc) math_ceil);
    ejsBindMethod(ejs, type, ES_Math_cos, (EjsProc) math_cos);
    ejsBindMethod(ejs, type, ES_Math_exp, (EjsProc) math_exp);
    ejsBindMethod(ejs, type, ES_Math_floor, (EjsProc) math_floor);
    ejsBindMethod(ejs, type, ES_Math_log, (EjsProc) math_log);
    ejsBindMethod(ejs, type, ES_Math_log10, (EjsProc) math_log10);
    ejsBindMethod(ejs, type, ES_Math_max, (EjsProc) math_max);
    ejsBindMethod(ejs, type, ES_Math_min, (EjsProc) math_min);
    ejsBindMethod(ejs, type, ES_Math_pow, (EjsProc) math_pow);
    ejsBindMethod(ejs, type, ES_Math_random, (EjsProc) math_random);
    ejsBindMethod(ejs, type, ES_Math_round, (EjsProc) math_round);
    ejsBindMethod(ejs, type, ES_Math_sin, (EjsProc) math_sin);
    ejsBindMethod(ejs, type, ES_Math_sqrt, (EjsProc) math_sqrt);
    ejsBindMethod(ejs, type, ES_Math_tan, (EjsProc) math_tan);
}


/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2010. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2010. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    @end
 */
/************************************************************************/
/*
 *  End of file "../src/core/src/ejsMath.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../src/core/src/ejsMemory.c"
 */
/************************************************************************/

/*
    ejsMemory.c - Memory class

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */


/*
    native static function get allocated(): Number
 */
static EjsObj *getAllocatedMemory(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv)
{
    MprAlloc    *alloc;

    alloc = mprGetAllocStats(ejs);
    return (EjsObj*) ejsCreateNumber(ejs, (int) alloc->bytesAllocated);
}


/*
    native static function callback(fn: Function): Void
 */
static EjsObj *setRedlineCallback(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv)
{
    mprAssert(argc == 1 && ejsIsFunction(argv[0]));

    if (!ejsIsFunction(argv[0])) {
        ejsThrowArgError(ejs, "Callaback is not a function");
        return 0;
    }
    ejs->memoryCallback = (EjsFunction*) argv[0];
    return 0;
}


/*
    native static function get maximum(): Number
 */
static EjsObj *getMaxMemory(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv)
{
    MprAlloc    *alloc;

    alloc = mprGetAllocStats(ejs);
    return (EjsObj*) ejsCreateNumber(ejs, (int) alloc->maxMemory);
}


/*
    native static function set maximum(limit: Number): Void
 */
static EjsObj *setMaxMemory(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv)
{
    int     maxMemory;

    mprAssert(argc == 1 && ejsIsNumber(argv[0]));

    maxMemory = ejsGetInt(ejs, argv[0]);
    mprSetAllocLimits(ejs, -1, maxMemory);
    return 0;
}


/*
    native static function get peak(): Number
 */
static EjsObj *getPeakMemory(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv)
{
    MprAlloc    *alloc;

    alloc = mprGetAllocStats(ejs);
    return (EjsObj*) ejsCreateNumber(ejs, (int) alloc->peakAllocated);
}


/*
    native static function get redline(): Number
 */
static EjsObj *getRedline(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv)
{
    MprAlloc    *alloc;

    alloc = mprGetAllocStats(ejs);
    return (EjsObj*) ejsCreateNumber(ejs, (int) alloc->redLine);
}


/*
    native static function set redline(limit: Number): Void
 */
static EjsObj *setRedline(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv)
{
    int     redline;

    mprAssert(argc == 1 && ejsIsNumber(argv[0]));

    redline = ejsGetInt(ejs, argv[0]);
    if (redline <= 0) {
        //  TODO - 64 bit
        redline = INT_MAX;
    }
    mprSetAllocLimits(ejs, redline, -1);
    return 0;
}


/*
    native static function get resident(): Number
 */
static EjsObj *getResident(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv)
{
    MprAlloc    *alloc;

    alloc = mprGetAllocStats(ejs);
    return (EjsObj*) ejsCreateNumber(ejs, (int) alloc->rss);
}


/*
    native static function get stack(): Number
 */
static EjsObj *getStack(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv)
{
    MprAlloc    *alloc;

    alloc = mprGetAllocStats(ejs);
    return (EjsObj*) ejsCreateNumber(ejs, (int) alloc->peakStack);
}


/*
    native static function get system(): Number
 */
static EjsObj *getSystemRam(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv)
{
    MprAlloc    *alloc;

    alloc = mprGetAllocStats(ejs);
    return (EjsObj*) ejsCreateNumber(ejs, (double) alloc->ram);
}


/*
    native static function stats(): Void
 */
static EjsObj *printStats(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv)
{
    //  TODO - should go to log file and not to stdout
    ejsPrintAllocReport(ejs);
    mprPrintAllocReport(ejs, "Memory Report");
    return 0;
}



void ejsConfigureMemoryType(Ejs *ejs)
{
    EjsType         *type;

    if ((type = ejsGetTypeByName(ejs, EJS_EJS_NAMESPACE, "Memory")) == 0) {
        mprError(ejs, "Can't find Memory type");
        return;
    }
    ejsBindMethod(ejs, type, ES_Memory_allocated, (EjsProc) getAllocatedMemory);
    ejsBindAccess(ejs, type, ES_Memory_callback, NULL, (EjsProc) setRedlineCallback);
    ejsBindAccess(ejs, type, ES_Memory_maximum, (EjsProc) getMaxMemory, (EjsProc) setMaxMemory);
    ejsBindMethod(ejs, type, ES_Memory_peak, (EjsProc) getPeakMemory);
    ejsBindAccess(ejs, type, ES_Memory_redline, (EjsProc) getRedline, (EjsProc) setRedline);
    ejsBindMethod(ejs, type, ES_Memory_resident, (EjsProc) getResident);
    ejsBindMethod(ejs, type, ES_Memory_stack, (EjsProc) getStack);
    ejsBindMethod(ejs, type, ES_Memory_system, (EjsProc) getSystemRam);
    ejsBindMethod(ejs, type, ES_Memory_stats, (EjsProc) printStats);
}

/*
    @copy   default
    
    Copyright (c) Embedthis Software LLC, 2003-2010. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2010. All Rights Reserved.
    
    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire 
    a commercial license from Embedthis Software. You agree to be fully bound 
    by the terms of either license. Consult the LICENSE.TXT distributed with 
    this software for full details.
    
    This software is open source; you can redistribute it and/or modify it 
    under the terms of the GNU General Public License as published by the 
    Free Software Foundation; either version 2 of the License, or (at your 
    option) any later version. See the GNU General Public License for more 
    details at: http://www.embedthis.com/downloads/gplLicense.html
    
    This program is distributed WITHOUT ANY WARRANTY; without even the 
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
    
    This GPL license does NOT permit incorporating this software into 
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses 
    for this software and support services are available from Embedthis 
    Software at http://www.embedthis.com 
    
    @end
 */
/************************************************************************/
/*
 *  End of file "../src/core/src/ejsMemory.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../src/core/src/ejsNamespace.c"
 */
/************************************************************************/

/**
    ejsNamespace.c - Ejscript Namespace class

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */



/*
    Cast the operand to the specified type
 */

static EjsObj *castNamespace(Ejs *ejs, EjsNamespace *vp, EjsType *type)
{
    switch (type->id) {
    case ES_Boolean:
        return (EjsObj*) ejsCreateBoolean(ejs, 1);

    case ES_String:
        return (EjsObj*) ejsCreateString(ejs, "[object Namespace]");

    default:
        ejsThrowTypeError(ejs, "Can't cast to this type");
        return 0;
    }
}


static EjsObj *invokeNamespaceOperator(Ejs *ejs, EjsNamespace *lhs, int opCode, EjsNamespace *rhs)
{
    bool        boolResult;

    switch (opCode) {
    case EJS_OP_COMPARE_EQ:
        if ((EjsObj*) rhs == ejs->nullValue || (EjsObj*) rhs == ejs->undefinedValue) {
            return (EjsObj*) ((opCode == EJS_OP_COMPARE_EQ) ? ejs->falseValue: ejs->trueValue);
        }
        boolResult = (strcmp(lhs->name, rhs->name) == 0 && strcmp(lhs->uri, rhs->uri) == 0);
        break;

    case EJS_OP_COMPARE_STRICTLY_EQ:
        boolResult = lhs == rhs;
        break;

    case EJS_OP_COMPARE_NE:
        if ((EjsObj*) rhs == ejs->nullValue || (EjsObj*) rhs == ejs->undefinedValue) {
            return (EjsObj*) ((opCode == EJS_OP_COMPARE_EQ) ? ejs->falseValue: ejs->trueValue);
        }
        boolResult = ! (strcmp(lhs->name, rhs->name) == 0 && strcmp(lhs->uri, rhs->uri) == 0);
        break;

    case EJS_OP_COMPARE_STRICTLY_NE:
        boolResult = !(lhs == rhs);
        break;

    default:
        ejsThrowTypeError(ejs, "Operation is not valid on this type");
        return 0;
    }
    return (EjsObj*) ejsCreateBoolean(ejs, boolResult);
}


/*
    Define a reserved namespace in a block.
 */
EjsNamespace *ejsDefineReservedNamespace(Ejs *ejs, EjsBlock *block, EjsName *typeName, cchar *spaceName)
{
    EjsNamespace    *namespace;

    namespace = ejsCreateReservedNamespace(ejs, typeName, spaceName);
    if (namespace) {
        if (ejsAddNamespaceToBlock(ejs, block, namespace) < 0) {
            return 0;
        }
    }
    return namespace;
}


/*
    Format a reserved namespace to create a unique namespace Uri. "internal, public, private, protected"

    Namespaces are formatted as strings using the following format, where type is optional. Types may be qualified.
        [type,space]

    Example:
        [debug::Shape,public] where Shape was declared as "debug class Shape"
 */
char *ejsFormatReservedNamespace(MprCtx ctx, EjsName *typeName, cchar *spaceName)
{
    cchar   *typeNameSpace;
    char    *namespace, *sp;
    int     len, typeLen, spaceLen, l;

    len = typeLen = spaceLen = 0;
    typeNameSpace = 0;

    if (typeName) {
        if (typeName->name == 0) {
            typeName = 0;
        }
        typeNameSpace = typeName->space ? typeName->space : EJS_PUBLIC_NAMESPACE;
    }

    if (typeName && typeName->name) {
        //  Join the qualified typeName to be "space::name"
        mprAssert(typeName->name);
        typeLen = (int) strlen(typeNameSpace);
        typeLen += 2 + (int) strlen(typeName->name);          //  Allow for the "::" between space::name
        len += typeLen;
    }
    spaceLen = (int) strlen(spaceName);

    /*
     *  Add 4 for [,,]
     *  Add 2 for the trailing "::" and one for the null
     */
    len += 4 + spaceLen + 2 + 1;

    namespace = mprAlloc(ctx, len);
    if (namespace == 0) {
        return 0;
    }

    sp = namespace;
    *sp++ = '[';

    if (typeName) {
        if (strcmp(typeNameSpace, EJS_PUBLIC_NAMESPACE) != 0) {
            l = (int) strlen(typeNameSpace);
            strcpy(sp, typeNameSpace);
            sp += l;
            *sp++ = ':';
            *sp++ = ':';
        }
        l = (int) strlen(typeName->name);
        strcpy(sp, typeName->name);
        sp += l;
    }

    *sp++ = ',';
    strcpy(sp, spaceName);
    sp += spaceLen;

    *sp++ = ']';
    *sp = '\0';

    mprAssert(sp <= &namespace[len]);

    return namespace;
}


/*
    Create a namespace with the given Uri as its definition qualifying value.
    TODO - uri is not used. Remove
 */
EjsNamespace *ejsCreateNamespace(Ejs *ejs, cchar *name, cchar *uri)
{
    EjsNamespace    *np;

    if (uri == 0) {
        uri = name;
    } else if (name == 0) {
        name = uri;
    }
    np = (EjsNamespace*) ejsCreate(ejs, ejs->namespaceType, 0);
    if (np) {
        np->name = (char*) name;
        np->uri = (char*) uri;
    }
    ejsSetDebugName(np, np->uri);
    return np;
}


/*
    Create a reserved namespace. Format the package, type and space names to create a unique namespace Uri.
    packageName, typeName and uri are optional.
 */
EjsNamespace *ejsCreateReservedNamespace(Ejs *ejs, EjsName *typeName, cchar *spaceName)
{
    EjsNamespace    *namespace;
    char            *formattedName;

    mprAssert(spaceName);

    if (typeName) {
        formattedName = (char*) ejsFormatReservedNamespace(ejs, typeName, spaceName);
    } else {
        formattedName = (char*) spaceName;
    }
    namespace = ejsCreateNamespace(ejs, formattedName, formattedName);
    return namespace;
}


void ejsCreateNamespaceType(Ejs *ejs)
{
    EjsType     *type;

    type = ejs->namespaceType = ejsCreateNativeType(ejs, "ejs", "Namespace", ES_Namespace, sizeof(EjsNamespace));
    type->helpers->cast = (EjsCastHelper) castNamespace;
    type->helpers->invokeOperator = (EjsInvokeOperatorHelper) invokeNamespaceOperator;
}


void ejsConfigureNamespaceType(Ejs *ejs)
{
    ejsSetProperty(ejs, ejs->global, ES_iterator, (EjsObj*) ejs->iteratorSpace);
    ejsSetProperty(ejs, ejs->global, ES_public, (EjsObj*) ejs->publicSpace);
#if ES_ejs
    ejsSetProperty(ejs, ejs->global, ES_ejs, (EjsObj*) ejs->ejsSpace);
#endif
}

/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2010. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2010. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    @end
 */
/************************************************************************/
/*
 *  End of file "../src/core/src/ejsNamespace.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../src/core/src/ejsNull.c"
 */
/************************************************************************/

/**
    ejsNull.c - Ejscript Null class

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */



/*
    Cast the null operand to a primitive type
 */

static EjsObj *castNull(Ejs *ejs, EjsObj *vp, EjsType *type)
{
    switch (type->id) {
    case ES_Boolean:
        return (EjsObj*) ejs->falseValue;

    case ES_Number:
        return (EjsObj*) ejs->zeroValue;

    case ES_Object:
    default:
        /*
            Cast null to anything else results in a null
         */
        return vp;

    case ES_String:
        return (EjsObj*) ejsCreateString(ejs, "null");
    }
}


static EjsObj *coerceNullOperands(Ejs *ejs, EjsObj *lhs, int opcode, EjsObj *rhs)
{
    switch (opcode) {

    case EJS_OP_ADD:
        if (!ejsIsNumber(rhs)) {
            return ejsInvokeOperator(ejs, (EjsObj*) ejsToString(ejs, lhs), opcode, rhs);
        }
        /* Fall through */

    case EJS_OP_AND: case EJS_OP_DIV: case EJS_OP_MUL: case EJS_OP_OR: case EJS_OP_REM:
    case EJS_OP_SHL: case EJS_OP_SHR: case EJS_OP_SUB: case EJS_OP_USHR: case EJS_OP_XOR:
        return ejsInvokeOperator(ejs, (EjsObj*) ejs->zeroValue, opcode, rhs);

    /*
        Comparision
     */
    case EJS_OP_COMPARE_LE: case EJS_OP_COMPARE_LT:
    case EJS_OP_COMPARE_GE: case EJS_OP_COMPARE_GT:
        if (ejsIsNumber(rhs)) {
            return ejsInvokeOperator(ejs, (EjsObj*) ejs->zeroValue, opcode, rhs);
        } else if (ejsIsString(rhs)) {
            return ejsInvokeOperator(ejs, (EjsObj*) ejsToString(ejs, lhs), opcode, rhs);
        }
        break;

    case EJS_OP_COMPARE_NE:
        if (ejsIsUndefined(rhs)) {
            return (EjsObj*) ejs->falseValue;
        }
        return (EjsObj*) ejs->trueValue;

    case EJS_OP_COMPARE_STRICTLY_NE:
        return (EjsObj*) ejs->trueValue;

    case EJS_OP_COMPARE_EQ:
        if (ejsIsUndefined(rhs)) {
            return (EjsObj*) ejs->trueValue;
        }
        return (EjsObj*) ejs->falseValue;

    case EJS_OP_COMPARE_STRICTLY_EQ:
        return (EjsObj*) ejs->falseValue;

    case EJS_OP_COMPARE_UNDEFINED:
    case EJS_OP_COMPARE_NOT_ZERO:
    case EJS_OP_COMPARE_NULL:
        return (EjsObj*) ejs->trueValue;

    case EJS_OP_COMPARE_FALSE:
    case EJS_OP_COMPARE_TRUE:
    case EJS_OP_COMPARE_ZERO:
        return (EjsObj*) ejs->falseValue;

    /*
        Unary operators
     */
    case EJS_OP_LOGICAL_NOT: case EJS_OP_NOT: case EJS_OP_NEG:
        return 0;

    default:
        ejsThrowTypeError(ejs, "Opcode %d not valid for type %s", opcode, lhs->type->qname.name);
        return ejs->undefinedValue;
    }
    return 0;
}


static EjsObj *invokeNullOperator(Ejs *ejs, EjsObj *lhs, int opcode, EjsObj *rhs)
{
    EjsObj      *result;

    if (rhs == 0 || lhs->type != rhs->type) {
        if ((result = coerceNullOperands(ejs, lhs, opcode, rhs)) != 0) {
            return result;
        }
    }

    /*
        Types now match. Both left and right types are both "null"
     */
    switch (opcode) {

    /*
        NOTE: strict eq is the same as eq
     */
    case EJS_OP_COMPARE_EQ: case EJS_OP_COMPARE_STRICTLY_EQ:
    case EJS_OP_COMPARE_LE: case EJS_OP_COMPARE_GE:
    case EJS_OP_COMPARE_UNDEFINED:
    case EJS_OP_COMPARE_NOT_ZERO:
    case EJS_OP_COMPARE_NULL:
        return (EjsObj*) ejs->trueValue;

    case EJS_OP_COMPARE_NE: case EJS_OP_COMPARE_STRICTLY_NE:
    case EJS_OP_COMPARE_LT: case EJS_OP_COMPARE_GT:
    case EJS_OP_COMPARE_FALSE:
    case EJS_OP_COMPARE_TRUE:
    case EJS_OP_COMPARE_ZERO:
        return (EjsObj*) ejs->falseValue;

    /*
        Unary operators
     */
    case EJS_OP_LOGICAL_NOT: case EJS_OP_NOT: case EJS_OP_NEG:
        return (EjsObj*) ejs->oneValue;

    /*
        Binary operators. Reinvoke with left = zero
     */
    case EJS_OP_ADD: case EJS_OP_AND: case EJS_OP_DIV: case EJS_OP_MUL: case EJS_OP_OR: case EJS_OP_REM:
    case EJS_OP_SHL: case EJS_OP_SHR: case EJS_OP_SUB: case EJS_OP_USHR: case EJS_OP_XOR:
        return ejsInvokeOperator(ejs, (EjsObj*) ejs->zeroValue, opcode, rhs);

    default:
        ejsThrowTypeError(ejs, "Opcode %d not implemented for type %s", opcode, lhs->type->qname.name);
        return 0;
    }
}


/*
    iterator native function get(): Iterator
 */
static EjsObj *getNullIterator(Ejs *ejs, EjsObj *np, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateIterator(ejs, np, NULL, 0, NULL);
}


static EjsObj *getNullProperty(Ejs *ejs, EjsNull *unused, int slotNum)
{
    ejsThrowReferenceError(ejs, "Object reference is null");
    return 0;
}


/*
    We dont actually allocate any nulls. We just reuse the singleton instance.
 */

EjsNull *ejsCreateNull(Ejs *ejs)
{
    return (EjsNull*) ejs->nullValue;
}


void ejsCreateNullType(Ejs *ejs)
{
    EjsType     *type;

    type = ejs->nullType = ejsCreateNativeType(ejs, "ejs", "Null", ES_Null, sizeof(EjsNull));

    type->helpers->cast             = (EjsCastHelper) castNull;
    type->helpers->getProperty      = (EjsGetPropertyHelper) getNullProperty;
    type->helpers->invokeOperator   = (EjsInvokeOperatorHelper) invokeNullOperator;

    ejs->nullValue = ejsCreate(ejs, type, 0);
    ejsSetDebugName(ejs->nullValue, "null");
}


void ejsConfigureNullType(Ejs *ejs)
{
    EjsType     *type;

    type = ejs->nullType;

    ejsSetProperty(ejs, ejs->global, ES_null, ejs->nullValue);
    ejsBindMethod(ejs, type, ES_Object_get, getNullIterator);
    ejsBindMethod(ejs, type, ES_Object_getValues, getNullIterator);
}


/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2010. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2010. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    @end
 */
/************************************************************************/
/*
 *  End of file "../src/core/src/ejsNull.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../src/core/src/ejsNumber.c"
 */
/************************************************************************/

/**
    ejsNumber.c - Number type class

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */




#define fixed(n) ((int64) (floor(n)))

/*
    Cast the operand to the specified type
 */
static EjsObj *castNumber(Ejs *ejs, EjsNumber *vp, EjsType *type)
{
    char    *result;
    
    switch (type->id) {
    case ES_Boolean:
        return (EjsObj*) ((vp->value) ? ejs->trueValue : ejs->falseValue);

    case ES_String:
        result = mprDtoa(vp, vp->value, 0, 0, 0);
        return (EjsObj*) ejsCreateStringAndFree(ejs, result);

    case ES_Number:
        return (EjsObj*) vp;
            
    default:
        ejsThrowTypeError(ejs, "Can't cast to this type");
        return 0;
    }
}


static EjsObj *cloneNumber(Ejs *ejs, EjsNumber *np, int deep)
{
    if (deep) {
        return (EjsObj*) ejsCreateNumber(ejs, np->value);
    }
    return (EjsObj*) np;
}


static EjsObj *coerceNumberOperands(Ejs *ejs, EjsObj *lhs, int opcode, EjsObj *rhs)
{
    switch (opcode) {
    /*
     *  Binary operators
     */
    case EJS_OP_ADD:
        if (ejsIsUndefined(rhs)) {
            return (EjsObj*) ejs->nanValue;
        } else if (ejsIsNull(rhs)) {
            return (EjsObj*) lhs;
        } else if (ejsIsBoolean(rhs) || ejsIsDate(rhs)) {
            return ejsInvokeOperator(ejs, lhs, opcode, (EjsObj*) ejsToNumber(ejs, rhs));
        } else {
            return ejsInvokeOperator(ejs, (EjsObj*) ejsToString(ejs, lhs), opcode, rhs);
        }
        break;

    case EJS_OP_AND: case EJS_OP_DIV: case EJS_OP_MUL: case EJS_OP_OR: case EJS_OP_REM:
    case EJS_OP_SHL: case EJS_OP_SHR: case EJS_OP_SUB: case EJS_OP_USHR: case EJS_OP_XOR:
        return ejsInvokeOperator(ejs, lhs, opcode, (EjsObj*) ejsToNumber(ejs, rhs));

    case EJS_OP_COMPARE_EQ: case EJS_OP_COMPARE_NE:
    case EJS_OP_COMPARE_LE: case EJS_OP_COMPARE_LT:
    case EJS_OP_COMPARE_GE: case EJS_OP_COMPARE_GT:
        if (ejsIsNull(rhs) || ejsIsUndefined(rhs)) {
            return (EjsObj*) ((opcode == EJS_OP_COMPARE_EQ) ? ejs->falseValue: ejs->trueValue);
        } else if (ejsIsNumber(rhs)) {
            return ejsInvokeOperator(ejs, (EjsObj*) ejsToNumber(ejs, lhs), opcode, rhs);
        } else if (ejsIsString(rhs)) {
            return ejsInvokeOperator(ejs, (EjsObj*) ejsToString(ejs, lhs), opcode, rhs);
        }
        return ejsInvokeOperator(ejs, lhs, opcode, (EjsObj*) ejsToNumber(ejs, rhs));

    case EJS_OP_COMPARE_STRICTLY_NE:
        return (EjsObj*) ejs->trueValue;

    case EJS_OP_COMPARE_STRICTLY_EQ:
        return (EjsObj*) ejs->falseValue;

    /*
     *  Unary operators
     */
    case EJS_OP_LOGICAL_NOT: case EJS_OP_NOT: case EJS_OP_NEG:
        return 0;

    case EJS_OP_COMPARE_NOT_ZERO:
    case EJS_OP_COMPARE_TRUE:
        return (EjsObj*) (((EjsNumber*) lhs)->value ? ejs->trueValue : ejs->falseValue);

    case EJS_OP_COMPARE_ZERO:
    case EJS_OP_COMPARE_FALSE:
        return (EjsObj*) (((EjsNumber*) lhs)->value ? ejs->falseValue: ejs->trueValue);

    case EJS_OP_COMPARE_UNDEFINED:
    case EJS_OP_COMPARE_NULL:
        return (EjsObj*) ejs->falseValue;

    default:
        ejsThrowTypeError(ejs, "Opcode %d not valid for type %s", opcode, lhs->type->qname.name);
        return ejs->undefinedValue;
    }
    return 0;
}


static EjsObj *invokeNumberOperator(Ejs *ejs, EjsNumber *lhs, int opcode, EjsNumber *rhs)
{
    EjsObj      *result;

    mprAssert(lhs);
    
    //  TODO - why test rhs == 0
    if (rhs == 0 || lhs->obj.type != rhs->obj.type) {
        if (!ejsIsA(ejs, (EjsObj*) lhs, ejs->numberType) || !ejsIsA(ejs, (EjsObj*) rhs, ejs->numberType)) {
            if ((result = coerceNumberOperands(ejs, (EjsObj*) lhs, opcode, (EjsObj*) rhs)) != 0) {
                return result;
            }
        }
    }

    /*
        Types now match, both numbers
     */
    switch (opcode) {

    case EJS_OP_COMPARE_EQ: case EJS_OP_COMPARE_STRICTLY_EQ:
        return (EjsObj*) ((lhs->value == rhs->value) ? ejs->trueValue: ejs->falseValue);

    case EJS_OP_COMPARE_NE: case EJS_OP_COMPARE_STRICTLY_NE:
        return (EjsObj*) ((lhs->value != rhs->value) ? ejs->trueValue: ejs->falseValue);

    case EJS_OP_COMPARE_LT:
        return (EjsObj*) ((lhs->value < rhs->value) ? ejs->trueValue: ejs->falseValue);

    case EJS_OP_COMPARE_LE:
        return (EjsObj*) ((lhs->value <= rhs->value) ? ejs->trueValue: ejs->falseValue);

    case EJS_OP_COMPARE_GT:
        return (EjsObj*) ((lhs->value > rhs->value) ? ejs->trueValue: ejs->falseValue);

    case EJS_OP_COMPARE_GE:
        return (EjsObj*) ((lhs->value >= rhs->value) ? ejs->trueValue: ejs->falseValue);

    /*
     *  Unary operators
     */
    case EJS_OP_COMPARE_NOT_ZERO:
        return (EjsObj*) ((lhs->value) ? ejs->trueValue: ejs->falseValue);

    case EJS_OP_COMPARE_ZERO:
        return (EjsObj*) ((lhs->value == 0) ? ejs->trueValue: ejs->falseValue);

    case EJS_OP_COMPARE_UNDEFINED:
    case EJS_OP_COMPARE_NULL:
    case EJS_OP_COMPARE_FALSE:
    case EJS_OP_COMPARE_TRUE:
        return (EjsObj*) ejs->falseValue;

    case EJS_OP_NEG:
        return (EjsObj*) ejsCreateNumber(ejs, -lhs->value);

    case EJS_OP_LOGICAL_NOT:
        return (EjsObj*) ejsCreateBoolean(ejs, !fixed(lhs->value));

    case EJS_OP_NOT:
        return (EjsObj*) ejsCreateNumber(ejs, (MprNumber) (~fixed(lhs->value)));


    /*
        Binary operations
     */
    case EJS_OP_ADD:
        return (EjsObj*) ejsCreateNumber(ejs, lhs->value + rhs->value);

    case EJS_OP_AND:
        return (EjsObj*) ejsCreateNumber(ejs, (MprNumber) (fixed(lhs->value) & fixed(rhs->value)));

    case EJS_OP_DIV:
        return (EjsObj*) ejsCreateNumber(ejs, lhs->value / rhs->value);

    case EJS_OP_MUL:
        return (EjsObj*) ejsCreateNumber(ejs, lhs->value * rhs->value);

    case EJS_OP_OR:
        return (EjsObj*) ejsCreateNumber(ejs, (MprNumber) (fixed(lhs->value) | fixed(rhs->value)));

    case EJS_OP_REM:
        return (EjsObj*) ejsCreateNumber(ejs, (MprNumber) (fixed(lhs->value) % fixed(rhs->value)));

    case EJS_OP_SHL:
        return (EjsObj*) ejsCreateNumber(ejs, (MprNumber) (fixed(lhs->value) << fixed(rhs->value)));

    case EJS_OP_SHR:
        return (EjsObj*) ejsCreateNumber(ejs, (MprNumber) (fixed(lhs->value) >> fixed(rhs->value)));

    case EJS_OP_SUB:
        return (EjsObj*) ejsCreateNumber(ejs, lhs->value - rhs->value);

    case EJS_OP_USHR:
        return (EjsObj*) ejsCreateNumber(ejs, (MprNumber) (fixed(lhs->value) >> fixed(rhs->value)));

    case EJS_OP_XOR:
        return (EjsObj*) ejsCreateNumber(ejs, (MprNumber) (fixed(lhs->value) ^ fixed(rhs->value)));

    default:
        ejsThrowTypeError(ejs, "Opcode %d not implemented for type %s", opcode, lhs->obj.type->qname.name);
        return 0;
    }
}


/*
    Number constructor.
    function Number(value: Object = null)
 */
static EjsObj *numberConstructor(Ejs *ejs, EjsNumber *np, int argc, EjsObj **argv)
{
    EjsNumber   *num;

    mprAssert(argc == 0 || argc == 1);

    if (argc == 1) {
        num = ejsToNumber(ejs, argv[0]);
        if (num) {
            np->value = num->value;
        }
    }
    return (EjsObj*) np;
}


/*
    Function to iterate and return each number in sequence.
    NOTE: this is not a method of Number. Rather, it is a callback function for Iterator.
 */
static EjsObj *nextNumber(Ejs *ejs, EjsIterator *ip, int argc, EjsObj **argv)
{
    EjsNumber   *np;

    np = (EjsNumber*) ip->target;
    if (!ejsIsNumber(np)) {
        ejsThrowReferenceError(ejs, "Wrong type");
        return 0;
    }

    if (ip->index < np->value) {
        return (EjsObj*) ejsCreateNumber(ejs, ip->index++);
    }
    ejsThrowStopIteration(ejs);
    return 0;
}


/*
    function integral(size: Number: 32): Number
 */
static EjsObj *integral(Ejs *ejs, EjsNumber *np, int argc, EjsObj **argv)
{
    int64   mask, result;
    int     size;

    size = (argc > 0) ? ejsGetInt(ejs, argv[0]) : 32;

    result = ((int64) np->value);
    if (size < 64) {
        mask = (1 << size) - 1;
        result &= mask;
    }
    return (EjsObj*) ejsCreateNumber(ejs, (MprNumber) result);
}


/*
    function get isFinite(): Boolean
 */
static EjsObj *isFinite(Ejs *ejs, EjsNumber *np, int argc, EjsObj **argv)
{
    if (np->value == ejs->nanValue->value || 
            np->value == ejs->infinityValue->value || 
            np->value == ejs->negativeInfinityValue->value) {
        return (EjsObj*) ejs->falseValue;
    }
    return (EjsObj*) ejs->trueValue;
}


/*
    function get isNaN(): Boolean
 */
static EjsObj *isNaN(Ejs *ejs, EjsNumber *np, int argc, EjsObj **argv)
{
    return (EjsObj*) (mprIsNan(np->value) ? ejs->trueValue : ejs->falseValue);
}


/*
    function toExponential(fractionDigits: Number = 0): String
    Display with only one digit before the decimal point.
 */
static EjsObj *toExponential(Ejs *ejs, EjsNumber *np, int argc, EjsObj **argv)
{
    char    *result;
    int     ndigits;
    
    ndigits = (argc > 0) ? ejsGetInt(ejs, argv[0]): 0;
    result = mprDtoa(np, np->value, ndigits, MPR_DTOA_N_DIGITS, MPR_DTOA_EXPONENT_FORM);
    return (EjsObj*) ejsCreateStringAndFree(ejs, result);
}


/*
    function toFixed(fractionDigits: Number = 0): String

    Display the specified number of fractional digits
 */
static EjsObj *toFixed(Ejs *ejs, EjsNumber *np, int argc, EjsObj **argv)
{
    char    *result;
    int     ndigits;
    
    ndigits = (argc > 0) ? ejsGetInt(ejs, argv[0]) : 0;
    result = mprDtoa(np, np->value, ndigits, MPR_DTOA_N_FRACTION_DIGITS, MPR_DTOA_FIXED_FORM);
    return (EjsObj*) ejsCreateStringAndFree(ejs, result);
}


/*
    function toPrecision(numDigits: Number = MAX_VALUE): String
    Display the specified number of total digits
 */
static EjsObj *toPrecision(Ejs *ejs, EjsNumber *np, int argc, EjsObj **argv)
{
    char    *result;
    int     ndigits;
    
    ndigits = (argc > 0) ? ejsGetInt(ejs, argv[0]) : 0;
    result = mprDtoa(np, np->value, ndigits, MPR_DTOA_N_DIGITS, 0);
    return (EjsObj*) ejsCreateStringAndFree(ejs, result);
}


/*
    Return the default iterator. This returns the index names.
    iterator native function get(): Iterator
 */
static EjsObj *getNumberIterator(Ejs *ejs, EjsObj *np, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateIterator(ejs, np, (EjsProc) nextNumber, 0, NULL);
}


/*
    Convert the number to a string.
    intrinsic function toString(): String
 */
static EjsObj *numberToString(Ejs *ejs, EjsObj *vp, int argc, EjsObj **argv)
{
    return castNumber(ejs, (EjsNumber*) vp, ejs->stringType);
}



#ifndef ejsIsNan
int ejsIsNan(double f)
{
#if BLD_WIN_LIKE
    return _isnan(f);
#elif VXWORKS
    /* TODO */
    return 0;
#else
    return (f == FP_NAN);
#endif
}
#endif


bool ejsIsInfinite(MprNumber f)
{
#if BLD_WIN_LIKE
    return !_finite(f);
#elif VXWORKS
    /* TODO */
    return 0;
#else
    return (f == FP_INFINITE);
#endif
}

/*
    Create an initialized number
 */

EjsNumber *ejsCreateNumber(Ejs *ejs, MprNumber value)
{
    EjsNumber   *vp;

    if (value == 0) {
        return ejs->zeroValue;
    } else if (value == 1) {
        return ejs->oneValue;
    } else if (value == -1) {
        return ejs->minusOneValue;
    }
    vp = (EjsNumber*) ejsCreate(ejs, ejs->numberType, 0);
    if (vp != 0) {
        vp->value = value;
    }
    ejsSetDebugName(vp, "number value");
    return vp;
}


void ejsCreateNumberType(Ejs *ejs)
{
    EjsType     *type;
    static int  zero = 0;

    type = ejs->numberType = ejsCreateNativeType(ejs, "ejs", "Number", ES_Number, sizeof(EjsNumber));
    type->immutable = 1;

    type->helpers->cast = (EjsCastHelper) castNumber;
    type->helpers->clone = (EjsCloneHelper) cloneNumber;
    type->helpers->invokeOperator = (EjsInvokeOperatorHelper) invokeNumberOperator;

    ejs->zeroValue = (EjsNumber*) ejsCreate(ejs, ejs->numberType, 0);
    ejs->zeroValue->value = 0;
    ejs->oneValue = (EjsNumber*) ejsCreate(ejs, ejs->numberType, 0);
    ejs->oneValue->value = 1;
    ejs->minusOneValue = (EjsNumber*) ejsCreate(ejs, ejs->numberType, 0);
    ejs->minusOneValue->value = -1;

    ejs->infinityValue = (EjsNumber*) ejsCreate(ejs, ejs->numberType, 0);
    ejs->infinityValue->value = 1.0 / zero;
    ejs->negativeInfinityValue = (EjsNumber*) ejsCreate(ejs, ejs->numberType, 0);
    ejs->negativeInfinityValue->value = -1.0 / zero;
    ejs->nanValue = (EjsNumber*) ejsCreate(ejs, ejs->numberType, 0);
    ejs->nanValue->value = 0.0 / zero;

    ejs->maxValue = (EjsNumber*) ejsCreate(ejs, ejs->numberType, 0);
    ejs->maxValue->value = 1.7976931348623157e+308;
    ejs->minValue = (EjsNumber*) ejsCreate(ejs, ejs->numberType, 0);
    ejs->minValue->value = 5e-324;

    ejsSetDebugName(ejs->infinityValue, "Infinity");
    ejsSetDebugName(ejs->negativeInfinityValue, "NegativeInfinity");
    ejsSetDebugName(ejs->nanValue, "NaN");

    ejsSetDebugName(ejs->minusOneValue, "-1");
    ejsSetDebugName(ejs->oneValue, "1");
    ejsSetDebugName(ejs->zeroValue, "0");
    ejsSetDebugName(ejs->maxValue, "MaxValue");
    ejsSetDebugName(ejs->minValue, "MinValue");
}


void ejsConfigureNumberType(Ejs *ejs)
{
    EjsType         *type;

    type = ejsGetTypeByName(ejs, "ejs", "Number");

    ejsBindMethod(ejs, type, ES_Number_Number, (EjsProc) numberConstructor);
    ejsBindMethod(ejs, type, ES_Number_integral, (EjsProc) integral);
    ejsBindMethod(ejs, type, ES_Number_isFinite, (EjsProc) isFinite);
    ejsBindMethod(ejs, type, ES_Number_isNaN, (EjsProc) isNaN);
    ejsBindMethod(ejs, type, ES_Number_toExponential, (EjsProc) toExponential);
    ejsBindMethod(ejs, type, ES_Number_toFixed, (EjsProc) toFixed);
    ejsBindMethod(ejs, type, ES_Number_toPrecision, (EjsProc) toPrecision);

    ejsBindMethod(ejs, type, ES_Object_get, getNumberIterator);
    ejsBindMethod(ejs, type, ES_Object_getValues, getNumberIterator);
    ejsBindMethod(ejs, type, ES_Object_toString, numberToString);

    ejsSetProperty(ejs, (EjsObj*) type, ES_Number_MaxValue, (EjsObj*) ejs->maxValue);
    ejsSetProperty(ejs, (EjsObj*) type, ES_Number_MinValue, (EjsObj*) ejs->minValue);

    ejsSetProperty(ejs, (EjsObj*) type, ES_Number_NEGATIVE_INFINITY, (EjsObj*) ejs->negativeInfinityValue);
    ejsSetProperty(ejs, (EjsObj*) type, ES_Number_POSITIVE_INFINITY, (EjsObj*) ejs->infinityValue);
    ejsSetProperty(ejs, (EjsObj*) type, ES_Number_NaN, (EjsObj*) ejs->nanValue);

    ejsSetProperty(ejs, ejs->global, ES_NegativeInfinity, (EjsObj*) ejs->negativeInfinityValue);
    ejsSetProperty(ejs, ejs->global, ES_Infinity, (EjsObj*) ejs->infinityValue);
    ejsSetProperty(ejs, ejs->global, ES_NaN, (EjsObj*) ejs->nanValue);
    ejsSetProperty(ejs, ejs->global, ES_double, (EjsObj*) type);
    ejsSetProperty(ejs, ejs->global, ES_num, (EjsObj*) type);
}

/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2010. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2010. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    @end
 */
/************************************************************************/
/*
 *  End of file "../src/core/src/ejsNumber.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../src/core/src/ejsObject.c"
 */
/************************************************************************/

/**
    ejsObject.c - Object class

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */




#define CMP_QNAME(a,b) cmpQname(a, b)


static int      cmpQname(EjsName *a, EjsName *b);
static EjsName  getObjectPropertyName(Ejs *ejs, EjsObj *obj, int slotNum);
static int      growSlots(Ejs *ejs, EjsObj *obj, int size);
static int      hashProperty(EjsObj *obj, int slotNum, EjsName *qname);
static int      lookupObjectProperty(struct Ejs *ejs, EjsObj *obj, EjsName *qname);
static EjsObj   *obj_defineProperty(Ejs *ejs, EjsObj *type, int argc, EjsObj **argv);
static EjsObj   *obj_toString(Ejs *ejs, EjsObj *vp, int argc, EjsObj **argv);
static void     removeHashEntry(Ejs *ejs, EjsObj  *obj, EjsName *qname);

/*
    Cast the operand to a primitive type
 */
static EjsObj *castObject(Ejs *ejs, EjsObj *obj, EjsType *type)
{
    EjsString   *result;
    
    mprAssert(ejsIsType(type));

    switch (type->id) {
    case ES_Boolean:
        return (EjsObj*) ejsCreateBoolean(ejs, 1);

    case ES_Number:
        result = ejsToString(ejs, (EjsObj*) obj);
        if (result == 0) {
            ejsThrowMemoryError(ejs);
            return 0;
        }
        return ejsParse(ejs, ejsGetString(ejs, result), ES_Number);

    case ES_String:
        return (EjsObj*) ejsCreateStringAndFree(ejs, mprStrcat(ejs, -1, "[object ", obj->type->qname.name, "]", NULL));

    default:
        if (ejsIsA(ejs, (EjsObj*) obj, type)) {
            return (EjsObj*) obj;
        }
        ejsThrowTypeError(ejs, "Can't cast to this type");
        return 0;
    }
}


/*
    Cast the operands depending on the operation code
 */
EjsObj *ejsCoerceOperands(Ejs *ejs, EjsObj *lhs, int opcode, EjsObj *rhs)
{
    switch (opcode) {

    /*
        Binary operators
     */
    case EJS_OP_ADD:
        return ejsInvokeOperator(ejs, (EjsObj*) ejsToString(ejs, lhs), opcode, rhs);

    case EJS_OP_AND: case EJS_OP_DIV: case EJS_OP_MUL: case EJS_OP_OR: case EJS_OP_REM:
    case EJS_OP_SHL: case EJS_OP_SHR: case EJS_OP_SUB: case EJS_OP_USHR: case EJS_OP_XOR:
        return ejsInvokeOperator(ejs, (EjsObj*) ejs->zeroValue, opcode, rhs);

    case EJS_OP_COMPARE_EQ:  case EJS_OP_COMPARE_NE:
        if (ejsIsNull(rhs) || ejsIsUndefined(rhs)) {
            return (EjsObj*) ((opcode == EJS_OP_COMPARE_EQ) ? ejs->falseValue: ejs->trueValue);
        } else if (ejsIsNumber(rhs)) {
            return ejsInvokeOperator(ejs, (EjsObj*) ejsToNumber(ejs, lhs), opcode, rhs);
        }
        return ejsInvokeOperator(ejs, (EjsObj*) ejsToString(ejs, lhs), opcode, rhs);

    case EJS_OP_COMPARE_LE: case EJS_OP_COMPARE_LT:
    case EJS_OP_COMPARE_GE: case EJS_OP_COMPARE_GT:
        if (ejsIsNumber(rhs)) {
            return ejsInvokeOperator(ejs, (EjsObj*) ejsToNumber(ejs, lhs), opcode, rhs);
        }
        return ejsInvokeOperator(ejs, (EjsObj*) ejsToString(ejs, lhs), opcode, rhs);

    case EJS_OP_COMPARE_STRICTLY_NE:
    case EJS_OP_COMPARE_UNDEFINED:
    case EJS_OP_COMPARE_NOT_ZERO:
    case EJS_OP_COMPARE_NULL:
        return (EjsObj*) ejs->trueValue;

    case EJS_OP_COMPARE_STRICTLY_EQ:
    case EJS_OP_COMPARE_FALSE:
    case EJS_OP_COMPARE_TRUE:
    case EJS_OP_COMPARE_ZERO:
        return (EjsObj*) ejs->falseValue;

    /* Unary operators */
    case EJS_OP_LOGICAL_NOT: case EJS_OP_NOT:
        return 0;

    default:
        ejsThrowTypeError(ejs, "Opcode %d not valid for type %s", opcode, lhs->type->qname.name);
        return ejs->undefinedValue;
    }
    return 0;
}


EjsObj *ejsObjectOperator(Ejs *ejs, EjsObj *lhs, int opcode, EjsObj *rhs)
{
    EjsObj      *result;

    if (rhs == 0 || lhs->type != rhs->type) {
        if ((result = ejsCoerceOperands(ejs, lhs, opcode, rhs)) != 0) {
            return result;
        }
    }
    /* Types now match */
    switch (opcode) {

    case EJS_OP_COMPARE_EQ: case EJS_OP_COMPARE_STRICTLY_EQ:
    case EJS_OP_COMPARE_LE: case EJS_OP_COMPARE_GE:
        return (EjsObj*) ejsCreateBoolean(ejs, (lhs == rhs));

    case EJS_OP_COMPARE_NE: case EJS_OP_COMPARE_STRICTLY_NE:
    case EJS_OP_COMPARE_LT: case EJS_OP_COMPARE_GT:
        return (EjsObj*) ejsCreateBoolean(ejs, !(lhs == rhs));

    /* Unary operators */

    case EJS_OP_COMPARE_NOT_ZERO:
        return (EjsObj*) ejs->trueValue;

    case EJS_OP_COMPARE_UNDEFINED:
    case EJS_OP_COMPARE_NULL:
    case EJS_OP_COMPARE_FALSE:
    case EJS_OP_COMPARE_TRUE:
    case EJS_OP_COMPARE_ZERO:
        return (EjsObj*) ejs->falseValue;

    case EJS_OP_LOGICAL_NOT: case EJS_OP_NOT: case EJS_OP_NEG:
        return (EjsObj*) ejs->oneValue;

    /* Binary operators */

    case EJS_OP_ADD: case EJS_OP_AND: case EJS_OP_DIV: case EJS_OP_MUL:
    case EJS_OP_REM: case EJS_OP_OR: case EJS_OP_SHL: case EJS_OP_SHR:
    case EJS_OP_SUB: case EJS_OP_USHR: case EJS_OP_XOR:
        return ejsInvokeOperator(ejs, (EjsObj*) ejsToNumber(ejs, lhs), opcode, (EjsObj*) ejsToNumber(ejs, rhs));

    default:
        ejsThrowTypeError(ejs, "Opcode %d not implemented for type %s", opcode, lhs->type->qname.name);
        return 0;
    }
    mprAssert(0);
}


/*
    Create an object which is an instance of a given type. This is used by all scripted types to create objects. NOTE: we 
    only initialize the Object base class. It is up to the  caller to complete the initialization for all other base classes 
    by calling the appropriate constructors. numSlots is the number of property slots to pre-allocate. Slots are allocated 
    and the property hash is configured.  If the type creates dynamic instances, then the property slots are allocated 
    separately and can grow. 
 */
EjsObj *ejsCreateObject(Ejs *ejs, EjsType *type, int numSlots)
{
    EjsObj      *obj, *prototype;

    mprAssert(type);
    mprAssert(numSlots >= 0);

    if ((prototype = (EjsObj*) type->prototype) != 0) {
        numSlots = max(numSlots, prototype->numSlots);
    }
    if (type->dynamicInstance) {
        if ((obj = (EjsObj*) ejsAlloc(ejs, type, 0)) == 0) {
            return 0;
        }
        if (numSlots > 0) {
            growSlots(ejs, obj, numSlots);
        }
        obj->dynamic = 1;
    } else {
        if ((obj = (EjsObj*) ejsAlloc(ejs, type, numSlots * sizeof(EjsSlot))) == 0) {
            return 0;
        }
        if (numSlots > 0) {
            obj->slots = (EjsSlot*) &(((char*) obj)[type->instanceSize]);
            obj->sizeSlots = numSlots;
        }
    }
    obj->numSlots = numSlots;
    obj->type = type;
    ejsSetDebugName(obj, type->qname.name);

    if (obj->sizeSlots > 0) {
        if (prototype == 0 || type->dontCopyPrototype) {
            ejsZeroSlots(ejs, obj->slots, obj->sizeSlots);
        } else {
            ejsCopySlots(ejs, obj, obj->slots, prototype->slots, prototype->numSlots, 1);
            if (numSlots > EJS_HASH_MIN_PROP) {
                ejsMakeObjHash(obj);
            }
            ejsZeroSlots(ejs, &obj->slots[prototype->numSlots], obj->sizeSlots - prototype->numSlots);
        }
    }
    return obj;
}


EjsObj *ejsCreateSimpleObject(Ejs *ejs)
{
    return ejsCreateObject(ejs, ejs->objectType, 0);
}


EjsObj *ejsCloneObject(Ejs *ejs, EjsObj *src, bool deep)
{
    EjsObj          *dest;
    EjsSlot         *dp, *sp;
    int             numSlots, i;

    numSlots = src->numSlots;
    dest = ejsCreateObject(ejs, src->type, numSlots);
    if (dest == 0) {
        return 0;
    }
    dest->numSlots = numSlots;
    //  TODO - OPT make a flags word
    dest->builtin = src->builtin;
    dest->dynamic = src->dynamic;
    dest->hidden = src->hidden;
    dest->isFunction = src->isFunction;
    dest->isPrototype = src->isPrototype;
    dest->isType = src->isType;
    dest->permanent = src->permanent;

    dp = dest->slots;
    sp = src->slots;
    for (i = 0; i < numSlots; i++, sp++, dp++) {
        *dp = *sp;
        //  MOB -- all native types must provide clone or set immutable
        if (deep /* MOB || !sp->value.ref->type->immutable */) {
            dp->value.ref = ejsClone(ejs, sp->value.ref, deep);
        }
    }
    ejsSetDebugName(dest, mprGetName(src));
    return dest;
}


static EjsObj *prepareAccessors(Ejs *ejs, EjsObj *obj, int slotNum, int *attributes, EjsObj *value)
{
    EjsFunction     *fun;
    EjsTrait        *trait;

    fun = (EjsFunction*) ejsGetProperty(ejs, obj, slotNum);

    if (*attributes & EJS_TRAIT_SETTER) {
        if (ejsIsFunction(fun)) {
            /* Existing getter, add a setter */
            fun->setter = (EjsFunction*) value;
            if ((trait = ejsGetTrait(obj, slotNum)) != 0) {
                *attributes |= trait->attributes;
            }
        } else {
            /* No existing getter, must define a dummy getter - will not be called */
            fun = (EjsFunction*) ejsCloneFunction(ejs, ejs->nopFunction, 0);
            fun->setter = (EjsFunction*) value;
        }
        ejsSetFunctionLocation(fun->setter, obj, slotNum);
        value = (EjsObj*) fun;

    } else if (*attributes & EJS_TRAIT_GETTER) {
        if (ejsIsFunction(fun) && ejsHasTrait(obj, slotNum, EJS_TRAIT_SETTER)) {
            /* Existing getter and setter - preserve any defined setter, overwrite getter */
            if (fun->setter) {
                ((EjsFunction*) value)->setter = fun->setter;
                *attributes |= EJS_TRAIT_SETTER;
            }
        }
    } else {
        mprAssert(0);
        return value;
    }
    return value;
}


/*
    Define (or redefine) a property and set its name, type, attributes and property value.
 */
static int defineObjectProperty(Ejs *ejs, EjsObj *obj, int slotNum, EjsName *qname, EjsType *propType, int attributes, 
    EjsObj *value)
{
    EjsFunction     *fun;
    EjsType         *type;
    int             priorSlot;

    mprAssert(ejs);
    mprAssert(slotNum >= -1);
    mprAssert(qname);

    if (attributes & (EJS_TRAIT_GETTER | EJS_TRAIT_SETTER) && !ejsIsFunction(value)) {
        ejsThrowTypeError(ejs, "Property \"%s\" is not a function", qname->name);
        return 0;
    }
    priorSlot = ejsLookupProperty(ejs, obj, qname);
    if (slotNum < 0) {
        if (priorSlot < 0) {
            slotNum = ejsGetPropertyCount(ejs, obj);
        } else {
            slotNum = priorSlot;
        }
    }
    if (priorSlot < 0 && ejsSetPropertyName(ejs, (EjsObj*) obj, slotNum, qname) < 0) {
        return EJS_ERR;
    }
    if (attributes & (EJS_TRAIT_GETTER | EJS_TRAIT_SETTER)) {
        value = prepareAccessors(ejs, obj, slotNum, &attributes, value);
    }
    if (ejsSetPropertyTrait(ejs, (EjsObj*) obj, slotNum, propType, attributes) < 0) {
        return EJS_ERR;
    }
    if (ejsSetProperty(ejs, (EjsObj*) obj, slotNum, value ? value: ejs->nullValue) < 0) {
        return EJS_ERR;
    }
    if (ejsIsFunction(value)) {
        fun = ((EjsFunction*) value);
        if (attributes & EJS_FUN_CONSTRUCTOR) {
            fun->constructor = 1;
        }
        ejsSetFunctionLocation(fun, obj, slotNum);
        if (!ejsIsNativeFunction(fun)) {
            obj->hasScriptFunctions = 1;
        }
        if (fun->staticMethod && ejsIsType(obj)) {
            type = (EjsType*) obj;
            if (!type->isInterface) {
                /* For static methods, find the right base class and set thisObj to speed up later invocations */
                fun->thisObj = obj;
            }
        }
    }
    return slotNum;
}


/*
    Delete an instance property. To delete class properties, use the type as the obj. This sets the property to null.
    It does not reclaim the property slot.
 */
static int deleteObjectProperty(Ejs *ejs, EjsObj *obj, int slotNum)
{
    EjsName     qname;
    EjsSlot     *sp;

    mprAssert(obj);
    mprAssert(obj->type);
    mprAssert(slotNum >= 0);

    if (slotNum < 0 || slotNum >= obj->numSlots) {
        ejsThrowReferenceError(ejs, "Invalid property slot to delete");
        return EJS_ERR;
    }
    qname = getObjectPropertyName(ejs, obj, slotNum);
    if (qname.name) {
        removeHashEntry(ejs, obj, &qname);
    }
    sp = &obj->slots[slotNum];
    sp->value.ref = ejs->undefinedValue;
    sp->trait.type = 0;
    sp->trait.attributes = EJS_TRAIT_DELETED | EJS_TRAIT_HIDDEN;
    return 0;
}


static int deleteObjectPropertyByName(Ejs *ejs, EjsObj *obj, EjsName *qname)
{
    int     slotNum;

    slotNum = lookupObjectProperty(ejs, obj, qname);
    if (slotNum < 0) {
        ejsThrowReferenceError(ejs, "Property does not exist");
        return EJS_ERR;
    }
    return deleteObjectProperty(ejs, obj, slotNum);
}


static void destroyObject(Ejs *ejs, EjsObj *vp)
{
    ejsFree(ejs, vp, -1);
}


static EjsObj *getObjectProperty(Ejs *ejs, EjsObj *obj, int slotNum)
{
    mprAssert(obj);
    mprAssert(obj->slots);
    mprAssert(slotNum >= 0);

    if (slotNum < 0 || slotNum >= obj->numSlots) {
        ejsThrowReferenceError(ejs, "Property at slot \"%d\" is not found", slotNum);
        return 0;
    }
    return obj->slots[slotNum].value.ref;
}


static int getObjectPropertyCount(Ejs *ejs, EjsObj *obj)
{
    mprAssert(obj);
    return obj->numSlots;
}


static EjsName getObjectPropertyName(Ejs *ejs, EjsObj *obj, int slotNum)
{
    EjsName     qname;

    mprAssert(obj);
    mprAssert(obj->slots);
    mprAssert(slotNum >= 0);
    mprAssert(slotNum < obj->numSlots);

    if (slotNum < 0 || slotNum >= obj->numSlots) {
        qname.name = 0;
        qname.space = 0;
        return qname;
    }
    return obj->slots[slotNum].qname;
}


static EjsTrait *getObjectPropertyTrait(Ejs *ejs, EjsObj *obj, int slotNum)
{
    return ejsGetTrait(obj, slotNum);
}


/*
    Lookup a property with a namespace qualifier in an object and return the slot if found. Return EJS_ERR if not found.
 */
static int lookupObjectProperty(struct Ejs *ejs, EjsObj *obj, EjsName *qname)
{
    EjsName     *propName;
    int         slotNum, index;

    mprAssert(qname);
    mprAssert(qname->name);
    mprAssert(qname->space);

    if (obj->hash == 0) {
        /* No hash. Just do a linear search */
        for (slotNum = 0; slotNum < obj->numSlots; slotNum++) {
            propName = &obj->slots[slotNum].qname;
            if (CMP_QNAME(propName, qname)) {
                return slotNum;
            }
        }
    } else {
        /*
            Find the property in the hash chain if it exists. Note the hash does not include the namespace portion.
            We assume that names rarely clash with different namespaces. We do this so variable lookup and do a one
            hash probe and find matching names. Lookup will then pick the right namespace.
         */
        index = ejsComputeHashCode(obj, qname);
        for (slotNum = obj->hash[index]; slotNum >= 0; slotNum = obj->slots[slotNum].hashChain) {
            propName = &obj->slots[slotNum].qname;
            if (CMP_QNAME(propName, qname)) {
                return slotNum;
            }
        }
    }
    return EJS_ERR;
}


/*
    Mark the object properties for the garbage collector
 */
void ejsMarkObject(Ejs *ejs, EjsObj *obj)
{
    EjsSlot     *sp;
    int         i;

    //  MOB -- probably not needed
    ejsMark(ejs, (EjsObj*) obj->type);

    sp = obj->slots;
    for (i = 0; i < obj->numSlots; i++, sp++) {
        if (sp->value.ref == ejs->nullValue) {
            continue;
        }
        ejsMark(ejs, sp->value.ref);
    }
}


/*
    Validate the supplied slot number. If set to -1, then return the next available property slot number.
    Grow the object if required and update numSlots
 */
int ejsGetSlot(Ejs *ejs, EjsObj *obj, int slotNum)
{
    mprAssert(obj->numSlots <= obj->sizeSlots);

    if (slotNum < 0) {
        if (!obj->dynamic) {
            if (obj == ejs->nullValue) {
                ejsThrowReferenceError(ejs, "Object is null");
            } else if (obj == ejs->undefinedValue) {
                ejsThrowReferenceError(ejs, "Object is undefined");
            } else {
                ejsThrowReferenceError(ejs, "Object is not extendable");
            }
            return EJS_ERR;
        }
        slotNum = obj->numSlots;
        if (obj->numSlots >= obj->sizeSlots) {
            if (growSlots(ejs, obj, obj->numSlots + 1) < 0) {
                ejsThrowMemoryError(ejs);
                return EJS_ERR;
            }
            obj->numSlots++;
        } else {
            obj->numSlots++;
        }
    } else if (slotNum >= obj->numSlots) {
        if (slotNum >= obj->sizeSlots) {
            if (growSlots(ejs, obj, slotNum + 1) < 0) {
                ejsThrowMemoryError(ejs);
                return EJS_ERR;
            }
        }
        obj->numSlots = slotNum + 1;
    }
    mprAssert(obj->numSlots <= obj->sizeSlots);
    return slotNum;
}


/**
    Set the value of a property.
    @param slot If slot is -1, then allocate the next free slot
    @return Return the property slot if successful. Return < 0 otherwise.
 */
static int setObjectProperty(Ejs *ejs, EjsObj *obj, int slotNum, EjsObj *value)
{
    mprAssert(ejs);
    mprAssert(obj);
    
    if ((slotNum = ejsGetSlot(ejs, obj, slotNum)) < 0) {
        return EJS_ERR;
    }
    mprAssert(slotNum < obj->numSlots);
    mprAssert(obj->numSlots <= obj->sizeSlots);

    //  MOB -- remove this
    if (obj->permanent && (EjsObj*) obj != ejs->global && !value->permanent) {
        value->permanent = 1;
    }

    mprAssert(value);
    obj->slots[slotNum].value.ref = value;
    return slotNum;
}


/*
    Set the name for a property. Objects maintain a hash lookup for property names. This is hash is created on demand 
    if there are more than N properties. If an object is not dynamic, it will use the types name hash. If dynamic, 
    then the types name hash will be copied when required. 
    
    MOB WARNING: Callers must supply persistent names strings in qname
 */
static int setObjectPropertyName(Ejs *ejs, EjsObj *obj, int slotNum, EjsName *qname)
{
    mprAssert(obj);
    mprAssert(qname);

    if ((slotNum = ejsGetSlot(ejs, obj, slotNum)) < 0) {
        return EJS_ERR;
    }
    mprAssert(slotNum < obj->numSlots);

    /* Remove the old hash entry if the name will change */
    if (obj->slots[slotNum].hashChain >= 0) {
        if (CMP_QNAME(&obj->slots[slotNum].qname, qname)) {
            return slotNum;
        }
        removeHashEntry(ejs, obj, &obj->slots[slotNum].qname);
    }
    /* Set the property name. NOTE: the name must be persistent.  */
    obj->slots[slotNum].qname = *qname;
    
    mprAssert(slotNum < obj->numSlots);
    mprAssert(obj->numSlots <= obj->sizeSlots);
    
    if (obj->numSlots > EJS_HASH_MIN_PROP && qname->name) {
        if (hashProperty(obj, slotNum, qname) < 0) {
            ejsThrowMemoryError(ejs);
            return EJS_ERR;
        }
    }
#if BLD_DEBUG
    {
        EjsObj  *value;

        value = obj->slots[slotNum].value.ref;
        if (value != ejs->nullValue && *mprGetName(value) == '\0') {
            ejsSetDebugName(value, qname->name);
        }
    }
#endif
    return slotNum;
}


/*
    Set the property Trait. Grow traits if required.
 */
static int setObjectPropertyTrait(Ejs *ejs, EjsObj *obj, int slotNum, EjsType *type, int attributes)
{
    mprAssert(obj);
    mprAssert(slotNum >= 0);

    if ((slotNum = ejsGetSlot(ejs, obj, slotNum)) < 0) {
        return EJS_ERR;
    }
    obj->slots[slotNum].trait.type = type;
    obj->slots[slotNum].trait.attributes = attributes;
    return slotNum;
}


/*
    Grow and object and update numSlots and numTraits if required
 */
int ejsGrowObject(Ejs *ejs, EjsObj *obj, int numSlots)
{
    if (numSlots > obj->sizeSlots) {
        if (growSlots(ejs, obj, numSlots) < 0) {
            return EJS_ERR;
        }
    }
    if (numSlots > obj->numSlots) {
        obj->numSlots = numSlots;
    }
    return 0;
}


/*
    Grow the slots, traits, and names by the specified "incr". The new slots|traits|names are created at the "offset"
    Does not update numSlots or numTraits.
 */
int ejsInsertGrowObject(Ejs *ejs, EjsObj *obj, int incr, int offset)
{
    EjsFunction     *fun;
    EjsSlot         *sp;
    int             i, size, mark;

    mprAssert(obj);
    mprAssert(incr >= 0);

    if (incr < 0) {
        return 0;
    }
    size = obj->numSlots + incr;
    if (obj->sizeSlots < size) {
        if (growSlots(ejs, obj, size) < 0) {
            return EJS_ERR;
        }
    }
    obj->numSlots += incr;
    mprAssert(obj->numSlots <= obj->sizeSlots);
    for (mark = offset + incr, i = obj->numSlots - 1; i >= mark; i--) {
        sp = &obj->slots[i - mark];
        obj->slots[i] = *sp;
        if (ejsIsFunction(sp->value.ref)) {
            fun = (EjsFunction*) sp->value.ref;
            if (fun->owner == obj) {
                fun->slotNum = i;
            }
        }
    }
    ejsZeroSlots(ejs, &obj->slots[offset], incr);
    if (ejsMakeObjHash(obj) < 0) {
        return EJS_ERR;
    }   
    return 0;
}


/*
    Allocate or grow the slots storage for an object. Does not update numSlots.
 */
static int growSlots(Ejs *ejs, EjsObj *obj, int sizeSlots)
{
    EjsSlot     *slots;
    int         factor;

    mprAssert(obj);
    mprAssert(sizeSlots > 0);
    mprAssert(sizeSlots > obj->sizeSlots);

    if (sizeSlots > obj->sizeSlots) {
        //  MOB OPT - this could grow by more than just 16 each time for < 256
        if (obj->sizeSlots > EJS_LOTSA_PROP) {
            factor = max(obj->sizeSlots / 4, EJS_ROUND_PROP);
            sizeSlots = (sizeSlots + factor) / factor * factor;
        }
        sizeSlots = EJS_PROP_ROUNDUP(sizeSlots);

        if (obj->slots == 0) {
            mprAssert(obj->sizeSlots == 0);
            mprAssert(sizeSlots > 0);
            obj->slots = (EjsSlot*) mprAlloc(obj, sizeof(EjsSlot) * sizeSlots);
            if (obj->slots == 0) {
                return EJS_ERR;
            }
            ejsZeroSlots(ejs, obj->slots, sizeSlots);
            obj->separateSlots = 1;
        } else {
            if (obj->separateSlots) {
                mprAssert(obj->sizeSlots > 0);
                obj->slots = (EjsSlot*) mprRealloc(obj, obj->slots, sizeof(EjsSlot) * sizeSlots);
            } else {
                slots = (EjsSlot*) mprAlloc(obj, sizeof(EjsSlot) * sizeSlots);
                memcpy(slots, obj->slots, obj->sizeSlots * sizeof(EjsSlot));
                obj->slots = slots;
                obj->separateSlots = 1;
            }
            if (obj->slots == 0) {
                return EJS_ERR;
            }
            ejsZeroSlots(ejs, &obj->slots[obj->sizeSlots], (sizeSlots - obj->sizeSlots));
        }
        obj->sizeSlots = sizeSlots;
    }
    mprAssert(obj->numSlots <= obj->sizeSlots);
    return 0;
}


/*
    Remove a slot and name. Copy up all other properties. WARNING: this can only be used before property binding and 
    should only be used by the compiler.
 */
static void removeSlot(Ejs *ejs, EjsObj *obj, int slotNum, int compact)
{
    int         i;

    mprAssert(obj);
    mprAssert(slotNum >= 0);
    mprAssert(compact);

    if (compact) {
        for (i = slotNum + 1; i < obj->numSlots; i++) {
            obj->slots[i - 1] = obj->slots[i];
        }
        obj->numSlots--;
        i--;
    } else {
        i = slotNum;
    }
    ejsZeroSlots(ejs, &obj->slots[i], 1);
    ejsMakeObjHash(obj);
}


void ejsZeroSlots(Ejs *ejs, EjsSlot *slots, int count)
{
    EjsSlot     *sp;

    mprAssert(slots);
    mprAssert(count >= 0);

    if (slots) {
        for (sp = &slots[count - 1]; sp >= slots; sp--) {
            sp->value.ref = ejs->nullValue;
            sp->hashChain = -1;
            sp->qname.name = "";
            sp->qname.space = "";
            sp->trait.type = 0;
            sp->trait.attributes = 0;
            sp->value.ref = 0;
        }
    }
}


void ejsCopySlots(Ejs *ejs, EjsObj *obj, EjsSlot *dest, EjsSlot *src, int count, int dup)
{
    mprAssert(src);
    mprAssert(dest);
    mprAssert(count >= 0);

    while (count-- > 0) {
        *dest = *src;
        dest->hashChain = -1;
        dest->hashChain = -1;
        if (dup) {
            dest->qname.space = mprStrdup(obj, src->qname.space);
            dest->qname.name = mprStrdup(obj, src->qname.name);
        }
        dest++;
        src++;
    }
}


void ejsSetTraitType(EjsTrait *trait, EjsType *type)
{
    mprAssert(trait);
    mprAssert(type == 0 || ejsIsType(type));
    trait->type = type;
}


void ejsSetTraitAttributes(EjsTrait *trait, int attributes)
{
    mprAssert(trait);
    trait->attributes = attributes;
}


EjsTrait *ejsGetTrait(EjsObj *obj, int slotNum)
{
    mprAssert(obj);

    if (slotNum < 0 || slotNum >= obj->numSlots) {
        return 0;
    }
    return &obj->slots[slotNum].trait;
}


int ejsHasTrait(EjsObj *obj, int slotNum, int attributes)
{
    EjsTrait    *trait;

    if ((trait = ejsGetTrait(obj, slotNum)) != 0) {
        return (trait->attributes & attributes);
    }
    return 0;
}


EjsTrait *ejsGetAndMakeTrait(Ejs *ejs, EjsObj *obj, int slotNum)
{
    if ((slotNum = ejsGetSlot(ejs, obj, slotNum)) < 0) {
        return 0;
    }
    return &obj->slots[slotNum].trait;
}


int ejsGetTraitAttributes(EjsObj *obj, int slotNum)
{
    mprAssert(obj);
    mprAssert(slotNum >= 0);

    if (slotNum < 0 || slotNum >= obj->numSlots) {
        mprAssert(0);
        return 0;
    }
    return obj->slots[slotNum].trait.attributes;
}


EjsType *ejsGetTraitType(EjsObj *obj, int slotNum)
{
    mprAssert(obj);
    mprAssert(slotNum >= 0);

    if (slotNum < 0 || slotNum >= obj->numSlots) {
        mprAssert(0);
        return 0;
    }
    return obj->slots[slotNum].trait.type;
}


//  MOB -- remove
int ejsGetNumTraits(EjsObj *obj)
{
    if (obj == 0) {
        return 0;
    }
    return obj->numSlots;
}


int ejsRemoveProperty(Ejs *ejs, EjsObj *obj, int slotNum)
{
    EjsFunction *fun;
    int         i;
    
    mprAssert(ejs);
    mprAssert(obj);
    
    if (slotNum < 0 || slotNum >= obj->numSlots) {
        return EJS_ERR;
    }
    removeSlot(ejs, (EjsObj*) obj, slotNum, 1);

    //  MOB -- great to get rid of owner/slotNum

    for (i = slotNum; i < obj->numSlots; i++) {
        fun = (EjsFunction*) obj->slots[i].value.ref;
        if (!ejsIsFunction(fun)) {
            continue;
        }
        fun->slotNum--;
        if (fun->setter) {
            fun->setter->slotNum--;
        }
    }
    return 0;
}


/*
    Exponential primes
 */
static int hashSizes[] = {
     19, 29, 59, 79, 97, 193, 389, 769, 1543, 3079, 6151, 12289, 24593, 49157, 98317, 196613, 0
};


int ejsGetHashSize(int numSlots)
{
    int     i;

    for (i = 0; i < hashSizes[i]; i++) {
        if (numSlots < hashSizes[i]) {
            return hashSizes[i];
        }
    }
    return hashSizes[i - 1];
}


static int hashProperty(EjsObj *obj, int slotNum, EjsName *qname)
{
    EjsName     *slotName;
    int         chainSlotNum, lastSlot, index;

    mprAssert(qname);

    if (obj->sizeHash < obj->numSlots) {
        /*  Remake the entire hash */
        return ejsMakeObjHash(obj);
    }
    index = ejsComputeHashCode(obj, qname);

    /* Scan the collision chain */
    lastSlot = -1;
    chainSlotNum = obj->hash[index];
    mprAssert(chainSlotNum < obj->numSlots);
    mprAssert(chainSlotNum < obj->sizeSlots);

    while (chainSlotNum >= 0) {
        slotName = &obj->slots[chainSlotNum].qname;
        if (CMP_QNAME(slotName, qname)) {
            return 0;
        }
        mprAssert(lastSlot != chainSlotNum);
        lastSlot = chainSlotNum;
        mprAssert(chainSlotNum != obj->slots[chainSlotNum].hashChain);
        chainSlotNum = obj->slots[chainSlotNum].hashChain;
        mprAssert(0 <= lastSlot && lastSlot < obj->sizeSlots);
    }
    if (lastSlot >= 0) {
        mprAssert(lastSlot < obj->numSlots);
        mprAssert(lastSlot != slotNum);
        obj->slots[lastSlot].hashChain = slotNum;

    } else {
        /* Start a new hash chain */
        obj->hash[index] = slotNum;
    }
    obj->slots[slotNum].hashChain = -2;
    obj->slots[slotNum].qname = *qname;
    return 0;
}


/*
    Allocate or grow the properties storage for an object. This routine will also manage the hash index for the object. 
    If numInstanceProp is < 0, then grow the number of properties by an increment. Otherwise, set the number of properties 
    to numInstanceProp. We currently don't allow reductions.
 */
int ejsMakeObjHash(EjsObj *obj)
{
    EjsSlot         *sp;
    int             i, newHashSize, *oldHash;

    mprAssert(obj);

    if (obj->numSlots <= EJS_HASH_MIN_PROP && obj->hash == 0) {
        /* Too few properties */
        return 0;
    }
    /*
        Reallocate the hash buckets if the hash needs to grow larger
     */
    oldHash = obj->hash;
    newHashSize = ejsGetHashSize(obj->numSlots);
    if (obj->sizeHash < newHashSize) {
        mprFree(obj->hash);
        obj->hash = (int*) mprAlloc(obj, newHashSize * sizeof(int));
        if (obj->hash == 0) {
            return EJS_ERR;
        }
        obj->sizeHash = newHashSize;
    }
    mprAssert(obj->hash);
    memset(obj->hash, -1, obj->sizeHash * sizeof(int));

    /*
        Clear out hash linkage
     */
    if (oldHash) {
        for (sp = obj->slots, i = 0; i < obj->numSlots; i++, sp++) {
            sp->hashChain = -1;
        }
    }
    /*
        Rehash existing properties
     */
    for (sp = obj->slots, i = 0; i < obj->numSlots; i++, sp++) {
        if (sp->qname.name && hashProperty(obj, i, &sp->qname) < 0) {
            return EJS_ERR;
        }
    }
    return 0;
}


void ejsClearObjHash(EjsObj *obj)
{
    EjsSlot         *sp;
    int             i;

    mprAssert(obj);

    if (obj->hash) {
        memset(obj->hash, -1, obj->sizeHash * sizeof(int));
        for (sp = obj->slots, i = 0; i < obj->numSlots; i++, sp++) {
            sp->hashChain = -1;
        }
    }
}


static void removeHashEntry(Ejs *ejs, EjsObj *obj, EjsName *qname)
{
    EjsSlot     *sp;
    EjsName     *nextName;
    int         index, slotNum, lastSlot;

    if (obj->hash == 0) {
        /*
            No hash. Just do a linear search
         */
        for (slotNum = 0; slotNum < obj->numSlots; slotNum++) {
            sp = &obj->slots[slotNum];
            if (CMP_QNAME(&sp->qname, qname)) {
                sp->qname.name = "";
                sp->qname.space = "";
                sp->hashChain = -1;
                return;
            }
        }
        mprAssert(0);
        return;
    }
    index = ejsComputeHashCode(obj, qname);
    slotNum = obj->hash[index];
    lastSlot = -1;
    while (slotNum >= 0) {
        sp = &obj->slots[slotNum];
        nextName = &sp->qname;
        if (CMP_QNAME(nextName, qname)) {
            if (lastSlot >= 0) {
                obj->slots[lastSlot].hashChain = obj->slots[slotNum].hashChain;
            } else {
                obj->hash[index] = obj->slots[slotNum].hashChain;
            }
            sp->qname.name = "";
            sp->qname.space = "";
            sp->hashChain = -1;
            return;
        }
        lastSlot = slotNum;
        slotNum = obj->slots[slotNum].hashChain;
    }
    mprAssert(0);
}


/*
    Compute a property name hash. Based on work by Paul Hsieh.
 */
int ejsComputeHashCode(EjsObj *obj, EjsName *qname)
{
    uchar   *cdata;
    uint    len, hash, rem, tmp;

    mprAssert(obj);
    mprAssert(qname);
    mprAssert(qname->name);

    if ((len = (int) strlen(qname->name)) == 0) {
        return 0;
    }

    rem = len & 3;
    hash = len;

#if KEEP_FOR_UNICODE
    for (len >>= 2; len > 0; len--, data += 2) {
        hash  += *data;
        tmp   =  (data[1] << 11) ^ hash;
        hash  =  (hash << 16) ^ tmp;
        hash  += hash >> 11;
    }
#endif

    cdata = (uchar*) qname->name;
    for (len >>= 2; len > 0; len--, cdata += 4) {
        hash  += *cdata | (cdata[1] << 8);
        tmp   =  ((cdata[2] | (cdata[3] << 8)) << 11) ^ hash;
        hash  =  (hash << 16) ^ tmp;
        hash  += hash >> 11;
    }
    switch (rem) {
    case 3: 
        hash += cdata[0] + (cdata[1] << 8);
        hash ^= hash << 16;
        hash ^= cdata[sizeof(ushort)] << 18;
        hash += hash >> 11;
        break;
    case 2: 
        hash += cdata[0] + (cdata[1] << 8);
        hash ^= hash << 11;
        hash += hash >> 17;
        break;
    case 1: hash += cdata[0];
        hash ^= hash << 10;
        hash += hash >> 1;
    }

    /* 
        Force "avalanching" of final 127 bits 
     */
    hash ^= hash << 3;
    hash += hash >> 5;
    hash ^= hash << 4;
    hash += hash >> 17;
    hash ^= hash << 25;
    hash += hash >> 6;

    mprAssert(obj->sizeHash);
    return hash % obj->sizeHash;
}


static int cmpQname(EjsName *a, EjsName *b) 
{
    mprAssert(a);
    mprAssert(b);
    mprAssert(a->name);
    mprAssert(a->space);
    mprAssert(b->name);
    mprAssert(b->space);

    if (a->name == b->name && a->space == b->space) {
        return 1;
    }
    if (a->name[0] == b->name[0] && strcmp(a->name, b->name) == 0) {
        if (a->space[0] == b->space[0] && strcmp(a->space, b->space) == 0) {
            return 1;
        }
    }
    return 0;
}

/*
    WARNING: All methods here may be invoked by Native classes that are based on EjsObj and not on EjsObj. Because 
    all classes subclass Object, they need to be able to use these methods. They MUST NOT use EjsObj internals.
 */


/*
    static function get prototype(): Object
 */
static EjsObj *obj_prototype(Ejs *ejs, EjsType *type, int argc, EjsObj **argv)
{
    mprAssert(ejsIsType(type));

    if (type->prototype == 0) {
        if ((type->prototype = ejsCreatePrototype(ejs, type, 0)) == 0) {
            return 0;
        }
        ejsSetProperty(ejs, (EjsObj*) type, ES_Object, type->prototype);
    }
    return type->prototype;
}


//  MOB -- complete
static EjsObj *obj_constructor(Ejs *ejs, EjsType *type, int argc, EjsObj **argv)
{
    return (EjsObj*) 0;
}


/*
    native function clone(deep: Boolean = true) : Object
 */
static EjsObj *obj_clone(Ejs *ejs, EjsObj *obj, int argc, EjsObj **argv)
{
    bool    deep;

    deep = (argc == 1 && argv[0] == (EjsObj*) ejs->trueValue);
    return ejsClone(ejs, obj, deep);
}


/*
    static function create(proto, props: Object = undefined): Void 
*/
static EjsObj *obj_create(Ejs *ejs, EjsObj *type, int argc, EjsObj **argv)
{
    EjsObj      *obj, *properties, *options;
    EjsType     *prototype;
    EjsName     qname;
    int         count, slotNum;

    prototype = (EjsType*) argv[0];
    properties = (argc >= 1) ? argv[1] : 0;

    if (!ejsIsType(prototype)) {
        ejsThrowArgError(ejs, "Prototype argument is not a prototype");
        return 0;
    }
    obj = ejsCreateObject(ejs, prototype, 0);
    if (properties) {
        count = ejsGetPropertyCount(ejs, properties);
        for (slotNum = 0; slotNum < count; slotNum++) {
            qname = ejsGetPropertyName(ejs, properties, slotNum);
            options = ejsGetProperty(ejs, properties, slotNum);
            argv[0] = obj;
            argv[1] = (EjsObj*) ejsCreateString(ejs, qname.name);
            argv[2] = options;
            obj_defineProperty(ejs, type, 3, argv);
        }
    }
    return (EjsObj*) obj;
}


/*
    static native function defineProperty(obj: Object, prop: String, options: Object): Void
*/
static EjsObj *obj_defineProperty(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    EjsFunction     *fun, *get, *set;
    EjsType         *type;
    EjsObj          *obj, *options, *configurable, *enumerable, *namespace, *value, *writable;
    EjsName         qname;
    char            *space, *name;
    int             attributes, slotNum;

    mprAssert(argc == 3);

    obj = argv[0];
    name = (char*) mprStrdup(obj, ejsGetString(ejs, argv[1]));
    options = argv[2];
    space = (char*) "";
    value = 0;
    set = get = 0;
    attributes = 0;

    if ((namespace = ejsGetPropertyByName(ejs, options, EN(&qname, "namespace"))) != 0) {
        space = (char*) mprStrdup(ejs, ejsGetString(ejs, namespace));
    }
    if ((slotNum = ejsLookupProperty(ejs, obj, ejsName(&qname, space, name))) >= 0) {
        if (ejsHasTrait(obj, slotNum, EJS_TRAIT_FIXED)) {
            ejsThrowTypeError(ejs, "Property \"%s\" is not configurable", qname.name);
            return 0;
        }
    }
    type = (EjsType*) ejsGetPropertyByName(ejs, options, EN(&qname, "type"));

    if ((configurable = ejsGetPropertyByName(ejs, options, EN(&qname, "configurable"))) != 0) {
        if (configurable == (EjsObj*) ejs->falseValue) {
            attributes |= EJS_TRAIT_FIXED;
        }
    }
    if ((enumerable = ejsGetPropertyByName(ejs, options, EN(&qname, "enumerable"))) != 0) {
        if (enumerable == (EjsObj*) ejs->falseValue) {
            attributes |= EJS_TRAIT_HIDDEN;
        }
    }
    value = ejsGetPropertyByName(ejs, options, EN(&qname, "value"));
    if (value && type && !ejsIsA(ejs, value, type)) {
        ejsThrowArgError(ejs, "Value is not of the required type");
        return 0;
    }

    if ((get = (EjsFunction*) ejsGetPropertyByName(ejs, options, EN(&qname, "get"))) != 0) {
        if (ejsIsFunction(get)) {
            get->setter = (EjsFunction*) ejsGetPropertyByName(ejs, obj, ejsName(&qname, space, "set"));
            attributes |= EJS_TRAIT_GETTER;
        } else {
            ejsThrowArgError(ejs, "The \"get\" property is not a function");
            return 0;
        }
    }
    if ((set = (EjsFunction*) ejsGetPropertyByName(ejs, options, EN(&qname, "set"))) != 0) {
        if (ejsIsFunction(set)) {
            if (get == 0 && (fun = (EjsFunction*) ejsGetPropertyByName(ejs, obj, ejsName(&qname, space, name))) != 0) {
                get = fun;
            }
            if (get) {
                get->setter = set;
            }
        } else {
            ejsThrowArgError(ejs, "The \"set\" property is not a function");
            return 0;
        }
        attributes |= EJS_TRAIT_SETTER;
    }
    if (value && (get || set)) {
        ejsThrowArgError(ejs, "Can't provide a value and getters or setters");
        return 0;
    }
    if (get) {
        value = (EjsObj*) get;
    }
    if ((writable = ejsGetPropertyByName(ejs, options, EN(&qname, "writable"))) != 0) {
        if (writable == (EjsObj*) ejs->falseValue) {
            attributes |= EJS_TRAIT_READONLY;
        }
    }
    ejsName(&qname, space, name);
    if (defineObjectProperty(ejs, obj, -1, ejsName(&qname, space, name), type, attributes, value) < 0) {
        ejsThrowTypeError(ejs, "Can't define property %s", name);
    }
    return 0;
}


/*
    static native function freeze(obj: Object): Void
*/
static EjsObj *obj_freeze(Ejs *ejs, EjsObj *type, int argc, EjsObj **argv)
{
    EjsTrait    *trait;
    EjsObj      *obj;
    int         slotNum;

    obj = argv[0];
    for (slotNum = 0; slotNum < obj->numSlots; slotNum++) {
        if ((trait = ejsGetAndMakeTrait(ejs, obj, slotNum)) == 0) {
            return 0;
        }
        trait->attributes |= EJS_TRAIT_READONLY | EJS_TRAIT_FIXED;
    }
    obj->dynamic = 0;
    return 0;
}


/*
    Function to iterate and return the next element name.
    NOTE: this is not a method of Object. Rather, it is a callback function for Iterator.
 */
static EjsObj *nextObjectKey(Ejs *ejs, EjsIterator *ip, int argc, EjsObj **argv)
{
    EjsObj      *obj;
    EjsName     qname;
    EjsTrait    *trait;

    obj = (EjsObj*) ip->target;

    for (; ip->index < obj->numSlots; ip->index++) {
        qname = ejsGetPropertyName(ejs, (EjsObj*) obj, ip->index);
        if (qname.name[0] == '\0') {
            continue;
        }
        trait = ejsGetPropertyTrait(ejs, obj, ip->index);
        if (trait && trait->attributes & (EJS_TRAIT_HIDDEN | EJS_TRAIT_DELETED | EJS_FUN_INITIALIZER)) {
            continue;
        }
        ip->index++;
        return (EjsObj*) ejsCreateString(ejs, qname.name);
    }
    ejsThrowStopIteration(ejs);
    return 0;
}


/*
    Return the default iterator.

    iterator native function get(options: Object = null): Iterator
 */
static EjsObj *obj_get(Ejs *ejs, EjsObj *obj, int argc, EjsObj **argv)
{
    EjsObj      *namespaces;
    bool        deep;

    deep = 0;
    namespaces = 0;
    return (EjsObj*) ejsCreateIterator(ejs, obj, (EjsProc) nextObjectKey, deep, (EjsArray*) namespaces);
}


/*
    Function to iterate and return the next element value.
    NOTE: this is not a method of Object. Rather, it is a callback function for Iterator
 */
static EjsObj *nextObjectValue(Ejs *ejs, EjsIterator *ip, int argc, EjsObj **argv)
{
    EjsObj      *obj;
    EjsTrait    *trait;

    obj = (EjsObj*) ip->target;

    for (; ip->index < obj->numSlots; ip->index++) {
        trait = ejsGetPropertyTrait(ejs, obj, ip->index);
        if (trait && trait->attributes & (EJS_TRAIT_HIDDEN | EJS_TRAIT_DELETED | EJS_FUN_INITIALIZER)) {
            continue;
        }
        return obj->slots[ip->index++].value.ref;
    }
    ejsThrowStopIteration(ejs);
    return 0;
}


/*
    Return an iterator to return the next array element value.

    iterator native function getValues(options: Object = null): Iterator
 */
static EjsObj *obj_getValues(Ejs *ejs, EjsObj *obj, int argc, EjsObj **argv)
{
    EjsObj      *namespaces;
    bool        deep;

    deep = 0;
    namespaces = 0;
    return (EjsObj*) ejsCreateIterator(ejs, obj, (EjsProc) nextObjectValue, deep, (EjsArray*) namespaces);
}


/*
    static native function getOwnPropertyDescriptor(obj: Object, prop: String): Object
 */
static EjsObj *obj_getOwnPropertyDescriptor(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    EjsFunction     *fun;
    EjsTrait        *trait;
    EjsObj          *obj, *result, *value;
    EjsName         qname, qn;
    EjsType         *type;
    EjsLookup       lookup;
    cchar           *prop;
    int             slotNum;

    obj = argv[0];
    prop = ejsGetString(ejs, argv[1]);
    if ((slotNum = ejsLookupVarWithNamespaces(ejs, obj, obj, EN(&qname, prop), &lookup)) < 0) {
        return (EjsObj*) ejs->falseValue;
    }
    trait = ejsGetTrait(obj, slotNum);
    result = ejsCreateSimpleObject(ejs);
    value = ejsGetVarByName(ejs, obj, EN(&qname, prop), &lookup);
    if (value == 0) {
        value = ejs->nullValue;
    }
    type = (trait) ? trait->type: 0;
    if (trait && trait->attributes & EJS_TRAIT_GETTER) {
        ejsSetPropertyByName(ejs, result, EN(&qname, "get"), value);
    } else if (trait && trait->attributes & EJS_TRAIT_SETTER) {
        fun = (EjsFunction*) value;
        if (ejsIsFunction(fun)) {
            ejsSetPropertyByName(ejs, result, EN(&qname, "set"), (EjsObj*) fun->setter);
        }
    } else if (value) {
        ejsSetPropertyByName(ejs, result, EN(&qname, "value"), value);
    }
    ejsSetPropertyByName(ejs, result, EN(&qname, "configurable"), (EjsObj*) 
        ejsCreateBoolean(ejs, !trait || !(trait->attributes & EJS_TRAIT_FIXED)));
    ejsSetPropertyByName(ejs, result, EN(&qname, "enumerable"), (EjsObj*) 
        ejsCreateBoolean(ejs, !trait || !(trait->attributes & EJS_TRAIT_HIDDEN)));
    qn = ejsGetPropertyName(ejs, obj, slotNum);
    ejsSetPropertyByName(ejs, result, EN(&qname, "namespace"), (EjsObj*) ejsCreateString(ejs, qn.space));
    ejsSetPropertyByName(ejs, result, EN(&qname, "type"), 
         type ? (EjsObj*) type : ejs->nullValue);
    ejsSetPropertyByName(ejs, result, EN(&qname, "writable"), (EjsObj*) 
        ejsCreateBoolean(ejs, !trait || !(trait->attributes & EJS_TRAIT_READONLY)));
    return result;
}


/*
    Get all properties names including non-enumerable properties

    static native function getOwnPropertyNames(obj: Object): Array
 */
static EjsObj *obj_getOwnPropertyNames(Ejs *ejs, EjsObj *type, int argc, EjsObj **argv)
{
    EjsObj      *obj;
    EjsArray    *result;
    EjsTrait    *trait;
    EjsName     qname;
    int         slotNum, index;

    obj = argv[0];
    if ((result = ejsCreateArray(ejs, 0)) == 0) {
        return 0;
    }
    for (index = slotNum = 0; slotNum < obj->numSlots; slotNum++) {
        if ((trait = ejsGetTrait(obj, slotNum)) != 0) {
            if (trait->attributes & (EJS_TRAIT_DELETED | EJS_FUN_INITIALIZER)) {
                continue;
            }
            if (ejsIsType(obj) && !(trait->attributes & EJS_PROP_STATIC)) {
                continue;
            }
        }
        qname = ejsGetPropertyName(ejs, obj, slotNum);
        if (qname.name[0] == '\0') {
            continue;
        }
        ejsSetProperty(ejs, (EjsObj*) result, index++, (EjsObj*) ejsCreateString(ejs, qname.name));
    }
    return (EjsObj*) result;
}


/*
    static native function getOwnPrototypeOf(obj: Object): Type
 */
static EjsObj *obj_getOwnPrototypeOf(Ejs *ejs, EjsObj *type, int argc, EjsObj **argv)
{
    EjsObj      *obj;

    obj = argv[0];
    return (EjsObj*) obj->type;
}


/*
    native function hasOwnProperty(name: String): Boolean
 */
static EjsObj *obj_hasOwnProperty(Ejs *ejs, EjsObj *obj, int argc, EjsObj **argv)
{
    EjsName     qname;
    EjsLookup   lookup;
    int         slotNum;
    cchar       *prop;

    prop = ejsGetString(ejs, argv[0]);
    slotNum = ejsLookupVarWithNamespaces(ejs, obj, obj, EN(&qname, prop), &lookup);
    return (EjsObj*) ejsCreateBoolean(ejs, slotNum >= 0);
}


//  MOB -- object should not have a length
/*
    Get the length for the object.

    intrinsic function get length(): Number
 */
static EjsObj *obj_length(Ejs *ejs, EjsObj *vp, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateNumber(ejs, ejsGetPropertyCount(ejs, vp));
}


/*
    static native function isExtensible(obj: Object): Boolean
 */
static EjsObj *obj_isExtensible(Ejs *ejs, EjsObj *type, int argc, EjsObj **argv)
{
    EjsObj      *obj;

    obj = argv[0];
    return (EjsObj*) ejsCreateBoolean(ejs, obj->dynamic);
}


/*
    static native function isFrozen(obj: Object): Boolean
 */
static EjsObj *obj_isFrozen(Ejs *ejs, EjsObj *type, int argc, EjsObj **argv)
{
    EjsTrait    *trait;
    EjsObj      *obj;
    int         frozen, slotNum;

    obj = argv[0];
    frozen = 1;
    for (slotNum = 0; slotNum < obj->numSlots; slotNum++) {
        if ((trait = ejsGetTrait(obj, slotNum)) != 0) {
            if (!(trait->attributes & EJS_TRAIT_READONLY)) {
                frozen = 0;
                break;
            }
            if (!(trait->attributes & EJS_TRAIT_FIXED)) {
                frozen = 0;
                break;
            }
        }
    }
    if (obj->dynamic) {
        frozen = 0;
    }
    return (EjsObj*) ejsCreateBoolean(ejs, frozen);
}


/*
    static native function isPrototypeOf(obj: Object): Boolean
 */
static EjsObj *obj_isPrototypeOf(Ejs *ejs, EjsObj *prototype, int argc, EjsObj **argv)
{
    EjsObj  *obj;
    
    obj = argv[0];
    return (EjsObj*) ejsCreateBoolean(ejs, ejsIsA(ejs, obj, (EjsType*) prototype));
}


/*
    static native function isSealed(obj: Object): Boolean
 */
static EjsObj *obj_isSealed(Ejs *ejs, EjsObj *type, int argc, EjsObj **argv)
{
    EjsTrait    *trait;
    EjsObj      *obj;
    int         sealed, slotNum;

    obj = argv[0];
    sealed = 1;
    for (slotNum = 0; slotNum < obj->numSlots; slotNum++) {
        if ((trait = ejsGetTrait(obj, slotNum)) != 0) {
            if (!(trait->attributes & EJS_TRAIT_FIXED)) {
                sealed = 0;
                break;
            }
        }
    }
    if (obj->dynamic) {
        sealed = 0;
    }
    return (EjsObj*) ejsCreateBoolean(ejs, sealed);
}


#if FUTURE
/*
    Get enumerable properties names

    static native function keys(obj: Object): Array
 */
static EjsObj *obj_keys(Ejs *ejs, EjsObj *type, int argc, EjsObj **argv)
{
    EjsObj      *obj, *vp;
    EjsArray    *result;
    EjsTrait    *trait;
    EjsName     qname;
    int         slotNum;

    obj = argv[0];
    if ((result = ejsCreateArray(ejs, obj->numSlots)) == 0) {
        return 0;
    }
    for (slotNum = 0; slotNum < obj->numSlots; slotNum++) {
        if ((trait = ejsGetTrait(obj, slotNum)) != 0) {
            if (trait->attributes & EJS_TRAIT_DELETED) {
                continue;
            }
        }
        vp = ejsGetProperty(ejs, obj, slotNum);
        qname = ejsGetPropertyName(ejs, obj, slotNum);
        ejsSetProperty(ejs, (EjsObj*) result, slotNum, (EjsObj*) ejsCreateString(ejs, qname.name));
    }
    return (EjsObj*) result;
}
#endif


/*
    static native function preventExtensions(obj: Object): Object
 */
static EjsObj *obj_preventExtensions(Ejs *ejs, EjsObj *type, int argc, EjsObj **argv)
{
    EjsObj      *obj;

    obj = argv[0];
    obj->dynamic = 0;
    return obj;
}


/*
    static native function seal(obj: Object): Void
*/
static EjsObj *obj_seal(Ejs *ejs, EjsObj *type, int argc, EjsObj **argv)
{
    EjsTrait    *trait;
    EjsObj      *obj;
    int         slotNum;

    obj = argv[0];
    for (slotNum = 0; slotNum < obj->numSlots; slotNum++) {
        if ((trait = ejsGetAndMakeTrait(ejs, obj, slotNum)) == 0) {
            return 0;
        }
        trait->attributes |= EJS_TRAIT_FIXED;
    }
    obj->dynamic = 0;
    return 0;
}


/*
    intrinsic native function propertyIsEnumerable(property: String, flag: Object = undefined): Boolean
 */
static EjsObj *obj_propertyIsEnumerable(Ejs *ejs, EjsObj *obj, int argc, EjsObj **argv)
{
    EjsTrait    *trait;
    EjsName     qname;
    EjsLookup   lookup;
    cchar       *prop;
    int         slotNum;

    mprAssert(argc == 1 || argc == 2);

    prop = ejsGetString(ejs, argv[0]);
    if ((slotNum = ejsLookupVarWithNamespaces(ejs, obj, obj, EN(&qname, prop), &lookup)) < 0) {
        return (EjsObj*) ejs->falseValue;
    }
    trait = ejsGetTrait(obj, slotNum);
    return (EjsObj*) ejsCreateBoolean(ejs, !trait || !(trait->attributes & EJS_TRAIT_HIDDEN));
}


/*
    Convert the object to a JSON string. This also handles Json for Arrays.

    function toJSON(options: Object = null): String

    Options: baseClasses, depth, indent, hidden, pretty, replacer
 */
static EjsObj *obj_toJSON(Ejs *ejs, EjsObj *vp, int argc, EjsObj **argv)
{
    MprBuf      *buf;
    EjsObj      *arg, *pp, *result;
    EjsName     qname;
    EjsObj      *obj, *options, *replacerArgs[2];
    EjsFunction *replacer;
    EjsString   *sv;
    EjsTrait    *trait;
    char        key[16], *cp, *indent;
    int         c, isArray, i, count, slotNum, depth, hidden, baseClasses, namespaces, pretty;

    /*
        The main code below can handle Arrays, Objects, objects derrived from Object and also native classes with properties.
        All others just use toString
     */
    count = ejsGetPropertyCount(ejs, vp);
    if (count == 0 && vp->type != ejs->objectType && vp->type != ejs->arrayType) {
        return (EjsObj*) ejsToString(ejs, vp);
    }
    depth = 99;
    baseClasses = hidden = namespaces = pretty = 0;
    replacer = NULL;
    indent = NULL;
    options = NULL;
    
    if (argc > 0) {
        options = argv[0];
        if ((arg = ejsGetPropertyByName(ejs, options, EN(&qname, "baseClasses"))) != 0) {
            baseClasses = (arg == (EjsObj*) ejs->trueValue);
        }
        if ((arg = ejsGetPropertyByName(ejs, options, EN(&qname, "depth"))) != 0) {
            depth = ejsGetInt(ejs, arg);
        }
        if ((arg = ejsGetPropertyByName(ejs, options, EN(&qname, "indent"))) != 0) {
            if (ejsIsString(arg)) {
               indent = ((EjsString*) arg)->value; 
            } else if (ejsIsNumber(arg)) {
                i = ejsGetInt(ejs, arg);
                if (i < 0 || i >= MPR_MAX_STRING) {
                    indent = NULL;
                } else {
                    indent = mprAlloc(arg, i + 1);
                    memset(indent, ' ', i);
                }
            }
        }
        if ((arg = ejsGetPropertyByName(ejs, options, EN(&qname, "hidden"))) != 0) {
            hidden = (arg == (EjsObj*) ejs->trueValue);
        }
        if ((arg = ejsGetPropertyByName(ejs, options, EN(&qname, "namespaces"))) != 0) {
            namespaces = (arg == (EjsObj*) ejs->trueValue);
        }
        if ((arg = ejsGetPropertyByName(ejs, options, EN(&qname, "pretty"))) != 0) {
            pretty = (arg == (EjsObj*) ejs->trueValue);
        }
        replacer = (EjsFunction*) ejsGetPropertyByName(ejs, options, EN(&qname, "replacer"));
        if (!ejsIsFunction(replacer)) {
            replacer = NULL;
        }
    }
    isArray = ejsIsArray(vp);

    obj = (EjsObj*) vp;
    buf = mprCreateBuf(ejs, 0, 0);
    mprPutCharToBuf(buf, isArray ? '[' : '{');
    if (pretty || indent) {
        mprPutCharToBuf(buf, '\n');
    }

    if (++ejs->serializeDepth <= depth) {
        for (slotNum = 0; slotNum < count && !ejs->exception; slotNum++) {
            trait = ejsGetPropertyTrait(ejs, obj, slotNum);
            if (trait && (trait->attributes & (EJS_TRAIT_HIDDEN | EJS_TRAIT_DELETED | EJS_FUN_INITIALIZER)) && !hidden) {
                continue;
            }
            pp = ejsGetProperty(ejs, obj, slotNum);
            if (ejs->exception) {
                return 0;
            }
            if (pp == 0 || (pp->hidden && !hidden)) {
                continue;
            }
            if (isArray) {
                mprItoa(key, sizeof(key), slotNum, 10);
                qname.name = key;
                qname.space = "";
            } else {
                qname = ejsGetPropertyName(ejs, vp, slotNum);
            }
            if (qname.name == 0) {
                continue;
            }
            if (qname.space[0] == '\0' && qname.name[0] == '\0') {
                continue;
            }
            if (pretty) {
                for (i = 0; i < ejs->serializeDepth; i++) {
                    mprPutStringToBuf(buf, "  ");
                }
            } else {
                if (indent) {
                    mprPutStringToBuf(buf, indent);
                }
            }
            if (!isArray) {
                if (namespaces) {
                    if (qname.space[0] != EJS_EMPTY_NAMESPACE[0]) {
                        mprPutFmtToBuf(buf, "\"%s\"::", qname.space);
                    }
                }
                mprPutCharToBuf(buf, '"');
                for (cp = (char*) qname.name; cp && *cp; cp++) {
                    c = *cp;
                    if (c == '"' || c == '\\') {
                        mprPutCharToBuf(buf, '\\');
                        mprPutCharToBuf(buf, c);
                    } else {
                        mprPutCharToBuf(buf, c);
                    }
                }
                mprPutStringToBuf(buf, "\":");
                if (pretty || indent) {
                    mprPutCharToBuf(buf, ' ');
                }
            }
            sv = (EjsString*) ejsToJSON(ejs, pp, options);
            if (sv == 0 || !ejsIsString(sv)) {
                if (!ejs->exception) {
                    ejsThrowTypeError(ejs, "Can't serialize property %s", qname.name);
                }
                return 0;
            } else {
                if (replacer) {
                    replacerArgs[0] = (EjsObj*) ejsCreateString(ejs, qname.name); 
                    replacerArgs[1] = (EjsObj*) sv; 
                    pp = ejsRunFunction(ejs, replacer, obj, 2, replacerArgs);
                }
                mprPutStringToBuf(buf, sv->value);
            }
            if ((slotNum + 1) < count) {
                mprPutCharToBuf(buf, ',');
            }
            if (pretty || indent) {
                mprPutCharToBuf(buf, '\n');
            }
        }
    }
    --ejs->serializeDepth; 
    if (pretty || indent) {
        for (i = ejs->serializeDepth; i > 0; i--) {
            mprPutStringToBuf(buf, "  ");
        }
    }
    mprPutCharToBuf(buf, isArray ? ']' : '}');
    mprAddNullToBuf(buf);
    result = (EjsObj*) ejsCreateString(ejs, mprGetBufStart(buf));
    mprFree(buf);
    return result;
}


#if ES_Object_toLocaleString
/*
    Convert the object to a localized string

    intrinsic function toLocaleString(): String
 */
static EjsObj *toLocaleString(Ejs *ejs, EjsObj *vp, int argc, EjsObj **argv)
{
    return obj_toString(ejs, vp, argc, argv);
}
#endif


static EjsObj *obj_toString(Ejs *ejs, EjsObj *vp, int argc, EjsObj **argv)
{
    if (ejsIsString(vp)) {
        return vp;
    }
    return (EjsObj*) castObject(ejs, vp, ejs->stringType);
}


/*
    Create the object type
 */
void ejsCreateObjectType(Ejs *ejs)
{
    EjsType         *type;
    EjsTypeHelpers  *helpers;

    type = ejs->objectType = ejsCreateNativeType(ejs, "ejs", "Object", ES_Object, sizeof(EjsObj));

    helpers = type->helpers = (EjsTypeHelpers*) mprAllocZeroed(ejs, sizeof(EjsTypeHelpers));

    helpers->name                   = "object-helpers";
    helpers->cast                   = (EjsCastHelper) castObject;
    helpers->clone                  = (EjsCloneHelper) ejsCloneObject;
    helpers->create                 = (EjsCreateHelper) ejsCreateObject;
    helpers->defineProperty         = (EjsDefinePropertyHelper) defineObjectProperty;
    helpers->deleteProperty         = (EjsDeletePropertyHelper) deleteObjectProperty;
    helpers->deletePropertyByName   = (EjsDeletePropertyByNameHelper) deleteObjectPropertyByName;
    helpers->destroy                = (EjsDestroyHelper) destroyObject;
    helpers->getProperty            = (EjsGetPropertyHelper) getObjectProperty;
    helpers->getPropertyCount       = (EjsGetPropertyCountHelper) getObjectPropertyCount;
    helpers->getPropertyName        = (EjsGetPropertyNameHelper) getObjectPropertyName;
    helpers->getPropertyTrait       = (EjsGetPropertyTraitHelper) getObjectPropertyTrait;
    helpers->lookupProperty         = (EjsLookupPropertyHelper) lookupObjectProperty;
    helpers->invokeOperator         = (EjsInvokeOperatorHelper) ejsObjectOperator;
    helpers->mark                   = (EjsMarkHelper) ejsMarkObject;
    helpers->setProperty            = (EjsSetPropertyHelper) setObjectProperty;
    helpers->setPropertyName        = (EjsSetPropertyNameHelper) setObjectPropertyName;
    helpers->setPropertyTrait       = (EjsSetPropertyTraitHelper) setObjectPropertyTrait;
}


void ejsConfigureObjectType(Ejs *ejs)
{
    EjsType         *type;

    type = ejsGetTypeByName(ejs, "ejs", "Object");

    ejsBindMethod(ejs, type, ES_Object_constructor, (EjsProc) obj_constructor);
    ejsBindMethod(ejs, type, ES_Object_prototype, (EjsProc) obj_prototype);
    ejsBindMethod(ejs, type, ES_Object_clone, obj_clone);
    ejsBindMethod(ejs, type, ES_Object_create, obj_create);
    ejsBindMethod(ejs, type, ES_Object_defineProperty, obj_defineProperty);
    ejsBindMethod(ejs, type, ES_Object_freeze, obj_freeze);
    ejsBindMethod(ejs, type, ES_Object_get, obj_get);
    ejsBindMethod(ejs, type, ES_Object_getOwnPropertyDescriptor, obj_getOwnPropertyDescriptor);
    ejsBindMethod(ejs, type, ES_Object_getOwnPropertyNames, obj_getOwnPropertyNames);
    ejsBindMethod(ejs, type, ES_Object_getOwnPrototypeOf, obj_getOwnPrototypeOf);
    ejsBindMethod(ejs, type, ES_Object_getValues, obj_getValues);
    ejsBindMethod(ejs, type, ES_Object_hasOwnProperty, obj_hasOwnProperty);
    ejsBindMethod(ejs, type, ES_Object_isExtensible, obj_isExtensible);
    ejsBindMethod(ejs, type, ES_Object_isFrozen, obj_isFrozen);
    ejsBindMethod(ejs, type, ES_Object_isPrototypeOf, obj_isPrototypeOf);
    ejsBindMethod(ejs, type, ES_Object_isSealed, obj_isSealed);

    //  MOB -- change back to public
    ejsBindMethod(ejs, type, ES_Object_length, obj_length);
    ejsBindMethod(ejs, type, ES_Object_preventExtensions, obj_preventExtensions);
    ejsBindMethod(ejs, type, ES_Object_propertyIsEnumerable, obj_propertyIsEnumerable);
    ejsBindMethod(ejs, type, ES_Object_seal, obj_seal);
    ejsBindMethod(ejs, type, ES_Object_toLocaleString, toLocaleString);
    ejsBindMethod(ejs, type, ES_Object_toString, obj_toString);
    ejsBindMethod(ejs, type, ES_Object_toJSON, obj_toJSON);
}

/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2010. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2010. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    @end
 */
/************************************************************************/
/*
 *  End of file "../src/core/src/ejsObject.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../src/core/src/ejsPath.c"
 */
/************************************************************************/

/*
    ejsPath.c - Path class.

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */




static char *getPathString(Ejs *ejs, EjsObj *vp);


static EjsPath *clonePath(Ejs *ejs, EjsPath *src, bool deep)
{
    EjsPath     *dest;

    dest = (EjsPath*) ejsCloneObject(ejs, (EjsObj*) src, deep);

    dest->info = src->info;
    dest->path = mprStrdup(dest, src->path);
    return dest;
}


//  TODO - should not need this
static void destroyPath(Ejs *ejs, EjsPath *pp)
{
    mprAssert(pp);

    mprFree(pp->path);
    pp->path = 0;
    ejsFree(ejs, (EjsObj*) pp, -1);
}


static EjsObj *coercePathOperands(Ejs *ejs, EjsPath *lhs, int opcode,  EjsObj *rhs)
{
    switch (opcode) {
    /*
        Binary operators
     */
    case EJS_OP_ADD:
        return ejsInvokeOperator(ejs, (EjsObj*) ejsCreateString(ejs, lhs->path), opcode, rhs);

    case EJS_OP_COMPARE_EQ: case EJS_OP_COMPARE_NE:
    case EJS_OP_COMPARE_LE: case EJS_OP_COMPARE_LT:
    case EJS_OP_COMPARE_GE: case EJS_OP_COMPARE_GT:
        if (ejsIsNull(rhs) || ejsIsUndefined(rhs)) {
            return (EjsObj*) ((opcode == EJS_OP_COMPARE_EQ) ? ejs->falseValue: ejs->trueValue);
        }
        return ejsInvokeOperator(ejs, (EjsObj*) ejsCreateString(ejs, lhs->path), opcode, rhs);

    case EJS_OP_COMPARE_STRICTLY_NE:
        return (EjsObj*) ejs->trueValue;

    case EJS_OP_COMPARE_STRICTLY_EQ:
        return (EjsObj*) ejs->falseValue;

    case EJS_OP_COMPARE_NOT_ZERO:
    case EJS_OP_COMPARE_TRUE:
        return (EjsObj*) ejs->trueValue;

    case EJS_OP_COMPARE_ZERO:
    case EJS_OP_COMPARE_FALSE:
        return (EjsObj*) ejs->falseValue;

    case EJS_OP_COMPARE_UNDEFINED:
    case EJS_OP_COMPARE_NULL:
        return (EjsObj*) ejs->falseValue;

    default:
        ejsThrowTypeError(ejs, "Opcode %d not valid for type %s", opcode, lhs->obj.type->qname.name);
        return ejs->undefinedValue;
    }
    return 0;
}


static EjsObj *invokePathOperator(Ejs *ejs, EjsPath *lhs, int opcode,  EjsPath *rhs, void *data)
{
    EjsObj      *result;

    if (rhs == 0 || lhs->obj.type != rhs->obj.type) {
        if ((result = coercePathOperands(ejs, lhs, opcode, (EjsObj*) rhs)) != 0) {
            return result;
        }
    }

    /*  Types now match, both paths
     */
    switch (opcode) {
    case EJS_OP_COMPARE_STRICTLY_EQ:
    case EJS_OP_COMPARE_EQ:
        if (lhs == rhs || (lhs->path == rhs->path)) {
            return (EjsObj*) ejs->trueValue;
        }
        return (EjsObj*) ejsCreateBoolean(ejs,  mprStrcmp(lhs->path, rhs->path) == 0);

    case EJS_OP_COMPARE_NE:
    case EJS_OP_COMPARE_STRICTLY_NE:
        return (EjsObj*) ejsCreateBoolean(ejs,  mprStrcmp(lhs->path, rhs->path) != 0);

    case EJS_OP_COMPARE_LT:
        return (EjsObj*) ejsCreateBoolean(ejs,  mprStrcmp(lhs->path, rhs->path) < 0);

    case EJS_OP_COMPARE_LE:
        return (EjsObj*) ejsCreateBoolean(ejs,  mprStrcmp(lhs->path, rhs->path) <= 0);

    case EJS_OP_COMPARE_GT:
        return (EjsObj*) ejsCreateBoolean(ejs,  mprStrcmp(lhs->path, rhs->path) > 0);

    case EJS_OP_COMPARE_GE:
        return (EjsObj*) ejsCreateBoolean(ejs,  mprStrcmp(lhs->path, rhs->path) >= 0);

    /*
        Unary operators
     */
    case EJS_OP_COMPARE_NOT_ZERO:
        return (EjsObj*) ((lhs->path) ? ejs->trueValue: ejs->falseValue);

    case EJS_OP_COMPARE_ZERO:
        return (EjsObj*) ((lhs->path == 0) ? ejs->trueValue: ejs->falseValue);


    case EJS_OP_COMPARE_UNDEFINED:
    case EJS_OP_COMPARE_NULL:
    case EJS_OP_COMPARE_FALSE:
    case EJS_OP_COMPARE_TRUE:
        return (EjsObj*) ejs->falseValue;

    /*
        Binary operators
     */
    case EJS_OP_ADD:
        return (EjsObj*) ejsCreatePath(ejs, mprJoinPath(ejs, lhs->path, rhs->path));

    default:
        ejsThrowTypeError(ejs, "Opcode %d not implemented for type %s", opcode, lhs->obj.type->qname.name);
        return 0;
    }
    mprAssert(0);
}


/*
    Constructor
    function Path(path: String)
 */
static EjsObj *pathConstructor(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    cchar   *path;

    mprAssert(argc == 1);
    if ((path = getPathString(ejs, argv[0])) == 0) {
        return (EjsObj*) fp;
    }
    fp->path = mprStrdup(fp, path);
    return (EjsObj*) fp;
}


/*
    Return an absolute path name for the file
    function get absolutePath()
 */
static EjsObj *absolutePath(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreatePathAndFree(ejs, mprGetAbsPath(fp, fp->path));
}


/*
    Get when the file was last accessed.
    function get accessed(): Date
 */
static EjsObj *getAccessedDate(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    MprPath     info;

    mprGetPathInfo(ejs, fp->path, &info);
    if (!info.valid) {
        return (EjsObj*) ejs->nullValue;
    }
    return (EjsObj*) ejsCreateDate(ejs, ((MprTime) info.atime) * 1000);
}


/*
    Get the base name of a file
    function basename(): Path
 */
static EjsObj *getPathBasename(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreatePathAndFree(ejs, mprGetPathBase(ejs, fp->path));
}


/*
    Get the path components
    function components(): Array
 */
static EjsObj *getPathComponents(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    MprFileSystem   *fs;
    EjsArray        *ap;
    char            *cp, *last;
    int             index;

    fs = mprLookupFileSystem(ejs, fp->path);
    ap = ejsCreateArray(ejs, 0);
    index = 0;
    for (last = cp = mprGetAbsPath(fp, fp->path); *cp; cp++) {
        if (*cp == fs->separators[0] || *cp == fs->separators[1]) {
            *cp++ = '\0';
            ejsSetProperty(ejs, (EjsObj*) ap, index++, (EjsObj*) ejsCreateString(ejs, last));
            last = cp;
        }
    }
    if (cp > last) {
        ejsSetProperty(ejs, (EjsObj*) ap, index++, (EjsObj*) ejsCreateString(ejs, last));
    }
    return (EjsObj*) ap;
}


/*
    Copy a file
    function copy(to: Object, options: Object = null): Void
    TODO - not implementing copy options parameter.
 */
static EjsObj *copyPath(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    MprFile     *from, *to;
    char        *buf, *toPath;
    int         bytes;
    int         rc;

    mprAssert(argc == 1);
    if ((toPath = getPathString(ejs, argv[0])) == 0) {
        return 0;
    }
    from = mprOpen(ejs, fp->path, O_RDONLY | O_BINARY, 0);
    if (from == 0) {
        ejsThrowIOError(ejs, "Cant open %s", fp->path);
        return 0;
    }

    to = mprOpen(ejs, toPath, O_CREAT | O_WRONLY | O_TRUNC | O_BINARY, EJS_FILE_PERMS);
    if (to == 0) {
        ejsThrowIOError(ejs, "Cant create %s", toPath);
        mprFree(from);
        return 0;
    }

    buf = mprAlloc(ejs, MPR_BUFSIZE);
    if (buf == 0) {
        ejsThrowMemoryError(ejs);
        mprFree(to);
        mprFree(from);
        return 0;
    }

    rc = 0;
    while ((bytes = mprRead(from, buf, MPR_BUFSIZE)) > 0) {
        if (mprWrite(to, buf, bytes) != bytes) {
            ejsThrowIOError(ejs, "Write error to %s", toPath);
            rc = 0;
            break;
        }
    }
    mprFree(from);
    mprFree(to);
    mprFree(buf);
    return 0;
}


/*
    Return when the file was created.
    function get created(): Date
 */
static EjsObj *getCreatedDate(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    MprPath     info;

    mprGetPathInfo(ejs, fp->path, &info);
    if (!info.valid) {
        return (EjsObj*) ejs->nullValue;
    }
    return (EjsObj*) ejsCreateDate(ejs, ((MprTime) info.ctime) * 1000);
}


/**
    Get the directory name portion of a file.
    function get dirname(): Path
 */
static EjsObj *getPathDirname(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreatePathAndFree(ejs, mprGetPathDir(ejs, fp->path));
}


/*
    Test to see if this file exists.
    function get exists(): Boolean
 */
static EjsObj *getPathExists(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    MprPath     info;

    return (EjsObj*) ejsCreateBoolean(ejs, mprGetPathInfo(ejs, fp->path, &info) == 0);
}


/*
    Get the file extension portion of the file name.
    function get extension(): String
 */
static EjsObj *getPathExtension(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    char    *cp;

    if ((cp = strrchr(fp->path, '.')) == 0) {
        return (EjsObj*) ejs->emptyStringValue;
    }
    return (EjsObj*) ejsCreateString(ejs, &cp[1]);
}


/*
    Function to iterate and return the next element index.
    NOTE: this is not a method of Array. Rather, it is a callback function for Iterator
 */
static EjsObj *nextPathKey(Ejs *ejs, EjsIterator *ip, int argc, EjsObj **argv)
{
    EjsPath     *fp;

    fp = (EjsPath*) ip->target;
    if (!ejsIsPath(ejs, fp)) {
        ejsThrowReferenceError(ejs, "Wrong type");
        return 0;
    }
    if (ip->index < mprGetListCount(fp->files)) {
        return (EjsObj*) ejsCreateNumber(ejs, ip->index++);
    }
    ejsThrowStopIteration(ejs);
    return 0;
}


/*
    Return the default iterator for use with "for ... in". This will iterate over the files in a directory.
    iterator function get(): Iterator
 */
static EjsObj *getPathIterator(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    mprFree(fp->files);
    fp->files = mprGetPathFiles(fp, fp->path, 0);
    return (EjsObj*) ejsCreateIterator(ejs, (EjsObj*) fp, (EjsProc) nextPathKey, 0, NULL);
}


/*
    Function to iterate and return the next element value.
    NOTE: this is not a method of Array. Rather, it is a callback function for Iterator
 */
static EjsObj *nextPathValue(Ejs *ejs, EjsIterator *ip, int argc, EjsObj **argv)
{
    EjsPath     *fp;
    MprDirEntry *dp;

    fp = (EjsPath*) ip->target;
    if (!ejsIsPath(ejs, fp)) {
        ejsThrowReferenceError(ejs, "Wrong type");
        return 0;
    }
    if (ip->index < mprGetListCount(fp->files)) {
        dp = (MprDirEntry*) mprGetItem(fp->files, ip->index++);
        return (EjsObj*) ejsCreatePath(ejs, dp->name);
    }
    ejsThrowStopIteration(ejs);
    return 0;
}


/*
    Return an iterator to enumerate the bytes in the file. For use with "for each ..."
    iterator function getValues(): Iterator
 */
static EjsObj *getPathValues(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    mprFree(fp->files);
    fp->files = mprGetPathFiles(fp, fp->path, 0);
    return (EjsObj*) ejsCreateIterator(ejs, (EjsObj*) fp, (EjsProc) nextPathValue, 0, NULL);
}


/*
    Get the files in a directory.
    function getFiles(enumDirs: Boolean = false): Array

    TODO - need pattern to match (what about "." and ".." and ".*")
    TODO - move this functionality into mprFile (see appweb dirHandler.c)
 */
static EjsObj *getPathFiles(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    EjsArray        *array;
    MprList         *list;
    MprDirEntry     *dp;
    char            *path;
    bool            enumDirs, noPath;
    int             next;

    mprAssert(argc == 0 || argc == 1);
    enumDirs = (argc == 1) ? ejsGetBoolean(ejs, argv[0]): 0;

    array = ejsCreateArray(ejs, 0);
    if (array == 0) {
        return 0;
    }
    list = mprGetPathFiles(array, fp->path, enumDirs);
    if (list == 0) {
        ejsThrowIOError(ejs, "Can't read directory");
        return 0;
    }
    noPath = (fp->path[0] == '.' && fp->path[1] == '\0') || 
        (fp->path[0] == '.' && fp->path[1] == '/' && fp->path[2] == '\0');

    for (next = 0; (dp = mprGetNextItem(list, &next)) != 0; ) {
        if (strcmp(dp->name, ".") == 0 || strcmp(dp->name, "..") == 0) {
            continue;
        }
        if (enumDirs || !(dp->isDir)) {
            if (noPath) {
                ejsSetProperty(ejs, (EjsObj*) array, -1, (EjsObj*) ejsCreatePath(ejs, dp->name));
            } else {
                /*
                    Prepend the directory name
                 */
                path = mprJoinPath(ejs, fp->path, dp->name);
                ejsSetProperty(ejs, (EjsObj*) array, -1, (EjsObj*) ejsCreatePathAndFree(ejs, path));
            }
        }
    }
    mprFree(list);
    return (EjsObj*) array;
}


#if FUTURE
static EjsObj *fileSystem(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    //  TODO
    return 0;
}
#endif


/*
    Determine if the file path has a drive spec (C:) in the file name
    static function hasDrive(): Boolean
 */
static EjsObj *pathHasDrive(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateBoolean(ejs, 
        (isalpha((int) fp->path[0]) && fp->path[1] == ':' && (fp->path[2] == '/' || fp->path[2] == '\\')));
}


/*
    function get isAbsolute(): Boolean
 */
static EjsObj *isPathAbsolute(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    return (EjsObj*) (mprIsAbsPath(ejs, fp->path) ? ejs->trueValue: ejs->falseValue);
}


/*
    Determine if the file name is a directory
    function get isDir(): Boolean
 */
static EjsObj *isPathDir(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    MprPath     info;
    int         rc;

    rc = mprGetPathInfo(ejs, fp->path, &info);
    return (EjsObj*) ejsCreateBoolean(ejs, rc == 0 && info.isDir);
}


/*
    function get isLink(): Boolean
 */
static EjsObj *isPathLink(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    MprPath     info;
    int         rc;

    rc = mprGetPathInfo(ejs, fp->path, &info);
    return (EjsObj*) ejsCreateBoolean(ejs, rc == 0 && info.isLink);
}


/*
    Determine if the file name is a regular file
    function get isRegular(): Boolean
 */
static EjsObj *isPathRegular(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    MprPath     info;

    mprGetPathInfo(ejs, fp->path, &info);
    return (EjsObj*) ejsCreateBoolean(ejs, info.isReg);
}


/*
    function get isRelative(): Boolean
 */
static EjsObj *isPathRelative(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    return (EjsObj*) (mprIsRelPath(ejs, fp->path) ? ejs->trueValue: ejs->falseValue);
}


/*
    Join path segments. Returns a normalized path.
    function join(...others): Path
 */
static EjsObj *joinPath(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    EjsArray    *args;
    cchar       *other;
    char        *result, *prior;
    int         i;

    args = (EjsArray*) argv[0];
    result = fp->path;
    for (i = 0; i < args->length; i++) {
        if ((other = getPathString(ejs, ejsGetProperty(ejs, (EjsObj*) args, i))) == NULL) {
            return 0;
        }
        prior = result;
        result = mprJoinPath(ejs, prior, other);
        if (prior != fp->path) {
            mprFree(prior);
        }
    }
    return (EjsObj*) ejsCreatePathAndFree(ejs, result);
}


/*
    Join extension
  
    function joinExt(ext: String): Path
 */
static EjsObj *joinPathExt(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    cchar   *ext;

    if (mprGetPathExtension(ejs, fp->path)) {
        return (EjsObj*) fp;
    }
    ext = ejsGetString(ejs, argv[0]);
    while (ext && *ext == '.') {
        ext++;
    }
    return (EjsObj*) ejsCreatePath(ejs, mprStrcat(ejs, -1, fp->path, ".", ext, NULL));
}


/*
    Get the length of the path name.
  
    override intrinsic function get length(): Number
 */
static EjsObj *pathLength(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateNumber(ejs, strlen(fp->path));
}


static EjsObj *pathLinkTarget(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    char    *path;

    if ((path = mprGetPathLink(ejs, fp->path)) == 0) {
        return (EjsObj*) ejs->nullValue;
    }
    return (EjsObj*) ejsCreatePathAndFree(ejs, mprGetPathLink(ejs, fp->path));
}


/*
    function makeDir(options: Object = null): Void
  
    Options: permissions, owner, group
 */
static EjsObj *makePathDir(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    MprPath     info;
    EjsName     qname;
    EjsObj      *options, *permissions;
#if FUTURE
    EjsObj      *owner, *group;
    cchar       *ownerName, *groupName;
#endif
    int         perms;
    
    perms = 0755;

    if (argc == 1) {
        options = argv[0];

        permissions = ejsGetPropertyByName(ejs, options, ejsName(&qname, EJS_PUBLIC_NAMESPACE, "permissions"));
#if FUTURE
        owner = ejsGetPropertyByName(ejs, options, ejsName(&qname, EJS_PUBLIC_NAMESPACE, "owner"));
        group = ejsGetPropertyByName(ejs, options, ejsName(&qname, EJS_PUBLIC_NAMESPACE, "group"));
#endif
        if (permissions) {
            perms = ejsGetInt(ejs, permissions);
        }
    }
    if (mprGetPathInfo(ejs, fp->path, &info) == 0 && info.isDir) {
        return 0;
    }
    if (mprMakeDir(ejs, fp->path, perms, 1) < 0) {
        ejsThrowIOError(ejs, "Cant create directory %s", fp->path);
        return 0;
    }
#if FUTURE
    if (owner) {
        ownerName = ejsGetString(ejs, owner);
    }
    if (group) {
        groupName = ejsGetString(ejs, group);
    }
#endif
    return 0;
}


/*
    function makeLink(target: Path, hard: Boolean = false): Void
 */
static EjsObj *makePathLink(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    cchar   *target;
    int     hard;

    target = ((EjsPath*) argv[0])->path;
    hard = (argc >= 2) ? (argv[1] == (EjsObj*) ejs->trueValue) : 0;
    if (mprMakeLink(ejs, fp->path, target, hard) < 0) {
        ejsThrowIOError(ejs, "Can't make link");
    }
    return 0;
}


/*
    Make a temporary file. Creates a new, uniquely named temporary file.
    NOTE: Still the callers responsibility to remove the temp file
  
    function makeTemp(): Path
 */
static EjsObj *makePathTemp(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    char    *path;

    if ((path = mprGetTempPath(ejs, fp->path)) == NULL) {
        ejsThrowIOError(ejs, "Can't make temp file");
        return 0;
    }
    return (EjsObj*) ejsCreatePathAndFree(ejs, path);
}


/*
    function map(separator: String): Path
 */
static EjsObj *pa_map(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    cchar   *sep;
    char    *path;
    int     separator;

    sep = ejsGetString(ejs, argv[0]);
    separator = *sep ? *sep : '/';
    path = mprStrdup(ejs, fp->path);
    mprMapSeparators(ejs, path, separator);
    return (EjsObj*) ejsCreatePathAndFree(ejs, path);
}


EjsObj *getMimeType(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateString(ejs, mprLookupMimeType(ejs, fp->path));
}


/*
    Get when the file was created or last modified.
  
    function get modified(): Date
 */
static EjsObj *getModifiedDate(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    MprPath     info;

    mprGetPathInfo(ejs, fp->path, &info);
    if (!info.valid) {
        return (EjsObj*) ejs->nullValue;
    }
    return (EjsObj*) ejsCreateDate(ejs, ((MprTime) info.mtime) * 1000);
}


/*
    function get name(): String
 */
static EjsObj *pa_name(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateString(ejs, fp->path);
}


/*
    function get natural(): Path
 */
static EjsObj *getNaturalPath(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreatePathAndFree(ejs, mprGetNativePath(ejs, fp->path));
}


/*
    function get normalize(): Path
 */
static EjsObj *normalizePath(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreatePathAndFree(ejs, mprGetNormalizedPath(ejs, fp->path));
}


/*
    Get the parent directory of the absolute path of the file.
  
    function get parent(): String
 */
static EjsObj *getPathParent(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreatePathAndFree(ejs, mprGetPathParent(fp, fp->path));
}


/*
    Get the path permissions
  
    function get perms(): Number
 */
static EjsObj *getPerms(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    MprPath     info;

    if (mprGetPathInfo(ejs, fp->path, &info) < 0) {
        return (EjsObj*) ejs->nullValue;
        return 0;
    }
    return (EjsObj*) ejsCreateNumber(ejs, info.perms);
}


/*
    Set the path permissions
  
    function set perms(perms: Number): Void
 */
static EjsObj *setPerms(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
#if !VXWORKS
    int     perms;

    perms = ejsGetInt(ejs, argv[0]);
    if (chmod(fp->path, perms) < 0) {
        ejsThrowIOError(ejs, "Can't update permissions for %s", fp->path);
    }
#endif
    return 0;
}


/*
    Get a portable (unix-like) representation of the path
  
    function get portable(lower: Boolean = false): Path
 */
static EjsObj *getPortablePath(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    char    *path;
    int     lower;

    lower = (argc >= 1 && argv[0] == (EjsObj*) ejs->trueValue);
    path = mprGetPortablePath(ejs, fp->path);
    if (lower) {
        mprStrLower(path);
    }
    return (EjsObj*) ejsCreatePathAndFree(ejs, path);
}


#if KEEP
/*
    Get the file contents as a byte array
  
    static function readBytes(path: String): ByteArray
 */
static EjsObj *readBytes(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    MprFile         *file;
    EjsByteArray    *result;
    cchar           *path;
    char            buffer[MPR_BUFSIZE];
    int             bytes, offset, rc;

    mprAssert(argc == 1 && ejsIsString(argv[0]));
    path = ejsGetString(ejs, argv[0]);

    file = mprOpen(ejs, path, O_RDONLY | O_BINARY, 0);
    if (file == 0) {
        ejsThrowIOError(ejs, "Can't open %s", path);
        return 0;
    }

    /*
        TODO - need to be smarter about running out of memory here if the file is very large.
     */
    result = ejsCreateByteArray(ejs, (int) mprGetFileSize(file));
    if (result == 0) {
        ejsThrowMemoryError(ejs);
        return 0;
    }

    rc = 0;
    offset = 0;
    while ((bytes = mprRead(file, buffer, MPR_BUFSIZE)) > 0) {
        if (ejsCopyToByteArray(ejs, result, offset, buffer, bytes) < 0) {
            ejsThrowMemoryError(ejs);
            rc = -1;
            break;
        }
        offset += bytes;
    }
    ejsSetByteArrayPositions(ejs, result, 0, offset);

    mprFree(file);
    return (EjsObj*) result;
}


/**
    Read the file contents as an array of lines.
  
    static function readLines(path: String): Array
 */
static EjsObj *readLines(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    MprFile     *file;
    MprBuf      *data;
    EjsArray    *result;
    cchar       *path;
    char        *start, *end, *cp, buffer[MPR_BUFSIZE];
    int         bytes, rc, lineno;

    mprAssert(argc == 1 && ejsIsString(argv[0]));
    path = ejsGetString(ejs, argv[0]);

    result = ejsCreateArray(ejs, 0);
    if (result == NULL) {
        ejsThrowMemoryError(ejs);
        return 0;
    }

    file = mprOpen(ejs, path, O_RDONLY | O_BINARY, 0);
    if (file == 0) {
        ejsThrowIOError(ejs, "Can't open %s", path);
        return 0;
    }

    /*
        TODO - need to be smarter about running out of memory here if the file is very large.
     */
    data = mprCreateBuf(ejs, 0, (int) mprGetFileSize(file) + 1);
    result = ejsCreateArray(ejs, 0);
    if (result == NULL || data == NULL) {
        ejsThrowMemoryError(ejs);
        mprFree(file);
        return 0;
    }

    rc = 0;
    while ((bytes = mprRead(file, buffer, MPR_BUFSIZE)) > 0) {
        if (mprPutBlockToBuf(data, buffer, bytes) != bytes) {
            ejsThrowMemoryError(ejs);
            rc = -1;
            break;
        }
    }

    start = mprGetBufStart(data);
    end = mprGetBufEnd(data);
    for (lineno = 0, cp = start; cp < end; cp++) {
        if (*cp == '\n') {
            if (ejsSetProperty(ejs, (EjsObj*) result, lineno++, 
                    (EjsObj*) ejsCreateStringWithLength(ejs, start, (int) (cp - start))) < 0) {
                break;
            }
            start = cp + 1;
        } else if (*cp == '\r') {
            start = cp + 1;
        }
    }
    if (cp > start) {
        ejsSetProperty(ejs, (EjsObj*) result, lineno++, (EjsObj*) ejsCreateStringWithLength(ejs, start, (int) (cp - start)));
    }

    mprFree(file);
    mprFree(data);

    return (EjsObj*) result;
}


/*
    Read the file contents as a string
  
    static function readString(path: String): String
 */
static EjsObj *readFileAsString(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    MprFile     *file;
    MprBuf      *data;
    EjsObj      *result;
    cchar       *path;
    char        buffer[MPR_BUFSIZE];
    int         bytes, rc;

    mprAssert(argc == 1 && ejsIsString(argv[0]));
    path = ejsGetString(ejs, argv[0]);

    file = mprOpen(ejs, path, O_RDONLY | O_BINARY, 0);
    if (file == 0) {
        ejsThrowIOError(ejs, "Can't open %s", path);
        return 0;
    }

    /*
        TODO - need to be smarter about running out of memory here if the file is very large.
     */
    data = mprCreateBuf(ejs, 0, (int) mprGetFileSize(file) + 1);
    if (data == 0) {
        ejsThrowMemoryError(ejs);
        return 0;
    }

    rc = 0;
    while ((bytes = mprRead(file, buffer, MPR_BUFSIZE)) > 0) {
        if (mprPutBlockToBuf(data, buffer, bytes) != bytes) {
            ejsThrowMemoryError(ejs);
            rc = -1;
            break;
        }
    }
    result = (EjsObj*) ejsCreateStringWithLength(ejs, mprGetBufStart(data),  mprGetBufLength(data));
    mprFree(file);
    mprFree(data);
    return result;
}


/*
    Get the file contents as an XML object
  
    static function readXML(path: String): XML
 */
static EjsObj *readXML(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    return 0;
}
#endif


/*
    Return a relative path name for the file.
  
    function get relativePath(): Path
 */
static EjsObj *relativePath(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreatePathAndFree(ejs, mprGetRelPath(fp, fp->path));
}


/*
    Remove the file associated with the File object. This may be a file or directory.
  
    function remove(): void
 */
static EjsObj *removePath(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    MprPath     info;

    if (mprGetPathInfo(ejs, fp->path, &info) == 0) {
        if (mprDeletePath(ejs, fp->path) < 0) {
            ejsThrowIOError(ejs, "Cant remove %s", fp->path);
        }
    }
    return 0;
}


/*
    Rename the file
  
    function rename(to: String): Void
 */
static EjsObj *renamePathFile(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    cchar    *to;

    mprAssert(argc == 1 && ejsIsString(argv[0]));
    to = ejsGetString(ejs, argv[0]);

    unlink((char*) to);
    if (rename(fp->path, to) < 0) {
        ejsThrowIOError(ejs, "Cant rename file %s to %s", fp->path, to);
        return 0;
    }
    return 0;
}


/*
    Resolve paths against others. Returns a normalized path.
  
    function resolve(...paths): Path
 */
static EjsObj *resolvePath(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    EjsArray    *args;
    cchar       *next;
    char        *result, *prior;
    int         i;

    args = (EjsArray*) argv[0];
    result = fp->path;
    for (i = 0; i < args->length; i++) {
        if ((next = getPathString(ejs, ejsGetProperty(ejs, (EjsObj*) args, i))) == NULL) {
            return 0;
        }
        prior = result;
        result = mprResolvePath(ejs, prior, next);
        if (prior != fp->path) {
            mprFree(prior);
        }
    }
    return (EjsObj*) ejsCreatePath(ejs, result);
}


/*
    Return true if the paths refer to the same file.
  
    function same(other: Object): Boolean
 */
static EjsObj *isPathSame(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    cchar   *other;

    if (ejsIsString(argv[0])) {
        other = ejsGetString(ejs, argv[0]);
    } else if (ejsIsPath(ejs, argv[0])) {
        other = ((EjsPath*) (argv[0]))->path;
    } else {
        return (EjsObj*) ejs->falseValue;
    }
    return (EjsObj*) (mprSamePath(ejs, fp->path, other) ? ejs->trueValue : ejs->falseValue);
}


/*
    function get separator(): String
 */
static EjsObj *pathSeparator(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    MprFileSystem   *fs;
    cchar           *cp;

    if ((cp = mprGetFirstPathSeparator(ejs, fp->path)) != 0) {
        return (EjsObj*) ejsCreateStringAndFree(ejs, mprAsprintf(ejs, -1, "%c", (int) *cp));
    }
    fs = mprLookupFileSystem(ejs, fp->path);
    return (EjsObj*) ejsCreateStringAndFree(ejs, mprAsprintf(ejs, -1, "%c", (int) fs->separators[0]));
}


/*
    Get the size of the file associated with this Path
  
    intrinsic function get size(): Number
 */
static EjsObj *getPathFileSize(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    if (mprGetPathInfo(ejs, fp->path, &fp->info) < 0) {
        return (EjsObj*) ejs->minusOneValue;
    }
    return (EjsObj*) ejsCreateNumber(ejs, (MprNumber) fp->info.size);
}


/*
    override function toJSON(): String
 */
static EjsObj *pathToJSON(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    EjsObj  *result;
    MprBuf  *buf;
    int     i, c, len;

    buf = mprCreateBuf(fp, 0, 0);
    len = strlen(fp->path);
    mprPutCharToBuf(buf, '"');
    for (i = 0; i < len; i++) {
        c = fp->path[i];
        if (c == '"' || c == '\\') {
            mprPutCharToBuf(buf, '\\');
            mprPutCharToBuf(buf, c);
        } else {
            mprPutCharToBuf(buf, c);
        }
    }
    mprPutCharToBuf(buf, '"');
    mprAddNullToBuf(buf);
    result = (EjsObj*) ejsCreateString(ejs, mprGetBufStart(buf));
    mprFree(buf);
    return result;
}


/*
    function toString(): String
 */
static EjsObj *pathToString(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateString(ejs, fp->path);
}


/*
    function trimExt(): Path
 */
static EjsObj *trimExt(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreatePathAndFree(ejs, mprTrimPathExtension(ejs, fp->path));
}


/*
    function truncate(size: Number): Void
 */
static EjsObj *truncatePath(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    int     size;

    size = ejsGetInt(ejs, argv[0]);
    if (mprTruncatePath(ejs, fp->path, size) < 0) {
        ejsThrowIOError(ejs, "Cant truncate %s", fp->path);
    }
    return 0;
}


#if KEEP
/*
    Put the file contents
  
    static function write(path: String, permissions: Number, ...args): void
 */
static EjsObj *writeToFile(Ejs *ejs, EjsPath *fp, int argc, EjsObj **argv)
{
    MprFile     *file;
    EjsArray    *args;
    char        *path, *data;
    int         i, bytes, length, permissions;

    mprAssert(argc == 3);

    path = ejsGetString(ejs, argv[0]);
    permissions = ejsGetInt(ejs, argv[1]);
    args = (EjsArray*) argv[2];

    /*
        Create fails if already present
     */
    mprDeletePath(ejs, path);
    file = mprOpen(ejs, path, O_CREAT | O_WRONLY | O_BINARY, permissions);
    if (file == 0) {
        ejsThrowIOError(ejs, "Cant create %s", path);
        return 0;
    }

    for (i = 0; i < args->length; i++) {
        data = ejsGetString(ejs, ejsToString(ejs, ejsGetProperty(ejs, (EjsObj*) args, i)));
        length = (int) strlen(data);
        bytes = mprWrite(file, data, length);
        if (bytes != length) {
            ejsThrowIOError(ejs, "Write error to %s", path);
            break;
        }
    }
    mprFree(file);
    return 0;
}
#endif


static char *getPathString(Ejs *ejs, EjsObj *vp)
{
    if (ejsIsString(vp)) {
        return (char*) ejsGetString(ejs, vp);
    } else if (ejsIsPath(ejs, vp)) {
        return ((EjsPath*) vp)->path;
    }
    ejsThrowIOError(ejs, "Bad path");
    return NULL;
}


EjsPath *ejsCreatePath(Ejs *ejs, cchar *path)
{
    EjsPath     *fp;
    EjsObj      *arg;

    fp = (EjsPath*) ejsCreate(ejs, ejs->pathType, 0);
    if (fp == 0) {
        return 0;
    }
    arg = (EjsObj*) ejsCreateString(ejs, path);
    pathConstructor(ejs, fp, 1, (EjsObj**) &arg);
    return fp;
}


EjsPath *ejsCreatePathAndFree(Ejs *ejs, char *value)
{
    EjsPath     *path;

    path = ejsCreatePath(ejs, value);
    mprFree(value);
    return path;
}


void ejsConfigurePathType(Ejs *ejs)
{
    EjsType     *type;

    type = ejs->pathType = ejsConfigureNativeType(ejs, EJS_EJS_NAMESPACE, "Path", sizeof(EjsPath));
    ejs->pathType = type;

    type->helpers = ejsCloneObjectHelpers(ejs, "path-helpers");
    type->helpers->clone = (EjsCloneHelper) clonePath;
    type->helpers->invokeOperator = (EjsInvokeOperatorHelper) invokePathOperator;
    type->helpers->destroy = (EjsDestroyHelper) destroyPath;

    //  TODO - rename all and use pa_ prefix
    ejsBindMethod(ejs, type, ES_Path_Path, (EjsProc) pathConstructor);
    ejsBindMethod(ejs, type, ES_Path_absolute, (EjsProc) absolutePath);
    ejsBindMethod(ejs, type, ES_Path_accessed, (EjsProc) getAccessedDate);
    ejsBindMethod(ejs, type, ES_Path_basename, (EjsProc) getPathBasename);
    ejsBindMethod(ejs, type, ES_Path_components, (EjsProc) getPathComponents);
    ejsBindMethod(ejs, type, ES_Path_copy, (EjsProc) copyPath);
    ejsBindMethod(ejs, type, ES_Path_created, (EjsProc) getCreatedDate);
    ejsBindMethod(ejs, type, ES_Path_dirname, (EjsProc) getPathDirname);
    ejsBindMethod(ejs, type, ES_Path_exists, (EjsProc) getPathExists);
    ejsBindMethod(ejs, type, ES_Path_extension, (EjsProc) getPathExtension);
    ejsBindMethod(ejs, type, ES_Path_files, (EjsProc) getPathFiles);
    ejsBindMethod(ejs, type, ES_Path_hasDrive, (EjsProc) pathHasDrive);
    ejsBindMethod(ejs, type, ES_Path_isAbsolute, (EjsProc) isPathAbsolute);
    ejsBindMethod(ejs, type, ES_Path_isDir, (EjsProc) isPathDir);
    ejsBindMethod(ejs, type, ES_Path_isLink, (EjsProc) isPathLink);
    ejsBindMethod(ejs, type, ES_Path_isRegular, (EjsProc) isPathRegular);
    ejsBindMethod(ejs, type, ES_Path_isRelative, (EjsProc) isPathRelative);
    ejsBindMethod(ejs, type, ES_Path_join, (EjsProc) joinPath);
    ejsBindMethod(ejs, type, ES_Path_joinExt, (EjsProc) joinPathExt);
    ejsBindMethod(ejs, type, ES_Path_length, (EjsProc) pathLength);
    ejsBindMethod(ejs, type, ES_Path_linkTarget, (EjsProc) pathLinkTarget);
    ejsBindMethod(ejs, type, ES_Path_makeDir, (EjsProc) makePathDir);
    ejsBindMethod(ejs, type, ES_Path_makeLink, (EjsProc) makePathLink);
    ejsBindMethod(ejs, type, ES_Path_makeTemp, (EjsProc) makePathTemp);
#if ES_Path_map
    ejsBindMethod(ejs, type, ES_Path_map, (EjsProc) pa_map);
#endif
    ejsBindMethod(ejs, type, ES_Path_mimeType, (EjsProc) getMimeType);
    ejsBindMethod(ejs, type, ES_Path_modified, (EjsProc) getModifiedDate);
#if ES_Path_name
    ejsBindMethod(ejs, type, ES_Path_name, (EjsProc) pa_name);
#endif
    ejsBindMethod(ejs, type, ES_Path_natural, (EjsProc) getNaturalPath);
    ejsBindMethod(ejs, type, ES_Path_normalize, (EjsProc) normalizePath);
    ejsBindMethod(ejs, type, ES_Path_parent, (EjsProc) getPathParent);
    ejsBindAccess(ejs, type, ES_Path_perms, (EjsProc) getPerms, (EjsProc) setPerms);
    ejsBindMethod(ejs, type, ES_Path_portable, (EjsProc) getPortablePath);
    ejsBindMethod(ejs, type, ES_Path_relative, (EjsProc) relativePath);
    ejsBindMethod(ejs, type, ES_Path_remove, (EjsProc) removePath);
    ejsBindMethod(ejs, type, ES_Path_rename, (EjsProc) renamePathFile);
    ejsBindMethod(ejs, type, ES_Path_resolve, (EjsProc) resolvePath);
    ejsBindMethod(ejs, type, ES_Path_same, (EjsProc) isPathSame);
    ejsBindMethod(ejs, type, ES_Path_separator, (EjsProc) pathSeparator);
    ejsBindMethod(ejs, type, ES_Path_size, (EjsProc) getPathFileSize);
    ejsBindMethod(ejs, type, ES_Path_trimExt, (EjsProc) trimExt);
    ejsBindMethod(ejs, type, ES_Path_truncate, (EjsProc) truncatePath);

    ejsBindMethod(ejs, type, ES_Object_get, (EjsProc) getPathIterator);
    ejsBindMethod(ejs, type, ES_Object_getValues, (EjsProc) getPathValues);
    ejsBindMethod(ejs, type, ES_Object_toJSON, (EjsProc) pathToJSON);
    ejsBindMethod(ejs, type, ES_Object_toString, (EjsProc) pathToString);
}


/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2010. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2010. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    @end
 */
/************************************************************************/
/*
 *  End of file "../src/core/src/ejsPath.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../src/core/src/ejsReflect.c"
 */
/************************************************************************/

/**
    ejsReflect.c - Reflection class and API

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */



/*
    Constructor

    public function Reflect(o: Object)
 */
static EjsObj *ref_Reflect(Ejs *ejs, EjsReflect *rp, int argc,  EjsObj **argv)
{
    mprAssert(argc == 1);
    rp->subject = argv[0];
    mprAssert(rp->subject->type);
    return (EjsObj*) rp;
}


/*
    Get the base class of the object.

    function get base(): Object
 */
static EjsObj *ref_base(Ejs *ejs, EjsReflect *rp, int argc, EjsObj **argv)
{
    EjsObj      *vp;

    vp = rp->subject;
    if (ejsIsType(vp)) {
        return (EjsObj*) (((EjsType*) vp)->baseType);
    }
    if (vp->type == 0) {
        return ejs->nullValue;
    }
    return (EjsObj*) vp->type;
}


/*
    function get isType(): Boolean
 */
static EjsObj *ref_isType(Ejs *ejs, EjsReflect *rp, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateBoolean(ejs, ejsIsType(rp->subject));
}


/*
    Get the type of the object.

    function get type(): Object
 */
static EjsObj *ref_type(Ejs *ejs, EjsReflect *rp, int argc, EjsObj **argv)
{
    EjsObj      *vp;

    vp = rp->subject;
    if (vp->type == 0) {
        return ejs->nullValue;
    }
    return (EjsObj*) vp->type;
}


/*
    Return the type name of a var as a string. If the var is a type, get the base type.
 */
EjsObj *ejsGetTypeName(Ejs *ejs, EjsObj *vp)
{
    EjsType     *type;

    if (vp == 0) {
        return ejs->undefinedValue;
    }
    type = (EjsType*) vp->type;
    if (type == 0) {
        return ejs->nullValue;
    }
    return (EjsObj*) ejsCreateString(ejs, type->qname.name);
}


/*
    Get the type name of a type object

    function get name(): String
 */
static EjsObj *ref_name(Ejs *ejs, EjsReflect *rp, int argc, EjsObj **argv)
{
    EjsType     *type;

    type = (EjsType*) rp->subject;
    if (!ejsIsType(type)) {
        ejsThrowArgError(ejs, "Object is not a type");
        return 0;
    }
    return (EjsObj*) ejsCreateString(ejs, type->qname.name);
}


/*
    function get typeOf(obj): String
 */
static EjsObj *ref_typeOf(Ejs *ejs, EjsObj *obj, int argc, EjsObj **argv)
{
    mprAssert(argc >= 1);
    return (EjsObj*) ejsGetTypeName(ejs, argv[0]);
}


/*
    Get the ecma "typeof" value for an object. Unfortunately, typeof is pretty lame.
 */
EjsObj *ejsGetTypeOf(Ejs *ejs, EjsObj *vp)
{
    if (vp == ejs->undefinedValue) {
        return (EjsObj*) ejsCreateString(ejs, "undefined");

    } else if (vp == ejs->nullValue) {
        /* Yea - I know, ECMAScript is broken */
        return (EjsObj*) ejsCreateString(ejs, "object");

    } if (ejsIsBoolean(vp)) {
        return (EjsObj*) ejsCreateString(ejs, "boolean");

    } else if (ejsIsNumber(vp)) {
        return (EjsObj*) ejsCreateString(ejs, "number");

    } else if (ejsIsString(vp)) {
        return (EjsObj*) ejsCreateString(ejs, "string");

    } else if (ejsIsFunction(vp)) {
        return (EjsObj*) ejsCreateString(ejs, "function");
               
    } else if (ejsIsType(vp)) {
        /* Pretend it is a constructor function */
        return (EjsObj*) ejsCreateString(ejs, "function");
               
    } else {
        return (EjsObj*) ejsCreateString(ejs, "object");
    }
}



static void markReflectVar(Ejs *ejs, EjsReflect *rp)
{
    //  MOB - probably not needed
    ejsMarkObject(ejs, (EjsObj*) rp);

    if (rp->subject) {
        ejsMark(ejs, rp->subject);
    }
}


void ejsConfigureReflectType(Ejs *ejs)
{
    EjsType     *type;

    type = ejsConfigureNativeType(ejs, EJS_EJS_NAMESPACE, "Reflect", sizeof(EjsReflect));

    type->helpers->mark = (EjsMarkHelper) markReflectVar;

    ejsBindMethod(ejs, type, type->numInherited, (EjsProc) ref_Reflect);
    ejsBindMethod(ejs, type, ES_Reflect_base, (EjsProc) ref_base);
    ejsBindMethod(ejs, type, ES_Reflect_isType, (EjsProc) ref_isType);
    ejsBindMethod(ejs, type, ES_Reflect_name, (EjsProc) ref_name);
    ejsBindMethod(ejs, type, ES_Reflect_type, (EjsProc) ref_type);
    ejsBindFunction(ejs, ejs->globalBlock, ES_typeOf, (EjsProc) ref_typeOf);
}


/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2010. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2010. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    @end
 */
/************************************************************************/
/*
 *  End of file "../src/core/src/ejsReflect.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../src/core/src/ejsRegExp.c"
 */
/************************************************************************/

/**
    ejsRegExp.c - RegExp type class

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */



#include    "pcre.h"


static char *makeFlags(EjsRegExp *rp);
static int parseFlags(EjsRegExp *rp, cchar *flags);

/*
    Cast the operand to the specified type

    intrinsic function cast(type: Type) : Object
 */
static EjsObj *castRegExp(Ejs *ejs, EjsRegExp *rp, EjsType *type)
{
    char    *pattern, *flags;

    switch (type->id) {
    case ES_Boolean:
        return (EjsObj*) ejs->trueValue;

    case ES_String:
        flags = makeFlags(rp);
        pattern = mprStrcat(rp, -1, "/", rp->pattern, "/", flags, NULL);
        mprFree(flags);
        return (EjsVar*) ejsCreateStringAndFree(ejs, pattern);

    default:
        ejsThrowTypeError(ejs, "Can't cast to this type");
        return 0;
    }
    return 0;
}


static void destroyRegExp(Ejs *ejs, EjsRegExp *rp)
{
    mprAssert(rp);

    if (rp->compiled) {
        free(rp->compiled);
        rp->compiled = 0;
    }
    ejsFree(ejs, (EjsObj*) rp, -1);
}


/*
    RegExp constructor

    RegExp(pattern: String, flags: String = null)
 */

static EjsObj *regexConstructor(Ejs *ejs, EjsRegExp *rp, int argc, EjsObj **argv)
{
    cchar       *errMsg, *pattern, *flags;
    int         column, errCode;

    pattern = ejsGetString(ejs, argv[0]);
    rp->options = PCRE_JAVASCRIPT_COMPAT;

    if (argc == 2) {
        flags = (char*) ejsGetString(ejs, argv[1]);
        rp->options |= parseFlags(rp, flags);
    }
    rp->pattern = mprStrdup(rp, pattern);
    if (rp->compiled) {
        free(rp->compiled);
    }
    rp->compiled = (void*) pcre_compile2(pattern, rp->options, &errCode, &errMsg, &column, NULL);
    if (rp->compiled == NULL) {
        ejsThrowArgError(ejs, "Can't compile regular expression. Error %s at column %d", errMsg, column);
    }
    return (EjsObj*) rp;
}


static EjsObj *getLastIndex(Ejs *ejs, EjsRegExp *rp, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateNumber(ejs, rp->endLastMatch);
}


/*
    function set lastIndex(value: Number): Void
 */
static EjsObj *setLastIndex(Ejs *ejs, EjsRegExp *rp, int argc, EjsObj **argv)
{
    rp->endLastMatch = (int) ejsGetNumber(ejs, argv[0]);
    return 0;
}


/*
    function exec(str: String, start: Number = 0): Array
 */
static EjsObj *exec(Ejs *ejs, EjsRegExp *rp, int argc, EjsObj **argv)
{
    EjsArray    *results;
    EjsString   *match;
    cchar       *str;
    int         matches[EJS_MAX_REGEX_MATCHES * 3];
    int         start, len, i, count, index;

    str = ejsGetString(ejs, argv[0]);
    if (argc == 2) {
        start = (int) ejsGetNumber(ejs, argv[1]);
    } else {
        start = rp->endLastMatch;
    }
    rp->matched = 0;
    mprAssert(rp->compiled);
    count = pcre_exec(rp->compiled, NULL, str, (int) strlen(str), start, 0, matches, sizeof(matches) / sizeof(int));
    if (count < 0) {
        rp->endLastMatch = 0;
        return (EjsObj*) ejs->nullValue;
    }
    results = ejsCreateArray(ejs, count);
    for (index = 0, i = 0; i < count; i++, index += 2) {
        len = matches[index + 1] - matches[index];
        match = ejsCreateStringWithLength(ejs, &str[matches[index]], len);
        ejsSetProperty(ejs, (EjsObj*) results, i, (EjsObj*) match);
        if (index == 0) {
            rp->matched = match;
        }
    }
    if (rp->global) {
        /* Only save if global flag used as per spec */
        rp->startLastMatch = matches[0];
        rp->endLastMatch = matches[1];
    }
    return (EjsObj*) results;
}


static EjsObj *getGlobalFlag(Ejs *ejs, EjsRegExp *rp, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateBoolean(ejs, rp->global);
}


static EjsObj *getIgnoreCase(Ejs *ejs, EjsRegExp *rp, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateBoolean(ejs, rp->ignoreCase);
}


static EjsObj *getMultiline(Ejs *ejs, EjsRegExp *rp, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateBoolean(ejs, rp->multiline);
}


static EjsObj *getSource(Ejs *ejs, EjsRegExp *rp, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateString(ejs, rp->pattern);
}


static EjsObj *matched(Ejs *ejs, EjsRegExp *rp, int argc, EjsObj **argv)
{
    if (rp->matched == 0) {
        return (EjsObj*) ejs->nullValue;
    }
    return (EjsObj*) rp->matched;
}


static EjsObj *start(Ejs *ejs, EjsRegExp *rp, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateNumber(ejs, rp->startLastMatch);
}


static EjsObj *sticky(Ejs *ejs, EjsRegExp *rp, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateBoolean(ejs, rp->sticky);
}


static EjsObj *test(Ejs *ejs, EjsRegExp *rp, int argc, EjsObj **argv)
{
    cchar       *str;
    int         count;

    str = ejsGetString(ejs, argv[0]);
    mprAssert(rp->compiled);
    count = pcre_exec(rp->compiled, NULL, str, (int) strlen(str), rp->endLastMatch, 0, 0, 0);
    if (count < 0) {
        rp->endLastMatch = 0;
        return (EjsObj*) ejs->falseValue;
    }
    return (EjsObj*) ejs->trueValue;
}


EjsString *ejsRegExpToString(Ejs *ejs, EjsRegExp *rp)
{
    return (EjsString*) castRegExp(ejs, rp, ejs->stringType);
}

/*
    Create an initialized regular expression object. The pattern should include
    the slash delimiters. For example: /abc/ or /abc/g
 */

EjsRegExp *ejsCreateRegExp(Ejs *ejs, cchar *pattern)
{
    EjsRegExp   *rp;
    cchar       *errMsg;
    char        *flags;
    int         column, errCode;

    mprAssert(pattern[0] == '/');
    if (*pattern != '/') {
        ejsThrowArgError(ejs, "Bad regular expression pattern. Must start with '/'");
        return 0;
    }

    rp = (EjsRegExp*) ejsCreate(ejs, ejs->regExpType, 0);
    if (rp != 0) {
        /*
            Strip off flags for passing to pcre_compile2
         */
        rp->pattern = mprStrdup(rp, &pattern[1]);
        if ((flags = strrchr(rp->pattern, '/')) != 0) {
            rp->options = parseFlags(rp, &flags[1]);
            *flags = '\0';
        }
        if (rp->compiled) {
            free(rp->compiled);
        }
        rp->compiled = pcre_compile2(rp->pattern, rp->options, &errCode, &errMsg, &column, NULL);
        if (rp->compiled == NULL) {
            ejsThrowArgError(ejs, "Can't compile regular expression. Error %s at column %d", errMsg, column);
            return 0;
        }
    }
    return rp;
}


static int parseFlags(EjsRegExp *rp, cchar *flags)
{
    cchar       *cp;
    int         options;

    if (flags == 0 || *flags == '\0') {
        return 0;
    }
    options = PCRE_JAVASCRIPT_COMPAT;
    for (cp = flags; *cp; cp++) {
        switch (tolower((int) *cp)) {
        case 'g':
            rp->global = 1;
            break;
        case 'i':
            rp->ignoreCase = 1;
            options |= PCRE_CASELESS;
            break;
        case 'm':
            rp->multiline = 1;
            options |= PCRE_MULTILINE;
            break;
        case 's':
            options |= PCRE_DOTALL;
            break;
        case 'y':
            rp->sticky = 1;
            break;
        case 'x':
            options |= PCRE_EXTENDED;
            break;
        case 'X':
            options |= PCRE_EXTRA;
            break;
        case 'U':
            options |= PCRE_UNGREEDY;
            break;
        }
    }
    return options;
}


static char *makeFlags(EjsRegExp *rp)
{
    char    buf[16], *cp;

    cp = buf;
    if (rp->global) {
        *cp++ = 'g';
    }
    if (rp->ignoreCase) {
        *cp++ = 'i';
    }
    if (rp->multiline) {
        *cp++ = 'm';
    }
    if (rp->sticky) {
        *cp++ = 'y';
    }
    if (rp->options & PCRE_DOTALL) {
        *cp++ = 's';
    }
    if (rp->options & PCRE_EXTENDED) {
        *cp++ = 'x';
    }
    if (rp->options & PCRE_EXTRA) {
        *cp++ = 'X';
    }
    if (rp->options & PCRE_UNGREEDY) {
        *cp++ = 'U';
    }
    *cp++ = '\0';
    return mprStrdup(rp, buf);
}


void ejsCreateRegExpType(Ejs *ejs)
{
    EjsType     *type;

    type = ejs->regExpType = ejsCreateNativeType(ejs, "ejs", "RegExp", ES_RegExp, sizeof(EjsRegExp));
    type->needFinalize = 1;
    type->helpers->cast = (EjsCastHelper) castRegExp;
    type->helpers->destroy = (EjsDestroyHelper) destroyRegExp;
}


void ejsConfigureRegExpType(Ejs *ejs)
{
    EjsType     *type;

    type = ejsConfigureNativeType(ejs, "ejs", "RegExp", sizeof(EjsRegExp));

    ejsBindMethod(ejs, type, ES_RegExp_RegExp, (EjsProc) regexConstructor);
    ejsBindMethod(ejs, type, ES_RegExp_exec, (EjsProc) exec);
    ejsBindAccess(ejs, type, ES_RegExp_lastIndex, (EjsProc) getLastIndex, (EjsProc) setLastIndex);
    ejsBindMethod(ejs, type, ES_RegExp_global, (EjsProc) getGlobalFlag);
    ejsBindMethod(ejs, type, ES_RegExp_ignoreCase, (EjsProc) getIgnoreCase);
    ejsBindMethod(ejs, type, ES_RegExp_multiline, (EjsProc) getMultiline);
    ejsBindMethod(ejs, type, ES_RegExp_source, (EjsProc) getSource);
    ejsBindMethod(ejs, type, ES_RegExp_matched, (EjsProc) matched);
    ejsBindMethod(ejs, type, ES_RegExp_start, (EjsProc) start);
    ejsBindMethod(ejs, type, ES_RegExp_sticky, (EjsProc) sticky);
    ejsBindMethod(ejs, type, ES_RegExp_test, (EjsProc) test);
    ejsBindMethod(ejs, type, ES_Object_toString, (EjsProc) ejsRegExpToString);
}


/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2010. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2010. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    @end
 */
/************************************************************************/
/*
 *  End of file "../src/core/src/ejsRegExp.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../src/core/src/ejsSocket.c"
 */
/************************************************************************/

/**
    ejsSocket.c - Socket class. This implements TCP/IP v4 and v6 connectivity.
    Copyright (c) All Rights Reserved. See details at the end of the file.
 */




static void enableSocketEvents(EjsSocket *sp, int (*proc)(EjsSocket *sp, MprEvent *event));
static int socketConnectEvent(EjsSocket *sp, MprEvent *event);
static int socketIOEvent(EjsSocket *sp, MprEvent *event);
static int socketListenEvent(EjsSocket *listen, MprEvent *event);

/*
    function Socket()
 */
static EjsObj *sock_Socket(Ejs *ejs, EjsSocket *sp, int argc, EjsObj **argv)
{
    sp->ejs = ejs;
    //  TODO -- ssl?
    sp->sock = mprCreateSocket(sp, NULL);
    if (sp->sock == 0) {
        ejsThrowMemoryError(ejs);
        return 0;
    }
    sp->waitHandler.fd = -1;
    return (EjsObj*) sp;
}


/*
    function addListener(name: [String|Array], listener: Function): Void
 */
EjsObj *sock_addListener(Ejs *ejs, EjsSocket *sp, int argc, EjsObj **argv)
{
    ejsAddListener(ejs, &sp->emitter, argv[0], argv[1]);
    return 0;
}


/*
    function accept(): Socket
 */
EjsObj *sock_accept(Ejs *ejs, EjsSocket *listen, int argc, EjsObj **argv)
{
    MprSocket   *sock;
    EjsSocket   *sp;

    if ((sock = mprAcceptSocket(listen->sock)) == 0) {
        ejsThrowIOError(ejs, "Can't accept new socket");
        return 0;
    }
    sp = ejsCreateSocket(ejs);
    sp->sock = sock;
    sp->async = listen->async;
    if (sp->async) {
        sp->mask |= MPR_READABLE;
        enableSocketEvents(sp, socketIOEvent);
    } else {
        mprSetSocketBlockingMode(sp->sock, 1);
    }
    return (EjsObj*) sp;
}


/*
    function get address(): Void
 */
EjsObj *sock_address(Ejs *ejs, EjsSocket *sp, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateString(ejs, sp->address);
}


/*
    function get async(): Boolean
 */
EjsObj *sock_async(Ejs *ejs, EjsSocket *sp, int argc, EjsObj **argv)
{
    return (sp->async) ? (EjsObj*) ejs->trueValue : (EjsObj*) ejs->falseValue;
}


/*
    function set async(enable: Boolean): Void
 */
EjsObj *sock_set_async(Ejs *ejs, EjsSocket *sp, int argc, EjsObj **argv)
{
    sp->async = (argv[0] == (EjsObj*) ejs->trueValue);
    return 0;
}


/*
    function close(): Void
 */
static EjsObj *sock_close(Ejs *ejs, EjsSocket *sp, int argc, EjsObj **argv)
{
    ejsSendEvent(ejs, sp->emitter, "close", (EjsObj*) sp);
    if (sp->sock) {
        mprFree(sp->sock);
        sp->sock = 0;
    }
    return 0;
}


/*
    function connect(address): Void
 */
static EjsObj *sock_connect(Ejs *ejs, EjsSocket *sp, int argc, EjsObj **argv)
{
    EjsString       *address;
    char            *cp;

    address = (EjsString*) argv[0];
    if (ejsIsNumber(address)) {
        sp->address = mprStrdup(sp, "127.0.0.1");
        sp->port = (int) ((EjsNumber*) address)->value;
    } else {
        if (!ejsIsString(address)) {
            address = ejsToString(ejs, (EjsObj*) address);
        }
        sp->address = mprStrdup(sp, address->value);
        if ((cp = strchr(sp->address, ':')) != 0) {
            *cp++ = '\0';
            sp->port = atoi(cp);
        } else {
            ejsThrowArgError(ejs, "Address must have a port");
            return 0;
        }
    }
    if (!sp->sock) {
        ejsThrowStateError(ejs, "Socket is closed");
        return 0;
    }
    if (mprOpenClientSocket(sp->sock, sp->address, sp->port, 0) < 0) {
        ejsThrowArgError(ejs, "Can't open client socket");
        return 0;
    }
    if (sp->async) {
        sp->mask |= MPR_READABLE;
        enableSocketEvents(sp, socketConnectEvent);
    } else {
        mprSetSocketBlockingMode(sp->sock, 1);
    }
    return 0;
}


/**
    function listen(address): Void
    @param address Can be either a "ip", "ip:port" or port
 */
static EjsObj *sock_listen(Ejs *ejs, EjsSocket *sp, int argc, EjsObj **argv)
{
    EjsString   *address;
    char        *cp;

    address = (EjsString*) argv[0];
    if (ejsIsNumber(address)) {
        sp->address = mprStrdup(sp, "");
        sp->port = (int) ((EjsNumber*) address)->value;
    } else {
        if (!ejsIsString(address)) {
            address = ejsToString(ejs, (EjsObj*) address);
        }
        sp->address = mprStrdup(sp, address->value);
        if ((cp = strchr(sp->address, ':')) != 0) {
            *cp++ = '\0';
            sp->port = atoi(cp);
        } else {
            ejsThrowArgError(ejs, "Address must have a port");
            return 0;
        }
    }
    if (!sp->sock) {
        ejsThrowStateError(ejs, "Socket is closed");
        return 0;
    }
    if (mprOpenServerSocket(sp->sock, sp->address, sp->port, 0) < 0) {
        ejsThrowArgError(ejs, "Can't open listening socket");
        return 0;
    }
    if (sp->async) {
        sp->mask |= MPR_READABLE;
        enableSocketEvents(sp, socketListenEvent);
    } else {
        mprSetSocketBlockingMode(sp->sock, 1);
    }
    return 0;
}


/*
    function get port(): Number
 */
static EjsObj *sock_port(Ejs *ejs, EjsSocket *sp, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateNumber(ejs, sp->port);
}


/*
    function read(buffer: ByteArray, offset: Number = 0, count: Number = -1): Object
 */
static EjsObj *sock_read(Ejs *ejs, EjsSocket *sp, int argc, EjsObj **argv)
{
    EjsByteArray    *ba;
    int             offset, count, nbytes;

    ba = (EjsByteArray*) argv[0];
    offset = (argc >= 1) ? ejsGetInt(ejs, argv[1]) : 0;
    count = (argc >= 2) ? ejsGetInt(ejs, argv[2]) : -1;

    if (offset < 0) {
        offset = ba->writePosition;
    }
    if (count < 0) {
        count = ba->length - offset;
    }
    if (count < 0) {
        //  Do something
    }
    nbytes = mprReadSocket(sp->sock, &ba->value[offset], count);
    if (nbytes < 0) {
        ejsThrowIOError(ejs, "Can't read from socket");
        return 0;
    }
    if (nbytes == 0) {
        //  TODO - but in async, this does not mean eof. See mpr for how to tell eof
        ejsSendEvent(ejs, sp->emitter, "eof", (EjsObj*) sp);
        //  TODO - do we need to set the mask here?
        return (EjsObj*) ejs->nullValue;
    }
    ba->writePosition += nbytes;
    sp->mask |= MPR_READABLE;
    enableSocketEvents(sp, socketIOEvent);
    return (EjsObj*) ejsCreateNumber(ejs, nbytes);
}


/*
    function get remoteAddress(): String
 */
static EjsObj *sock_remoteAddress(Ejs *ejs, EjsSocket *sp, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateString(ejs, sp->address);
}


/*
    function removeListener(name, listener: Function): Void
 */
static EjsObj *sock_removeListener(Ejs *ejs, EjsSocket *sp, int argc, EjsObj **argv)
{
    ejsRemoveListener(ejs, sp->emitter, argv[0], argv[1]);
    return 0;
}


static int writeSocketData(Ejs *ejs, EjsSocket *sp)
{
    EjsByteArray    *ba;
    int             count, nbytes;

    ba = sp->data;
    nbytes = 0;
    count = 0;
    if (ba && (count = ejsGetByteArrayAvailable(ba)) > 0) {
        nbytes = mprWriteSocket(sp->sock, &ba->value[ba->readPosition], count);
        if (nbytes < 0) {
            ejsThrowIOError(ejs, "Can't write to socket");
            return 0;
        }
        ba->readPosition += nbytes;
    }
    if (ejsGetByteArrayAvailable(ba) == 0) {
        if (sp->emitter) {
            ejsSendEvent(ejs, sp->emitter, "writable", (EjsObj*) sp);
        }
        if (sp->async) {
            sp->mask &= ~MPR_WRITABLE;
        }
    } else if (sp->async) {
        if (nbytes < count) {
            sp->mask |= MPR_WRITABLE;
        } else {
            sp->mask &= ~MPR_WRITABLE;
        }
    }
    return nbytes;
}


/*
    function write(...data): Number
 */
static EjsObj *sock_write(Ejs *ejs, EjsSocket *sp, int argc, EjsObj **argv)
{
    int     nbytes;

    if (sp->data) {
        ejsResetByteArray(sp->data);
    } else {
        sp->data = ejsCreateByteArray(ejs, -1);
    } 
    //  TODO - OPT. Could not copy and write directly from original source if source is a byte array
    if (ejsWriteToByteArray(ejs, sp->data, 1, &argv[0]) < 0) {
        return 0;
    }
    if ((nbytes = writeSocketData(ejs, sp)) < 0) {
        return 0;
    }
    if (sp->async) {
        enableSocketEvents(sp, socketIOEvent);
    }
    return (EjsObj*) ejsCreateNumber(ejs, nbytes);
}



static void enableSocketEvents(EjsSocket *sp, int (*proc)(EjsSocket *sp, MprEvent *event))
{
    if (sp->waitHandler.fd < 0) {
        mprInitWaitHandler(sp, &sp->waitHandler, sp->sock->fd, sp->mask, sp->ejs->dispatcher, (MprEventProc) proc, sp);
    } else {
        //  TODO - need API for this
        sp->waitHandler.proc = (MprEventProc) proc;
        mprEnableWaitEvents(&sp->waitHandler, sp->mask);
    }
}


static int socketConnectEvent(EjsSocket *sp, MprEvent *event)
{
    Ejs     *ejs;

    ejs = sp->ejs;
    if (sp->emitter) {
        ejsSendEvent(ejs, sp->emitter, "connect", (EjsObj*) sp);
        ejsSendEvent(ejs, sp->emitter, "writable", (EjsObj*) sp);
    }
    enableSocketEvents(sp, socketIOEvent);
    return 0;
}


static int socketListenEvent(EjsSocket *listen, MprEvent *event)
{
    Ejs     *ejs;

    ejs = listen->ejs;
    if (listen->emitter) {
        ejsSendEvent(ejs, listen->emitter, "accept", (EjsObj*) listen);
    }
    enableSocketEvents(listen, socketListenEvent);
    return 0;
}


static int socketIOEvent(EjsSocket *sp, MprEvent *event)
{
    Ejs     *ejs;

    ejs = sp->ejs;
    if (event->mask & MPR_READABLE) {
        if (sp->emitter) {
            ejsSendEvent(ejs, sp->emitter, "readable", (EjsObj*) sp);
        }
        sp->mask |= MPR_READABLE;
    } 
    if (event->mask & MPR_WRITABLE) {
        writeSocketData(ejs, sp);
    }
    enableSocketEvents(sp, socketIOEvent);
    return 0;
}


/*  Mark the object properties for the garbage collector
 */
static void markSocket(Ejs *ejs, EjsSocket *sp)
{
    //  MOB -- not needed
    ejsMarkObject(ejs, (EjsObj*) sp);

    if (sp->emitter) {
        ejsMark(ejs, (EjsObj*) sp->emitter);
    }
    if (sp->data) {
        ejsMark(ejs, (EjsObj*) sp->data);
    }
}



EjsSocket *ejsCreateSocket(Ejs *ejs)
{
    EjsSocket     *sp;

    sp = (EjsSocket*) ejsCreate(ejs, ejsGetTypeByName(ejs, EJS_EJS_NAMESPACE, "Socket"), 0);
    if (sp == 0) {
        return 0;
    }
    sp->ejs = ejs;
    sp->waitHandler.fd = -1;
    return sp;
}


void ejsConfigureSocketType(Ejs *ejs)
{
    EjsType     *type;

    type = ejsConfigureNativeType(ejs, EJS_EJS_NAMESPACE, "Socket", sizeof(EjsSocket));

    type->helpers = ejsCloneObjectHelpers(ejs, "socket-helpers");
    type->helpers->mark = (EjsMarkHelper) markSocket;

    ejsBindMethod(ejs, type, ES_Socket_Socket, (EjsProc) sock_Socket);
    ejsBindMethod(ejs, type, ES_Socket_accept, (EjsProc) sock_accept);
    ejsBindMethod(ejs, type, ES_Socket_addListener, (EjsProc) sock_addListener);
    ejsBindMethod(ejs, type, ES_Socket_address, (EjsProc) sock_address);
    ejsBindAccess(ejs, type, ES_Socket_async, (EjsProc) sock_async, (EjsProc) sock_set_async);
    ejsBindMethod(ejs, type, ES_Socket_close, (EjsProc) sock_close);
    ejsBindMethod(ejs, type, ES_Socket_connect, (EjsProc) sock_connect);
    ejsBindMethod(ejs, type, ES_Socket_listen, (EjsProc) sock_listen);
    ejsBindMethod(ejs, type, ES_Socket_port, (EjsProc) sock_port);
    ejsBindMethod(ejs, type, ES_Socket_read, (EjsProc) sock_read);
    ejsBindMethod(ejs, type, ES_Socket_remoteAddress, (EjsProc) sock_remoteAddress);
    ejsBindMethod(ejs, type, ES_Socket_removeListener, (EjsProc) sock_removeListener);
    ejsBindMethod(ejs, type, ES_Socket_write, (EjsProc) sock_write);
}

/*
    @copy   default
 
    Copyright (c) Embedthis Software LLC, 2003-2010. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2010. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    @end
 */
/************************************************************************/
/*
 *  End of file "../src/core/src/ejsSocket.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../src/core/src/ejsString.c"
 */
/************************************************************************/

/**
    ejsString.c - Ejscript string class

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */


#include    "pcre.h"


static int catString(Ejs *ejs, EjsString *dest, char *str, int len);
static int indexof(cchar *str, int len, cchar *pattern, int patlen, int dir);

/*
    Cast the string operand to a primitive type
 */
static EjsObj *castString(Ejs *ejs, EjsString *sp, EjsType *type)
{
    mprAssert(sp);
    mprAssert(type);

    if (type == ejs->pathType) {
        return (EjsObj*) ejsCreatePath(ejs, sp->value);
        
    } else if (type == ejs->uriType) {
        return (EjsObj*) ejsCreateUri(ejs, sp->value);
    }
    
    switch (type->id) {
    case ES_Boolean:
        if (sp->value[0]) {
            return (EjsObj*) ejs->trueValue;
        } else {
            return (EjsObj*) ejs->falseValue;
        }

    case ES_Number:
        return (EjsObj*) ejsParse(ejs, sp->value, ES_Number);

    case ES_RegExp:
        if (sp->value && sp->value[0] == '/') {
            return (EjsObj*) ejsCreateRegExp(ejs, sp->value);
        } else {
            EjsObj      *result;
            char        *buf;
            buf = mprStrcat(ejs, -1, "/", sp->value, "/", NULL);
            result = (EjsObj*) ejsCreateRegExp(ejs, buf);
            mprFree(buf);
            return result;
        }

    case ES_String:
        return (EjsObj*) sp;

    default:
        ejsThrowTypeError(ejs, "Can't cast to required type");
        return 0;
    }
    return 0;
}


/*
    Clone a string. Shallow copies simply return a reference as strings are immutable.
 */
static EjsString *cloneString(Ejs *ejs, EjsString *sp, bool deep)
{
    if (deep) {
        return ejsCreateStringWithLength(ejs, sp->value, sp->length);
    }
    return sp;
}


//  TODO - can remove as free var will do this automatically
static void destroyString(Ejs *ejs, EjsString *sp)
{
    mprAssert(sp);

    mprFree(sp->value);
    sp->value = 0;
    ejsFree(ejs, (EjsObj*) sp, -1);
}


/*
    Get a string element. Slot numbers correspond to character indicies.
 */
static EjsObj *getStringProperty(Ejs *ejs, EjsString *sp, int index)
{
    if (index < 0 || index >= sp->length) {
        ejsThrowOutOfBoundsError(ejs, "Bad string subscript");
        return 0;
    }
    return (EjsObj*) ejsCreateStringWithLength(ejs, &sp->value[index], 1);
}


static EjsObj *coerceStringOperands(Ejs *ejs, EjsObj *lhs, int opcode,  EjsObj *rhs)
{
    switch (opcode) {
    /*
        Binary operators
     */
    case EJS_OP_ADD:
        return ejsInvokeOperator(ejs, lhs, opcode, (EjsObj*) ejsToString(ejs, rhs));

    /*
        Overloaded operators
     */
    case EJS_OP_MUL:
        if (ejsIsNumber(rhs)) {
            return ejsInvokeOperator(ejs, (EjsObj*) ejsToNumber(ejs, lhs), opcode, rhs);
        }
        return ejsInvokeOperator(ejs, lhs, opcode, (EjsObj*) ejsToNumber(ejs, rhs));

    case EJS_OP_REM:
        return 0;

    case EJS_OP_AND: case EJS_OP_DIV: case EJS_OP_OR:
    case EJS_OP_SHL: case EJS_OP_SHR: case EJS_OP_SUB: case EJS_OP_USHR: case EJS_OP_XOR:
        return ejsInvokeOperator(ejs, (EjsObj*) ejsToNumber(ejs, lhs), opcode, rhs);

    case EJS_OP_COMPARE_EQ: case EJS_OP_COMPARE_NE:
    case EJS_OP_COMPARE_LE: case EJS_OP_COMPARE_LT:
    case EJS_OP_COMPARE_GE: case EJS_OP_COMPARE_GT:
        return ejsInvokeOperator(ejs, lhs, opcode, (EjsObj*) ejsToString(ejs, rhs));

    case EJS_OP_COMPARE_STRICTLY_NE:
        return (EjsObj*) ejs->trueValue;

    case EJS_OP_COMPARE_STRICTLY_EQ:
        return (EjsObj*) ejs->falseValue;

    /*
        Unary operators
     */
    case EJS_OP_LOGICAL_NOT:
        return ejsInvokeOperator(ejs, (EjsObj*) ejsToBoolean(ejs, lhs), opcode, rhs);

    case EJS_OP_NOT:
    case EJS_OP_NEG:
        return ejsInvokeOperator(ejs, (EjsObj*) ejsToNumber(ejs, lhs), opcode, rhs);

    case EJS_OP_COMPARE_NOT_ZERO:
    case EJS_OP_COMPARE_TRUE:
        return (EjsObj*) (((EjsString*) lhs)->value ? ejs->trueValue : ejs->falseValue);

    case EJS_OP_COMPARE_ZERO:
    case EJS_OP_COMPARE_FALSE:
        return (EjsObj*) (((EjsString*) lhs)->value ? ejs->falseValue: ejs->trueValue);

    case EJS_OP_COMPARE_UNDEFINED:
    case EJS_OP_COMPARE_NULL:
        return (EjsObj*) ejs->falseValue;

    default:
        ejsThrowTypeError(ejs, "Opcode %d not valid for type %s", opcode, lhs->type->qname.name);
        return ejs->undefinedValue;
    }
    return 0;
}


static EjsObj *invokeStringOperator(Ejs *ejs, EjsString *lhs, int opcode,  EjsString *rhs, void *data)
{
    EjsObj      *result;
    EjsObj      *arg;

    if (rhs == 0 || lhs->obj.type != rhs->obj.type) {
        if (!ejsIsA(ejs, (EjsObj*) lhs, ejs->stringType) || !ejsIsA(ejs, (EjsObj*) rhs, ejs->stringType)) {
            if ((result = coerceStringOperands(ejs, (EjsObj*) lhs, opcode, (EjsObj*) rhs)) != 0) {
                return result;
            }
        }
    }
    /*
        Types now match, both strings
     */
    switch (opcode) {
    case EJS_OP_COMPARE_STRICTLY_EQ:
    case EJS_OP_COMPARE_EQ:
        if (lhs == rhs || (lhs->value == rhs->value)) {
            return (EjsObj*) ejs->trueValue;
        }
        return (EjsObj*) ejsCreateBoolean(ejs,  mprMemcmp(lhs->value, lhs->length, rhs->value, rhs->length) == 0);

    case EJS_OP_COMPARE_NE:
    case EJS_OP_COMPARE_STRICTLY_NE:
        if (lhs->length != rhs->length) {
            return (EjsObj*) ejs->trueValue;
        }
        return (EjsObj*) ejsCreateBoolean(ejs,  mprMemcmp(lhs->value, lhs->length, rhs->value, rhs->length) != 0);

    case EJS_OP_COMPARE_LT:
        return (EjsObj*) ejsCreateBoolean(ejs,  mprMemcmp(lhs->value, lhs->length, rhs->value, rhs->length) < 0);

    case EJS_OP_COMPARE_LE:
        return (EjsObj*) ejsCreateBoolean(ejs,  mprMemcmp(lhs->value, lhs->length, rhs->value, rhs->length) <= 0);

    case EJS_OP_COMPARE_GT:
        return (EjsObj*) ejsCreateBoolean(ejs,  mprMemcmp(lhs->value, lhs->length, rhs->value, rhs->length) > 0);

    case EJS_OP_COMPARE_GE:
        return (EjsObj*) ejsCreateBoolean(ejs,  mprMemcmp(lhs->value, lhs->length, rhs->value, rhs->length) >= 0);

    /*
        Unary operators
     */
    case EJS_OP_COMPARE_NOT_ZERO:
        return (EjsObj*) ((lhs->value) ? ejs->trueValue: ejs->falseValue);

    case EJS_OP_COMPARE_ZERO:
        return (EjsObj*) ((lhs->value == 0) ? ejs->trueValue: ejs->falseValue);


    case EJS_OP_COMPARE_UNDEFINED:
    case EJS_OP_COMPARE_NULL:
    case EJS_OP_COMPARE_FALSE:
    case EJS_OP_COMPARE_TRUE:
        return (EjsObj*) ejs->falseValue;

    /*
        Binary operators
     */
    case EJS_OP_ADD:
        result = (EjsObj*) ejsCreateString(ejs, lhs->value);
        ejsStrcat(ejs, (EjsString*) result, (EjsObj*) rhs);
        return result;

    case EJS_OP_AND: case EJS_OP_DIV: case EJS_OP_OR:
    case EJS_OP_SHL: case EJS_OP_SHR: case EJS_OP_USHR: case EJS_OP_XOR:
        return ejsInvokeOperator(ejs, (EjsObj*) ejsToNumber(ejs, (EjsObj*) lhs), opcode, (EjsObj*) rhs);

#if EXTENSIONS || 1
    /*
        Overloaded
     */
    case EJS_OP_SUB:
        arg = (EjsObj*) rhs;
        return ejsRunFunctionBySlot(ejs, (EjsObj*) lhs, ES_String_MINUS, 1, &arg);

    case EJS_OP_REM:
        arg = (EjsObj*) rhs;
        return ejsRunFunctionBySlot(ejs, (EjsObj*) lhs, ES_String_MOD, 1, &arg);
#endif

    case EJS_OP_NEG:
    case EJS_OP_LOGICAL_NOT:
    case EJS_OP_NOT:
        /* Already handled in coerceStringOperands */
    default:
        ejsThrowTypeError(ejs, "Opcode %d not implemented for type %s", opcode, lhs->obj.type->qname.name);
        return 0;
    }
    mprAssert(0);
}


/*
    Lookup an string index.
 */
static int lookupStringProperty(struct Ejs *ejs, EjsString *sp, EjsName *qname)
{
    int     index;

    if (qname == 0 || ! isdigit((int) qname->name[0])) {
        return EJS_ERR;
    }
    index = atoi(qname->name);
    if (index < sp->length) {
        return index;
    }

    return EJS_ERR;
}


/*
    String constructor.

        function String()
        function String(str: String)
 */
static EjsObj *stringConstructor(Ejs *ejs, EjsString *sp, int argc, EjsObj **argv)
{
    EjsArray    *args;
    EjsString   *str;

    mprAssert(argc == 0 || (argc == 1 && ejsIsArray(argv[0])));
    sp->length = 0;

    if (argc == 1) {
        args = (EjsArray*) argv[0];
        if (args->length > 0) {
            str = ejsToString(ejs, ejsGetProperty(ejs, (EjsObj*) args, 0));
            if (str) {
                sp->value = mprStrdup(sp, str->value);
                sp->length = str->length;
            }
        } else {
            sp->value = mprStrdup(ejs, "");
            if (sp->value == 0) {
                return 0;
            }
            sp->length = 0;
        }

    } else {
        sp->value = mprStrdup(ejs, "");
        if (sp->value == 0) {
            return 0;
        }
        sp->length = 0;
    }
    return (EjsObj*) sp;
}


/*
    Do a case sensitive comparison between this string and another.

    function caseCompare(compare: String): Number
 */
static EjsObj *caseCompare(Ejs *ejs, EjsString *sp, int argc, EjsObj **argv)
{
    int     result;

    mprAssert(argc == 1 && ejsIsString(argv[0]));

    result = mprStrcmp(sp->value, ((EjsString*) argv[0])->value);
    return (EjsObj*) ejsCreateNumber(ejs, result);
}


/*
    Do a case insensitive comparison between this string and another.

    function caselessCompare(compare: String): Number
 */
static EjsObj *caselessCompare(Ejs *ejs, EjsString *sp, int argc, EjsObj **argv)
{
    int     result;

    mprAssert(argc == 1 && ejsIsString(argv[0]));

    result = mprStrcmpAnyCase(sp->value, ((EjsString*) argv[0])->value);
    return (EjsObj*) ejsCreateNumber(ejs, result);
}


/*
    Return a string containing the character at a given index

    function charAt(index: Number): String
 */
static EjsObj *charAt(Ejs *ejs, EjsString *sp, int argc, EjsObj **argv)
{
    int     index;

    mprAssert(argc == 1 && ejsIsNumber(argv[0]));
    index = ejsGetInt(ejs, argv[0]);
    if (index < 0 || index >= sp->length) {
        ejsThrowOutOfBoundsError(ejs, "Bad string subscript");
        return 0;
    }
    return (EjsObj*) ejsCreateStringWithLength(ejs, &sp->value[index], 1);
}


/*
    Return an integer containing the character at a given index

    function charCodeAt(index: Number = 0): Number
 */

static EjsObj *charCodeAt(Ejs *ejs, EjsString *sp, int argc, EjsObj **argv)
{
    int     index;

    index = (argc == 1) ? ejsGetInt(ejs, argv[0]) : 0;
    if (index < 0) {
        index = sp->length -1 ;
    }
    if (index < 0 || index >= sp->length) {
        return (EjsObj*) ejs->nanValue;;
    }
    return (EjsObj*) ejsCreateNumber(ejs, (uchar) sp->value[index]);
}


/*
    Catenate args to a string and return a new string.

    function concat(...args): String
 */
static EjsObj *concatString(Ejs *ejs, EjsString *sp, int argc, EjsObj **argv)
{
    EjsArray    *args;
    EjsString   *result;
    int         i, count;

    mprAssert(argc == 1 && ejsIsArray(argv[0]));
    args = (EjsArray*) argv[0];

    result = ejsDupString(ejs, sp);

    count = ejsGetPropertyCount(ejs, (EjsObj*) args);
    for (i = 0; i < args->length; i++) {
        if (ejsStrcat(ejs, result, ejsGetProperty(ejs, (EjsObj*) args, i)) < 0) {
            ejsThrowMemoryError(ejs);
            return 0;
        }
    }
    return (EjsObj*) result;
}


/**
    Check if a string contains the pattern (string or regexp)

    function contains(pattern: Object): Boolean
 */
static EjsObj *containsString(Ejs *ejs, EjsString *sp, int argc, EjsObj **argv)
{
    EjsObj      *pat;

    pat = argv[0];

    if (ejsIsString(pat)) {
        return (EjsObj*) ejsCreateBoolean(ejs, strstr(sp->value, ((EjsString*) pat)->value) != 0);
    } else if (ejsIsRegExp(pat)) {
        EjsRegExp   *rp;
        int         count;
        rp = (EjsRegExp*) argv[0];
        count = pcre_exec(rp->compiled, NULL, sp->value, sp->length, 0, 0, 0, 0);
        return (EjsObj*) ejsCreateBoolean(ejs, count >= 0);
    }
    ejsThrowTypeError(ejs, "Wrong argument type");
    return 0;
}


/**
    Check if a string ends with a given pattern

    function endsWith(pattern: String): Boolean
 */
static EjsObj *endsWith(Ejs *ejs, EjsString *sp, int argc, EjsObj **argv)
{
    cchar       *pattern;
    int         len;

    mprAssert(argc == 1 && ejsIsString(argv[0]));

    pattern = ejsGetString(ejs, argv[0]);
    len = (int) strlen(pattern);
    if (len > sp->length) {
        return (EjsObj*) ejs->falseValue;
    }
    return (EjsObj*) ejsCreateBoolean(ejs, strncmp(&sp->value[sp->length - len], pattern, len) == 0);
}


/**
    Format the arguments

    function format(...args): String

    Format:         %[modifier][width][precision][bits][type]
 */
static EjsObj *formatString(Ejs *ejs, EjsString *sp, int argc, EjsObj **argv)
{
    EjsArray    *args, *inner;
    EjsString   *result;
    EjsObj      *value;
    char        *buf;
    char        fmt[16];
    int         c, i, len, nextArg, start, kind, last;

    mprAssert(argc == 1 && ejsIsArray(argv[0]));

    args = (EjsArray*) argv[0];

    /*
        Flatten the args if there is only one element and it is itself an array. This happens when invoked
        via the overloaded operator '%' which in turn invokes format()
     */
    if (args->length == 1) {
        inner = (EjsArray*) ejsGetProperty(ejs, (EjsObj*) args, 0);
        if (ejsIsArray(inner)) {
            args = inner;
        }
    }
    result = ejsCreateString(ejs, 0);

    if (result == 0) {
        ejsThrowMemoryError(ejs);
        return 0;
    }

    /*
        Parse the format string and extract one specifier at a time.
     */
    last = 0;
    for (i = 0, nextArg = 0; i < sp->length && nextArg < args->length; i++) {
        c = sp->value[i];
        if (c != '%') {
            continue;
        }

        if (i > last) {
            catString(ejs, result, &sp->value[last], i - last);
        }

        /*
            Find the end of the format specifier and determine the format type (kind)
         */
        start = i++;
        i += (int) strspn(&sp->value[i], "-+ #,0*123456789.hlL");
        kind = sp->value[i];

        if (strchr("cdefginopsSuxX", kind)) {
            len = i - start + 1;
            mprMemcpy(fmt, sizeof(fmt), &sp->value[start], len);
            fmt[len] = '\0';

            value = ejsGetProperty(ejs, (EjsObj*) args, nextArg);

            buf = 0;
            switch (kind) {
            case 'd': case 'i': case 'o': case 'u':
                value = (EjsObj*) ejsToNumber(ejs, value);
                buf = mprAsprintf(ejs, -1, fmt, (int64) ejsGetNumber(ejs, value));
                break;

            case 'e': case 'g': case 'f':
                value = (EjsObj*) ejsToNumber(ejs, value);
                buf = mprAsprintf(ejs, -1, fmt, (double) ejsGetNumber(ejs, value));
                break;

            case 's':
                value = (EjsObj*) ejsToString(ejs, value);
                buf = mprAsprintf(ejs, -1, fmt, ejsGetString(ejs, value));
                break;

            case 'X': case 'x':
                buf = mprAsprintf(ejs, -1, fmt, (int64) ejsGetNumber(ejs, value));
                break;

            case 'n':
                buf = mprAsprintf(ejs, -1, fmt, 0);

            default:
                ejsThrowArgError(ejs, "Bad format specifier");
                return 0;
            }
            catString(ejs, result, buf, strlen(buf));
            mprFree(buf);
            last = i + 1;
            nextArg++;
        }
    }

    i = (int) strlen(sp->value);
    if (i > last) {
        catString(ejs, result, &sp->value[last], i - last);
    }

    return (EjsObj*) result;
}


/*
    Create a string from character codes

    static function fromCharCode(...codes): String
 */
static EjsObj *fromCharCode(Ejs *ejs, EjsString *unused, int argc, EjsObj **argv)
{
    EjsString   *result;
    EjsArray    *args;
    EjsObj      *vp;
    int         i;

    mprAssert(argc == 1 && ejsIsArray(argv[0]));
    args = (EjsArray*) argv[0];

    result = (EjsString*) ejsCreateBareString(ejs, argc + 1);
    if (result == 0) {
        return 0;
    }

    for (i = 0; i < args->length; i++) {
        vp = ejsGetProperty(ejs, (EjsObj*) args, i);
        result->value[i] = ejsGetInt(ejs, ejsToNumber(ejs, vp));
    }
    result->value[i] = '\0';
    result->length = args->length;

    return (EjsObj*) result;
}


/*
    Function to iterate and return the next character code.
    NOTE: this is not a method of String. Rather, it is a callback function for Iterator
 */
static EjsObj *nextStringKey(Ejs *ejs, EjsIterator *ip, int argc, EjsObj **argv)
{
    EjsString   *sp;

    sp = (EjsString*) ip->target;

    if (!ejsIsString(sp)) {
        ejsThrowReferenceError(ejs, "Wrong type");
        return 0;
    }

    if (ip->index < sp->length) {
        return (EjsObj*) ejsCreateNumber(ejs, ip->index++);
    }
    ejsThrowStopIteration(ejs);
    return 0;
}


/*
    Return the default iterator. This returns the array index names.

    iterator function get(): Iterator
 */
static EjsObj *getStringIterator(Ejs *ejs, EjsObj *sp, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateIterator(ejs, sp, (EjsProc) nextStringKey, 0, NULL);
}


/*
    Function to iterate and return the next string character (as a string).
    NOTE: this is not a method of Array. Rather, it is a callback function for Iterator
 */
static EjsObj *nextStringValue(Ejs *ejs, EjsIterator *ip, int argc, EjsObj **argv)
{
    EjsString   *sp;

    sp = (EjsString*) ip->target;
    if (!ejsIsString(sp)) {
        ejsThrowReferenceError(ejs, "Wrong type");
        return 0;
    }

    if (ip->index < sp->length) {
        return (EjsObj*) ejsCreateStringWithLength(ejs, &sp->value[ip->index++], 1);
    }
    ejsThrowStopIteration(ejs);
    return 0;
}


/*
    Return an iterator to return the next array element value.

    iterator function getValues(): Iterator
 */
static EjsObj *getStringValues(Ejs *ejs, EjsObj *sp, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateIterator(ejs, sp, (EjsProc) nextStringValue, 0, NULL);
}


/*
    Get the length of a string.
    @return Returns the number of characters in the string

    override function get length(): Number
 */

static EjsObj *stringLength(Ejs *ejs, EjsString *ap, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateNumber(ejs, ap->length);
}


/*
    Return the position of the first occurance of a substring

    function indexOf(pattern: String, startIndex: Number = 0): Number
 */
static EjsObj *indexOf(Ejs *ejs, EjsString *sp, int argc,  EjsObj **argv)
{
    cchar   *pattern;
    int     index, start, patternLength;

    mprAssert(1 <= argc && argc <= 2);
    mprAssert(ejsIsString(argv[0]));

    pattern = ejsGetString(ejs, argv[0]);
    patternLength = ((EjsString*) argv[0])->length;

    if (argc == 2) {
        start = ejsGetInt(ejs, argv[1]);
        if (start > sp->length) {
            start = sp->length;
        }
        if (start < 0) {
            start = 0;
        }
    } else {
        start = 0;
    }

    index = indexof(&sp->value[start], sp->length - start, pattern, patternLength, 1);
    if (index < 0) {
        return (EjsObj*) ejs->minusOneValue;
    }
    return (EjsObj*) ejsCreateNumber(ejs, index + start);
}


static EjsObj *isAlpha(Ejs *ejs, EjsString *sp, int argc,  EjsObj **argv)
{
    cchar   *cp;

    if (sp->length == 0) {
        return (EjsObj*) ejs->falseValue;
    }
    for (cp = sp->value; cp < &sp->value[sp->length]; cp++) {
        if (!isalpha((int) *cp)) {
            return (EjsObj*) ejs->falseValue;
        }
    }
    return (EjsObj*) ejs->trueValue;
}


static EjsObj *isAlphaNum(Ejs *ejs, EjsString *sp, int argc,  EjsObj **argv)
{
    cchar   *cp;

    if (sp->length == 0) {
        return (EjsObj*) ejs->falseValue;
    }
    for (cp = sp->value; cp < &sp->value[sp->length]; cp++) {
        if (!isalnum((int) *cp)) {
            return (EjsObj*) ejs->falseValue;
        }
    }
    return (EjsObj*) ejs->trueValue;
}


static EjsObj *isDigit(Ejs *ejs, EjsString *sp, int argc,  EjsObj **argv)
{
    cchar   *cp;

    if (sp->length == 0) {
        return (EjsObj*) ejs->falseValue;
    }
    for (cp = sp->value; cp < &sp->value[sp->length]; cp++) {
        if (!isdigit((int) *cp)) {
            return (EjsObj*) ejs->falseValue;
        }
    }
    return (EjsObj*) ejs->trueValue;
}


static EjsObj *isLower(Ejs *ejs, EjsString *sp, int argc,  EjsObj **argv)
{
    cchar   *cp;

    if (sp->length == 0) {
        return (EjsObj*) ejs->falseValue;
    }
    for (cp = sp->value; cp < &sp->value[sp->length]; cp++) {
        if (!islower((int) *cp)) {
            return (EjsObj*) ejs->falseValue;
        }
    }
    return (EjsObj*) ejs->trueValue;
}


static EjsObj *isSpace(Ejs *ejs, EjsString *sp, int argc,  EjsObj **argv)
{
    cchar   *cp;

    if (sp->length == 0) {
        return (EjsObj*) ejs->falseValue;
    }
    for (cp = sp->value; cp < &sp->value[sp->length]; cp++) {
        if (!isspace((int) *cp)) {
            return (EjsObj*) ejs->falseValue;
        }
    }
    return (EjsObj*) ejs->trueValue;
}


static EjsObj *isUpper(Ejs *ejs, EjsString *sp, int argc,  EjsObj **argv)
{
    cchar   *cp;

    if (sp->length == 0) {
        return (EjsObj*) ejs->falseValue;
    }
    for (cp = sp->value; cp < &sp->value[sp->length]; cp++) {
        if (!isupper((int) *cp)) {
            return (EjsObj*) ejs->falseValue;
        }
    }
    return (EjsObj*) ejs->trueValue;
}


/*
    Return the position of the last occurance of a substring

    function lastIndexOf(pattern: String, start: Number = -1): Number
 */
static EjsObj *lastIndexOf(Ejs *ejs, EjsString *sp, int argc,  EjsObj **argv)
{
    cchar   *pattern;
    int     start, patternLength, index;

    mprAssert(1 <= argc && argc <= 2);

    pattern = ejsGetString(ejs, argv[0]);
    patternLength = ((EjsString*) argv[0])->length;

    if (argc == 2) {
        start = ejsGetInt(ejs, argv[1]);
        if (start > sp->length) {
            start = sp->length;
        }
        if (start < 0) {
            start = 0;
        }

    } else {
        start = 0;
    }
    if (start < 0 || start >= sp->length) {
        ejsThrowOutOfBoundsError(ejs, "Bad start subscript");
        return 0;
    }
    index = indexof(sp->value, sp->length, pattern, patternLength, -1);
    if (index < 0) {
        return (EjsObj*) ejs->minusOneValue;
    }
    return (EjsObj*) ejsCreateNumber(ejs, index);
}


/*
    Match a pattern

    function match(pattern: RegExp): Array
 */
static EjsObj *match(Ejs *ejs, EjsString *sp, int argc, EjsObj **argv)
{
    EjsRegExp   *rp;
    EjsArray    *results;
    EjsString   *match;
    int         matches[EJS_MAX_REGEX_MATCHES * 3];
    int         i, count, len, resultCount;

    rp = (EjsRegExp*) argv[0];
    rp->endLastMatch = 0;
    results = NULL;
    resultCount = 0;

    do {
        count = pcre_exec(rp->compiled, NULL, sp->value, sp->length, rp->endLastMatch, 0, matches, 
            sizeof(matches) / sizeof(int));
        if (count <= 0) {
            break;
        }
        if (results == 0) {
            results = ejsCreateArray(ejs, count);
        }
        for (i = 0; i < count * 2; i += 2) {
            len = matches[i + 1] - matches[i];
            match = ejsCreateStringWithLength(ejs, &sp->value[matches[i]], len);
            ejsSetProperty(ejs, (EjsObj*) results, resultCount++, (EjsObj*) match);
            rp->endLastMatch = matches[i + 1];
            if (rp->global) {
                break;
            }
        }
    } while (rp->global);
    if (results == NULL) {
        return (EjsObj*) ejs->nullValue;
    }
    return (EjsObj*) results;
}


static EjsObj *printable(Ejs *ejs, EjsString *sp, int argc, EjsObj **argv)
{
    EjsString       *result;
    char            buf[16];
    int             i, j, k, len, nonprint;

    nonprint = 0;
    for (i = 0; i < sp->length; i++)  {
        if (!isprint((uchar) sp->value[i])) {
            nonprint++;
        }
    }
    if (nonprint == 0) {
        return (EjsObj*) sp;
    }

    result = ejsCreateBareString(ejs, sp->length + (nonprint * 6) + 1);
    if (result == 0) {
        return 0;
    }
    for (i = 0, j = 0; i < sp->length; i++)  {
        if (isprint((uchar) sp->value[i])) {
            result->value[j++] = sp->value[i];
        } else {
            result->value[j++] = '\\';
            result->value[j++] = 'u';
            mprItoa(buf, 4, sp->value[i], 16);
            len = (int) strlen(buf);
            for (k = len; k < 4; k++) {
                result->value[j++] = '0';
            }
            for (k = 0; buf[k]; k++) {
                result->value[j++] = buf[k];
            }
        }
    }
    result->value[j] = '\0';
    result->length = j;
    return (EjsObj*) result;
}


static EjsObj *quote(Ejs *ejs, EjsString *sp, int argc, EjsObj **argv)
{
    EjsString       *result;

    result = ejsCreateBareString(ejs, sp->length + 2);
    if (result == 0) {
        return 0;
    }
    memcpy(&result->value[1], sp->value, sp->length);
    result->value[0] = '"';
    result->value[sp->length + 1] = '"';
    result->value[sp->length + 2] = '\0';
    result->length = sp->length + 2;
    return (EjsObj*) result;
}


/*
    Remove characters and return a new string.

    function remove(start: Number, end: Number = -1): String

 */
static EjsObj *removeCharsFromString(Ejs *ejs, EjsString *sp, int argc, EjsObj **argv)
{
    EjsString       *result;
    int             start, end, i, j;

    mprAssert(1 <= argc && argc <= 2);

    start = ejsGetInt(ejs, argv[0]);
    end = ejsGetInt(ejs, argv[1]);

    if (start < 0) {
        start += sp->length;
    }
    if (start < 0) {
        start = 0;
    }
    if (end < 0) {
        end += sp->length;
    }
    if (end < 0) {
        end = 0;
    }
    if (start >= sp->length) {
        start = sp->length - 1;
    }
    if (end > sp->length) {
        end = sp->length;
    }
    result = ejsCreateBareString(ejs, sp->length - (end - start));
    if (result == 0) {
        return 0;
    }
    for (j = i = 0; i < start; i++, j++) {
        result->value[j] = sp->value[i];
    }
    for (i = end; i < sp->length; i++, j++) {
        result->value[j] = sp->value[i];
    }
    result->value[j] = '\0';
    return (EjsObj*) result;
}


/*
    Search and replace.

    function replace(pattern: (String|Regexp), replacement: String): String

 */
static EjsObj *replace(Ejs *ejs, EjsString *sp, int argc, EjsObj **argv)
{
    EjsString   *result, *replacement;
    cchar       *pattern;
    int         index, patternLength;

    result = 0;
    replacement = (EjsString*) argv[1];

    if (ejsIsString(argv[0])) {
        pattern = ejsGetString(ejs, argv[0]);
        patternLength = ((EjsString*) argv[0])->length;

        index = indexof(sp->value, sp->length, pattern, patternLength, 1);
        if (index >= 0) {
            result = ejsCreateString(ejs, 0);
            if (result == 0) {
                return 0;
            }
            catString(ejs, result, sp->value, index);
            catString(ejs, result, replacement->value, replacement->length);

            index += patternLength;
            if (index < sp->length) {
                catString(ejs, result, &sp->value[index], sp->length - index);
            }

        } else {
            result = ejsDupString(ejs, sp);
        }

    } else if (ejsIsRegExp(argv[0])) {
        EjsRegExp   *rp;
        char        *cp, *lastReplace, *end;
        int         matches[EJS_MAX_REGEX_MATCHES * 3];
        int         count, endLastMatch, submatch;

        rp = (EjsRegExp*) argv[0];
        result = ejsCreateString(ejs, 0);
        endLastMatch = 0;

        do {
            count = pcre_exec(rp->compiled, NULL, sp->value, sp->length, endLastMatch, 0, matches, 
                    sizeof(matches) / sizeof(int));
            if (count <= 0) {
                break;
            }
            if (endLastMatch < matches[0]) {
                /* Append prior string text */
                catString(ejs, result, &sp->value[endLastMatch], matches[0] - endLastMatch);
            }

            /*
                Process the replacement template
             */
            end = &replacement->value[replacement->length];
            lastReplace = replacement->value;

            for (cp = replacement->value; cp < end; ) {
                if (*cp == '$') {
                    if (lastReplace < cp) {
                        catString(ejs, result, lastReplace, (int) (cp - lastReplace));
                    }
                    switch (*++cp) {
                    case '$':
                        catString(ejs, result, "$", 1);
                        break;
                    case '&':
                        /* Replace the matched string */
                        catString(ejs, result, &sp->value[matches[0]], matches[1] - matches[0]);
                        break;
                    case '`':
                        /* Insert the portion that preceeds the matched string */
                        catString(ejs, result, sp->value, matches[0]);
                        break;
                    case '\'':
                        /* Insert the portion that follows the matched string */
                        catString(ejs, result, &sp->value[matches[1]], sp->length - matches[1]);
                        break;
                    default:
                        /* Insert the nth submatch */
                        if (isdigit((int) *cp)) {
                            submatch = (int) mprAtoi(cp, 10);
                            while (isdigit((int) *++cp))
                                ;
                            cp--;
                            if (submatch < count) {
                                submatch *= 2;
                                catString(ejs, result, &sp->value[matches[submatch]], 
                                    matches[submatch + 1] - matches[submatch]);
                            }

                        } else {
                            ejsThrowArgError(ejs, "Bad replacement $ specification");
                            return 0;
                        }
                    }
                    lastReplace = cp + 1;
                }
                cp++;
            }
            if (lastReplace < cp && lastReplace < end) {
                catString(ejs, result, lastReplace, (int) (cp - lastReplace));
            }
            endLastMatch = matches[1];

        } while (rp->global);

        if (endLastMatch < sp->length) {
            /* Append remaining string text */
            catString(ejs, result, &sp->value[endLastMatch], sp->length - endLastMatch);
        }

    } else {
        ejsThrowTypeError(ejs, "Wrong argument type");
        return 0;
    }
    return (EjsObj*) result;
}


static EjsObj *reverseString(Ejs *ejs, EjsString *sp, int argc, EjsObj **argv)
{
    int         i, j, tmp;

    if ((sp = ejsCreateStringWithLength(ejs, sp->value, sp->length)) == 0) {
        return 0;
    }
    if (sp->length <= 1) {
        return (EjsObj*) sp;
    }
    i = (sp->length - 2) / 2;
    j = (sp->length + 1) / 2;
    for (; i >= 0; i--, j++) {
        tmp = sp->value[i];
        sp->value[i] = sp->value[j];
        sp->value[j] = tmp;
    }
    return (EjsObj*) sp;
}


/*
    Search for a pattern
    function search(pattern: (String | RegExp)): Number
 */
static EjsObj *searchString(Ejs *ejs, EjsString *sp, int argc, EjsObj **argv)
{
    cchar       *pattern;
    int         index, patternLength;

    if (ejsIsString(argv[0])) {
        pattern = ejsGetString(ejs, argv[0]);
        patternLength = ((EjsString*) argv[0])->length;

        index = indexof(sp->value, sp->length, pattern, patternLength, 1);
        return (EjsObj*) ejsCreateNumber(ejs, index);

    } else if (ejsIsRegExp(argv[0])) {
        EjsRegExp   *rp;
        int         matches[EJS_MAX_REGEX_MATCHES * 3];
        int         count;
        rp = (EjsRegExp*) argv[0];
        count = pcre_exec(rp->compiled, NULL, sp->value, sp->length, 0, 0, matches, sizeof(matches) / sizeof(int));
        if (count < 0) {
            return (EjsObj*) ejs->minusOneValue;
        }
        return (EjsObj*) ejsCreateNumber(ejs, matches[0]);

    } else {
        ejsThrowTypeError(ejs, "Wrong argument type");
        return 0;
    }
}


/*
    Return a substring. End is one past the last character.

    function slice(start: Number, end: Number = -1, step: Number = 1): String
 */
static EjsObj *sliceString(Ejs *ejs, EjsString *sp, int argc, EjsObj **argv)
{
    EjsString       *result;
    int             start, end, step, i, j;

    mprAssert(1 <= argc && argc <= 3);

    start = ejsGetInt(ejs, argv[0]);
    if (argc >= 2) {
        end = ejsGetInt(ejs, argv[1]);
    } else {
        end = sp->length;
    }
    if (argc == 3) {
        step = ejsGetInt(ejs, argv[2]);
    } else {
        step = 1;
    }

    if (start < 0) {
        start += sp->length;
    }
    if (end < 0) {
        end += sp->length;
    }
    if (step == 0) {
        step = 1;
    }
    if (start < 0) {
        start = 0;
    }
    if (start >= sp->length) {
        start = sp->length;
    }
    if (end < 0) {
        end = 0;
    }
    if (end >= sp->length) {
        end = sp->length;
    }
    result = ejsCreateBareString(ejs, (end - start) / abs(step));
    if (result == 0) {
        return 0;
    }
    if (step > 0) {
        for (i = start, j = 0; i < end; i += step) {
            result->value[j++] = sp->value[i];
        }

    } else {
        for (i = end - 1, j = 0; i >= start; i += step) {
            result->value[j++] = sp->value[i];
        }
    }
    result->value[j] = '\0';
    result->length = j;
    return (EjsObj*) result;
}


/*
    Split a string

    function split(delimiter: (String | RegExp), limit: Number = -1): Array
 */
static EjsObj *split(Ejs *ejs, EjsString *sp, int argc, EjsObj **argv)
{
    EjsArray    *results;
    EjsString   *elt;
    cchar       *delim;
    char        *cp, *mark, *end;
    int         delimLen, limit;

    mprAssert(1 <= argc && argc <= 2);

    limit = (argc == 2) ? ejsGetInt(ejs, argv[1]): -1;
    results = ejsCreateArray(ejs, 0);

    if (ejsIsString(argv[0])) {
        delim = ejsGetString(ejs, argv[0]);
        delimLen = (int) strlen(delim);

        if (delimLen == 0) {
            for (cp = sp->value; (--limit != -1) && *cp; cp++) {
                ejsSetProperty(ejs, (EjsObj*) results, -1, (EjsObj*) ejsCreateStringWithLength(ejs, cp, 1));
            }

        } else {
            end = &sp->value[sp->length];
            for (mark = cp = sp->value; (--limit != -1) && mark < end; mark++) {
                if (strncmp(mark, delim, delimLen) == 0) {
                    elt = ejsCreateStringWithLength(ejs, cp, (int) (mark - cp));
                    ejsSetProperty(ejs, (EjsObj*) results, -1, (EjsObj*) elt);
                    cp = mark + delimLen;
                    mark = cp;
                    if (mark >= end) {
                        break;
                    }
                }
            }
            if (mark > cp) {
                elt = ejsCreateStringWithLength(ejs, cp, (int) (mark - cp));
                ejsSetProperty(ejs, (EjsObj*) results, -1, (EjsObj*) elt);
            }
        }
        return (EjsObj*) results;

    } else if (ejsIsRegExp(argv[0])) {
        EjsRegExp   *rp;
        EjsString   *match;
        int         matches[EJS_MAX_REGEX_MATCHES * 3], count, resultCount;
        
        rp = (EjsRegExp*) argv[0];
        rp->endLastMatch = 0;
        resultCount = 0;
        do {
            count = pcre_exec(rp->compiled, NULL, sp->value, sp->length, rp->endLastMatch, 0, matches, 
                sizeof(matches) / sizeof(int));
            if (count <= 0) {
                break;
            }
            if (rp->endLastMatch < matches[0]) {
                match = ejsCreateStringWithLength(ejs, &sp->value[rp->endLastMatch], matches[0] - rp->endLastMatch);
                ejsSetProperty(ejs, (EjsObj*) results, resultCount++, (EjsObj*) match);
            }
            rp->endLastMatch = matches[1];
        } while (rp->global);

        if (rp->endLastMatch < sp->length) {
            match = ejsCreateStringWithLength(ejs, &sp->value[rp->endLastMatch], sp->length - rp->endLastMatch);
            ejsSetProperty(ejs, (EjsObj*) results, resultCount++, (EjsObj*) match);
        }
        return (EjsObj*) results;
    }

    ejsThrowTypeError(ejs, "Wrong argument type");
    return 0;
}


/**
    Check if a string starts with a given pattern

    function startsWith(pattern: String): Boolean
 */
static EjsObj *startsWith(Ejs *ejs, EjsString *sp, int argc, EjsObj **argv)
{
    cchar       *pattern;
    int         len;

    mprAssert(argc == 1 && ejsIsString(argv[0]));

    pattern = ejsGetString(ejs, argv[0]);
    len = (int) strlen(pattern);

    return (EjsObj*) ejsCreateBoolean(ejs, strncmp(&sp->value[0], pattern, len) == 0);
}


/*
    Extract a substring. Simple routine with positive indicies.

    function substring(start: Number, end: Number = -1): String
 */
static EjsObj *substring(Ejs *ejs, EjsString *sp, int argc, EjsObj **argv)
{
    int     start, end, tmp;

    start = ejsGetInt(ejs, argv[0]);
    if (argc == 2) {
        end = ejsGetInt(ejs, argv[1]);
    } else {
        end = sp->length;
    }

    if (start < 0) {
        start = 0;
    }
    if (start >= sp->length) {
        start = sp->length - 1;
    }
    if (end < 0) {
        end = sp->length;
    }
    if (end > sp->length) {
        end = sp->length;
    }
    /*
        Swap if start is bigger than end
     */
    if (start > end) {
        tmp = start;
        start = end;
        end = tmp;
    }
    return (EjsObj*) ejsCreateStringWithLength(ejs, &sp->value[start], end - start);
}


/*
    Convert the string to camelCase. Return a new string.

    function toCamel(): String
 */
static EjsObj *toCamel(Ejs *ejs, EjsString *sp, int argc, EjsObj **argv)
{
    EjsString   *result;

    result = ejsCreateStringWithLength(ejs, sp->value, sp->length);
    if (result == 0) {
        return 0;
    }
    result->value[0] = tolower((int) sp->value[0]);

    return (EjsObj*) result;
}


/*
    Convert to a JSON string

    override function toJSON(): String
 */
static EjsObj *stringToJSON(Ejs *ejs, EjsString *sp, int argc, EjsObj **argv)
{
    EjsObj  *result;
    MprBuf  *buf;
    int     i, c;

    buf = mprCreateBuf(sp, 0, 0);
    mprPutCharToBuf(buf, '"');
    for (i = 0; i < sp->length; i++) {
        c = sp->value[i];
        if (c == '"' || c == '\\') {
            mprPutCharToBuf(buf, '\\');
            mprPutCharToBuf(buf, c);
        } else {
            mprPutCharToBuf(buf, c);
        }
    }
    mprPutCharToBuf(buf, '"');
    mprAddNullToBuf(buf);
    result = (EjsObj*) ejsCreateString(ejs, mprGetBufStart(buf));
    mprFree(buf);
    return result;
}


/*
    Convert the string to lower case.

    function toLower(locale: String = null): String
 */
static EjsObj *toLower(Ejs *ejs, EjsString *sp, int argc,  EjsObj **argv)
{
    EjsString       *result;
    int             i;

    result = ejsCreateStringWithLength(ejs, sp->value, sp->length);
    if (result == 0) {
        return 0;
    }
    for (i = 0; i < result->length; i++) {
        result->value[i] = tolower((int) result->value[i]);
    }
    return (EjsObj*) result;
}


/*
    Convert the string to PascalCase. Return a new string.

    function toPascal(): String
 */
static EjsObj *toPascal(Ejs *ejs, EjsString *sp, int argc, EjsObj **argv)
{
    EjsString   *result;

    result = ejsCreateStringWithLength(ejs, sp->value, sp->length);
    if (result == 0) {
        return 0;
    }
    result->value[0] = toupper((int) sp->value[0]);

    return (EjsObj*) result;
}


/*
    Convert to a string

    override function toString(): String
 */
static EjsObj *stringToString(Ejs *ejs, EjsString *sp, int argc, EjsObj **argv)
{
    return (EjsObj*) sp;
}


/*
    Convert the string to upper case.
    @return Returns a new upper case version of the string.
    @spec ejs-11

    function toUpper(locale: String = null): String
 */
static EjsObj *toUpper(Ejs *ejs, EjsString *sp, int argc,  EjsObj **argv)
{
    EjsString       *result;
    int             i;

    result = ejsCreateStringWithLength(ejs, sp->value, sp->length);
    if (result == 0) {
        return 0;
    }
    for (i = 0; i < result->length; i++) {
        result->value[i] = toupper((int) result->value[i]);
    }
    return (EjsObj*) result;
}


/*
    Scan the input and tokenize according to the format string

    function tokenize(format: String): Array
 */
static EjsObj *tokenize(Ejs *ejs, EjsString *sp, int argc, EjsObj **argv)
{
    EjsArray    *result;
    cchar       *fmt;
    char        *end, *buf;

    mprAssert(argc == 1 && ejsIsString(argv[0]));

    buf = sp->value;
    fmt = ejsGetString(ejs, argv[0]);
    result = ejsCreateArray(ejs, 0);

    for (fmt = ejsGetString(ejs, argv[0]); *fmt && buf < &sp->value[sp->length]; ) {
        if (*fmt++ != '%') {
            continue;
        }
        switch (*fmt) {
        case 's':
            for (end = buf; *end; end++) {
                if (isspace((int) *end)) {
                    break;
                }
            }
            ejsSetProperty(ejs, (EjsObj*) result, -1, (EjsObj*) ejsCreateStringWithLength(ejs, buf, (int) (end - buf)));
            buf = end;
            break;

        case 'd':
            ejsSetProperty(ejs, (EjsObj*) result, -1, ejsParse(ejs, buf, ES_Number));
            while (*buf && !isspace((int) *buf)) {
                buf++;
            }
            break;

        default:
            ejsThrowArgError(ejs, "Bad format specifier");
            return 0;
        }
        while (*buf && isspace((int) *buf)) {
            buf++;
        }
    }
    return (EjsObj*) result;
}

/*
   Flags for trim where
 */
#define TRIM_START  0x1
#define TRIM_END    0x2

static EjsObj *trim(Ejs *ejs, EjsString *sp, cchar *pattern, int where)
{
    cchar           *start, *end, *mark;
    int             index, patternLength;

    if (pattern == 0) {
        start = sp->value;
        if (where & TRIM_START) {
            for (; start < &sp->value[sp->length]; start++) {
                if (!isspace((int) *start)) {
                    break;
                }
            }
        }
        end = &sp->value[sp->length - 1];
        if (where & TRIM_END) {
            for (end = &sp->value[sp->length - 1]; end >= start; end--) {
                if (!isspace((int) *end)) {
                    break;
                }
            }
        }
        end++;
    } else {
        patternLength = strlen(pattern);
        if (patternLength <= 0 || patternLength > sp->length) {
            return (EjsObj*) sp;
        }
        mark = sp->value;
        if (where & TRIM_START) {
            for (; &mark[patternLength] < &sp->value[sp->length]; mark += patternLength) {
                index = indexof(mark, patternLength, pattern, patternLength, 1);
                if (index != 0) {
                    break;
                }
            }
        }
        start = mark;

        mark = &sp->value[sp->length - patternLength];
        if (where & TRIM_END) {
            for (; mark >= sp->value; mark -= patternLength) {
                index = indexof(mark, patternLength, pattern, patternLength, 1);
                if (index != 0) {
                    break;
                }
            }
        }
        end = mark + patternLength;
    }
    return (EjsObj*) ejsCreateStringWithLength(ejs, start, (int) (end - start));
}


/**
    Returns a trimmed copy of the string. Normally used to trim white space, but can be used to trim any substring
    from the start or end of the string.
    @param str May be set to a substring to trim from the string. If not set, it defaults to any white space.
    @return Returns a (possibly) modified copy of the string

    function trim(str: String = null): String
 */
static EjsObj *trimString(Ejs *ejs, EjsString *sp, int argc,  EjsObj **argv)
{
    cchar   *pattern;

    mprAssert(argc == 0 || (argc == 1 && ejsIsString(argv[0])));

    if (argc == 0) {
        return trim(ejs, sp, NULL, TRIM_START | TRIM_END);

    } else {
        pattern = ejsGetString(ejs, argv[0]);
        return trim(ejs, sp, pattern, TRIM_START | TRIM_END);
    }
}


/*  function trimStart(str: String = null): String
 */
static EjsObj *trimStartString(Ejs *ejs, EjsString *sp, int argc,  EjsObj **argv)
{
    cchar   *pattern;

    mprAssert(argc == 0 || (argc == 1 && ejsIsString(argv[0])));

    if (argc == 0) {
        return trim(ejs, sp, NULL, TRIM_START);

    } else {
        pattern = ejsGetString(ejs, argv[0]);
        return trim(ejs, sp, pattern, TRIM_START);
    }
}


/*  function trimEnd(str: String = null): String
 */
static EjsObj *trimEndString(Ejs *ejs, EjsString *sp, int argc,  EjsObj **argv)
{
    cchar   *pattern;

    mprAssert(argc == 0 || (argc == 1 && ejsIsString(argv[0])));

    if (argc == 0) {
        return trim(ejs, sp, NULL, TRIM_END);

    } else {
        pattern = ejsGetString(ejs, argv[0]);
        return trim(ejs, sp, pattern, TRIM_END);
    }
}

/**
    Fast append a string. This modifies the original "dest" string. BEWARE: strings are meant to be immutable.
    Only use this when constructing strings.
 */
static int catString(Ejs *ejs, EjsString *dest, char *str, int len)
{
    EjsString   *castSrc;
    char        *oldBuf, *buf;
    int         oldLen, newLen;

    mprAssert(dest);

    castSrc = 0;

    oldBuf = dest->value;
    oldLen = dest->length;
    newLen = oldLen + len + 1;

#if FUTURE
    if (newLen < MPR_SLAB_STR_MAX) {
        buf = oldBuf;
    } else {
#endif
        buf = (char*) mprRealloc(ejs, oldBuf, newLen);
        if (buf == 0) {
            return -1;
        }
        dest->value = buf;
#if FUTURE
    }
#endif
    memcpy(&buf[oldLen], str, len);
    dest->length += len;
    buf[dest->length] = '\0';

    return 0;
}


/**
    Fast append a string. This modifies the original "dest" string. BEWARE: strings are meant to be immutable.
    Only use this when constructing strings.
 */
int ejsStrcat(Ejs *ejs, EjsString *dest, EjsObj *src)
{
    EjsString   *castSrc;
    char        *str;
    int         len;

    mprAssert(dest);

    castSrc = 0;

    if (ejsIsString(dest)) {
        if (! ejsIsString(src)) {
            castSrc = (EjsString*) ejsToString(ejs, src);
            if (castSrc == 0) {
                return -1;
            }
            len = (int) strlen(castSrc->value);
            str = castSrc->value;

        } else {
            str = ((EjsString*) src)->value;
            len = ((EjsString*) src)->length;
        }

        if (catString(ejs, dest, str, len) < 0) {
            return -1;
        }

    } else {
        /*
            Convert the source to a string and then steal the rusult buffer and assign to the destination
            BUG - should be freeing the destination string.
         */
        castSrc = (EjsString*) ejsToString(ejs, src);
        dest->value = castSrc->value;
        mprStealBlock(dest, dest->value);
        castSrc->value = 0;
    }
    return 0;
}


/*
    Copy a string. Always null terminate.
 */
int ejsStrdup(MprCtx ctx, uchar **dest, cvoid *src, int nbytes)
{
    mprAssert(dest);
    mprAssert(src);

    if (nbytes > 0) {
        *dest = (uchar*) mprAlloc(ctx, nbytes + 1);
        if (*dest == 0) {
            return MPR_ERR_NO_MEMORY;
        }
        strncpy((char*) *dest, (char*) src, nbytes);

    } else {
        *dest = (uchar*) mprAlloc(ctx, 1);
        nbytes = 0;
    }
    (*dest)[nbytes] = '\0';
    return nbytes;
}


/*
    Find a substring. Search forward or backwards. Return the index in the string where the pattern was found.
    Return -1 if not found.
 */
static int indexof(cchar *str, int len, cchar *pattern, int patternLength, int dir)
{
    cchar   *s1, *s2;
    int     i, j;

    mprAssert(dir == 1 || dir == -1);

    if (dir > 0) {
        for (i = 0; i < len; i++) {
            s1 = &str[i];
            for (j = 0, s2 = pattern; j < patternLength; s1++, s2++, j++) {
                if (*s1 != *s2) {
                    break;
                }
            }
            if (*s2 == '\0') {
                return i;
            }
        }

    } else {
        for (i = len - 1; i >= 0; i--) {
            s1 = &str[i];
            for (j = 0, s2 = pattern; j < patternLength; s1++, s2++, j++) {
                if (*s1 != *s2) {
                    break;
                }
            }
            if (*s2 == '\0') {
                return i;
            }
        }
    }
    return -1;
}



EjsString *ejsCreateString(Ejs *ejs, cchar *value)
{
    EjsString   *sp;

    /*
        No need to invoke constructor
     */
    sp = (EjsString*) ejsCreate(ejs, ejs->stringType, 0);
    if (sp != 0) {
        sp->value = mprStrdup(ejs, value);
        if (sp->value == 0) {
            return 0;
        }
        sp->length = (int) strlen(sp->value);
        ejsSetDebugName(sp, sp->value);
    }
    return sp;
}


EjsString *ejsCreateStringAndFree(Ejs *ejs, char *value)
{
    EjsString   *sp;

    sp = (EjsString*) ejsCreate(ejs, ejs->stringType, 0);
    if (sp != 0) {
        if (value == 0) {
            value = mprStrdup(sp, "");
        }
        sp->value = value;
        mprStealBlock(sp, value);
        sp->length = (int) strlen(sp->value);
        ejsSetDebugName(sp, sp->value);
    }
    return sp;
}


EjsString *ejsDupString(Ejs *ejs, EjsString *sp)
{
    return ejsCreateStringWithLength(ejs, sp->value, sp->length);
}


/*
    Initialize a binary string value.
 */
EjsString *ejsCreateStringWithLength(Ejs *ejs, cchar *value, int len)
{
    EjsString   *sp;
    uchar       *dest;

    //  OPT Would be much faster to allocate the string value in the actual object since strings are immutable
    sp = (EjsString*) ejsCreate(ejs, ejs->stringType, 0);
    if (sp != 0) {
        sp->length = ejsStrdup(ejs, &dest, value, len);
        sp->value = (char*) dest;
        if (sp->length < 0) {
            return 0;
        }
    }
    return sp;
}


/*
    Initialize an string with a pre-allocated buffer but without data..
 */
EjsString *ejsCreateBareString(Ejs *ejs, int len)
{
    EjsString   *sp;
    
    //  OPT Would be much faster to allocate the string value in the actual object since strings are immutable
    sp = (EjsString*) ejsCreate(ejs, ejs->stringType, 0);
    if (sp != 0) {
        sp->value = mprAlloc(sp, len + 1);
        if (sp->value == 0) {
            return 0;
        }
        sp->length = len;
        sp->value[len] = '\0';
    }
    return sp;
}


void ejsCreateStringType(Ejs *ejs)
{
    EjsType     *type;

    type = ejs->stringType = ejsCreateNativeType(ejs, "ejs", "String", ES_String, sizeof(EjsString));

    type->helpers->cast = (EjsCastHelper) castString;
    type->helpers->clone = (EjsCloneHelper) cloneString;
    type->helpers->destroy = (EjsDestroyHelper) destroyString;
    type->helpers->getProperty = (EjsGetPropertyHelper) getStringProperty;
    type->helpers->invokeOperator = (EjsInvokeOperatorHelper) invokeStringOperator;
    type->helpers->lookupProperty = (EjsLookupPropertyHelper) lookupStringProperty;

    type->numericIndicies = 1;

    /*
        Pre-create the empty string.
     */
    ejs->emptyStringValue = (EjsString*) ejsCreateString(ejs, "");
    ejsSetDebugName(ejs->emptyStringValue, "emptyString");
}


void ejsConfigureStringType(Ejs *ejs)
{
    EjsType     *type;

    type = ejsGetTypeByName(ejs, "ejs", "String");

    /*
        Define the "string" alias
     */
    ejsSetProperty(ejs, ejs->global, ES_string, (EjsObj*) type);
    ejsBindMethod(ejs, type, ES_String_String, (EjsProc) stringConstructor);
    ejsBindMethod(ejs, type, ES_String_caseCompare, (EjsProc) caseCompare);
    ejsBindMethod(ejs, type, ES_String_caselessCompare, (EjsProc) caselessCompare);
    ejsBindMethod(ejs, type, ES_String_charAt, (EjsProc) charAt);
    ejsBindMethod(ejs, type, ES_String_charCodeAt, (EjsProc) charCodeAt);
    ejsBindMethod(ejs, type, ES_String_concat, (EjsProc) concatString);
    ejsBindMethod(ejs, type, ES_String_contains, (EjsProc) containsString);
    ejsBindMethod(ejs, type, ES_String_endsWith, (EjsProc) endsWith);
    ejsBindMethod(ejs, type, ES_String_format, (EjsProc) formatString);
    ejsBindMethod(ejs, type, ES_String_fromCharCode, (EjsProc) fromCharCode);
    ejsBindMethod(ejs, type, ES_Object_get, (EjsProc) getStringIterator);
    ejsBindMethod(ejs, type, ES_Object_getValues, (EjsProc) getStringValues);
    ejsBindMethod(ejs, type, ES_String_indexOf, (EjsProc) indexOf);
    ejsBindMethod(ejs, type, ES_String_isDigit, (EjsProc) isDigit);
    ejsBindMethod(ejs, type, ES_String_isAlpha, (EjsProc) isAlpha);
    ejsBindMethod(ejs, type, ES_String_isAlphaNum, (EjsProc) isAlphaNum);
    ejsBindMethod(ejs, type, ES_String_isLower, (EjsProc) isLower);
    ejsBindMethod(ejs, type, ES_String_isSpace, (EjsProc) isSpace);
    ejsBindMethod(ejs, type, ES_String_isUpper, (EjsProc) isUpper);
    ejsBindMethod(ejs, type, ES_String_lastIndexOf, (EjsProc) lastIndexOf);
    ejsBindMethod(ejs, type, ES_String_length, (EjsProc) stringLength);
    ejsBindMethod(ejs, type, ES_String_match, (EjsProc) match);
    ejsBindMethod(ejs, type, ES_String_remove, (EjsProc) removeCharsFromString);
    ejsBindMethod(ejs, type, ES_String_slice, (EjsProc) sliceString);
    ejsBindMethod(ejs, type, ES_String_split, (EjsProc) split);
    ejsBindMethod(ejs, type, ES_String_printable, (EjsProc) printable);
    ejsBindMethod(ejs, type, ES_String_quote, (EjsProc) quote);
    ejsBindMethod(ejs, type, ES_String_replace, (EjsProc) replace);
    ejsBindMethod(ejs, type, ES_String_reverse, (EjsProc) reverseString);
    ejsBindMethod(ejs, type, ES_String_search, (EjsProc) searchString);
    ejsBindMethod(ejs, type, ES_String_startsWith, (EjsProc) startsWith);
    ejsBindMethod(ejs, type, ES_String_substring, (EjsProc) substring);
    ejsBindMethod(ejs, type, ES_String_toCamel, (EjsProc) toCamel);
    ejsBindMethod(ejs, type, ES_Object_toJSON, (EjsProc) stringToJSON);
    ejsBindMethod(ejs, type, ES_String_toLower, (EjsProc) toLower);
    ejsBindMethod(ejs, type, ES_String_toPascal, (EjsProc) toPascal);
    ejsBindMethod(ejs, type, ES_Object_toString, (EjsProc) stringToString);
    ejsBindMethod(ejs, type, ES_String_toUpper, (EjsProc) toUpper);
    ejsBindMethod(ejs, type, ES_String_tokenize, (EjsProc) tokenize);
    ejsBindMethod(ejs, type, ES_String_trim, (EjsProc) trimString);
    ejsBindMethod(ejs, type, ES_String_trimStart, (EjsProc) trimStartString);
    ejsBindMethod(ejs, type, ES_String_trimEnd, (EjsProc) trimEndString);

#if FUTURE
    ejsBindMethod(ejs, type, ES_String_LBRACKET, operLBRACKET);
    ejsBindMethod(ejs, type, ES_String_PLUS, operPLUS);
    ejsBindMethod(ejs, type, ES_String_MINUS, operMINUS);
    ejsBindMethod(ejs, type, ES_String_LT, operLT);
    ejsBindMethod(ejs, type, ES_String_GT, operGT);
    ejsBindMethod(ejs, type, ES_String_EQ, operEQ);
    ejsBindMethod(ejs, type, ES_String_MOD, operMOD);
    ejsBindMethod(ejs, type, ES_String_MUL, operMUL);
#endif
}

/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2010. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2010. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    @end
 */
/************************************************************************/
/*
 *  End of file "../src/core/src/ejsString.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../src/core/src/ejsSystem.c"
 */
/************************************************************************/

/*
    ejsSystem.c -- System class

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */



/*
    function run(cmd: String): String
 */
static EjsObj *system_run(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    MprCmd      *cmd;
    EjsString   *result;
    cchar       *cmdline;
    char        *err, *output;
    int         status;

    mprAssert(argc == 1 && ejsIsString(argv[0]));

    cmd = mprCreateCmd(ejs, ejs->dispatcher);
    cmdline = ejsGetString(ejs, argv[0]);
    status = mprRunCmd(cmd, cmdline, &output, &err, 0);
    if (status) {
        ejsThrowError(ejs, "Command failed: %s\n\nExit status: %d\n\nError Output: \n%s\nPrevious Output: \n%s\n", 
            cmdline, status, err, output);
        mprFree(cmd);
        return 0;
    }
    result = ejsCreateString(ejs, output);
    mprFree(cmd);
    return (EjsObj*) result;
}


/*
    function runx(cmd: String): Void
 */
static EjsObj *system_runx(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    MprCmd      *cmd;
    char        *err;
    int         status;

    mprAssert(argc == 1 && ejsIsString(argv[0]));

    cmd = mprCreateCmd(ejs, ejs->dispatcher);
    status = mprRunCmd(cmd, ejsGetString(ejs, argv[0]), NULL, &err, 0);
    if (status) {
        ejsThrowError(ejs, "Can't run command: %s\nDetails: %s", ejsGetString(ejs, argv[0]), err);
        mprFree(err);
    }
    mprFree(cmd);
    return 0;
}


//  TODO - refactor and rename
/*
    function daemon(cmd: String): Number
 */
static EjsObj *system_daemon(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    MprCmd      *cmd;
    int         status, pid;

    mprAssert(argc == 1 && ejsIsString(argv[0]));

    cmd = mprCreateCmd(ejs, ejs->dispatcher);
    status = mprRunCmd(cmd, ejsGetString(ejs, argv[0]), NULL, NULL, MPR_CMD_DETACH);
    if (status) {
        ejsThrowError(ejs, "Can't run command: %s", ejsGetString(ejs, argv[0]));
    }
    pid = cmd->pid;
    mprFree(cmd);
    return (EjsObj*) ejsCreateNumber(ejs, pid);
}


//  TODO - refactor and rename
/*
    function exec(cmd: String): Void
 */
static EjsObj *system_exec(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
#if BLD_UNIX_LIKE
    char    **argVector;
    int     argCount;

    mprMakeArgv(ejs, NULL, ejsGetString(ejs, argv[0]), &argCount, &argVector);
    execv(argVector[0], argVector);
#endif
    ejsThrowStateError(ejs, "Can't exec %s", ejsGetString(ejs, argv[0]));
    return 0;
}


/*
    function get hostname(): String
 */
static EjsObj *system_hostname(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateStringAndFree(ejs, mprStrdup(ejs, mprGetHostName(ejs)));
}


/*
    function get ipaddr(): String
 */
static EjsObj *system_ipaddr(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
#if BLD_UNIX_LIKE || BLD_WIN_LIKE
    struct addrinfo *res, *reslist, hints;
    cchar           *ip;
    char			ipaddr[MPR_MAX_STRING], service[MPR_MAX_STRING];

    if ((ip = mprGetIpAddr(ejs)) != 0) {
        return (EjsObj*) ejsCreateString(ejs, mprGetIpAddr(ejs));
    }
    memset((char*) &hints, 0, sizeof(hints));
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_family = AF_INET;
    if (getaddrinfo(mprGetHostName(ejs), NULL, &hints, &reslist) == 0) {
        ip = 0;
        //  TODO - support IPv6
        for (res = reslist; res; res = res->ai_next) {
            if (getnameinfo(res->ai_addr, res->ai_addrlen, ipaddr, sizeof(ipaddr) - 1, service, sizeof(service) - 1, 
                    NI_NUMERICHOST | NI_NUMERICSERV | NI_NOFQDN) == 0) {
                if (strncmp(ipaddr, "10.", 3) == 0 || strncmp(ipaddr, "127.", 4) == 0 ||
                     strncmp(ipaddr, "169.", 4) == 0 || strncmp(ipaddr, "172.", 4) == 0 ||
                     strncmp(ipaddr, "192.", 4) == 0) {
                    if (ip == 0) {
                        ip = mprStrdup(ejs, ipaddr);
                    }
                } else {
                    ip = mprStrdup(ejs, ipaddr);
                    break;
                }
            }
        }
        return (EjsVar*) ejsCreateString(ejs, ip ? ip : "127.0.0.1");
    }
#endif
    return ejs->nullValue;
}



void ejsConfigureSystemType(Ejs *ejs)
{
    EjsType         *type;

    if ((type = ejsGetTypeByName(ejs, EJS_EJS_NAMESPACE, "System")) == 0) {
        mprError(ejs, "Can't find System type");
        return;
    }
    ejsBindMethod(ejs, type, ES_System_daemon, (EjsProc) system_daemon);
    ejsBindMethod(ejs, type, ES_System_exec, (EjsProc) system_exec);
    ejsBindMethod(ejs, type, ES_System_run, (EjsProc) system_run);
    ejsBindMethod(ejs, type, ES_System_runx, (EjsProc) system_runx);
    ejsBindMethod(ejs, type, ES_System_hostname, (EjsProc) system_hostname);
#if ES_System_ipaddr
    ejsBindMethod(ejs, type, ES_System_ipaddr, (EjsProc) system_ipaddr);
#endif
}

/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2010. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2010. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    @end
 */
/************************************************************************/
/*
 *  End of file "../src/core/src/ejsSystem.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../src/core/src/ejsTimer.c"
 */
/************************************************************************/

/*
    ejsTimer.c -- Timer class

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */




static int timerCallback(EjsTimer *tp, MprEvent *e);

/*
    Create a new timer

    function Timer(period: Number, callback: Function, oneShot: Boolean = true, drift: Boolean = true)
 */
static EjsVar *constructor(Ejs *ejs, EjsTimer *tp, int argc, EjsVar **argv)
{
    int     flags;

    mprAssert(argc >= 2);
    mprAssert(ejsIsNumber(argv[0]));
    mprAssert(ejsIsFunction(argv[1]));

    tp->ejs = ejs;
    tp->period = ejsGetInt(ejs, argv[0]);
    tp->callback = (EjsFunction*) argv[1];
    tp->oneShot = (argc >= 3) ? ejsGetInt(ejs, argv[2]) : 1;
    tp->drift = (argc >= 4) ? ejsGetInt(ejs, argv[3]) : 1;

    flags = tp->oneShot ? 0 : MPR_EVENT_CONTINUOUS;
    if ((tp->event = mprCreateEvent(ejs->dispatcher, "timer", tp->period, (MprEventProc) timerCallback, tp, flags)) == 0) {
        ejsThrowMemoryError(ejs);
        return 0;
    }
    return 0;
}


/*
    Get the timer drift setting

    function get drift(): Boolean
 */
static EjsVar *getDrift(Ejs *ejs, EjsTimer *tp, int argc, EjsVar **argv)
{
    mprAssert(argc == 0);
    return (EjsVar*) ejsCreateBoolean(ejs, tp->drift);
}


/*
    Set the timer drift setting

    function set drift(period: Boolean): Void
 */
static EjsVar *setDrift(Ejs *ejs, EjsTimer *tp, int argc, EjsVar **argv)
{
    mprAssert(argc == 1 && ejsIsBoolean(argv[0]));
    tp->drift = ejsGetBoolean(ejs, argv[0]);
    return 0;
}


/*
    Get the timer period

    function get period(): Number
 */
static EjsVar *getPeriod(Ejs *ejs, EjsTimer *tp, int argc, EjsVar **argv)
{
    mprAssert(argc == 0);
    return (EjsVar*) ejsCreateNumber(ejs, tp->period);
}


/*
    Set the timer period and restart the timer

    function set period(period: Number): Void
 */
static EjsVar *setPeriod(Ejs *ejs, EjsTimer *tp, int argc, EjsVar **argv)
{
    mprAssert(argc == 1 && ejsIsNumber(argv[0]));

    tp->period = ejsGetInt(ejs, argv[0]);
    mprRescheduleEvent(tp->event, tp->period);
    return 0;
}


/*
    Restart a timer

    function restart(); Void
 */
static EjsVar *restart(Ejs *ejs, EjsTimer *tp, int argc, EjsVar **argv)
{
    mprAssert(argc == 0);
    mprRestartContinuousEvent(tp->event);
    return 0;
}


/*
    Stop a timer

    function stop(): Void
 */
static EjsVar *stop(Ejs *ejs, EjsTimer *tp, int argc, EjsVar **argv)
{
    mprAssert(argc == 0);
    mprRemoveEvent(tp->event);
    return 0;
}

/*
    This creates a timer event object, but does not schedule it.
 */
EjsObj *ejsCreateTimerEvent(Ejs *ejs, EjsTimer *tp)
{
    EjsObj       *event;

    if ((event = ejsCreateObject(ejs, ejs->timerEventType, 0)) == 0) {
        return 0;
    }
    ejsSetProperty(ejs, (EjsVar*) event, ES_Event_data, (EjsVar*) tp);
    ejsSetProperty(ejs, (EjsVar*) event, ES_Event_timestamp, (EjsVar*) ejsCreateDate(ejs, 0));
    return event;
}


static int timerCallback(EjsTimer *tp, MprEvent *e)
{
    Ejs         *ejs;
    EjsObj      *event;
    EjsVar      *arg;

    mprAssert(tp);

    ejs = tp->ejs;
    if ((event = ejsCreateTimerEvent(ejs, tp)) == 0) {
        return 0;
    }
    arg = (EjsVar*) event;
    ejsRunFunction(tp->ejs, tp->callback, NULL, 1, &arg);
    if (tp->ejs->exception) {
        //  TODO must have way that users can catch these
        mprError(tp, 0, "Exception in timer: %s", ejsGetErrorMsg(tp->ejs, 1));
    }
    return 0;
}



void ejsConfigureTimerType(Ejs *ejs)
{
    EjsType     *type;

    ejs->timerEventType = ejsGetTypeByName(ejs, "ejs", "TimerEvent");
    type = ejsGetTypeByName(ejs, "ejs", "Timer");
    type->instanceSize = sizeof(EjsTimer);

    ejsBindMethod(ejs, type, ES_Timer_Timer, (EjsProc) constructor);
    ejsBindMethod(ejs, type, ES_Timer_restart, (EjsProc) restart);
    ejsBindMethod(ejs, type, ES_Timer_stop, (EjsProc) stop);
    ejsBindAccess(ejs, type, ES_Timer_period, (EjsProc) getPeriod, (EjsProc) setPeriod);
    ejsBindAccess(ejs, type, ES_Timer_drift, (EjsProc) getDrift, (EjsProc) setDrift);
}

/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2010. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2010. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    @end
 */
/************************************************************************/
/*
 *  End of file "../src/core/src/ejsTimer.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../src/core/src/ejsType.c"
 */
/************************************************************************/

/**
    ejsType.c - Type class

    The type class is the base class for all types (classes) in the system.

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */




static EjsType *createBootstrapType(Ejs *ejs, int numSlots);
static EjsType *createType(Ejs *ejs, EjsName *qname, EjsModule *up, EjsType *baseType, int instanceSize, int numSlots, 
        int attributes, void *typeData);
static void fixInstanceSize(Ejs *ejs, EjsType *type);
static int fixupPrototypeProperties(Ejs *ejs, EjsType *type, EjsObj *obj, EjsObj *base, int makeRoom);
static int fixupTypeProperties(Ejs *ejs, EjsType *type, EjsType *baseType, int makeRoom);
static void setAttributes(EjsType *type, int attributes);

/*
    Copy a type. 

    intrinsic function copy(type: Object): Object
 */
static EjsType *cloneTypeVar(Ejs *ejs, EjsType *src, bool deep)
{
    EjsType     *dest;

    if (! ejsIsType(src)) {
        ejsThrowTypeError(ejs, "Expecting a Type object");
        return 0;
    }

    dest = (EjsType*) (ejs->blockType->helpers->clone)(ejs, (EjsObj*) src, deep);
    if (dest == 0) {
        return dest;
    }

    dest->baseType = src->baseType;
    dest->callsSuper = src->callsSuper;
    dest->dontPool = src->dontPool;
    dest->final = src->final;
    dest->hasBaseConstructors = src->hasBaseConstructors;
    dest->hasBaseInitializers = src->hasBaseInitializers;
    dest->hasBaseStaticInitializers = src->hasBaseStaticInitializers;
    dest->hasConstructor = src->hasConstructor;
    dest->hasInitializer = src->hasInitializer;
    dest->hasMeta = src->hasMeta;
    dest->hasStaticInitializer = src->hasStaticInitializer;
    dest->helpers = src->helpers;
    dest->id = src->id;
    dest->immutable = src->immutable;
    dest->initialized = src->initialized;
    dest->prototype = src->prototype;
    dest->instanceSize = src->instanceSize;
    dest->isInterface = src->isInterface;
    dest->module = src->module;
    dest->numericIndicies = src->numericIndicies;
    dest->qname = src->qname;

    dest->skipScope = src->skipScope;
    dest->subTypeCount = src->subTypeCount;
    dest->typeData = src->typeData;

    return dest;
}


/*
    Create a new Type object. numSlots is the number of property slots to pre-allocate.
    This is hand-crafted to create types as small as possible.
 */
static EjsType *createTypeVar(Ejs *ejs, EjsType *typeType, int numSlots)
{
    EjsType         *type;
    EjsObj          *obj;
    EjsObj          *vp;
    char            *start;
    int             typeSize, sizeHash, dynamic;

    mprAssert(ejs);

    /*
        If the compiler is building itself (empty mode), then the types themselves must be dynamic. Otherwise, the type
        is fixed and will contain the names hash and traits in one memory block. 
        NOTE: don't confuse this with dynamic objects.
     */
    sizeHash = 0;

    if (numSlots < 0 || ejs->empty || ejs->flags & EJS_FLAG_DYNAMIC) {
        dynamic = 1;
        typeSize = sizeof(EjsType);
        numSlots = 0;

    } else {
        dynamic = 0;
        typeSize = sizeof(EjsType);
        typeSize += (int) sizeof(EjsSlot) * numSlots;
        if (numSlots > EJS_HASH_MIN_PROP) {
            sizeHash = ejsGetHashSize(numSlots);
            typeSize += (sizeHash * (int) sizeof(EjsSlot*));
        }
    }

    if ((vp = (EjsObj*) mprAllocZeroed(ejsGetAllocCtx(ejs), typeSize)) == 0) {
        ejsThrowMemoryError(ejs);
        return 0;
    }
    obj = (EjsObj*) vp;
    type = (EjsType*) vp;

    vp->type = type;
    vp->master = (ejs->master == 0);
    vp->type = typeType;
    vp->isType = 1;
    vp->dynamic = dynamic;
    type->subTypeCount = typeType->subTypeCount + 1;
    ejsInitList(&type->block.namespaces);

    if (!dynamic) {
        /*
            This is for a fixed type. This is the normal case when not compiling. Layout is:
                Slots           sizeof(EjsSlot) * numSlots
                Hash buckets    ejsGetHashSize(numslots)
         */
        start = (char*) type + sizeof(EjsType);

        if (numSlots > 0) {
            obj->sizeSlots = numSlots;
            obj->slots = (EjsSlot*) start;
            ejsZeroSlots(ejs, obj->slots, numSlots);
            start += sizeof(EjsSlot) * numSlots;
        }
        if (sizeHash > 0) {
            obj->hash = (int*) start;
            obj->sizeHash = sizeHash;
            memset(obj->hash, -1, sizeHash * sizeof(int));
            start += sizeof(int) * sizeHash;
        }
        mprAssert((start - (char*) type) <= typeSize);
    }
    ejsSetDebugName(vp, "type");
#if BLD_DEBUG
    ejsAddToGcStats(ejs, vp, ES_Type);
#endif
    return type;
}


/*
    Create a bootstrap type variable. This is used for the Object, Block and Type types.
 */
static EjsType *createBootstrapType(Ejs *ejs, int numSlots)
{
    EjsType     *type, bootstrap;
    EjsObj      bootstrapPrototype;

    mprAssert(ejs);

    memset(&bootstrap, 0, sizeof(bootstrap));
    memset(&bootstrapPrototype, 0, sizeof(bootstrapPrototype));

    bootstrap.instanceSize = sizeof(EjsType);
    bootstrap.subTypeCount = -1;
    bootstrap.prototype = &bootstrapPrototype;

    type = (EjsType*) createTypeVar(ejs, &bootstrap, numSlots);
    if (type == 0) {
        return 0;
    }
    /*
        This will be hand-crafted later
     */
    type->block.obj.type = 0;
    return type;
}


/*
    Lookup a property with a namespace qualifier in an object and return the slot if found. Return EJS_ERR if not found.
 */
static int lookupTypeProperty(struct Ejs *ejs, EjsType *type, EjsName *qname)
{
    EjsName     name;
    int         slotNum;

    slotNum = (ejs->objectType->helpers->lookupProperty)(ejs, (EjsObj*) type, qname);

    if (slotNum < 0 && strcmp(qname->name, "prototype") == 0 && qname->space[0] == '\0') {
        /*
            On-demand creation of the Type.prototype. Replace Object.prototype getter for this type.
         */
        if (type->prototype == 0) {
            type->prototype = ejsCreatePrototype(ejs, type, 0);
        }
        ejsDefineProperty(ejs, (EjsObj*) type, ES_Object_prototype, ejsName(&name, type->qname.space, qname->name),
            ejs->objectType, 0, (EjsObj*) type->prototype);
    }
    return slotNum;
}


void markType(Ejs *ejs, EjsType *type)
{
    ejsMarkBlock(ejs, (EjsBlock*) type);

    if (type->prototype) {
        ejsMark(ejs, type->prototype);
    }
    if (type->baseType) {
        ejsMark(ejs, (EjsObj*) type->baseType);
    }
}


static int setTypeProperty(Ejs *ejs, EjsType *type, int slotNum, EjsObj *value)
{
    if (slotNum < 0 && !type->block.obj.dynamic) {
        ejsThrowTypeError(ejs, "Object is not dynamic");
        return EJS_ERR;
    }
    return (ejs->blockType->helpers->setProperty)(ejs, (EjsObj*) type, slotNum, value);
}


/*
    Create a core built-in type. This is used by core native type code to either create a type or to get a type
    that has been made by loading ejs.mod. Handles the EMPTY case when building the compiler itself.
 */
EjsType *ejsCreateCoreType(Ejs *ejs, EjsName *qname, EjsType *baseType, int instanceSize, int id, int numTypeProp,
    int numInstanceProp, int attributes)
{
    EjsType     *type;

    type = ejsCreateType(ejs, qname, 0, baseType, instanceSize, id, numTypeProp, numInstanceProp, attributes, 0);
    if (type == 0) {
        ejs->hasError = 1;
        return 0;
    }
    /*
        The coreTypes hash allows the loader to match the essential core type objects to those being loaded from a mod file.
     */
    mprAddHash(ejs->coreTypes, qname->name, type);
    return type;
}


EjsType *ejsCreateNativeType(Ejs *ejs, cchar *space, cchar *name, int id, int instanceSize)
{
    EjsName     qname;

    return ejsCreateCoreType(ejs, ejsName(&qname, space, name), NULL, instanceSize, id, 0, 0, 0);
}


EjsType *ejsConfigureNativeType(Ejs *ejs, cchar *space, cchar *name, int instanceSize)
{
    EjsType     *type;

    if ((type = ejsGetTypeByName(ejs, space, name)) == 0) {
        mprError(ejs, "Can't find %s type", name);
        return 0;
    }
    type->instanceSize = instanceSize;
    return type;
}


EjsType *ejsCreateTypeFromFunction(Ejs *ejs, EjsFunction *fun)
{
    EjsName     qname;
    EjsType     *type;
    int         slotNum;

    slotNum = ejsGetPropertyCount(ejs, ejs->global);

    qname = ejsGetPropertyName(ejs, fun->owner, fun->slotNum);
    qname.space = "-prototype-";
    type = ejsCreateType(ejs, &qname, NULL, ejs->objectType, ejs->objectType->instanceSize,
        slotNum, ES_Object_NUM_CLASS_PROP, ES_Object_NUM_INSTANCE_PROP, 
        EJS_TYPE_DYNAMIC_INSTANCE | EJS_TYPE_HAS_CONSTRUCTOR, NULL);
    if (type == 0) {
        return 0;
    }
    type->dontCopyPrototype = 1;

    /*
        Type is installed, but not hashed in the global names
        MOB -- should traits be defined (non-enumerable, fixed)? yes.
     */
    ejsSetProperty(ejs, ejs->global, slotNum, (EjsObj*) type);

    /*
        Install the function as the constructor
     */
    ejsSetProperty(ejs, (EjsObj*) type, type->numInherited, (EjsObj*) fun);
    fun->constructor = 1;
    fun->thisObj = 0;
    return type;
}


/*
    Create a new type and initialize. BaseType is the super class for instances of the type being created. The
    returned EjsType will be an instance of EjsType. numTypeProp and  numInstanceProp should be set to the number
    of non-inherited properties.
 */
EjsType *ejsCreateType(Ejs *ejs, EjsName *qname, EjsModule *up, EjsType *baseType, int instanceSize, int typeId, 
        int numTypeProp, int numInstanceProp, int attributes, void *typeData)
{
    EjsType     *type;
    
    mprAssert(ejs);

    type = createType(ejs, qname, up, baseType, instanceSize, numTypeProp, attributes, typeData);
    if (type == 0) {
        return 0;
    }
    type->id = typeId;
    ejsSetDebugName(type, type->qname.name);

    if (numInstanceProp > 0 && ejs->typeType) {
        type->prototype = ejsCreatePrototype(ejs, type, numInstanceProp);
        ejsSetProperty(ejs, (EjsObj*) type, ES_Object_prototype, type->prototype);
    }
    //  MOB -- this should be inline in type
    type->helpers = ejsCloneObjectHelpers(ejs, qname->name);
    return type;
}


EjsType *ejsConfigureType(Ejs *ejs, EjsType *type, EjsModule *up, EjsType *baseType, int numTypeProp, int numInstanceProp, 
    int attributes)
{
    type->module = up;
    setAttributes(type, attributes);

    if (numTypeProp > 0 && ejsGrowObject(ejs, &type->block.obj, numTypeProp) < 0) {
        return 0;
    }
    if (numInstanceProp > 0) {
        if (type->prototype == 0) {
            type->prototype = ejsCreatePrototype(ejs, type, numInstanceProp);
        } else {
            ejsGrowObject(ejs, type->prototype, numInstanceProp);
        }
    }
    if (baseType && ejsFixupType(ejs, type, baseType, 0) < 0) {
        return 0;
    }
    return type;
}


/*
    OPT - should be able to just read in the attributes without having to stuff some in var and some in type.
    Should eliminate all the specific fields and just use BIT MASKS.
 */
static void setAttributes(EjsType *type, int attributes)
{
    if (attributes & EJS_TYPE_FINAL) {
        type->final = 1;
    }
    if (attributes & EJS_TYPE_HAS_CONSTRUCTOR) {
        type->hasConstructor = 1;
    }
    if (attributes & EJS_TYPE_DYNAMIC_INSTANCE) {
        type->dynamicInstance = 1;
    }
    if (attributes & EJS_TYPE_HAS_INITIALIZER) {
        type->hasInitializer = 1;
    }
    if (attributes & EJS_TYPE_IMMUTABLE) {
        type->immutable = 1;
    }
    if (attributes & EJS_TYPE_INTERFACE) {
        type->isInterface = 1;
    }
    if (attributes & EJS_TYPE_FIXUP) {
        type->needFixup = 1;
    }
    if (attributes & EJS_TYPE_HAS_STATIC_INITIALIZER) {
        type->hasStaticInitializer = 1;
    }
    if (attributes & EJS_TYPE_CALLS_SUPER) {
        type->callsSuper = 1;
    }
}


/*
    Create a type object and initialize.
 */
static EjsType *createType(Ejs *ejs, EjsName *qname, EjsModule *up, EjsType *baseType, int instanceSize, int numSlots, 
        int attributes, void *typeData)
{
    EjsType     *type;

    mprAssert(ejs);
    mprAssert(instanceSize > 0);
    
    /*
        Create the type. For Object and Type, the value of ejs->typeType will be null. So bootstrap these first two types. 
     */
    if (ejs->typeType == 0) {
        type = (EjsType*) createBootstrapType(ejs, numSlots);
    } else {
        type = (EjsType*) createTypeVar(ejs, ejs->typeType, numSlots);
    }
    if (type == 0) {
        return 0;
    }
    type->qname.name = qname->name;
    type->qname.space = qname->space;
    type->module = up;
    type->typeData = typeData;
    type->baseType = baseType;
    type->instanceSize = instanceSize;
    setAttributes(type, attributes);

    if (numSlots > 0 && ejsGrowObject(ejs, &type->block.obj, numSlots) < 0) {
        return 0;
    }
    if (baseType && ejsFixupType(ejs, type, baseType, 0) < 0) {
        return 0;
    }
    return type;
}


EjsObj *ejsCreatePrototype(Ejs *ejs, EjsType *type, int numSlots)
{
    EjsObj      *prototype, *protoBase;

    if ((prototype = ejsCreateObject(ejs, ejs->objectType, numSlots)) == 0) {
        return 0;
    }
    prototype->isPrototype = 1;
    if (numSlots > 0) {
        if (ejsGrowObject(ejs, prototype, numSlots) < 0) {
            return 0;
        }
    }
    if (type->baseType) {
        if ((protoBase = type->baseType->prototype) != 0) {
            if (ejsGrowObject(ejs, prototype, protoBase->numSlots) < 0) {
                return 0;
            }
            if (ejsInheritProperties(ejs, prototype, protoBase, protoBase->numSlots, 0, 0) < 0) {
                return 0;
            }
            type->numPrototypeInherited = protoBase->numSlots;
        }
    }
    ejsSetDebugName(prototype, mprStrcat(type, -1, type->qname.name, "-Prototype", NULL));
    return prototype;
}


#if FUTURE
static void patchType(Ejs *ejs, EjsType *type)
{
    EjsType     *base;
    EjsObj      *vp;
    EjsFunction *fun, *existingFun;
    int         i, j;

    if (type->block.obj.visited || type->baseType == 0) {
        return;
    }
    type->block.obj.visited = 1;
    if (!type->isInterface && !ejsIsPrototype(type)) {
        base = type->baseType;
        for (j = 0; j < base->block.obj.numSlots; j++) {
            fun = (EjsFunction*) ejsGetProperty(ejs, (EjsObj*) ot, j);
            if (ejsIsNativeFunction(fun)) {
                existingFun = (EjsFunction*) ejsGetProperty(ejs, (EjsObj*) type, j);
                if (!ejsIsFunction(existingFun) || !existingFun->override) {
                    ejsSetProperty(ejs, (EjsObj*) type, j, (EjsObj*) fun);
                }
            }
        }
    }
    if (type->prototype) {
        patchObjectSlots(ejs, type->prototype);
    }
    type->block.obj.visited = 0;
}
#endif


EjsType *ejsGetType(Ejs *ejs, int slotNum)
{
    EjsType     *type;

    if (slotNum < 0 || slotNum >= ejs->globalBlock->obj.numSlots) {
        return 0;
    }
    type = (EjsType*) ejsGetProperty(ejs, ejs->global, slotNum);
    if (type == 0 || !ejsIsType(type)) {
        return 0;
    }
    return type;
}


EjsType *ejsGetTypeByName(Ejs *ejs, cchar *space, cchar *name)
{
    EjsName     qname;

    return (EjsType*) ejsGetPropertyByName(ejs, ejs->global, ejsName(&qname, space, name));
}


/*
    Copy inherited type slots and traits. Don't copy overridden properties and clear property names for static properites
 */
int ejsInheritProperties(Ejs *ejs, EjsObj *obj, EjsObj *baseBlock, int count, int offset, bool implementing)
{
    EjsTrait        *trait, *baseTrait;
    EjsFunction     *fun, *existingFun;
    EjsObj          *vp;
    int             i, start;

    mprAssert(obj);
    
    if (baseBlock == 0 || count <= 0) {
        return 0;
    }
    start = baseBlock->numSlots - count;

    if (obj->isPrototype) {
        //  MOB -- does this need to always dup?
        ejsCopySlots(ejs, obj, obj->slots, baseBlock->slots, baseBlock->numSlots, 1);

    } else {
        for (i = start; i < baseBlock->numSlots; i++, offset++) {
            existingFun = (EjsFunction*) obj->slots[offset].value.ref;
            trait = &obj->slots[offset].trait;
            baseTrait = &baseBlock->slots[offset].trait;
            
            if (existingFun && ejsIsFunction(existingFun) && existingFun->override) {
                continue;
            }
            /*
                Copy implemented properties, static and instance functions
             */
            vp = baseBlock->slots[i].value.ref;
            //  MOB -- remove implementing. Use trait instead of staticMethod
            if (implementing || (vp && ejsIsFunction(vp) && !((EjsFunction*) vp)->staticMethod) ||
                    (baseTrait->attributes & EJS_PROP_SHARED)) {
                ejsCopySlots(ejs, obj, &obj->slots[offset], &baseBlock->slots[i], 1, 1);
                if (implementing && ejsIsFunction(vp) && ((EjsFunction*) vp)->staticMethod) {
                    ((EjsFunction*) vp)->thisObj = 0;
                }
            }
            if (vp && ejsIsFunction(vp)) {
                fun = (EjsFunction*) vp;
                if (fun->override) {
                    trait->attributes |= EJS_FUN_INHERITED;
                }
            }
        }
    }
    ejsMakeObjHash(obj);
    return 0;
}


static void fixInstanceSize(Ejs *ejs, EjsType *type)
{
    EjsType     *tp;

    for (tp = type->baseType; tp && tp != ejs->objectType; tp = tp->baseType) {
        if (tp->instanceSize > type->instanceSize) {
            type->instanceSize = tp->instanceSize;
        }
    }
}


/*
    Fixup a type. This is used by the compiler and loader when it must first define a type when its base type or
    property types may not yet be defined (ie. forward references. Consequently, it must fixup the type and its 
    counts of inherited properties. It must also copy inherited slots and traits.
 */
int ejsFixupType(Ejs *ejs, EjsType *type, EjsType *baseType, int makeRoom)
{
    mprAssert(ejs);
    mprAssert(type);
    mprAssert(type != baseType);

    type->needFixup = 0;
    type->baseType = baseType;
    
    if (baseType) {
        if (baseType->hasConstructor || baseType->hasBaseConstructors) {
            type->hasBaseConstructors = 1;
        }
        if (baseType->hasInitializer || baseType->hasBaseInitializers) {
            type->hasBaseInitializers = 1;
        }
        if (baseType != ejs->objectType && baseType->dynamicInstance) {
            type->dynamicInstance = 1;
        }
        type->subTypeCount = baseType->subTypeCount + 1;
    }
    if (fixupTypeProperties(ejs, type, baseType, makeRoom) < 0) {
        return EJS_ERR;
    }
    if (baseType && baseType->prototype /*  || type->implements) */) {
        mprAssert(type->baseType == baseType);
        if (type->prototype == 0) {
            type->prototype = ejsCreatePrototype(ejs, type, 0);
        } else {
            fixupPrototypeProperties(ejs, type, type->prototype, baseType->prototype, 1);
        }
    }
    fixInstanceSize(ejs, type);
    return 0;
}


static int fixupTypeProperties(Ejs *ejs, EjsType *type, EjsType *baseType, int makeRoom)
{
    EjsType         *iface;
    EjsNamespace    *nsp;
    EjsObj          *base;
    int             next, offset, count, nextNsp, baseInterface;

    mprAssert(type != baseType);
    mprAssert(!type->block.obj.isPrototype);

    base = (EjsObj*) baseType;
    if (baseType == 0 || base->numSlots == 0) {
        return EJS_ERR;
    }
    baseInterface = ejsIsType(base) && ((EjsType*) base)->isInterface;
    
    /*
        Count the number of inherited traits and insert
     */
    if (makeRoom) {
        count = base->numSlots;
        if (type->implements) {
            for (next = 0; ((iface = mprGetNextItem(type->implements, &next)) != 0); ) {
                if (iface) {
                    if (!iface->isInterface) {
                        count += iface->block.obj.numSlots - iface->numInherited;
                    }
                }
            }
        }
        if (count > 0 && ejsInsertGrowObject(ejs, (EjsObj*) type, count, 0) < 0) {
            return EJS_ERR;
        }
    }

    offset = 0;
    if (ejsInheritProperties(ejs, (EjsObj*) type, (EjsObj*) base, base->numSlots, offset, 0) < 0) {
        return EJS_ERR;
    }
    type->numInherited = base->numSlots;
    offset += base->numSlots;

    if (type->implements) {
        for (next = 0; ((iface = mprGetNextItem(type->implements, &next)) != 0); ) {
            for (nextNsp = 0; (nsp = (EjsNamespace*) ejsGetNextItem(&iface->block.namespaces, &nextNsp)) != 0;) {
                mprAssert(ejsIsBlock(type));
                ejsAddNamespaceToBlock(ejs, (EjsBlock*) type, nsp);
            }
        }
    }
    return 0;
}


static int fixupPrototypeProperties(Ejs *ejs, EjsType *type, EjsObj *obj, EjsObj *base, int makeRoom)
{
    mprAssert(obj != base);

    if (makeRoom && base->numSlots > 0 && ejsInsertGrowObject(ejs, obj, base->numSlots, 0) < 0) {
        return EJS_ERR;
    }
    if (ejsInheritProperties(ejs, obj, base, base->numSlots, 0, 0) < 0) {
        return EJS_ERR;
    }
    return 0;
}


/*
    Set the native method function for a function property
 */
int ejsBindMethod(Ejs *ejs, EjsType *type, int slotNum, EjsProc nativeProc)
{
    return ejsBindFunction(ejs, &type->block, slotNum, nativeProc);
}


int ejsBindAccess(Ejs *ejs, EjsType *type, int slotNum, EjsProc getter, EjsProc setter)
{
    EjsFunction     *fun;
    EjsBlock        *block;
    EjsName         qname;

    block = &type->block;

    if (getter) {
        if (ejsBindFunction(ejs, block, slotNum, getter) < 0) {
            return EJS_ERR;
        }
    }
    if (setter) {
        fun = (EjsFunction*) ejsGetProperty(ejs, (EjsObj*) block, slotNum);
        if (fun == 0 || !ejsIsFunction(fun) || fun->setter == 0 || !ejsIsFunction(fun->setter)) {
            ejs->hasError = 1;
            mprError(ejs, "Attempt to bind non-existant setter function for slot %d in block/type \"%s\"", slotNum, 
                ejsGetDebugName(block));
            return EJS_ERR;
        }
        fun = fun->setter;
        if (fun->body.code.codeLen != 0) {
            qname = ejsGetPropertyName(ejs, fun->owner, fun->slotNum);
            mprError(ejs, "Setting a native method on a non-native function \"%s\" in block/type \"%s\"", qname.name, 
                ejsGetDebugName(block));
            ejs->hasError = 1;
        }
        fun->body.proc = setter;
        fun->nativeProc = 1;
    }
    return 0;
}


/*
    Set the native method function for a function property
 */
int ejsBindFunction(Ejs *ejs, EjsBlock *block, int slotNum, EjsProc nativeProc)
{
    EjsFunction     *fun;
    EjsName         qname;

    fun = (EjsFunction*) ejsGetProperty(ejs, (EjsObj*) block, slotNum);
    if (fun == 0 || !ejsIsFunction(fun)) {
        mprAssert(fun);
        ejs->hasError = 1;
        mprError(ejs, "Attempt to bind non-existant function for slot %d in block/type \"%s\"", slotNum, 
            ejsGetDebugName(block));
        return EJS_ERR;
    }
    if (fun->body.code.codeLen != 0) {
        qname = ejsGetPropertyName(ejs, fun->owner, fun->slotNum);
        mprError(ejs, "Setting a native method on a non-native function \"%s\" in block/type \"%s\"", qname.name, 
            ejsGetDebugName(block));
        ejs->hasError = 1;
    }
    fun->body.proc = nativeProc;
    fun->nativeProc = 1;
    return 0;
}


/*
    Define a global public function. Returns a positive slot number, otherwise a negative MPR error.
 */
int ejsDefineGlobalFunction(Ejs *ejs, cchar *name, EjsProc fn)
{
    EjsFunction *fun;
    EjsName     qname;

    if ((fun = ejsCreateFunction(ejs, NULL, -1, 0, 0, 0, ejs->objectType, 0, NULL, NULL, 0)) == 0) {
        return MPR_ERR_NO_MEMORY;
    }
    fun->body.proc = fn;
    fun->nativeProc = 1;
    ejsName(&qname, EJS_PUBLIC_NAMESPACE, name);
    return ejsSetPropertyByName(ejs, ejs->global, &qname, (EjsObj*) fun);
}


/*
    Return true if target is an instance of type or a sub class of it.
 */
bool ejsIsA(Ejs *ejs, EjsObj *target, EjsType *type)
{
    mprAssert(type);

    if (!ejsIsType(type)) {
        return 0;
    }
    if (target == 0) {
        return 0;
    }
    return ejsIsTypeSubType(ejs, target->type, type);
}


/*
    Return true if "target" is a "type", subclass of "type" or implements "type".
 */
bool ejsIsTypeSubType(Ejs *ejs, EjsType *target, EjsType *type)
{
    EjsType     *tp, *iface;
    int         next;

    mprAssert(target);
    mprAssert(type);
    
    if (!ejsIsType(target) || !ejsIsType(type)) {
        return 0;
    }
    /*
        See if target is a subtype of type
     */
    for (tp = target; tp; tp = tp->baseType) {
        /*
            Test ID also to allow cloned interpreters to match where the IDs are equal
         */
        if (tp == type || tp->id == type->id) {
            return 1;
        }
    }
    /*
        See if target implements type
     */
    if (target->implements) {
        for (next = 0; (iface = mprGetNextItem(target->implements, &next)) != 0; ) {
            if (iface == type) {
                return 1;
            }
        }
    }
    return 0;
}


/*
    Get the attributes of the type property at slotNum.

 */
int ejsGetTypePropertyAttributes(Ejs *ejs, EjsObj *vp, int slotNum)
{
    EjsType     *type;

    if (!ejsIsType(vp)) {
        mprAssert(ejsIsType(vp));
        return EJS_ERR;
    }
    type = (EjsType*) vp;
    return ejsGetTraitAttributes((EjsObj*) type, slotNum);
}


/*
    This call is currently only used to update the type namespace after resolving a run-time namespace.
 */
void ejsSetTypeName(Ejs *ejs, EjsType *type, EjsName *qname)
{
    type->qname.name = qname->name;
    type->qname.space = qname->space;
    ejsSetDebugName(type, qname->name);

    if (type->prototype) {
        ejsSetDebugName(type->prototype, qname->name);
    }
}


/*
    Define namespaces for a class. Inherit the protected and internal namespaces from all base classes.
 */
void ejsDefineTypeNamespaces(Ejs *ejs, EjsType *type)
{
    EjsNamespace        *nsp;

    if (type->baseType) {
        /*
            Inherit the base class's protected and internal namespaces
         */
        ejsInheritBaseClassNamespaces(ejs, type, type->baseType);
    }
    //  TODO - add readonly here
    nsp = ejsDefineReservedNamespace(ejs, (EjsBlock*) type, &type->qname, EJS_PROTECTED_NAMESPACE);
    nsp->flags |= EJS_NSP_PROTECTED;
    nsp = ejsDefineReservedNamespace(ejs, (EjsBlock*) type, &type->qname, EJS_PRIVATE_NAMESPACE);
    nsp->flags |= EJS_NSP_PRIVATE;
}


/*
    Return the total memory size used by a type
    MOB - not counting name sizes or methods etc. Should count everything.
 */
static int ejsGetBlockSize(Ejs *ejs, EjsObj *obj)
{
    int     size, numSlots;

    numSlots = ejsGetPropertyCount(ejs, obj);
    size = (numSlots * sizeof(EjsSlot));
    size += (obj->sizeHash * sizeof(int));
    if (ejsIsBlock(obj)) {
        size += sizeof(EjsBlock) - sizeof(EjsObj);
    }
    if (ejsIsType(obj)) {
        size += sizeof(EjsType) + sizeof(EjsTypeHelpers);
        size += sizeof(EjsType) - sizeof(EjsBlock);
    }
    return size;
}


/*
    Return the total memory size used by a type
 */
int ejsGetTypeSize(Ejs *ejs, EjsType *type)
{
    int     size;

    size = ejsGetBlockSize(ejs, (EjsObj*) type);
    if (type->prototype) {
        size += ejsGetBlockSize(ejs, type->prototype);
    }
    return size;
}



void ejsCreateTypeType(Ejs *ejs)
{
    EjsType     *type;

    type = ejs->typeType = ejsCreateNativeType(ejs, "ejs", "Type", ES_Type, sizeof(EjsType));

    /*
        Override the create helper when creating types
     */
    type->helpers = ejsCloneBlockHelpers(ejs, "type-helpers");
    type->helpers->clone            = (EjsCloneHelper) cloneTypeVar;
    type->helpers->create           = (EjsCreateHelper) createTypeVar;
    type->helpers->lookupProperty   = (EjsLookupPropertyHelper) lookupTypeProperty;
    type->helpers->setProperty      = (EjsSetPropertyHelper) setTypeProperty;
    type->helpers->mark             = (EjsMarkHelper) markType;

    /*
        WARNING: read closely. This can be confusing. Fixup the helpers for the object type. We need to find
        helpers via objectType->type->helpers. So we set it to the Type type. We keep objectType->baseType == 0
        because Object has no base type. Similarly for the Type type.
     */
    ejs->objectType->block.obj.type = ejs->typeType;
    ejs->typeType->block.obj.type = ejs->objectType;
    ejs->blockType->block.obj.type = ejs->typeType;
}


/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2010. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2010. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    @end
 */
/************************************************************************/
/*
 *  End of file "../src/core/src/ejsType.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../src/core/src/ejsUri.c"
 */
/************************************************************************/

/*
    ejsUri.c - Uri class.

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */




static char *getUriString(Ejs *ejs, EjsObj *vp);
static int same(Ejs *ejs, HttpUri *u1, HttpUri *u2, int exact);
static void setUriFromHash(Ejs *ejs, EjsUri *up, EjsObj *arg);
static EjsObj *uri_join(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv);
static char *uriToString(Ejs *ejs, EjsUri *up);


static EjsUri *cloneUri(Ejs *ejs, EjsUri *src, bool deep)
{
    EjsUri     *dest;
    char        *uri;

    /*  Deep copy will complete the uri */
    uri = httpUriToString(src, src->uri, deep);
    dest = (EjsUri*) ejsCloneObject(ejs, (EjsObj*) src, deep);
    dest->uri = httpCreateUri(ejs, uri, 0);
    mprFree(uri);
    return dest;
}


static EjsObj *coerceUriOperands(Ejs *ejs, EjsUri *lhs, int opcode,  EjsObj *rhs)
{
    HttpUri     *uri;
    char        *ustr;

    switch (opcode) {
    /*
        Binary operators
     */
    case EJS_OP_ADD:
        uri = lhs->uri;
        ustr = httpFormatUri(lhs, uri->scheme, uri->host, uri->port, uri->path, uri->reference, uri->query, 0);
        return ejsInvokeOperator(ejs, (EjsObj*) ejsCreateString(ejs, ustr), opcode, rhs);

    case EJS_OP_COMPARE_EQ: case EJS_OP_COMPARE_NE:
    case EJS_OP_COMPARE_LE: case EJS_OP_COMPARE_LT:
    case EJS_OP_COMPARE_GE: case EJS_OP_COMPARE_GT:
        if (ejsIsNull(rhs) || ejsIsUndefined(rhs)) {
            return (EjsObj*) ((opcode == EJS_OP_COMPARE_EQ) ? ejs->falseValue: ejs->trueValue);
        }
        uri = lhs->uri;
        ustr = httpFormatUri(lhs, uri->scheme, uri->host, uri->port, uri->path, uri->reference, uri->query, 0);
        return ejsInvokeOperator(ejs, (EjsObj*) ejsCreateStringAndFree(ejs, ustr), opcode, rhs);

    case EJS_OP_COMPARE_STRICTLY_NE:
        return (EjsObj*) ejs->trueValue;

    case EJS_OP_COMPARE_STRICTLY_EQ:
        return (EjsObj*) ejs->falseValue;

    case EJS_OP_COMPARE_NOT_ZERO:
    case EJS_OP_COMPARE_TRUE:
        return (EjsObj*) ejs->trueValue;

    case EJS_OP_COMPARE_ZERO:
    case EJS_OP_COMPARE_FALSE:
        return (EjsObj*) ejs->falseValue;

    case EJS_OP_COMPARE_UNDEFINED:
    case EJS_OP_COMPARE_NULL:
        return (EjsObj*) ejs->falseValue;

    default:
        ejsThrowTypeError(ejs, "Opcode %d not valid for type %s", opcode, lhs->obj.type->qname.name);
        return ejs->undefinedValue;
    }
    return 0;
}


static EjsObj *invokeUriOperator(Ejs *ejs, EjsUri *lhs, int opcode,  EjsUri *rhs, void *data)
{
    EjsObj      *result;

    if (rhs == 0 || lhs->obj.type != rhs->obj.type) {
        if ((result = coerceUriOperands(ejs, lhs, opcode, (EjsObj*) rhs)) != 0) {
            return result;
        }
    }

    /*  Types now match, both Uris
     */
    switch (opcode) {
    case EJS_OP_COMPARE_STRICTLY_EQ:
    case EJS_OP_COMPARE_EQ:
        if (lhs == rhs || (lhs->uri == rhs->uri)) {
            return (EjsObj*) ejs->trueValue;
        }
        return (EjsObj*) ejsCreateBoolean(ejs,  same(ejs, lhs->uri, rhs->uri, 1));

    case EJS_OP_COMPARE_NE:
    case EJS_OP_COMPARE_STRICTLY_NE:
        return (EjsObj*) ejsCreateBoolean(ejs,  !same(ejs, lhs->uri, rhs->uri, 1));

    /*  NOTE: these only compare the paths */
    case EJS_OP_COMPARE_LT:
        return (EjsObj*) ejsCreateBoolean(ejs,  mprStrcmp(lhs->uri->path, rhs->uri->path) < 0);

    case EJS_OP_COMPARE_LE:
        return (EjsObj*) ejsCreateBoolean(ejs,  mprStrcmp(lhs->uri->path, rhs->uri->path) <= 0);

    case EJS_OP_COMPARE_GT:
        return (EjsObj*) ejsCreateBoolean(ejs,  mprStrcmp(lhs->uri->path, rhs->uri->path) > 0);

    case EJS_OP_COMPARE_GE:
        return (EjsObj*) ejsCreateBoolean(ejs,  mprStrcmp(lhs->uri->path, rhs->uri->path) >= 0);

    /*  
        Unary operators
     */
    case EJS_OP_COMPARE_NOT_ZERO:
        return (EjsObj*) ((lhs->uri->path) ? ejs->trueValue: ejs->falseValue);

    case EJS_OP_COMPARE_ZERO:
        return (EjsObj*) ((lhs->uri->path == 0) ? ejs->trueValue: ejs->falseValue);


    case EJS_OP_COMPARE_UNDEFINED:
    case EJS_OP_COMPARE_NULL:
    case EJS_OP_COMPARE_FALSE:
    case EJS_OP_COMPARE_TRUE:
        return (EjsObj*) ejs->falseValue;

    /*  
        Binary operators
     */
    case EJS_OP_ADD:
        return uri_join(ejs, lhs, 1, (EjsObj**) &rhs);

    default:
        ejsThrowTypeError(ejs, "Opcode %d not implemented for type %s", opcode, lhs->obj.type->qname.name);
        return 0;
    }
    mprAssert(0);
}



/*  
    Constructor
    function Uri(path: String)
    function Uri(parts: Object)
 */
static EjsObj *uri_constructor(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    EjsObj      *arg;
    char        *ustr;

    mprAssert(argc == 1);
    arg = argv[0];
    if (ejsIsString(arg)) {
        if ((ustr = getUriString(ejs, arg)) == 0) {
            return 0;
        }
        up->uri = httpCreateUri(up, ustr, 0);
        mprFree(ustr);
    } else {
        setUriFromHash(ejs, up, arg);
    }
    return (EjsObj*) up;
}


/*  
    function get basename(): Uri
 */
static EjsObj *uri_basename(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    EjsUri      *np;
    char        *path, *cp;
    int         len;

    np = cloneUri(ejs, up, 0);
    path = np->uri->path;
    if (path == 0) {
        return (EjsObj*) ejs->emptyStringValue;
    }
    len = strlen(path);
    if (path[len - 1] == '/') {
        *path = '\0';
    } else {
        if ((cp = strrchr(path, '/')) != 0) {
            np->uri->path = &cp[1];
        }
    }
    return (EjsObj*) np;
}


/*  
    Complete missing parts of a Uri
    function get complete()
 */
static EjsObj *uri_complete(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    return (EjsObj*) cloneUri(ejs, up, 1);
}


/*  
    Break a uri into components
  
    function components(): Object
 */
static EjsObj *uri_components(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    EjsObj      *obj;
    HttpUri     *uri;
    EjsName     qname;

    uri = up->uri;
    obj = ejsCreateSimpleObject(ejs);

    if (uri->scheme) {
        ejsSetPropertyByName(ejs, obj, EN(&qname, "scheme"), (EjsObj*) ejsCreateString(ejs, uri->scheme));
    }
    if (uri->host) {
        ejsSetPropertyByName(ejs, obj, EN(&qname, "host"), (EjsObj*) ejsCreateString(ejs, uri->host));
    }
    if (uri->port > 0) {
        ejsSetPropertyByName(ejs, obj, EN(&qname, "port"), (EjsObj*) ejsCreateNumber(ejs, uri->port));
    }
    if (uri->path) {
        ejsSetPropertyByName(ejs, obj, EN(&qname, "path"), (EjsObj*) ejsCreateString(ejs, uri->path));
    }
    if (uri->reference) {
        ejsSetPropertyByName(ejs, obj, EN(&qname, "reference"), (EjsObj*) ejsCreateString(ejs, uri->reference));
    }
    if (uri->query) {
        ejsSetPropertyByName(ejs, obj, EN(&qname, "query"), (EjsObj*) ejsCreateString(ejs, uri->query));
    }
    return (EjsObj*) obj;
}


/*  
    Decode a Uri
    static function decode(str: String): String
 */
static EjsObj *uri_decode(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateStringAndFree(ejs, mprUriDecode(ejs, ejsGetString(ejs, argv[0])));
}


/*  
    Decode a Uri component
    static function decodeComponent(str: String): String
 */
static EjsObj *uri_decodeComponent(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateStringAndFree(ejs, mprUriDecode(ejs, ejsGetString(ejs, argv[0])));
}


/*  
    function get dirname(): Uri
 */
static EjsObj *uri_dirname(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    EjsUri      *np;
    char        *path, *cp;
    int         len;

    np = cloneUri(ejs, up, 0);
    path = np->uri->path;
    if (path == 0) {
        return (EjsObj*) ejs->emptyStringValue;
    }
    len = strlen(path);
    if (path[len - 1] == '/') {
        if (len > 1) {
            path[len - 1] = '\0';
        }
    } else {
        if ((cp = strrchr(path, '/')) != 0) {
            if (cp > path) {
                *cp = '\0';
            } else {
                cp[1] = '\0';
            }
        }
    }
    return (EjsObj*) np;
}


/*  
    Uri Encode a string
    function encode(str: String): String
 */
static EjsObj *uri_encode(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateStringAndFree(ejs, mprUriEncode(ejs, ejsGetString(ejs, argv[0]), MPR_ENCODE_URI));
}


/*  
    Encode a Uri component
    static function encodeComponent(str: String): String
 */
static EjsObj *uri_encodeComponent(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateStringAndFree(ejs, mprUriEncode(ejs, ejsGetString(ejs, argv[0]), MPR_ENCODE_URI_COMPONENT));
}


/*  
    Get the Uri extension
    static function get extension(): String
 */
static EjsObj *uri_extension(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateString(ejs, up->uri->ext);
}


/*  
    Set the Uri extension
    static function set extension(ext: String): Void
 */
static EjsObj *uri_set_extension(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    HttpUri     *uri;

    uri = up->uri;
    uri->ext = mprStrdup(uri, ejsGetString(ejs, argv[0]));
    uri->path = mprStrcat(uri, -1, mprTrimPathExtension(uri, uri->path), uri->ext, NULL);
    return 0;
}


/*  
    Determine if the uri has an extension
    static function get hasExtension(): Boolean
 */
static EjsObj *uri_hasExtension(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    return (EjsObj*) ((up->uri->ext) ? ejs->trueValue : ejs->falseValue);
}


/*  
    Determine if the uri has a host
    static function get hasHost(): Boolean
 */
static EjsObj *uri_hasHost(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    return (EjsObj*) ((up->uri->host) ? ejs->trueValue : ejs->falseValue);
}


/*  
    Determine if the uri has a port
    static function get hasPort(): Boolean
 */
static EjsObj *uri_hasPort(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    return (EjsObj*) ((up->uri->port > 0) ? ejs->trueValue : ejs->falseValue);
}


/*  
    Determine if the uri has a query
    static function get hasQuery(): Boolean
 */
static EjsObj *uri_hasQuery(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    return (EjsObj*) ((up->uri->query) ? ejs->trueValue : ejs->falseValue);
}


/*  
    Determine if the uri has a reference
    static function get hasReference(): Boolean
 */
static EjsObj *uri_hasReference(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    return (EjsObj*) ((up->uri->reference) ? ejs->trueValue : ejs->falseValue);
}


/*  
    Determine if the uri has a scheme
    static function get hasScheme(): Boolean
 */
static EjsObj *uri_hasScheme(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    return (EjsObj*) ((up->uri->scheme) ? ejs->trueValue : ejs->falseValue);
}


/*  
    Get the host portion
    static function get host(): String
 */
static EjsObj *uri_host(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    if (up->uri->host == 0) {
        return (EjsObj*) ejsCreateString(ejs, "localhost");
    }    
    return (EjsObj*) ejsCreateString(ejs, up->uri->host);
}


/*  
    Set the host portion
    static function set host(name: String): Void
 */
static EjsObj *uri_set_host(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    up->uri->host = mprStrdup(up->uri, ejsGetString(ejs, argv[0]));
    return 0;
}


/*  
    function get isAbsolute(): Boolean
 */
static EjsObj *uri_isAbsolute(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    return (EjsObj*) ((up->uri->path[0] == '/') ? ejs->trueValue : ejs->falseValue);
}


/*  
    Determine if the file name is a directory. This 
    function get isDir(): Boolean
 */
static EjsObj *uri_isDir(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    HttpUri     *uri;

    uri = up->uri;
    return (EjsObj*) ((uri->path[strlen(uri->path) - 1] == '/') ? ejs->trueValue : ejs->falseValue);
}


/*  
    Join uri segments
    function join(...others): Uri
 */
static EjsObj *uri_join(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    EjsUri      *np;
    EjsArray    *args;
    HttpUri     *uri, *nuri;
    char        *other;
    char        *result, *prior;
    int         i;

    args = (EjsArray*) argv[0];
    uri = up->uri;
    result = uri->path;
    np = cloneUri(ejs, up, 0);
    nuri = np->uri;

    for (i = 0; i < args->length; i++) {
        if ((other = getUriString(ejs, ejsGetProperty(ejs, (EjsObj*) args, i))) == NULL) {
            return 0;
        }
        prior = result;
        if (other[0] == '/') {
            result = mprStrdup(nuri, other);
        } else {
            if (prior[strlen(prior) - 1] == '/') {
                result = mprStrcat(nuri, -1, prior, other, NULL);
            } else {
                result = mprStrcat(nuri, -1, prior, "/", other, NULL);
            }
        }
        mprFree(other);
        if (prior != uri->path) {
            mprFree(prior);
        }
    }
    np->uri->path = result;
    np->uri->ext = (char*) mprGetPathExtension(np->uri, np->uri->path);
    return (EjsObj*) np;
}


/*  
    Join extension
    function joinExt(ext: String): Uri
 */
static EjsObj *uri_joinExt(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    EjsUri      *np;
    HttpUri     *nuri;
    char        *ext;

    np = cloneUri(ejs, up, 1);
    nuri = np->uri;
    ext = mprStrdup(nuri, ejsGetString(ejs, argv[0]));
    if (ext && *ext == '.') {
        ext++;
    }
    nuri->ext = ext;
    nuri->path = mprStrcat(nuri, -1, mprTrimPathExtension(nuri, nuri->path), ".", nuri->ext, NULL);
    return (EjsObj*) np;
}


/*  
    Get the mimeType
    function mimeType(): String
 */
static EjsObj *uri_mimeType(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateString(ejs, mprLookupMimeType(ejs, up->uri->ext));
}


/*  
    function get normalize(): Uri
 */
static EjsObj *uri_normalize(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    EjsUri      *np;

    np = cloneUri(ejs, up, 0);
    np->uri->path = mprGetNormalizedPath(ejs, up->uri->path);
    return (EjsObj*) np;
}


/*  
    Get the path portion
    static function get path(): String
 */
static EjsObj *uri_path(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateString(ejs, up->uri->path);
}


/*  
    Set the path portion
    static function set path(path: String): Void
 */
static EjsObj *uri_set_path(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    up->uri->path = mprStrdup(up, ejsGetString(ejs, argv[0]));
    up->uri->ext = (char*) mprGetPathExtension(up->uri, up->uri->path);
    return 0;
}


/*  
    Get the port portion
    static function get port(): Number
 */
static EjsObj *uri_port(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    HttpUri     *uri;
    
    uri = up->uri;
    if (uri->port == 0) {
        if (uri->scheme == 0 || strcmp(uri->scheme, "http") == 0) {
            return (EjsObj*) ejsCreateNumber(ejs, 80);
        } else if (uri->scheme && strcmp(uri->scheme, "https") == 0) {
            return (EjsObj*) ejsCreateNumber(ejs, 443);
        }
    }
    return (EjsObj*) ejsCreateNumber(ejs, up->uri->port);
}


/*  
    Set the port portion
    static function set port(port: Number): Void
 */
static EjsObj *uri_set_port(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    up->uri->port = ejsGetInt(ejs, argv[0]);
    return 0;
}


/*  
    Replace the Uri extension
    static function set replaceExt(ext: String): Uri
 */
static EjsObj *uri_replaceExtension(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    EjsUri      *np;
    HttpUri     *nuri;
    char        *ext;

    np = cloneUri(ejs, up, 1);
    nuri = np->uri;
    nuri->path = mprTrimPathExtension(nuri, nuri->path);
    ext = mprStrdup(np, ejsGetString(ejs, argv[0]));
    if (ext && *ext == '.') {
        ext++;
    }
    nuri->ext = ext;
    nuri->path = mprStrcat(nuri, -1, mprTrimPathExtension(nuri, nuri->path), ".", nuri->ext, NULL);
    return (EjsObj*) np;
}


/*  
    Get the scheme portion
    static function get scheme(): String
 */
static EjsObj *uri_scheme(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    if (up->uri->scheme == 0) {
        return (EjsObj*) ejsCreateString(ejs, "http");
    }
    return (EjsObj*) ejsCreateString(ejs, up->uri->scheme);
}


/*  
    Set the scheme portion
    static function set scheme(scheme: String): Void
 */
static EjsObj *uri_set_scheme(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    up->uri->scheme = mprStrdup(up, ejsGetString(ejs, argv[0]));
    return 0;
}


/*  
    Get the query portion
    static function get query(): String
 */
static EjsObj *uri_query(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateString(ejs, up->uri->query);
}


/*  
    Set the query portion
    static function set query(query: String): Void
 */
static EjsObj *uri_set_query(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    up->uri->query = mprStrdup(up, ejsGetString(ejs, argv[0]));
    return 0;
}


/*  
    Get the reference portion
    static function get reference(): String
 */
static EjsObj *uri_reference(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateString(ejs, up->uri->reference);
}


/*  
    Set the reference portion
    static function set reference(reference: String): Void
 */
static EjsObj *uri_set_reference(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    up->uri->reference = mprStrdup(up, ejsGetString(ejs, argv[0]));
    return 0;
}


/*  
    Compare two Uris
    function same(other: String, exact: Boolean = false): Boolean
 */
static EjsObj *uri_same(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    EjsUri  *other;
    int     exact;

    other = (EjsUri*) argv[0];
    exact = (argc == 2 && argv[1] == (EjsObj*) ejs->trueValue);
    return (EjsObj*) (same(ejs, up->uri, other->uri, exact) ? ejs->trueValue: ejs->falseValue);
}


/* 
   function toString(): String
 */
static EjsObj *uri_toString(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    HttpUri     *uri;

    uri = up->uri;
    return (EjsObj*) ejsCreateStringAndFree(ejs, httpUriToString(up, uri, 0));
}


/*  
    function trimExt(): Uri
 */
static EjsObj *uri_trimExt(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    EjsUri      *np;
    HttpUri     *nuri;

    np = cloneUri(ejs, up, 1);
    nuri = np->uri;
    nuri->ext = 0;
    nuri->path = mprTrimPathExtension(nuri, nuri->path);
    return (EjsObj*) np;
}


/*  
    function set uri(value: String): Void
 */
static EjsObj *uri_set_uri(Ejs *ejs, EjsUri *up, int argc, EjsObj **argv)
{
    mprFree(up->uri);
    up->uri = httpCreateUri(up, ejsGetString(ejs, argv[0]), 0);
    return 0;
}


static char *uriToString(Ejs *ejs, EjsUri *up)
{
    HttpUri     *uri;

    uri = up->uri;
    return httpFormatUri(ejs, uri->scheme, uri->host, uri->port, uri->path, uri->reference, uri->query, 0);
}


static char *getUriString(Ejs *ejs, EjsObj *vp)
{
    if (ejsIsString(vp)) {
        return mprStrdup(ejs, ejsGetString(ejs, vp));
    } else if (ejsIsUri(ejs, vp)) {
        return uriToString(ejs, ((EjsUri*) vp));
    }
    ejsThrowIOError(ejs, "Bad path");
    return NULL;
}


static int same(Ejs *ejs, HttpUri *u1, HttpUri *u2, int exact)
{
    if (u1 == u2) {
        return 1;
    }
    if ((u1->scheme && !u2->scheme) || (!u1->scheme && u2->scheme)) {
        return 0;
    }
    if (u1->scheme && strcmp(u1->scheme, u2->scheme) != 0) {
        return 0;
    }
    if ((u1->host && !u2->host) || (!u1->host && u2->host)) {
        return 0;
    }
    if (u1->host && strcmp(u1->host, u2->host) != 0) {
        return 0;
    }
    if ((u1->path && !u2->path) || (!u1->path && u2->path)) {
        return 0;
    }
    if (u1->path && strcmp(u1->path, u2->path) != 0) {
        return 0;
    }
    if (u1->port != u2->port) {
        return 0;
    }
    if (exact) {
        if ((u1->reference && !u2->reference) || (!u1->reference && u2->reference)) {
            return 0;
        }
        if (u1->reference && strcmp(u1->reference, u2->reference) != 0) {
            return 0;
        }
        if ((u1->query && !u2->query) || (!u1->query && u2->query)) {
            return 0;
        }
        if (u1->query && strcmp(u1->query, u2->query) != 0) {
            return 0;
        }
    }
    return 1;
}


static void setUriFromHash(Ejs *ejs, EjsUri *up, EjsObj *arg)
{
    EjsObj      *schemeObj, *hostObj, *portObj, *pathObj, *referenceObj, *queryObj;
    EjsName     qname;
    cchar       *scheme, *host, *path, *reference, *query;
    int         port;

    schemeObj = ejsGetPropertyByName(ejs, arg, EN(&qname, "scheme"));
    scheme = (schemeObj && ejsIsString(schemeObj)) ? ejsGetString(ejs, schemeObj) : 0;

    hostObj = ejsGetPropertyByName(ejs, arg, EN(&qname, "host"));
    host = (hostObj && ejsIsString(hostObj)) ? ejsGetString(ejs, hostObj) : 0;

    port = 0;
    if ((portObj = ejsGetPropertyByName(ejs, arg, EN(&qname, "port"))) != 0) {
        if (ejsIsNumber(portObj)) {
            port = ejsGetInt(ejs, portObj);
        } else if (ejsIsString(portObj)) {
            port = (int) mprAtoi(ejsGetString(ejs, portObj), 10);
        }
    }

    pathObj = ejsGetPropertyByName(ejs, arg, EN(&qname, "path"));
    path = (pathObj && ejsIsString(pathObj)) ? ejsGetString(ejs, pathObj) : 0;

    referenceObj = ejsGetPropertyByName(ejs, arg, EN(&qname, "reference"));
    reference = (referenceObj && ejsIsString(referenceObj)) ? ejsGetString(ejs, referenceObj) : 0;

    queryObj = ejsGetPropertyByName(ejs, arg, EN(&qname, "query"));
    query = (queryObj && ejsIsString(queryObj)) ? ejsGetString(ejs, queryObj) : 0;

    mprFree(up->uri);
    up->uri = httpCreateUriFromParts(up, scheme, host, port, path, reference, query);
}



EjsUri *ejsCreateUri(Ejs *ejs, cchar *path)
{
    EjsUri     *up;
    EjsObj      *arg;

    up = (EjsUri*) ejsCreate(ejs, ejs->uriType, 0);
    if (up == 0) {
        return 0;
    }
    arg = (EjsObj*) ejsCreateString(ejs, path);
    uri_constructor(ejs, up, 1, (EjsObj**) &arg);
    return up;
}


EjsUri *ejsCreateUriAndFree(Ejs *ejs, char *value)
{
    EjsUri     *up;

    up = ejsCreateUri(ejs, value);
    mprFree(value);
    return up;
}


void ejsConfigureUriType(Ejs *ejs)
{
    EjsType     *type;

    type = ejs->uriType = ejsConfigureNativeType(ejs, EJS_EJS_NAMESPACE, "Uri", sizeof(EjsUri));

    type->helpers = ejsCloneObjectHelpers(ejs, "uri-helpers");
    type->helpers->clone = (EjsCloneHelper) cloneUri;
    type->helpers->invokeOperator = (EjsInvokeOperatorHelper) invokeUriOperator;

    ejsBindMethod(ejs, type, ES_Uri_Uri, (EjsProc) uri_constructor);
    ejsBindMethod(ejs, type, ES_Uri_basename, (EjsProc) uri_basename);
    ejsBindMethod(ejs, type, ES_Uri_complete, (EjsProc) uri_complete);
    ejsBindMethod(ejs, type, ES_Uri_components, (EjsProc) uri_components);
    ejsBindMethod(ejs, type, ES_Uri_decode, (EjsProc) uri_decode);
    ejsBindMethod(ejs, type, ES_Uri_decodeComponent, (EjsProc) uri_decodeComponent);
    ejsBindMethod(ejs, type, ES_Uri_dirname, (EjsProc) uri_dirname);
    ejsBindMethod(ejs, type, ES_Uri_encode, (EjsProc) uri_encode);
    ejsBindMethod(ejs, type, ES_Uri_encodeComponent, (EjsProc) uri_encodeComponent);
    ejsBindAccess(ejs, type, ES_Uri_extension, (EjsProc) uri_extension, (EjsProc) uri_set_extension);
    ejsBindMethod(ejs, type, ES_Uri_hasExtension, (EjsProc) uri_hasExtension);
    ejsBindMethod(ejs, type, ES_Uri_hasHost, (EjsProc) uri_hasHost);
    ejsBindMethod(ejs, type, ES_Uri_hasPort, (EjsProc) uri_hasPort);
    ejsBindMethod(ejs, type, ES_Uri_hasQuery, (EjsProc) uri_hasQuery);
    ejsBindMethod(ejs, type, ES_Uri_hasReference, (EjsProc) uri_hasReference);
    ejsBindMethod(ejs, type, ES_Uri_hasScheme, (EjsProc) uri_hasScheme);
    ejsBindAccess(ejs, type, ES_Uri_host, (EjsProc) uri_host, (EjsProc) uri_set_host);
    ejsBindMethod(ejs, type, ES_Uri_isAbsolute, (EjsProc) uri_isAbsolute);
    ejsBindMethod(ejs, type, ES_Uri_isDir, (EjsProc) uri_isDir);
    ejsBindMethod(ejs, type, ES_Uri_join, (EjsProc) uri_join);
    ejsBindMethod(ejs, type, ES_Uri_joinExt, (EjsProc) uri_joinExt);
    ejsBindMethod(ejs, type, ES_Uri_mimeType, (EjsProc) uri_mimeType);
    ejsBindMethod(ejs, type, ES_Uri_normalize, (EjsProc) uri_normalize);
    ejsBindAccess(ejs, type, ES_Uri_path, (EjsProc) uri_path, (EjsProc) uri_set_path);
    ejsBindAccess(ejs, type, ES_Uri_port, (EjsProc) uri_port, (EjsProc) uri_set_port);
    ejsBindAccess(ejs, type, ES_Uri_scheme, (EjsProc) uri_scheme, (EjsProc) uri_set_scheme);
    ejsBindAccess(ejs, type, ES_Uri_query, (EjsProc) uri_query, (EjsProc) uri_set_query);
    ejsBindAccess(ejs, type, ES_Uri_reference, (EjsProc) uri_reference, (EjsProc) uri_set_reference);
    ejsBindMethod(ejs, type, ES_Uri_replaceExt, (EjsProc) uri_replaceExtension);
    ejsBindMethod(ejs, type, ES_Uri_same, (EjsProc) uri_same);
    ejsBindMethod(ejs, type, ES_Uri_trimExt, (EjsProc) uri_trimExt);
    ejsBindAccess(ejs, type, ES_Uri_uri, (EjsProc) uri_toString, (EjsProc) uri_set_uri);
    ejsBindMethod(ejs, type, ES_Object_toString, (EjsProc) uri_toString);
}

/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2010. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2010. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    @end
 */
/************************************************************************/
/*
 *  End of file "../src/core/src/ejsUri.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../src/core/src/ejsVoid.c"
 */
/************************************************************************/

/**
    ejsVoid.c - Ejscript Void class (aka undefined)

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */



/*
    Cast the void operand to a primitive type
 */

static EjsObj *castVoid(Ejs *ejs, EjsVoid *vp, EjsType *type)
{
    switch (type->id) {
    case ES_Boolean:
        return (EjsObj*) ejs->falseValue;

    case ES_Number:
        return (EjsObj*) ejs->nanValue;

    case ES_Object:
        return vp;

    case ES_String:
        return (EjsObj*) ejsCreateString(ejs, "undefined");

    default:
        ejsThrowTypeError(ejs, "Can't cast to this type");
        return 0;
    }
}



static EjsObj *coerceVoidOperands(Ejs *ejs, EjsVoid *lhs, int opcode, EjsVoid *rhs)
{
    switch (opcode) {

    case EJS_OP_ADD:
        if (!ejsIsNumber(rhs)) {
            return ejsInvokeOperator(ejs, (EjsObj*) ejsToString(ejs, lhs), opcode, rhs);
        }
        /* Fall through */

    case EJS_OP_AND: case EJS_OP_DIV: case EJS_OP_MUL: case EJS_OP_OR: case EJS_OP_REM:
    case EJS_OP_SHL: case EJS_OP_SHR: case EJS_OP_SUB: case EJS_OP_USHR: case EJS_OP_XOR:
        return ejsInvokeOperator(ejs, (EjsObj*) ejs->nanValue, opcode, rhs);

    /*
     *  Comparision
     */
    case EJS_OP_COMPARE_LE: case EJS_OP_COMPARE_LT:
    case EJS_OP_COMPARE_GE: case EJS_OP_COMPARE_GT:
        return (EjsObj*) ejs->falseValue;

    case EJS_OP_COMPARE_NE:
        if (ejsIsNull(rhs)) {
            return (EjsObj*) ejs->falseValue;
        }
        return (EjsObj*) ejs->trueValue;

    case EJS_OP_COMPARE_STRICTLY_NE:
        return (EjsObj*) ejs->trueValue;

    case EJS_OP_COMPARE_EQ:
        if (ejsIsNull(rhs)) {
            return (EjsObj*) ejs->trueValue;
        }
        return (EjsObj*) ejs->falseValue;

    case EJS_OP_COMPARE_STRICTLY_EQ:
        return (EjsObj*) ejs->falseValue;

    /*
     *  Unary operators
     */
    case EJS_OP_LOGICAL_NOT: case EJS_OP_NOT: case EJS_OP_NEG:
        return 0;

    case EJS_OP_COMPARE_UNDEFINED:
    case EJS_OP_COMPARE_NOT_ZERO:
    case EJS_OP_COMPARE_NULL:
        return (EjsObj*) ejs->trueValue;

    case EJS_OP_COMPARE_FALSE:
    case EJS_OP_COMPARE_TRUE:
    case EJS_OP_COMPARE_ZERO:
        return (EjsObj*) ejs->falseValue;

    default:
        ejsThrowTypeError(ejs, "Opcode %d not valid for type %s", opcode, lhs->type->qname.name);
        return ejs->undefinedValue;
    }
    return 0;
}



static EjsObj *invokeVoidOperator(Ejs *ejs, EjsVoid *lhs, int opcode, EjsVoid *rhs)
{
    EjsObj      *result;

    if (rhs == 0 || lhs->type != rhs->type) {
        if ((result = coerceVoidOperands(ejs, lhs, opcode, rhs)) != 0) {
            return result;
        }
    }

    /*
     *  Types match, left and right types are both "undefined"
     */
    switch (opcode) {

    case EJS_OP_COMPARE_EQ: case EJS_OP_COMPARE_STRICTLY_EQ:
    case EJS_OP_COMPARE_LE: case EJS_OP_COMPARE_GE:
    case EJS_OP_COMPARE_UNDEFINED:
    case EJS_OP_COMPARE_NOT_ZERO:
    case EJS_OP_COMPARE_NULL:
        return (EjsObj*) ejs->trueValue;

    case EJS_OP_COMPARE_NE: case EJS_OP_COMPARE_STRICTLY_NE:
    case EJS_OP_COMPARE_LT: case EJS_OP_COMPARE_GT:
    case EJS_OP_COMPARE_FALSE:
    case EJS_OP_COMPARE_TRUE:
    case EJS_OP_COMPARE_ZERO:
        return (EjsObj*) ejs->falseValue;

    /*
     *  Unary operators
     */
    case EJS_OP_LOGICAL_NOT: case EJS_OP_NOT: case EJS_OP_NEG:
        return (EjsObj*) ejs->nanValue;

    /*
     *  Binary operators
     */
    case EJS_OP_ADD: case EJS_OP_AND: case EJS_OP_DIV: case EJS_OP_MUL: case EJS_OP_OR: case EJS_OP_REM:
    case EJS_OP_SHL: case EJS_OP_SHR: case EJS_OP_SUB: case EJS_OP_USHR: case EJS_OP_XOR:
        return (EjsObj*) ejs->nanValue;

    default:
        ejsThrowTypeError(ejs, "Opcode %d not implemented for type %s", opcode, lhs->type->qname.name);
        return 0;
    }
    mprAssert(0);
}


/*
    iterator native function get(): Iterator
 */
static EjsObj *getVoidIterator(Ejs *ejs, EjsObj *np, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateIterator(ejs, np, NULL, 0, NULL);
}


static EjsObj *getVoidProperty(Ejs *ejs, EjsVoid *unused, int slotNum)
{
    ejsThrowReferenceError(ejs, "Object reference is null");
    return 0;
}


/*
    We don't actually create any instances. We just use a reference to the undefined singleton instance.
 */
EjsVoid *ejsCreateUndefined(Ejs *ejs)
{
    return (EjsVoid*) ejs->undefinedValue;
}


void ejsCreateVoidType(Ejs *ejs)
{
    EjsType     *type;

    type = ejs->voidType = ejsCreateNativeType(ejs, "ejs", "Void", ES_Void, sizeof(EjsVoid));

    type->helpers->cast             = (EjsCastHelper) castVoid;
    type->helpers->invokeOperator   = (EjsInvokeOperatorHelper) invokeVoidOperator;
    type->helpers->getProperty      = (EjsGetPropertyHelper) getVoidProperty;

    ejs->undefinedValue = ejsCreate(ejs, type, 0);
    ejsSetDebugName(ejs->undefinedValue, "undefined");
}


void ejsConfigureVoidType(Ejs *ejs)
{
    EjsType     *type;

    type = ejsGetTypeByName(ejs, "ejs", "Void");

    ejsSetProperty(ejs, ejs->global, ES_void, (EjsObj*) type);
    ejsSetProperty(ejs, ejs->global, ES_undefined, ejs->undefinedValue);
    ejsBindMethod(ejs, type, ES_Object_get, getVoidIterator);
    ejsBindMethod(ejs, type, ES_Object_getValues, getVoidIterator);
}



/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2010. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2010. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    @end
 */
/************************************************************************/
/*
 *  End of file "../src/core/src/ejsVoid.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../src/core/src/ejsWorker.c"
 */
/************************************************************************/

/*
    ejsWorker - VM Worker thread classes

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */



typedef struct Message {
    EjsWorker   *worker;
    cchar       *callback;
    char        *data;
    char        *message;
    char        *filename;
    char        *stack;
    int         lineNumber;
    int         callbackSlot;
} Message;


static void addWorker(Ejs *ejs, EjsWorker *worker);
static int join(Ejs *ejs, EjsObj *workers, int timeout);
static void handleError(Ejs *ejs, EjsWorker *worker, EjsObj *exception);
static void loadFile(EjsWorker *insideWorker, cchar *filename);
static void removeWorker(Ejs *ejs, EjsWorker *worker);
static int workerMain(EjsWorker *worker, MprEvent *event);
static EjsObj *workerPreload(Ejs *ejs, EjsWorker *worker, int argc, EjsObj **argv);

/*
    function Worker(script: String = null, options: Object = null)

    Script is optional. If supplied, the script is run immediately by a worker thread. This call
    does not block. Options are: search and name.
 */
static EjsObj *workerConstructor(Ejs *ejs, EjsWorker *worker, int argc, EjsObj **argv)
{
    Ejs             *wejs;
    EjsObj          *options, *value, *search;
    EjsName         qname;
    EjsWorker       *self;
    EjsNamespace    *ns;
    cchar           *name;

    worker->ejs = ejs;
    worker->state = EJS_WORKER_BEGIN;

    options = (argc == 2) ? (EjsObj*) argv[1]: NULL;
    name = 0;
    search = 0;

    if (options) {
        search = ejsGetPropertyByName(ejs, options, ejsName(&qname, "", "search"));
        value = ejsGetPropertyByName(ejs, options, ejsName(&qname, "", "name"));
        if (ejsIsString(value)) {
            name = ejsGetString(ejs, value);
        }
    }

    if (name) {
        worker->name = mprStrdup(worker, name);
    } else {
        worker->name = mprAsprintf(worker, -1, "worker-%d", mprGetListCount(ejs->workers));
    }

    /*
        Create a new interpreter and an "inside" worker object and pair it with the current "outside" worker.
     */
    //  TODO - must change NULL to ejs to get a master clone
    wejs = ejsCreateVm(ejs->service, NULL, NULL, NULL, 0);
    if (wejs == 0) {
        ejsThrowMemoryError(ejs);
        return 0;
    }
    if (search) {
        ejsSetSearchPath(ejs, (EjsArray*) search);
    }
    worker->pair = self = ejsCreateWorker(wejs);
    self->state = EJS_WORKER_BEGIN;
    self->ejs = wejs;
    self->inside = 1;
    self->pair = worker;
    self->name = mprStrcat(self, -1, "inside-", worker->name, NULL);
    mprEnableDispatcher(wejs->dispatcher);

    //  TODO - these should be don't delete
    ejsSetProperty(ejs,  (EjsObj*) worker, ES_Worker_name, (EjsObj*) ejsCreateString(ejs, self->name));
    ejsSetProperty(wejs, (EjsObj*) self,   ES_Worker_name, (EjsObj*) ejsCreateString(wejs, self->name));

    ejsSetPropertyByName(wejs, wejs->global, ejsName(&qname, EJS_WORKER_NAMESPACE, "self"), (EjsObj*) self);

    /*
        Workers have a dedicated namespace to enable viewing of the worker globals (self, onmessage, postMessage...)
     */
    ns = ejsDefineReservedNamespace(wejs, wejs->globalBlock, 0, EJS_WORKER_NAMESPACE);

    /*
        Make the inside worker permanent so we don't need to worry about whether worker->pair->ejs is valid
     */
    self->obj.permanent = 1;
    
    if (argc > 0 && ejsIsPath(ejs, argv[0])) {
        addWorker(ejs, worker);
        worker->scriptFile = mprStrdup(worker, ((EjsPath*) argv[0])->path);
        worker->state = EJS_WORKER_STARTED;
        worker->obj.permanent = 1;
        if (mprCreateEvent(wejs->dispatcher, "workerMain", 0, (MprEventProc) workerMain, self, 0) < 0) {
            ejsThrowStateError(ejs, "Can't create worker event");
            worker->obj.permanent = 0;
            return 0;
        }
    }
    return (EjsObj*) worker;
}


/*
    Add a worker object to the list of workers for this interpreter
 */
static void addWorker(Ejs *ejs, EjsWorker *worker) 
{
    mprAssert(ejs == worker->ejs);
    mprAssert(worker);
    mprAssert(!worker->inside);
    mprAssert(worker->state == EJS_WORKER_BEGIN);

    lock(ejs);
    mprAddItem(ejs->workers, worker);
    unlock(ejs);
}


static void removeWorker(Ejs *ejs, EjsWorker *worker) 
{
    mprAssert(ejs == worker->ejs);
    mprAssert(!worker->inside);
    mprAssert(worker);

    lock(ejs);
    mprRemoveItem(ejs->workers, worker);
    if (ejs->joining) {
        //  MOB - why
        mprWakeWaitService(ejs);
    }
    unlock(ejs);
}


/*
    Start a worker thread. This is called by eval() and load(). Not by preload() or by Worker(). It always joins.
 */
static EjsObj *startWorker(Ejs *ejs, EjsWorker *outsideWorker, int timeout)
{
    EjsWorker   *insideWorker;
    Ejs         *inside;
    EjsObj      *result;

    mprAssert(ejs);
    mprAssert(outsideWorker);
    mprAssert(!outsideWorker->inside);
    mprAssert(outsideWorker->state == EJS_WORKER_BEGIN);

    LOG(ejs, 5, "Worker.startWorker");

    if (outsideWorker->state > EJS_WORKER_BEGIN) {
        ejsThrowStateError(ejs, "Worker has already started");
        return 0;
    }
    mprAssert(outsideWorker->pair);
    mprAssert(outsideWorker->pair->ejs);
    insideWorker = outsideWorker->pair;
    mprAssert(insideWorker->inside);
    inside = insideWorker->ejs;
    mprAssert(insideWorker->state == EJS_WORKER_BEGIN);

    addWorker(ejs, outsideWorker);
    outsideWorker->state = EJS_WORKER_STARTED;
    outsideWorker->obj.permanent = 1;

    if (mprCreateEvent(inside->dispatcher, "workerMain", 0, (MprEventProc) workerMain, insideWorker, 0) < 0) {
        ejsThrowStateError(ejs, "Can't create worker event");
        outsideWorker->obj.permanent = 0;
        return 0;
    }
    if (timeout == 0) {
        return ejs->undefinedValue;
    } 
    if (timeout < 0) {
        timeout = MAXINT;
    }
    if (join(ejs, (EjsObj*) outsideWorker, timeout) < 0) {
        return ejs->undefinedValue;
    }
    result = (EjsObj*) ejsToJSON(ejs, inside->result, NULL);
    if (result == 0) {
        return ejs->nullValue;
    }
    return ejsDeserialize(ejs, (EjsString*) result);
}


/*
    function eval(script: String, timeout: Boolean = -1): String
 */
static EjsObj *workerEval(Ejs *ejs, EjsWorker *worker, int argc, EjsObj **argv)
{
    int     timeout;

    mprAssert(ejsIsString(argv[0]));

    worker->scriptLiteral = mprStrdup(worker, ejsGetString(ejs, argv[0]));
    timeout = argc == 2 ? ejsGetInt(ejs, argv[1]): MAXINT;
    return startWorker(ejs, worker, timeout);
}


/*
    static function exit()
 */
static EjsObj *workerExit(Ejs *ejs, EjsWorker *unused, int argc, EjsObj **argv)
{
    ejs->exiting = 1;
    ejsAttention(ejs);
    return 0;
}


/*
    Return true if the join is successful
 */
static int reapJoins(Ejs *ejs, EjsObj *workers)
{
    EjsWorker   *worker;
    EjsArray    *set;
    int         i, completed;

    lock(ejs);
    if (workers == 0 || workers == ejs->nullValue) {
        /* Join all */
        completed = 0;
        for (i = 0; i < mprGetListCount(ejs->workers); i++) {
            worker = mprGetItem(ejs->workers, i);
            if (worker->state >= EJS_WORKER_COMPLETE) {
                completed++;
            }
        }
        if (completed == mprGetListCount(ejs->workers)) {
            unlock(ejs);
            return 1;
        }
    } else if (ejsIsArray(workers)) {
        /* Join a set */
        set = (EjsArray*) workers;
        for (i = 0; i < set->length; i++) {
            worker = (EjsWorker*) set->data[i];
            if (worker->state < EJS_WORKER_COMPLETE) {
                break;
            }
        }
        if (i >= set->length) {
            unlock(ejs);
            return 1;
        }
    } else if (workers->type == ejs->workerType) {
        /* Join one worker */
        worker = (EjsWorker*) workers;
        if (worker->state >= EJS_WORKER_COMPLETE) {
            unlock(ejs);
            return 1;
        }
    }
    unlock(ejs);
    return 0;
}


static int join(Ejs *ejs, EjsObj *workers, int timeout)
{
    MprTime     mark;
    int         result, remaining;

    LOG(ejs, 5, "Worker.join: joining %d", ejs->joining);

    mark = mprGetTime(ejs);
    remaining = timeout;
    do {
        ejs->joining = !reapJoins(ejs, workers);
        if (!ejs->joining) {
            break;
        }
        ejsServiceEvents(ejs, remaining, MPR_SERVICE_ONE_THING);
        remaining = (int) mprGetRemainingTime(ejs, mark, timeout);
    } while (remaining > 0 && !ejs->exception);

    if (ejs->exception) {
        return 0;
    }
    result = (ejs->joining) ? MPR_ERR_TIMEOUT: 0;
    ejs->joining = 0;
    LOG(ejs, 5, "Worker.join: result %d", result);
    return result;
}


/*
    static function join(workers: Object = null, timeout: Number = -1): Boolean
 */
static EjsObj *workerJoin(Ejs *ejs, EjsWorker *unused, int argc, EjsObj **argv)
{
    EjsObj      *workers;
    int         timeout;

    workers = (argc > 0) ? argv[0] : NULL;
    timeout = (argc == 2) ? ejsGetInt(ejs, argv[1]) : MAXINT;

    return (join(ejs, workers, timeout) == 0) ? (EjsObj*) ejs->trueValue: (EjsObj*) ejs->falseValue;
}


/*
    Load a file into the worker. This can be a script file or a module. This runs on the inside interpreter
 */
static void loadFile(EjsWorker *worker, cchar *path)
{
    Ejs         *ejs;
    EjsObj      *result;
    cchar       *cp;

    mprAssert(worker->inside);
    mprAssert(worker->pair && worker->pair->ejs);

    ejs = worker->ejs;
    result = 0;

    if ((cp = strrchr(path, '.')) != NULL && strcmp(cp, EJS_MODULE_EXT) != 0) {
        if (ejs->service->loadScriptFile == 0) {
            ejsThrowIOError(ejs, "load: Compiling is not enabled for %s", path);
            return;
        }
        (ejs->service->loadScriptFile)(ejs, path, NULL);

    } else {
        /* Error reporting via thrown exceptions */
        ejsLoadModule(ejs, path, -1, -1, 0);
    }
}


/*
    function load(script: Path, timeout: Number = 0): Void
 */
static EjsObj *workerLoad(Ejs *ejs, EjsWorker *worker, int argc, EjsObj **argv)
{
    int     timeout;

    mprAssert(argc == 0 || ejsIsPath(ejs, argv[0]));

    worker->scriptFile = mprStrdup(worker, ((EjsPath*) argv[0])->path);
    timeout = argc == 2 ? ejsGetInt(ejs, argv[1]): 0;
    return startWorker(ejs, worker, timeout);
}


/*
    static function lookup(name: String): Worker
 */
static EjsObj *workerLookup(Ejs *ejs, EjsObj *unused, int argc, EjsObj **argv)
{
    EjsWorker   *worker;
    cchar       *name;
    int         next;

    name = ejsGetString(ejs, argv[0]);
    lock(ejs);
    for (next = 0; (worker = mprGetNextItem(ejs->workers, &next)) != NULL; ) {
        if (worker->name && strcmp(name, worker->name) == 0) {
            unlock(ejs);
            return (EjsObj*) worker;
        }
    }
    unlock(ejs);
    return ejs->nullValue;
}


/*
    Process a message sent from postMessage. This may run inside the worker or outside in the parent depending on the
    direction of the message. But it ALWAYS runs in the appropriate thread for the interpreter.
 */
static int doMessage(Message *msg, MprEvent *mprEvent)
{
    Ejs         *ejs;
    EjsObj      *event;
    EjsWorker   *worker;
    EjsFunction *callback;
    EjsObj      *argv[1];

    worker = msg->worker;
    worker->gotMessage = 1;
    ejs = worker->ejs;

    callback = (EjsFunction*) ejsGetProperty(ejs, (EjsObj*) worker, msg->callbackSlot);

    switch (msg->callbackSlot) {
    case ES_Worker_onclose:
        event = ejsCreate(ejs, ejs->eventType, 0);
        break;
    case ES_Worker_onerror:
        event = ejsCreate(ejs, ejs->errorEventType, 0);
        break;
    case ES_Worker_onmessage:
        event = ejsCreate(ejs, ejs->eventType, 0);
        break;
    default:
        mprAssert(msg->callbackSlot == 0);
        mprFree(mprEvent);
        return 0;
    }
    if (msg->data) {
        ejsSetProperty(ejs, event, ES_Event_data, (EjsObj*) ejsCreateStringAndFree(ejs, msg->data));
    }
    if (msg->message) {
        ejsSetProperty(ejs, event, ES_ErrorEvent_message, (EjsObj*) ejsCreateStringAndFree(ejs, msg->message));
    }
    if (msg->filename) {
        ejsSetProperty(ejs, event, ES_ErrorEvent_filename, (EjsObj*) ejsCreateStringAndFree(ejs, msg->filename));
        ejsSetProperty(ejs, event, ES_ErrorEvent_lineno, (EjsObj*) ejsCreateNumber(ejs, msg->lineNumber));
    }
    if (msg->stack) {
        ejsSetProperty(ejs, event, ES_ErrorEvent_stack, (EjsObj*) ejsCreateStringAndFree(ejs, msg->stack));
    }

    if (callback == 0 || (EjsObj*) callback == ejs->nullValue) {
        if (msg->callbackSlot == ES_Worker_onmessage) {
            mprLog(ejs, 1, "Discard message as no onmessage handler defined for worker");
            
        } else if (msg->callbackSlot == ES_Worker_onerror) {
            ejsThrowError(ejs, "Exception in Worker: %s", ejsGetErrorMsg(worker->pair->ejs, 1));

        } else {
            /* Ignore onclose message */
        }

    } else if (!ejsIsFunction(callback)) {
        ejsThrowTypeError(ejs, "Worker callback %s is not a function", msg->callback);

    } else {
        argv[0] = event;
        ejsRunFunction(ejs, callback, (EjsObj*) worker, 1, argv);
    }
    if (msg->callbackSlot == ES_Worker_onclose) {
        mprAssert(!worker->inside);
        worker->state = EJS_WORKER_COMPLETE;
        LOG(ejs, 5, "Worker.doMessage: complete");
        removeWorker(ejs, worker);
        /*
            Now that the inside worker is complete, the outside worker does not need to be protected from GC
         */
        worker->obj.permanent = 0;
    }
    mprFree(msg);
    mprFree(mprEvent);
    return 0;
}


/*
    function preeval(script: String): String
    NOTE: this blocks. 
 */
static EjsObj *workerPreeval(Ejs *ejs, EjsWorker *worker, int argc, EjsObj **argv)
{
    Ejs         *inside;
    EjsWorker   *insideWorker;
    EjsObj      *result;

    mprAssert(!worker->inside);

    if (worker->state > EJS_WORKER_BEGIN) {
        ejsThrowStateError(ejs, "Worker has already started");
        return 0;
    }
    insideWorker = worker->pair;
    mprAssert(insideWorker->inside);
    inside = insideWorker->ejs;

    (inside->service->loadScriptLiteral)(inside, ejsGetString(ejs, argv[0]), NULL);
    if (inside->exception) {
        handleError(ejs, worker, inside->exception);
        return 0;
    }
    result = (EjsObj*) ejsToJSON(ejs, inside->result, NULL);
    if (result == 0) {
        return ejs->nullValue;
    }
    return ejsDeserialize(ejs, (EjsString*) result);
}


/*
    function preload(path: Path): String
    NOTE: this blocks. 
 */
static EjsObj *workerPreload(Ejs *ejs, EjsWorker *worker, int argc, EjsObj **argv)
{
    Ejs         *inside;
    EjsWorker   *insideWorker;
    EjsObj      *result;

    mprAssert(argc > 0 && ejsIsPath(ejs, argv[0]));
    mprAssert(!worker->inside);

    if (worker->state > EJS_WORKER_BEGIN) {
        ejsThrowStateError(ejs, "Worker has already started");
        return 0;
    }
    insideWorker = worker->pair;
    mprAssert(insideWorker->inside);
    inside = insideWorker->ejs;

    loadFile(worker->pair, ((EjsPath*) argv[0])->path);
    if (inside->exception) {
        handleError(ejs, worker, inside->exception);
        return 0;
    }
    result = (EjsObj*) ejsToJSON(ejs, inside->result, NULL);
    if (result == 0) {
        return ejs->nullValue;
    }
    return ejsDeserialize(ejs, (EjsString*) result);
}


/*
    Post a message to this worker. Note: the worker is the destination worker which may be the parent.
 *
    function postMessage(data: Object, ports: Array = null): Void
 */
static EjsObj *workerPostMessage(Ejs *ejs, EjsWorker *worker, int argc, EjsObj **argv)
{
    EjsObj          *data;
    EjsWorker       *target;
    MprDispatcher   *dispatcher;
    Message         *msg;

    if (worker->state >= EJS_WORKER_CLOSED) {
        ejsThrowStateError(ejs, "Worker has completed");
        return 0;
    }
    /*
        Create the event with serialized data in the originating interpreter. It owns the data.
     */
    if ((data = (EjsObj*) ejsToJSON(ejs, argv[0], NULL)) == 0) {
        ejsThrowArgError(ejs, "Can't serialize message data");
        return 0;
    }
    if ((msg = mprAllocObjZeroed(ejs, Message)) == 0) {
        ejsThrowMemoryError(ejs);
        return 0;
    }
    target = worker->pair;
    msg->data = mprStrdup(target->ejs, ejsGetString(ejs, data));
    msg->worker = target;
    msg->callback = "onmessage";
    msg->callbackSlot = ES_Worker_onmessage;

    dispatcher = target->ejs->dispatcher;
    mprCreateEvent(dispatcher, "postMessage", 0, (MprEventProc) doMessage, msg, 0);
    return 0;
}


/*
    Worker thread main procedure. Worker is the inside worker.
 */
static int workerMain(EjsWorker *insideWorker, MprEvent *event)
{
    Ejs             *outside, *inside;
    EjsWorker       *outsideWorker;
    MprDispatcher   *dispatcher;
    Message         *msg;

    mprAssert(insideWorker->inside);
    outsideWorker = insideWorker->pair;
    mprAssert(!outsideWorker->inside);
    mprAssert(insideWorker->state == EJS_WORKER_BEGIN);

    outside = outsideWorker->ejs;
    inside = insideWorker->ejs;
    insideWorker->state = EJS_WORKER_STARTED;
    
    /*
        Run the script or file
     */
    if (outsideWorker->scriptFile) {
        loadFile(insideWorker, outsideWorker->scriptFile);

    } else if (outsideWorker->scriptLiteral) {
        if (outside->service->loadScriptLiteral == 0) {
            ejsThrowIOError(outside, "worker: Compiling is not enabled");
            return 0;
        }
        (outside->service->loadScriptLiteral)(inside, outsideWorker->scriptLiteral, NULL);
    }
    /*
        Check for exceptions
     */
    if (inside->exception) {
        handleError(outside, outsideWorker, inside->exception);
        inside->exception = 0;
    }
    if ((msg = mprAllocObjZeroed(outside, Message)) == 0) {
        ejsThrowMemoryError(outside);
        return 0;
    }

    /*
        Post "onclose" finalization message
     */
    msg->worker = outsideWorker;
    msg->callback = "onclose";
    msg->callbackSlot = ES_Worker_onclose;

    insideWorker->state = EJS_WORKER_CLOSED;
    outsideWorker->state = EJS_WORKER_CLOSED;
    insideWorker->obj.permanent = 0;
    dispatcher = outside->dispatcher;
    mprCreateEvent(dispatcher, "doMessage", 0, (MprEventProc) doMessage, msg, 0);
    return 0;
}


/*
    function terminate()
 */
static EjsObj *workerTerminate(Ejs *ejs, EjsWorker *worker, int argc, EjsObj **argv)
{    
    if (worker->state == EJS_WORKER_BEGIN) {
        ejsThrowStateError(ejs, "Worker has not yet started");
        return 0;
    }
    if (worker->state >= EJS_WORKER_COMPLETE) {
        return 0;
    }
  
    /*
        Switch to the inside worker if called from outside
     */
    mprAssert(worker->pair && worker->pair->ejs);
    ejs = (!worker->inside) ? worker->pair->ejs : ejs;
    worker->terminated = 1;
    ejs->exiting = 1;
    mprWakeWaitService(ejs);
    return 0;
}


/*
    function waitForMessage(timeout: Number = -1): Boolean
 */
static EjsObj *workerWaitForMessage(Ejs *ejs, EjsWorker *worker, int argc, EjsObj **argv)
{
    MprTime     mark;
    int         remaining, timeout;

    timeout = (argc > 0) ? ejsGetInt(ejs, argv[0]): MAXINT;
    if (timeout < 0) {
        timeout = MAXINT;
    }
    mark = mprGetTime(ejs);
    remaining = timeout;

    worker->gotMessage = 0;
    do {
        ejsServiceEvents(ejs, remaining, MPR_SERVICE_ONE_THING);
        remaining = (int) mprGetRemainingTime(ejs, mark, timeout);
    } while (!worker->gotMessage && remaining > 0 && !ejs->exception);

    if (worker->gotMessage) {
        worker->gotMessage = 0;
        return (EjsObj*) ejs->trueValue;
    } else {
        return (EjsObj*) ejs->trueValue;
    }
}


/*
    WARNING: the inside interpreter owns the exception object. Must fully extract all fields
 */
static void handleError(Ejs *ejs, EjsWorker *worker, EjsObj *exception)
{
    EjsError        *error;
    MprDispatcher   *dispatcher;
    Message         *msg;

    mprAssert(!worker->inside);
    mprAssert(exception);
    mprAssert(ejs == worker->ejs);

    if ((msg = mprAllocObjZeroed(ejs, Message)) == 0) {
        ejsThrowMemoryError(ejs);
        return;
    }
    msg->worker = worker;
    msg->callback = "onerror";
    msg->callbackSlot = ES_Worker_onerror;
    
    /*
        Inside interpreter owns the exception object, so must fully extract all exception. 
        Allocate into the outside worker's interpreter.
     */
    if (ejsIsError(exception)) {
        error = (EjsError*) exception;
        msg->message = mprStrdup(ejs, error->message);
        msg->filename = mprStrdup(ejs, error->filename ? error->filename : "script");
        msg->lineNumber = error->lineNumber;
        msg->stack = mprStrdup(ejs, error->stack);

    } else if (ejsIsString(exception)) {
        msg->message = mprStrdup(ejs, ejsGetString(ejs, exception));

    } else {
        msg->message = mprStrdup(ejs, ejsGetString(ejs, (EjsObj*) ejsToString(ejs, exception)));
    }
    dispatcher = ejs->dispatcher;
    mprCreateEvent(dispatcher, "doMessage-error", 0, (MprEventProc) doMessage, msg, 0);
}


EjsWorker *ejsCreateWorker(Ejs *ejs)
{
    return (EjsWorker*) ejsCreate(ejs, ejs->workerType, 0);
}


static void destroyWorker(Ejs *ejs, EjsWorker *worker)
{
    if (!worker->inside) {
        removeWorker(ejs, worker);
        mprAssert(worker->pair);
        mprFree(worker->pair->ejs);
        worker->pair = 0;
    }
    ejsFree(ejs, (EjsObj*) worker, -1);
}


static void markWorker(Ejs *ejs, EjsWorker *worker)
{
    ejsMarkObject(ejs, (EjsObj*) worker);
}


void ejsConfigureWorkerType(Ejs *ejs)
{
    EjsType     *type;

    type = ejs->workerType = ejsConfigureNativeType(ejs, EJS_EJS_NAMESPACE, "Worker", sizeof(EjsWorker));
    type->needFinalize = 1;

    type->helpers = ejsCloneObjectHelpers(ejs, "worker-helpers");
    type->helpers->destroy = (EjsDestroyHelper) destroyWorker;
    type->helpers->mark = (EjsMarkHelper) markWorker;

    ejsBindMethod(ejs, type, ES_Worker_Worker, (EjsProc) workerConstructor);
    ejsBindMethod(ejs, type, ES_Worker_eval, (EjsProc) workerEval);
    ejsBindMethod(ejs, type, ES_Worker_exit, (EjsProc) workerExit);
    ejsBindMethod(ejs, type, ES_Worker_join, (EjsProc) workerJoin);
    ejsBindMethod(ejs, type, ES_Worker_load, (EjsProc) workerLoad);
    ejsBindMethod(ejs, type, ES_Worker_lookup, (EjsProc) workerLookup);
    ejsBindMethod(ejs, type, ES_Worker_preload, (EjsProc) workerPreload);
    ejsBindMethod(ejs, type, ES_Worker_preeval, (EjsProc) workerPreeval);
    ejsBindMethod(ejs, type, ES_Worker_postMessage, (EjsProc) workerPostMessage);
    ejsBindMethod(ejs, type, ES_Worker_terminate, (EjsProc) workerTerminate);
    ejsBindMethod(ejs, type, ES_Worker_waitForMessage, (EjsProc) workerWaitForMessage);
}

/*
    @copy   default
    
    Copyright (c) Embedthis Software LLC, 2003-2010. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2010. All Rights Reserved.
    
    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire 
    a commercial license from Embedthis Software. You agree to be fully bound 
    by the terms of either license. Consult the LICENSE.TXT distributed with 
    this software for full details.
    
    This software is open source; you can redistribute it and/or modify it 
    under the terms of the GNU General Public License as published by the 
    Free Software Foundation; either version 2 of the License, or (at your 
    option) any later version. See the GNU General Public License for more 
    details at: http://www.embedthis.com/downloads/gplLicense.html
    
    This program is distributed WITHOUT ANY WARRANTY; without even the 
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
    
    This GPL license does NOT permit incorporating this software into 
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses 
    for this software and support services are available from Embedthis 
    Software at http://www.embedthis.com 
    
    @end
 */

/************************************************************************/
/*
 *  End of file "../src/core/src/ejsWorker.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../src/core/src/ejsXML.c"
 */
/************************************************************************/

/**
    ejsXML.c - XML type.

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */



/*
    XML methods
 */
static EjsObj   *loadXml(Ejs *ejs, EjsXML *xml, int argc, EjsObj **argv);
static EjsObj   *saveXml(Ejs *ejs, EjsXML *xml, int argc, EjsObj **argv);
static EjsObj   *xmlToString(Ejs *ejs, EjsObj *vp, int argc, EjsObj **argv);

#if KEEP
static EjsObj   *valueOf(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv);
static EjsObj   *toXmlString(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv);
static EjsObj   *appendChild(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv);
static EjsObj   *attributes(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv);
static EjsObj   *child(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv);
static EjsObj   *elements(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv);
static EjsObj   *comments(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv);
static EjsObj   *decendants(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv);
static EjsObj   *elements(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv);
static EjsObj   *insertChildAfter(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv);
static EjsObj   *insertChildBefore(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv);
static EjsObj   *replace(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv);
static EjsObj   *setName(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv);
static EjsObj   *text(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv);

#endif

static bool allDigitsForXml(cchar *name);
static bool deepCompare(EjsXML *lhs, EjsXML *rhs);
static int readStringData(MprXml *xp, void *data, char *buf, int size);
static int readFileData(MprXml *xp, void *data, char *buf, int size);


static EjsXML *createXml(Ejs *ejs, EjsType *type, int size)
{
    return (EjsXML*) ejsCreateXML(ejs, 0, NULL, NULL, NULL);
}


//  TODO - can remove this
static void destroyXml(Ejs *ejs, EjsXML *xml)
{
    ejsFree(ejs, (EjsObj*) xml, -1);
}


static EjsObj *cloneXml(Ejs *ejs, EjsXML *xml, bool deep)
{
    EjsXML  *newXML;

    newXML = (EjsXML*) ejsCreate(ejs, xml->obj.type, 0);
    if (newXML == 0) {
        ejsThrowMemoryError(ejs);
        return 0;
    }
    return (EjsObj*) newXML;
}


/*
    Cast the object operand to a primitive type
 */
static EjsObj *castXml(Ejs *ejs, EjsXML *xml, EjsType *type)
{
    EjsXML      *item;
    EjsObj      *result;
    MprBuf      *buf;

    mprAssert(ejsIsXML(ejs, xml));

    if (type == ejs->xmlListType) {
        return (EjsObj*) xml;
    }

    switch (type->id) {
    case ES_Object:

    case ES_Boolean:
        return (EjsObj*) ejsCreateBoolean(ejs, 1);

    case ES_Number:
        result = castXml(ejs, xml, ejs->stringType);
        result = (EjsObj*) ejsToNumber(ejs, result);
        return result;

    case ES_String:
        if (xml->kind == EJS_XML_ELEMENT) {
            if (xml->elements == 0) {
                return (EjsObj*) ejs->emptyStringValue;
            }
            if (xml->elements && mprGetListCount(xml->elements) == 1) {
                //  TODO - what about PI and comments?
                item = mprGetFirstItem(xml->elements);
                if (item->kind == EJS_XML_TEXT) {
                    return (EjsObj*) ejsCreateString(ejs, item->value);
                }
            }
        }
        buf = mprCreateBuf(ejs, MPR_BUFSIZE, -1);
        if (ejsXMLToString(ejs, buf, xml, -1) < 0) {
            mprFree(buf);
            return 0;
        }
        result = (EjsObj*) ejsCreateString(ejs, (char*) buf->start);
        mprFree(buf);
        return result;

    default:
        ejsThrowTypeError(ejs, "Can't cast to this type");
        return 0;
    }
    return 0;
}


static int deleteXmlPropertyByName(Ejs *ejs, EjsXML *xml, EjsName *qname)
{
    EjsXML      *item;
    bool        removed;
    int         next;

    removed = 0;

    if (qname->name[0] == '@') {
        /* @ and @* */
        if (xml->attributes) {
            for (next = 0; (item = mprGetNextItem(xml->attributes, &next)) != 0; ) {
                mprAssert(qname->name[0] == '@');
                if (qname->name[1] == '*' || strcmp(item->qname.name, &qname->name[1]) == 0) {
                    mprRemoveItemAtPos(xml->attributes, next - 1);
                    item->parent = 0;
                    removed = 1;
                    next -= 1;
                }
            }
        }

    } else {
        /* name and   */
        if (xml->elements) {
            for (next = 0; (item = mprGetNextItem(xml->elements, &next)) != 0; ) {
                mprAssert(item->qname.name);
                if (qname->name[0] == '*' || strcmp(item->qname.name, qname->name) == 0) {
                    mprRemoveItemAtPos(xml->elements, next - 1);
                    item->parent = 0;
                    removed = 1;
                    next -= 1;
                }
            }
        }
    }
    return (removed) ? 0 : EJS_ERR;
}


static EjsObj *getXmlNodeName(Ejs *ejs, EjsXML *xml, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateString(ejs, xml->qname.name);
}



/*
    Function to iterate and return the next element name.
    NOTE: this is not a method of Xml. Rather, it is a callback function for Iterator
 */
static EjsObj *nextXmlKey(Ejs *ejs, EjsIterator *ip, int argc, EjsObj **argv)
{
    EjsXML  *xml;

    xml = (EjsXML*) ip->target;
    if (!ejsIsXML(ejs, xml)) {
        ejsThrowReferenceError(ejs, "Wrong type");
        return 0;
    }

    for (; ip->index < mprGetListCount(xml->elements); ip->index++) {
        return (EjsObj*) ejsCreateNumber(ejs, ip->index++);
    }
    ejsThrowStopIteration(ejs);
    return 0;
}


/*
    Return the default iterator. This returns the array index names.

    iterator native function get(): Iterator
 */
static EjsObj *getXmlIterator(Ejs *ejs, EjsObj *xml, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateIterator(ejs, xml, (EjsProc) nextXmlKey, 0, NULL);
}


/*
    Function to iterate and return the next element value.
    NOTE: this is not a method of Xml. Rather, it is a callback function for Iterator
 */
static EjsObj *nextXmlValue(Ejs *ejs, EjsIterator *ip, int argc, EjsObj **argv)
{
    EjsXML      *xml, *vp;

    xml = (EjsXML*) ip->target;
    if (!ejsIsXML(ejs, xml)) {
        ejsThrowReferenceError(ejs, "Wrong type");
        return 0;
    }

    for (; ip->index < mprGetListCount(xml->elements); ip->index++) {
        vp = (EjsXML*) mprGetItem(xml->elements, ip->index);
        if (vp == 0) {
            continue;
        }
        ip->index++;
        return (EjsObj*) vp;
    }
    ejsThrowStopIteration(ejs);
    return 0;
}


/*
    Return an iterator to return the next array element value.

    iterator native function getValues(): Iterator
 */
static EjsObj *getXmlValues(Ejs *ejs, EjsObj *ap, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateIterator(ejs, ap, (EjsProc) nextXmlValue, 0, NULL);
}


static int getXmlPropertyCount(Ejs *ejs, EjsXML *xml)
{
    return mprGetListCount(xml->elements);
}


/*
    Lookup a property by name. There are 7 kinds of lookups:
         prop, @att, [prop], *, @*, .name, .@name
 */
static EjsObj *getXmlPropertyByName(Ejs *ejs, EjsXML *xml, EjsName *qname)
{
    EjsXML      *item, *result, *list;
    int         next, nextList;

    result = 0;

    mprAssert(xml->kind < 5);
    if (isdigit((int) qname->name[0]) && allDigitsForXml(qname->name)) {
        /*
            Consider xml as a list with only one entry == xml. Then return the 0'th entry
         */
        return (EjsObj*) xml;
    }

    if (qname->name[0] == '@') {
        /* @ and @* */
        result = ejsCreateXMLList(ejs, xml, qname);
        if (xml->attributes) {
            for (next = 0; (item = mprGetNextItem(xml->attributes, &next)) != 0; ) {
                mprAssert(qname->name[0] == '@');
                if (qname->name[1] == '*' || strcmp(item->qname.name, &qname->name[1]) == 0) {
                    result = ejsAppendToXML(ejs, result, item);
                }
            }
        }

    } else if (qname->name[0] == '.') {
        /* Decenders (do ..@ also) */
        result = ejsXMLDescendants(ejs, xml, qname);

    } else {
        /* name and   */
        result = ejsCreateXMLList(ejs, xml, qname);
        if (xml->elements) {
            for (next = 0; (item = mprGetNextItem(xml->elements, &next)) != 0; ) {
                if (item->kind == EJS_XML_LIST) {
                    list = item;
                    for (nextList = 0; (item = mprGetNextItem(list->elements, &nextList)) != 0; ) {
                        mprAssert(item->qname.name);
                        if (qname->name[0] == '*' || strcmp(item->qname.name, qname->name) == 0) {
                            result = ejsAppendToXML(ejs, result, item);
                        }
                    }

                } else if (item->qname.name) {
                    mprAssert(item->qname.name);
                    if (qname->name[0] == '*' || strcmp(item->qname.name, qname->name) == 0) {
                        result = ejsAppendToXML(ejs, result, item);
                    }
                }
            }
        }
    }
    return (EjsObj*) result;
}


static EjsObj *invokeXmlOperator(Ejs *ejs, EjsXML *lhs, int opcode,  EjsXML *rhs)
{
    EjsObj      *result;

    if ((result = ejsCoerceOperands(ejs, (EjsObj*) lhs, opcode, (EjsObj*) rhs)) != 0) {
        return result;
    }

    switch (opcode) {
    case EJS_OP_COMPARE_EQ:
        return (EjsObj*) ejsCreateBoolean(ejs, deepCompare(lhs, rhs));

    case EJS_OP_COMPARE_NE:
        return (EjsObj*) ejsCreateBoolean(ejs, !deepCompare(lhs, rhs));

    default:
        return ejsObjectOperator(ejs, (EjsObj*) lhs, opcode, (EjsObj*) rhs);
    }
}


/*
    Set a property attribute by name.
 */
static int setXmlPropertyAttributeByName(Ejs *ejs, EjsXML *xml, EjsName *qname, EjsObj *value)
{
    EjsXML      *elt, *attribute, *rp, *xvalue, *lastElt;
    EjsString   *sv;
    EjsName     qn;
    char        *str;
    int         index, last, next;

    /*
        Attribute. If the value is an XML list, convert to a space separated string
     */
    xvalue = (EjsXML*) value;
    if (ejsIsXML(ejs, xvalue) && xvalue->kind == EJS_XML_LIST) {
        str = 0;
        for (next = 0; (elt = mprGetNextItem(xvalue->elements, &next)) != 0; ) {
            sv = (EjsString*) ejsCast(ejs, (EjsObj*) elt, ejs->stringType);
            str = mprReallocStrcat(ejs, -1, str, " ", sv->value, NULL);
        }
        value = (EjsObj*) ejsCreateString(ejs, str);
        mprFree(str);

    } else {
        value = ejsCast(ejs, value, ejs->stringType);
    }
    mprAssert(ejsIsString(value));

    /*
        Find the first attribute that matches. Delete all other attributes of the same name.
     */
    index = 0;
    if (xml->attributes) {
        lastElt = 0;
        for (last = -1, index = -1; (elt = mprGetPrevItem(xml->attributes, &index)) != 0; ) {
            mprAssert(qname->name[0] == '@');
            if (strcmp(elt->qname.name, &qname->name[1]) == 0) {
                if (last >= 0) {
                    rp = mprGetItem(xml->attributes, last);
                    mprRemoveItemAtPos(xml->attributes, last);
                }
                last = index;
                lastElt = elt;
            }
        }
        if (lastElt) {
            /*
                Found a match. So replace its value
             */
            mprFree(lastElt->value);
            lastElt->value = mprStrdup(lastElt, ((EjsString*) value)->value);
            return last;

        } else {
            index = mprGetListCount(xml->attributes);
        }
    }
    //  TODO - namespace work to do here

    /*
        Not found. Create a new attribute node
     */
    mprAssert(ejsIsString(value));
    ejsName(&qn, 0, &qname->name[1]);
    attribute = ejsCreateXML(ejs, EJS_XML_ATTRIBUTE, &qn, xml, ((EjsString*) value)->value);
    if (xml->attributes == 0) {
        xml->attributes = mprCreateList(xml);
    }
    mprSetItem(xml->attributes, index, attribute);
    return index;
}


/*
    Create a value node. If the value is an XML node already, we are done. Otherwise, cast the value to a string
    and create a text child node containing the string value.
 */
static EjsXML *createValueNode(Ejs *ejs, EjsXML *elt, EjsObj *value)
{
    EjsXML      *text;
    EjsString   *str;

    if (ejsIsXML(ejs, value)) {
        return (EjsXML*) value;
    }

    str = (EjsString*) ejsCast(ejs, value, ejs->stringType);
    if (str == 0) {
        return 0;
    }

    if (mprGetListCount(elt->elements) == 1) {
        /*
            Update an existing text element
         */
        text = mprGetFirstItem(elt->elements);
        if (text->kind == EJS_XML_TEXT) {
            mprFree(text->value);
            text->value = mprStrdup(elt, str->value);
            return elt;
        }
    }

    /*
        Create a new text element
     */
    if (str->value && str->value[0] != '\0') {
        text = ejsCreateXML(ejs, EJS_XML_TEXT, NULL, elt, str->value);
        elt = ejsAppendToXML(ejs, elt, text);
    }
    return elt;
}


void ejsMarkXML(Ejs *ejs, EjsXML *xml)
{
    EjsObj          *item;
    int             next;

    //  MOB -- is this needed?
    ejsMarkObject(ejs, (EjsObj*) xml);

    if (xml->parent && !xml->parent->obj.visited) {
        ejsMark(ejs, (EjsObj*) xml->parent);
    }
    if (xml->targetObject && !xml->targetObject->obj.visited) {
        ejsMark(ejs, (EjsObj*) xml->targetObject);
    }
    for (next = 0; (item = mprGetNextItem(xml->attributes, &next)) != 0; ) {
        ejsMark(ejs, (EjsObj*) item);
    }
    for (next = 0; (item = mprGetNextItem(xml->elements, &next)) != 0; ) {
        ejsMark(ejs, (EjsObj*) item);
    }
    for (next = 0; (item = mprGetNextItem(xml->namespaces, &next)) != 0; ) {
        ejsMark(ejs, (EjsObj*) item);
    }
}


/*
    Set a property by name
    There are 7 kinds of qname's: prop, @att, [prop], *, @*, .name, .@name
 */
static int setXmlPropertyByName(Ejs *ejs, EjsXML *xml, EjsName *qname, EjsObj *value)
{
    EjsXML      *elt, *xvalue, *rp, *lastElt;
    EjsObj      *originalValue;
    int         index, last;

    last = 0;
    lastElt = 0;

    mprLog(ejs, 9, "XMLSet %s.%s = \"%s\"", xml->qname.name, qname->name,
        ((EjsString*) ejsCast(ejs, value, ejs->stringType))->value);

    if (isdigit((int) qname->name[0]) && allDigitsForXml(qname->name)) {
        ejsThrowTypeError(ejs, "Integer indicies for set are not allowed");
        return EJS_ERR;
    }

    if (xml->kind != EJS_XML_ELEMENT) {
        //  TODO spec requires this -- but why? -- surely throw?
        return 0;
    }

    /*
        Massage the value type.
     */
    originalValue = value;

    xvalue = (EjsXML*) value;
    if (ejsIsXML(ejs, xvalue)) {
        if (xvalue->kind == EJS_XML_LIST) {
            value = (EjsObj*) ejsDeepCopyXML(ejs, xvalue);

        } else if (xvalue->kind == EJS_XML_TEXT || xvalue->kind == EJS_XML_ATTRIBUTE) {
            value = ejsCast(ejs, originalValue, ejs->stringType);

        } else {
            value = (EjsObj*) ejsDeepCopyXML(ejs, xvalue);
        }

    } else {
        value = ejsCast(ejs, value, ejs->stringType);
    }

    if (qname->name[0] == '@') {
        return setXmlPropertyAttributeByName(ejs, xml, qname, value);
    }

    /*
        Delete redundant elements by the same name.
     */
    if (xml->elements) {
        for (last = -1, index = -1; (elt = mprGetPrevItem(xml->elements, &index)) != 0; ) {
            if (qname->name[0] == '*' || (elt->kind == EJS_XML_ELEMENT && strcmp(elt->qname.name, qname->name) == 0)) {
                /*
                    Must remove all redundant elements of the same name except the first one
                 */
                if (last >= 0) {
                    rp = mprGetItem(xml->elements, last);
                    rp->parent = 0;
                    mprRemoveItemAtPos(xml->elements, last);
                }
                last = index;
                lastElt = elt;
            }
        }
    }

    if (xml->elements == 0) {
        //  TODO - need routine to do this centrally so we can control the default number of elements in the list?
        xml->elements = mprCreateList(xml);
    }

    elt = lastElt;
    index = last;

    if (qname->name[0] == '*') {
        /*
            Special case when called from XMLList to update the value of an element
         */
        xml = createValueNode(ejs, xml, value);

    } else if (elt == 0) {
        /*
            Not found. New node required.
         */
        elt = ejsCreateXML(ejs, EJS_XML_ELEMENT, qname, xml, NULL);
        if (elt == 0) {
            return 0;
        }
        index = mprGetListCount(xml->elements);
        xml = ejsAppendToXML(ejs, xml, createValueNode(ejs, elt, value));

    } else {
        /*
            Update existing element.
         */
        xml = ejsSetXML(ejs, xml, index, createValueNode(ejs, elt, value));
    }

    if (xml == 0) {
        return EJS_ERR;
    }
    return index;
}


/*
    Deep compare
 */
static bool deepCompare(EjsXML *lhs, EjsXML *rhs)
{
    EjsXML      *l, *r;
    int         i;

    if (lhs == rhs) {
        return 1;
    }
    //  TODO - must compare all the namespaces?
    if (lhs->kind != rhs->kind) {
        return 0;

    } else  if (mprStrcmp(lhs->qname.name, rhs->qname.name) != 0) {
        return 0;

    } else if (mprGetListCount(lhs->attributes) != mprGetListCount(rhs->attributes)) {
        //  TODO - must compare all the attributes
        return 0;

    } else if (mprGetListCount(lhs->elements) != mprGetListCount(rhs->elements)) {
        //  TODO - must compare all the children
        return 0;

    } else if (mprStrcmp(lhs->value, rhs->value) != 0) {
        return 0;

    } else {
        for (i = 0; i < mprGetListCount(lhs->elements); i++) {
            l = mprGetItem(lhs->elements, i);
            r = mprGetItem(rhs->elements, i);
            if (! deepCompare(l, r)) {
                return 0;
            }
        }
    }
    return 1;
}


//  TODO - rename ejsGetXMLDescendants. Check all other names.
EjsXML *ejsXMLDescendants(Ejs *ejs, EjsXML *xml, EjsName *qname)
{
    EjsXML          *item, *result;
    int             next;

    result = ejsCreateXMLList(ejs, xml, qname);
    if (result == 0) {
        return 0;
    }

    if (qname->name[0] == '@') {
        if (xml->attributes) {
            for (next = 0; (item = mprGetNextItem(xml->attributes, &next)) != 0; ) {
                mprAssert(qname->name[0] == '@');
                if (qname->name[1] == '*' || strcmp(item->qname.name, &qname->name[1]) == 0) {
                    result = ejsAppendToXML(ejs, result, item);
                }
            }
        }

    } else {
        if (xml->elements) {
            for (next = 0; (item = mprGetNextItem(xml->elements, &next)) != 0; ) {
                if (qname->name[0] == '*' || strcmp(item->qname.name, &qname->name[1]) == 0) {
                    result = ejsAppendToXML(ejs, result, item);
                } else {
                    result = ejsAppendToXML(ejs, result, ejsXMLDescendants(ejs, item, qname));
                }
            }
        }
    }
    return result;
}


EjsXML *ejsDeepCopyXML(Ejs *ejs, EjsXML *xml)
{
    EjsXML      *root, *elt;
    int         next;

    if (xml == 0) {
        return 0;
    }

    if (xml->kind == EJS_XML_LIST) {
        root = ejsCreateXMLList(ejs, xml->targetObject, &xml->targetProperty);
    } else {
        root = ejsCreateXML(ejs, xml->kind, &xml->qname, NULL, xml->value);
    }
    if (root == 0) {
        return 0;
    }

    //  TODO - must copy inScopeNamespaces?

    if (xml->attributes) {
        root->attributes = mprCreateList(root);
        for (next = 0; (elt = (EjsXML*) mprGetNextItem(xml->attributes, &next)) != 0; ) {
            elt = ejsDeepCopyXML(ejs, elt);
            if (elt) {
                elt->parent = root;
                mprAddItem(root->attributes, elt);
            }
        }
    }

    if (xml->elements) {
        root->elements = mprCreateList(root);
        for (next = 0; (elt = mprGetNextItem(xml->elements, &next)) != 0; ) {
            mprAssert(ejsIsXML(ejs, elt));
            elt = ejsDeepCopyXML(ejs, elt);
            if (elt) {
                elt->parent = root;
                mprAddItem(root->elements, elt);
            }
        }
    }

    if (mprHasAllocError(ejs)) {
        mprFree(root);
        return 0;
    }
    return root;
}

/*
    native function XML(value: Object = null)
 */
static EjsObj *xmlConstructor(Ejs *ejs, EjsXML *thisObj, int argc, EjsObj **argv)
{
    EjsObj      *arg, *vp;
    cchar       *str;

    //  TODO - should be also able to handle a File object

    if (thisObj == 0) {
        /*
            Called as a function - cast the arg
         */
        if (argc > 0){
            arg = ejsCast(ejs, argv[0], ejs->stringType);
            if (arg == 0) {
                return 0;
            }
        }
        thisObj = ejsCreateXML(ejs, 0, NULL, NULL, NULL);
    }
    if (argc == 0) {
        return (EjsObj*) thisObj;
    }

    arg = argv[0];
    mprAssert(arg);

    if (ejsIsNull(arg) || ejsIsUndefined(arg)) {
        return (EjsObj*) thisObj;
    }
    arg = ejsCast(ejs, argv[0], ejs->stringType);
    if (arg && ejsIsString(arg)) {
        str = ((EjsString*) arg)->value;
        if (str == 0) {
            return 0;
        }
        while (isspace((int) *str)) str++;
        if (*str == '<') {
            /* XML Literal */
            ejsLoadXMLString(ejs, thisObj, str);

        } else {
            /* Load from file */
            loadXml(ejs, thisObj, argc, argv);
        }
    } else if (arg && ejsIsXML(ejs, arg)) {
        if ((vp = xmlToString(ejs, argv[0], 0, NULL)) != 0) {
            ejsLoadXMLString(ejs, thisObj, ejsGetString(ejs, vp));
        }

    } else {
        ejsThrowArgError(ejs, "Bad type passed to XML constructor");
        return 0;
    }
    return (EjsObj*) thisObj;
}


static EjsObj *loadXml(Ejs *ejs, EjsXML *xml, int argc, EjsObj **argv)
{
    MprFile     *file;
    MprXml      *xp;
    cchar       *filename;

    mprAssert(argc == 1 && ejsIsString(argv[0]));

    filename = ejsGetString(ejs, argv[0]);
    file = mprOpen(ejs, filename, O_RDONLY, 0664);
    if (file == 0) {
        ejsThrowIOError(ejs, "Can't open: %s", filename);
        return 0;
    }

    //  TODO - convert to open/close
    xp = ejsCreateXmlParser(ejs, xml, filename);
    if (xp == 0) {
        ejsThrowMemoryError(ejs);
        mprFree(xp);
        mprFree(file);
        return 0;
    }
    mprXmlSetInputStream(xp, readFileData, (void*) file);

    if (mprXmlParse(xp) < 0) {
        if (! ejsHasException(ejs)) {
            ejsThrowIOError(ejs, "Can't parse XML file: %s\nDetails %s",  filename, mprXmlGetErrorMsg(xp));
        }
        mprFree(xp);
        mprFree(file);
        return 0;
    }

    mprFree(xp);
    mprFree(file);
    return 0;
}


static EjsObj *saveXml(Ejs *ejs, EjsXML *xml, int argc, EjsObj **argv)
{
    MprBuf      *buf;
    MprFile     *file;
    cchar       *filename;
    int         bytes, len;

    if (argc != 1 || !ejsIsString(argv[0])) {
        ejsThrowArgError(ejs, "Bad args. Usage: save(filename);");
        return 0;
    }
    filename = ((EjsString*) argv[0])->value;

    /*
        Create a buffer to hold the output. All in memory.
     */
    buf = mprCreateBuf(ejs, MPR_BUFSIZE, -1);
    mprPutStringToBuf(buf, "<?xml version=\"1.0\"?>\n");

    /*
       Convert XML to a string
     */
    if (ejsXMLToString(ejs, buf, xml, 0) < 0) {
        mprFree(buf);
        return 0;
    }

    file = mprOpen(ejs, filename,  O_CREAT | O_TRUNC | O_WRONLY | O_TEXT, 0664);
    if (file == 0) {
        ejsThrowIOError(ejs, "Can't open: %s, %d", filename,  mprGetOsError(ejs));
        return 0;
    }

    len = mprGetBufLength(buf);
    bytes = mprWrite(file, buf->start, len);
    if (bytes != len) {
        ejsThrowIOError(ejs, "Can't write to: %s", filename);
        mprFree(file);
        return 0;
    }
    mprWrite(file, "\n", 1);
    mprFree(buf);
    mprFree(file);
    return 0;
}


/*
    Convert to a JSON string

    override function toJSON(): String
 */
static EjsObj *xmlToJson(Ejs *ejs, EjsObj *vp, int argc, EjsObj **argv)
{
    EjsString       *sp;
    MprBuf          *buf;
    EjsVar          *result;
    cchar           *cp;

    /*
        Quote all quotes
     */
    sp = ejsToString(ejs, vp);
    buf = mprCreateBuf(ejs, -1, -1);
    mprPutCharToBuf(buf, '"');
    for (cp = ejsGetString(ejs, sp); *cp; cp++) {
        if (*cp == '"') {
            mprPutCharToBuf(buf, '\\');
        }
        mprPutCharToBuf(buf, (uchar) *cp);
    }
    mprPutCharToBuf(buf, '"');
    mprAddNullToBuf(buf);
    result = (EjsVar*) ejsCreateStringAndFree(ejs, mprStealBuf(vp, buf));
    mprFree(buf);
    return result;
}


/*
    Convert the XML object to a string.

    intrinsic function toString() : String
 */
static EjsObj *xmlToString(Ejs *ejs, EjsObj *vp, int argc, EjsObj **argv)
{
    return (vp->type->helpers->cast)(ejs, vp, ejs->stringType);
}


/*
    Get the length of an array.
    @return Returns the number of items in the array

    intrinsic public override function get length(): int
 */
static EjsObj *xmlLength(Ejs *ejs, EjsXML *xml, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateNumber(ejs, mprGetListCount(xml->elements));
}


#if KEEP
/*
    Set the length. TODO - what does this do?
    intrinsic public override function set length(value: int): void
 */
static EjsObj *setLength(Ejs *ejs, EjsXML *xml, int argc, EjsObj **argv)
{
    int         length;

    mprAssert(ejsIsXML(ejs, xml));

    if (argc != 1) {
        ejsThrowArgError(ejs, "usage: obj.length = value");
        return 0;
    }
    length = ejsVarToInteger(ejs, argv[0]);

    if (length < ap->length) {
        for (i = length; i < ap->length; i++) {
            if (ejsSetProperty(ejs, (EjsObj*) ap, i, (EjsObj*) ejs->undefinedValue) < 0) {
                //  TODO - DIAG
                return 0;
            }
        }

    } else if (length > ap->length) {
        if (ejsSetProperty(ejs, (EjsObj*) ap, length - 1,  (EjsObj*) ejs->undefinedValue) < 0) {
            //  TODO - DIAG
            return 0;
        }
    }

    ap->length = length;
    return 0;
}
#endif

/*
    Set an indexed element to an XML value
 */
EjsXML *ejsSetXML(Ejs *ejs, EjsXML *xml, int index, EjsXML *node)
{
    EjsXML      *old;

    if (xml == 0 || node == 0) {
        return 0;
    }

    if (xml->elements == 0) {
        xml->elements = mprCreateList(xml);

    } else {
        old = (EjsXML*) mprGetItem(xml->elements, index);
        if (old && old != node) {
            old->parent = 0;
        }
    }

    if (xml->kind != EJS_XML_LIST) {
        node->parent = xml;
    }
    mprSetItem(xml->elements, index, node);
    return xml;
}


#if KEEP
int ejsCopyName(MprCtx ctx, EjsName *to, EjsName *from)
{
/*

    TODO -

    mprFree((char*) to->name);
    mprFree((char*) to->space);

    to->name = mprStrdup(ctx, from->name);
    to->space = mprStrdup(ctx, from->space);
    if (to->name == 0 || to->space == 0) {
        return EJS_ERR;
    }
*/
    *to = *from;
    return 0;
}
#endif


EjsXML *ejsAppendToXML(Ejs *ejs, EjsXML *xml, EjsXML *node)
{
    EjsXML      *elt;
    int         next;

    if (xml == 0 || node == 0) {
        return 0;
    }
    if (xml->elements == 0) {
        xml->elements = mprCreateList(xml);
    }

    if (node->kind == EJS_XML_LIST) {
        for (next = 0; (elt = mprGetNextItem(node->elements, &next)) != 0; ) {
            if (xml->kind != EJS_XML_LIST) {
                elt->parent = xml;
            }
            mprAddItem(xml->elements, elt);
        }
        xml->targetObject = node->targetObject;
        xml->targetProperty = node->targetProperty;

    } else {
        if (xml->kind != EJS_XML_LIST) {
            node->parent = xml;
        }
        mprAddItem(xml->elements, node);
    }
    return xml;
}


int ejsAppendAttributeToXML(Ejs *ejs, EjsXML *parent, EjsXML *node)
{
    if (parent->attributes == 0) {
        parent->attributes = mprCreateList(parent);
    }
    node->parent = parent;
    return mprAddItem(parent->attributes, node);
}


static int readFileData(MprXml *xp, void *data, char *buf, int size)
{
    mprAssert(xp);
    mprAssert(data);
    mprAssert(buf);
    mprAssert(size > 0);

    return mprRead((MprFile*) data, buf, size);
}


static int readStringData(MprXml *xp, void *data, char *buf, int size)
{
    EjsXmlState *parser;
    int         rc, len;

    mprAssert(xp);
    mprAssert(buf);
    mprAssert(size > 0);

    parser = (EjsXmlState*) xp->parseArg;

    if (parser->inputPos < parser->inputSize) {
        len = min(size, (parser->inputSize - parser->inputPos));
        rc = mprMemcpy(buf, size, &parser->inputBuf[parser->inputPos], len);
        parser->inputPos += len;
        return rc;
    }
    return 0;
}


static bool allDigitsForXml(cchar *name)
{
    cchar   *cp;

    for (cp = name; *cp; cp++) {
        if (!isdigit((int) *cp) || *cp == '.') {
            return 0;
        }
    }
    return 1;
}


EjsXML *ejsCreateXML(Ejs *ejs, int kind, EjsName *qname, EjsXML *parent, cchar *value)
{
    EjsXML      *xml;

    xml = (EjsXML*) ejsAlloc(ejs, ejs->xmlType, 0);
    if (xml == 0) {
        return 0;
    }
    if (qname) {
        xml->qname.name = mprStrdup(xml, qname->name);
        xml->qname.space = mprStrdup(xml, qname->space);
    }
    xml->kind = kind;
    xml->parent = parent;
    if (value) {
        xml->value = mprStrdup(xml, value);
    }
    ejsSetDebugName(xml, "XML Node");
    return xml;
}


EjsXML *ejsConfigureXML(Ejs *ejs, EjsXML *xml, int kind, cchar *name, EjsXML *parent, cchar *value)
{
    mprFree((char*) xml->qname.name);
    xml->qname.name = mprStrdup(xml, name);
    xml->kind = kind;
    xml->parent = parent;
    if (value) {
        mprFree(xml->value);
        xml->value = mprStrdup(xml, value);
    }
    return xml;
}


/*
    Support routine. Not an class method
 */
void ejsLoadXMLString(Ejs *ejs, EjsXML *xml, cchar *xmlString)
{
    EjsXmlState *parser;
    MprXml      *xp;

    xp = ejsCreateXmlParser(ejs, xml, "string");
    parser = mprXmlGetParseArg(xp);
    parser->inputBuf = xmlString;
    parser->inputSize = (int) strlen(xmlString);
    mprXmlSetInputStream(xp, readStringData, (void*) 0);

    if (mprXmlParse(xp) < 0 && !ejsHasException(ejs)) {
        ejsThrowSyntaxError(ejs, "Can't parse XML string: %s",  mprXmlGetErrorMsg(xp));
    }
    mprFree(xp);
}


void ejsCreateXMLType(Ejs *ejs)
{
    EjsType     *type;

    type = ejs->xmlType = ejsCreateNativeType(ejs, EJS_EJS_NAMESPACE, "XML", 0, sizeof(EjsXML));

    /*
        Must not bind as XML uses get/setPropertyByName to defer to user XML elements over XML methods
     */
    type->block.nobind = 1;

    type->helpers = ejsCloneObjectHelpers(ejs, "xml-helpers");
    type->helpers->clone = (EjsCloneHelper) cloneXml;
    type->helpers->cast = (EjsCastHelper) castXml;
    type->helpers->create = (EjsCreateHelper) createXml;
    type->helpers->destroy = (EjsDestroyHelper) destroyXml;
    type->helpers->getPropertyByName = (EjsGetPropertyByNameHelper) getXmlPropertyByName;
    type->helpers->getPropertyCount = (EjsGetPropertyCountHelper) getXmlPropertyCount;
    type->helpers->deletePropertyByName = (EjsDeletePropertyByNameHelper) deleteXmlPropertyByName;
    type->helpers->invokeOperator = (EjsInvokeOperatorHelper) invokeXmlOperator;
    type->helpers->mark = (EjsMarkHelper) ejsMarkXML;
    type->helpers->setPropertyByName = (EjsSetPropertyByNameHelper) setXmlPropertyByName;
}


void ejsConfigureXMLType(Ejs *ejs)
{
    EjsType     *type;

    type = ejsGetTypeByName(ejs, EJS_EJS_NAMESPACE, "XML");

    /*
        Define the XML class methods
     */
    ejsBindMethod(ejs, type, ES_XML_XML, (EjsProc) xmlConstructor);
    ejsBindMethod(ejs, type, ES_XML_length, (EjsProc) xmlLength);
    ejsBindMethod(ejs, type, ES_XML_load, (EjsProc) loadXml);
    ejsBindMethod(ejs, type, ES_XML_save, (EjsProc) saveXml);
    ejsBindMethod(ejs, type, ES_XML_name, (EjsProc) getXmlNodeName);

    /*
        Override these methods
     */
    ejsBindMethod(ejs, type, ES_Object_toString, (EjsProc) xmlToString);
    ejsBindMethod(ejs, type, ES_Object_toJSON, (EjsProc) xmlToJson);

    ejsBindMethod(ejs, type, ES_Object_get, getXmlIterator);
    ejsBindMethod(ejs, type, ES_Object_getValues, getXmlValues);

#if FUTURE
    ejsBindMethod(ejs, type, ES_XML_parent, parent);
    ejsBindMethod(ejs, type, "valueOf", valueOf, NULL);
#endif
}


/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2010. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2010. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    @end
 */
/************************************************************************/
/*
 *  End of file "../src/core/src/ejsXML.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../src/core/src/ejsXMLList.c"
 */
/************************************************************************/

/**
    ejsXMLList.c - XMLList type.

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */



/*
    XMLList methods
 */

#if KEEP
static EjsObj   *valueOf(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv);
static EjsObj   *xlLength(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv);
static EjsObj   *toXmlString(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv);
static EjsObj   *appendChild(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv);
static EjsObj   *attributes(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv);
static EjsObj   *child(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv);
static EjsObj   *elements(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv);
static EjsObj   *comments(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv);
static EjsObj   *decendants(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv);
static EjsObj   *elements(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv);
static EjsObj   *insertChildAfter(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv);
static EjsObj   *insertChildBefore(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv);
static EjsObj   *replace(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv);
static EjsObj   *setName(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv);
static EjsObj   *text(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv);

#endif

static bool allDigitsForXmlList(cchar *name);
static EjsXML *resolve(Ejs *ejs, EjsXML *obj);
static EjsXML *shallowCopy(Ejs *ejs, EjsXML *xml);


static EjsXML *createXmlListVar(Ejs *ejs, EjsType *type, int size)
{
    return (EjsXML*) ejsCreateXMLList(ejs, NULL, NULL);
}


//  TODO - can remove this
static void destroyXmlList(Ejs *ejs, EjsXML *list)
{
    ejsFree(ejs, (EjsObj*) list, -1);
}


static EjsObj *cloneXmlList(Ejs *ejs, EjsXML *list, bool deep)
{
    EjsXML  *newList;

    //  TODO - implement deep copy
    newList = (EjsXML*) ejsCreate(ejs, list->obj.type, 0);
    if (newList == 0) {
        ejsThrowMemoryError(ejs);
        return 0;
    }
    //  TODO incomplete
    return (EjsObj*) newList;
}


/*
    Cast the object operand to a primitive type
 */
static EjsObj *xlCast(Ejs *ejs, EjsXML *vp, EjsType *type)
{
    MprBuf      *buf;
    EjsObj      *result;
    EjsXML      *elt, *item;
    int         next;

    if (type == ejs->xmlType) {
        return (EjsObj*) vp;
    }

    switch (type->id) {
    case ES_Object:

    case ES_Boolean:
        return (EjsObj*) ejsCreateBoolean(ejs, 1);

    case ES_Number:
        result = xlCast(ejs, vp, ejs->stringType);
        result = (EjsObj*) ejsToNumber(ejs, result);
        return result;

    case ES_String:
        buf = mprCreateBuf(ejs, MPR_BUFSIZE, -1);
        if (mprGetListCount(vp->elements) == 1) {
            elt = mprGetFirstItem(vp->elements);
            if (elt->kind == EJS_XML_ELEMENT) {
                if (elt->elements == 0) {
                    return (EjsObj*) ejs->emptyStringValue;
                }
                if (elt->elements && mprGetListCount(elt->elements) == 1) {
                    //  TODO - what about PI and comments?
                    item = mprGetFirstItem(elt->elements);
                    if (item->kind == EJS_XML_TEXT) {
                        return (EjsObj*) ejsCreateString(ejs, item->value);
                    }
                }
            }
        }
        for (next = 0; (elt = mprGetNextItem(vp->elements, &next)) != 0; ) {
            if (ejsXMLToString(ejs, buf, elt, -1) < 0) {
                mprFree(buf);
                return 0;
            }
        }
        result = (EjsObj*) ejsCreateString(ejs, (char*) buf->start);
        mprFree(buf);
        return result;

    default:
        ejsThrowTypeError(ejs, "Can't cast to this type");
        return 0;
    }
}


//  TODO - seems the return code for delete should be boolean?

static int deleteXmlListPropertyByName(Ejs *ejs, EjsXML *list, EjsName *qname)
{
    EjsXML      *elt;
    int         index, next;

    if (isdigit((int) qname->name[0]) && allDigitsForXmlList(qname->name)) {
        index = atoi(qname->name);

        elt = (EjsXML*) mprGetItem(list->elements, index);
        if (elt) {
            if (elt->parent) {
                if (elt->kind == EJS_XML_ATTRIBUTE) {
                    ejsDeletePropertyByName(ejs, (EjsObj*) elt->parent, &elt->qname);
                } else {
                    //  TODO - let q be the property of parent where parent[q] == x[i]
                    mprRemoveItem(elt->parent->elements, elt);
                    elt->parent = 0;
                }
            }
        }
        //  Spec says return true even if index is out of range. We return 0 for true and < 0 for false.
        //  TODO - should ejs throw?
        return 0;
    }

    for (next = 0; (elt = mprGetNextItem(list->elements, &next)) != 0; ) {
        if (elt->kind == EJS_XML_ELEMENT /* && elt->parent */) {
            ejsDeletePropertyByName(ejs, (EjsObj*) elt /* TODO was elt->parent */, qname);
        }
    }
    return 0;
}


static int getXmlListPropertyCount(Ejs *ejs, EjsXML *list)
{
    return mprGetListCount(list->elements);
}


/*
    Lookup a property by name. There are 7 kinds of lookups:
         prop, @att, [prop], *, @*, .name, .@name
 */
static EjsObj *getXmlListPropertyByName(Ejs *ejs, EjsXML *list, EjsName *qname)
{
    EjsXML      *result, *subList, *item;
    int         nextItem;

    /*
        Get the n'th item in the list
     */
    if (isdigit((int) qname->name[0]) && allDigitsForXmlList(qname->name)) {
        return mprGetItem(list->elements, atoi(qname->name));
    }

    result = ejsCreateXMLList(ejs, list, qname);

    /*
        Build a list of all the elements that themselves have a property qname.
     */
    for (nextItem = 0; (item = mprGetNextItem(list->elements, &nextItem)) != 0; ) {
        if (item->kind == EJS_XML_ELEMENT) {
            subList = (EjsXML*) ejsGetPropertyByName(ejs, (EjsObj*) item, qname);
            mprAssert(ejsIsXML(ejs, subList));
            ejsAppendToXML(ejs, result, subList);

        } else {
            //  TODO - do we ever get a list in a list?
            mprAssert(0);
        }
    }
    return (EjsObj*) result;
}


static EjsObj *getXmlListNodeName(Ejs *ejs, EjsXML *xml, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateString(ejs, xml->qname.name);
}



/*
    Function to iterate and return the next element name.
    NOTE: this is not a method of Xml. Rather, it is a callback function for Iterator
 */
static EjsObj *nextXmlListKey(Ejs *ejs, EjsIterator *ip, int argc, EjsObj **argv)
{
    EjsXML  *xml;

    xml = (EjsXML*) ip->target;
    if (!ejsIsXML(ejs, xml)) {
        ejsThrowReferenceError(ejs, "Wrong type");
        return 0;
    }

    for (; ip->index < mprGetListCount(xml->elements); ip->index++) {
        return (EjsObj*) ejsCreateNumber(ejs, ip->index++);
    }
    ejsThrowStopIteration(ejs);
    return 0;
}


/*
    Return the default iterator. This returns the array index names.

    iterator native function get(): Iterator
 */
static EjsObj *getXmlListIterator(Ejs *ejs, EjsObj *xml, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateIterator(ejs, xml, (EjsProc) nextXmlListKey, 0, NULL);
}


/*
    Function to iterate and return the next element value.
    NOTE: this is not a method of Xml. Rather, it is a callback function for Iterator
 */
static EjsObj *nextXmlListValue(Ejs *ejs, EjsIterator *ip, int argc, EjsObj **argv)
{
    EjsXML      *xml, *vp;

    xml = (EjsXML*) ip->target;
    if (!ejsIsXML(ejs, xml)) {
        ejsThrowReferenceError(ejs, "Wrong type");
        return 0;
    }

    for (; ip->index < mprGetListCount(xml->elements); ip->index++) {
        vp = (EjsXML*) mprGetItem(xml->elements, ip->index);
        if (vp == 0) {
            continue;
        }
        ip->index++;
        return (EjsObj*) vp;
    }
    ejsThrowStopIteration(ejs);
    return 0;
}


/*
    Return an iterator to return the next array element value.

    iterator native function getValues(): Iterator
 */
static EjsObj *getXmlListValues(Ejs *ejs, EjsObj *ap, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateIterator(ejs, ap, (EjsProc) nextXmlListValue, 0, NULL);
}


#if OLD
/*
    Handle all core operators. We currenly handle only === and !==
    TODO. Must implement: +, -, <, >, <=, >=, ==, ===, !=, !==, &, |
 */
static EjsObj *invokeOperator(Ejs *ejs, EjsXML *lhs, int opCode,  EjsXML *rhs)
{
    EjsObj      *l, *r;
    bool        boolResult;

    mprAssert(ejsIsXML(ejs, lhs));
    mprAssert(ejsIsXML(ejs, rhs));

    //  TODO - Complete
    switch (opCode) {
    case EJS_OP_COMPARE_EQ:
    case EJS_OP_COMPARE_STRICTLY_EQ:
        boolResult = (lhs == rhs);
        break;

    case EJS_OP_COMPARE_NE:
    case EJS_OP_COMPARE_STRICTLY_NE:
        boolResult = !(lhs == rhs);
        break;

    default:
        /*
            Cast to strings and re-invoke
         */
        l = ejsCast(ejs, (EjsObj*) lhs, ejs->stringType);
        r = ejsCast(ejs, (EjsObj*) rhs, ejs->stringType);
        return ejsInvokeOperator(ejs, l, opCode, r);
    }
    return (EjsObj*) ejsCreateBoolean(ejs, boolResult);
}
#endif


/*
    Set an alpha property by name.
 */
static int setAlphaPropertyByName(Ejs *ejs, EjsXML *list, EjsName *qname, EjsObj *value)
{
    EjsXML      *elt, *targetObject;
    int         count;

    targetObject = 0;

    count = ejsGetPropertyCount(ejs, (EjsObj*) list);
    if (count > 1) {
        //  TODO - why no error in spec?
        mprAssert(0);
        return 0;
    }

    if (count == 0) {
        /*
            Empty list so resolve the real target object and append it to the list.
         */
        targetObject = resolve(ejs, list);
        if (targetObject == 0) {
            return 0;
        }
        if (ejsGetPropertyCount(ejs, (EjsObj*) targetObject) != 1) {
            return 0;
        }
        ejsAppendToXML(ejs, list, targetObject);
    }

    /*
        Update the element
     */
    mprAssert(ejsGetPropertyCount(ejs, (EjsObj*) list) == 1);
    elt = mprGetItem(list->elements, 0);                        //  TODO OPT - GetFirstItem
    mprAssert(elt);
    ejsSetPropertyByName(ejs, (EjsObj*) elt, qname, value);
    return 0;
}


static EjsXML *createElement(Ejs *ejs, EjsXML *list, EjsXML *targetObject, EjsName *qname, EjsObj *value)
{
    EjsXML      *elt, *last, *attList;
    int         index;
    int         j;

    if (targetObject && ejsIsXML(ejs, targetObject) && targetObject->kind == EJS_XML_LIST) {

        /*
            If the target is a list it must have 1 element. So switch to it.
            TODO - could we get resolve to do this?
         */
        if (mprGetListCount(targetObject->elements) != 1) {
            /* Spec says so - TODO why no error? */
            return 0;
        }
        targetObject = mprGetFirstItem(targetObject->elements);
    }

    /*
        Return if the target object is not an XML element
     */
    if (!ejsIsXML(ejs, targetObject) || targetObject->kind != EJS_XML_ELEMENT) {
            /* Spec says so - TODO why no error? */
        return 0;
    }

    elt = ejsCreateXML(ejs, EJS_XML_ELEMENT, &list->targetProperty, targetObject, NULL);

    if (list->targetProperty.name && list->targetProperty.name[0] == '@') {
        elt->kind = EJS_XML_ATTRIBUTE;
        attList = (EjsXML*) ejsGetPropertyByName(ejs, (EjsObj*) targetObject, &list->targetProperty);
        if (attList && mprGetListCount(attList->elements) > 0) {
            /* Spec says so. But this surely means you can't update an attribute? */
            return 0;
        }
    } else if (list->targetProperty.name == 0 || qname->name[0] == '*') {
        elt->kind = EJS_XML_TEXT;
        elt->qname.name = 0;
    }

    index = mprGetListCount(list->elements);

    if (elt->kind != EJS_XML_ATTRIBUTE) {
        if (targetObject) {
            if (index > 0) {
                /*
                    Find the place of the last list item in the resolved target object.
                 */
                last = mprGetItem(list->elements, index - 1);
                j = mprLookupItem(targetObject->elements, last);
            } else {
                j = -1;
            } 
            if (j < 0) {
                j = mprGetListCount(targetObject->elements) - 1;
            }
            //  TODO - really need to wrap this ejsInsertXML(EjsXML *xml, int index, EjsXML *node)
            if (targetObject->elements == 0) {
                targetObject->elements = mprCreateList(targetObject);
            }
            /*
                Insert into the target object
             */
            mprInsertItemAtPos(targetObject->elements, j + 1, elt);
        }

        if (ejsIsXML(ejs, value)) {
            if (((EjsXML*) value)->kind == EJS_XML_LIST) {
                elt->qname = ((EjsXML*) value)->targetProperty;
            } else {
                elt->qname = ((EjsXML*) value)->qname;
            }
        }

        /*
            Insert into the XML list
         */
        mprSetItem(list->elements, index, elt);
    }
    return (EjsXML*) mprGetItem(list->elements, index);
}


/*
    Update an existing element
 */
static int updateElement(Ejs *ejs, EjsXML *list, EjsXML *elt, int index, EjsObj *value)
{
    EjsXML      *node;
    EjsName     name;
    int         i, j;

    if (!ejsIsXML(ejs, value)) {
        /* Not XML or XMLList -- convert to string */
        value = ejsCast(ejs, value, ejs->stringType);                //  TODO - seem to be doing this in too many places
    }
    mprSetItem(list->elements, index, value);

    if (elt->kind == EJS_XML_ATTRIBUTE) {
        mprAssert(ejsIsString(value));
        i = mprLookupItem(elt->parent->elements, elt);
        mprAssert(i >= 0);
        ejsSetXML(ejs, elt->parent, i, elt);
        //  TODO - why do this. Doesn't above do this?
        ejsSetPropertyByName(ejs, (EjsObj*) elt->parent, &elt->qname, value);
        mprFree(elt->value);
        elt->value = mprStrdup(elt, ((EjsString*) value)->value);
    }

    if (ejsIsXML(ejs, value) && ((EjsXML*) value)->kind == EJS_XML_LIST) {
        value = (EjsObj*) shallowCopy(ejs, (EjsXML*) value);
        if (elt->parent) {
            index = mprLookupItem(elt->parent->elements, elt);
            mprAssert(index >= 0);
            for (j = 0; j < mprGetListCount(((EjsXML*) value)->elements); j++) {
                mprInsertItemAtPos(elt->parent->elements, index, value);
            }
        }

    } else if (ejsIsXML(ejs, value) || elt->kind != EJS_XML_ELEMENT) {
        if (elt->parent) {
            index = mprLookupItem(elt->parent->elements, elt);
            mprAssert(index >= 0);
            mprSetItem(elt->parent->elements, index, value);
            ((EjsXML*) value)->parent = elt->parent;
            if (ejsIsString(value)) {
                node = ejsCreateXML(ejs, EJS_XML_TEXT, NULL, list, ((EjsString*) value)->value);
                mprSetItem(list->elements, index, node);
            } else {
                mprSetItem(list->elements, index, value);
            }
        }

    } else {
        ejsName(&name, 0, "*");
        ejsSetPropertyByName(ejs, (EjsObj*) elt, &name, value);
    }
    return index;
}


/*
    Set a property by name.
 */
static int setXmlListPropertyByName(Ejs *ejs, EjsXML *list, EjsName *qname, EjsObj *value)
{
    EjsXML      *elt, *targetObject;
    int         index;

    if (!isdigit((int) qname->name[0])) {
        return setAlphaPropertyByName(ejs, list, qname, value);
    }

    /*
        Numeric property
     */
    targetObject = 0;
    if (list->targetObject) {
        /*
            Find the real underlying target object. May be an XML object or XMLList if it contains multiple elements.
         */
        targetObject = resolve(ejs, list->targetObject);
        if (targetObject == 0) {
            /* Spec says so - TODO why no error? */
            return 0;
        }
    }

    index = atoi(qname->name);
    if (index >= mprGetListCount(list->elements)) {
        /*
            Create, then fall through to update
         */
        elt = createElement(ejs, list, targetObject, qname, value);
        if (elt == 0) {
            return 0;
        }

    } else {
        elt = mprGetItem(list->elements, index);
    }
    mprAssert(elt);
    updateElement(ejs, list, elt, index, value);
    return index;
}


static bool allDigitsForXmlList(cchar *name)
{
    cchar   *cp;

    for (cp = name; *cp; cp++) {
        if (!isdigit((int) *cp) || *cp == '.') {
            return 0;
        }
    }
    return 1;
}


static EjsXML *shallowCopy(Ejs *ejs, EjsXML *xml)
{
    EjsXML      *root, *elt;
    int         next;

    mprAssert(xml->kind == EJS_XML_LIST);

    if (xml == 0) {
        return 0;
    }
    root = ejsCreateXMLList(ejs, xml->targetObject, &xml->targetProperty);
    if (root == 0) {
        return 0;
    }
    if (xml->elements) {
        root->elements = mprCreateList(root);
        for (next = 0; (elt = mprGetNextItem(xml->elements, &next)) != 0; ) {
            mprAssert(ejsIsXML(ejs, elt));
            if (elt) {
                mprAddItem(root->elements, elt);
            }
        }
    }
    if (mprHasAllocError(ejs)) {
        mprFree(root);
        return 0;
    }
    return root;
}


/*
    Resolve empty XML list objects to an actual XML object. This is used by SetPropertyByName to find the actual object to update.
    This method resolves the value of empty XMLLists. If the XMLList is not empty, the list will be returned. If list is empty,
    this method attempts to create an element based on the list targetObject and targetProperty.
 */
static EjsXML *resolve(Ejs *ejs, EjsXML *xml)
{
    EjsXML  *targetObject, *targetPropertyList;

    if (!ejsIsXML(ejs, xml) || xml->kind != EJS_XML_LIST) {
        /* Resolved to an XML object */
        return xml;
    }
    if (mprGetListCount(xml->elements) > 0) {
        /* Resolved to a list of items */
        return xml;
    }
    if (xml->targetObject == 0 || xml->targetProperty.name == 0 || xml->targetProperty.name[0] == '*') {
        /* End of chain an no more target objects */
        return 0;
    }
    targetObject = resolve(ejs, xml->targetObject);
    if (targetObject == 0) {
        return 0;
    }
    //  TODO - OPT. targetPropertyList is also being created below.
    targetPropertyList = (EjsXML*) ejsGetPropertyByName(ejs, (EjsObj*) targetObject, &xml->targetProperty);
    if (targetPropertyList == 0) {
        return 0;
    }
    if (ejsGetPropertyCount(ejs, (EjsObj*) targetPropertyList) == 0) {
        /*
            Property does not exist in the target.
         */
        if (targetObject->kind == EJS_XML_LIST && ejsGetPropertyCount(ejs, (EjsObj*) targetObject) > 1) {
            return 0;
        }
        /*
            Create the property as an element (The text value will be optimized away).
            TODO - OPT. Need an empty string value in EjsFiber.
         */
        ejsSetPropertyByName(ejs, (EjsObj*) targetObject, &xml->targetProperty, (EjsObj*) ejsCreateString(ejs, ""));
        targetPropertyList = (EjsXML*) ejsGetPropertyByName(ejs, (EjsObj*) targetObject, &xml->targetProperty);
    }
    return targetPropertyList;
}



static EjsObj *xmlListConstructor(Ejs *ejs, EjsObj *thisObj, int argc, EjsObj **argv)
{
#if FUTURE
    EjsObj      *vp;
    cchar       *str;

    if (argc == 1) {
        vp = argv[0];

        if (ejsIsObject(vp)) {
            /* Convert DOM to XML. Not implemented */;

        } else if (ejsIsString(vp)) {
            str = ((EjsString*) vp)->value;
            if (str == 0) {
                return 0;
            }
            if (*str == '<') {
                /* XML Literal */
                return loadXmlString(ejs, (EjsXML*) thisObj, str);

            } else {
                /* Load from file */
                return load(ejs, (EjsXML*) thisObj, argc, argv);
            }
        } else {
            ejsThrowArgError(ejs, "Bad type passed to XML constructor");
            return 0;
        }
    }
#endif
    return (EjsObj*) thisObj;
}


/*
    Convert to a JSON string

    override function toJSON(): String
 */
static EjsObj *xmlListToJson(Ejs *ejs, EjsObj *vp, int argc, EjsObj **argv)
{
    EjsString       *sp;
    MprBuf          *buf;
    EjsVar          *result;
    cchar           *cp;

    /*
        Quote all quotes
     */
    sp = ejsToString(ejs, vp);
    buf = mprCreateBuf(ejs, -1, -1);
    mprPutCharToBuf(buf, '"');
    for (cp = ejsGetString(ejs, sp); *cp; cp++) {
        if (*cp == '"') {
            mprPutCharToBuf(buf, '\\');
        }
        mprPutCharToBuf(buf, (uchar) *cp);
    }
    mprPutCharToBuf(buf, '"');
    mprAddNullToBuf(buf);
    result = (EjsVar*) ejsCreateStringAndFree(ejs, mprStealBuf(vp, buf));
    mprFree(buf);
    return result;
}


/*
    Convert the XML object to a string.

    intrinsic function toString() : String
 */
static EjsObj *xmlListToString(Ejs *ejs, EjsObj *vp, int argc, EjsObj **argv)
{
    return (vp->type->helpers->cast)(ejs, vp, ejs->stringType);
}


/*
    Get the length of an array.
    @return Returns the number of items in the array

    intrinsic public override function get length(): int
 */

static EjsObj *xlLength(Ejs *ejs, EjsXML *xml, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateNumber(ejs, mprGetListCount(xml->elements));
}


#if FUTURE
/*
    Set the length. TODO - what does this do?
    intrinsic public override function set length(value: int): void
 */
static EjsObj *setLength(Ejs *ejs, EjsXMLList *xml, int argc, EjsObj **argv)
{
    int         length;

    mprAssert(ejsIsXMLList(ejs, xml));

    if (argc != 1) {
        ejsThrowArgError(ejs, "usage: obj.length = value");
        return 0;
    }
    length = ejsVarToInteger(ejs, argv[0]);

#if KEEP
    if (length < ap->length) {
        for (i = length; i < ap->length; i++) {
            if (ejsSetProperty(ejs, (EjsObj*) ap, i, (EjsObj*) ejs->undefinedValue) < 0) {
                //  TODO - DIAG
                return 0;
            }
        }

    } else if (length > ap->length) {
        if (ejsSetProperty(ejs, (EjsObj*) ap, length - 1,  (EjsObj*) ejs->undefinedValue) < 0) {
            //  TODO - DIAG
            return 0;
        }
    }

    ap->length = length;
#endif
    return 0;
}
#endif



EjsXML *ejsCreateXMLList(Ejs *ejs, EjsXML *targetObject, EjsName *targetProperty)
{
    EjsType     *type;
    EjsXML      *list;

    type = ejs->xmlListType;

    list = (EjsXML*) ejsAlloc(ejs, type, 0);
    if (list == 0) {
        return 0;
    }
    list->kind = EJS_XML_LIST;
    list->elements = mprCreateList(list);
    list->targetObject = targetObject;

    if (targetProperty) {
        list->targetProperty.name = mprStrdup(list, targetProperty->name);
    }
    return list;
}


void ejsCreateXMLListType(Ejs *ejs)
{
    EjsType     *type;

    type = ejs->xmlListType = ejsCreateNativeType(ejs, EJS_EJS_NAMESPACE, "XMLList", ES_XMLList, sizeof(EjsXML));

    /*
        Must not bind as XML uses get/setPropertyByName to defer to user XML elements over XML methods
     */
    type->block.nobind = 1;

    type->helpers = ejsCloneObjectHelpers(ejs, "xmllist-helpers");
    type->helpers->clone = (EjsCloneHelper) cloneXmlList;
    type->helpers->cast = (EjsCastHelper) xlCast;
    type->helpers->create = (EjsCreateHelper) createXmlListVar;
    type->helpers->destroy = (EjsDestroyHelper) destroyXmlList;
    type->helpers->getPropertyByName = (EjsGetPropertyByNameHelper) getXmlListPropertyByName;
    type->helpers->getPropertyCount = (EjsGetPropertyCountHelper) getXmlListPropertyCount;
    type->helpers->deletePropertyByName = (EjsDeletePropertyByNameHelper) deleteXmlListPropertyByName;
    type->helpers->invokeOperator = (EjsInvokeOperatorHelper) ejsObjectOperator;
    type->helpers->mark = (EjsMarkHelper) ejsMarkXML;
    type->helpers->setPropertyByName = (EjsSetPropertyByNameHelper) setXmlListPropertyByName;
}

void ejsConfigureXMLListType(Ejs *ejs)
{
    EjsType     *type;


    type = ejsGetTypeByName(ejs, EJS_EJS_NAMESPACE, "XMLList");

    /*
        Define the XMLList class methods
     */
    ejsBindMethod(ejs, type, ES_XMLList_length, (EjsProc) xlLength);
    ejsBindMethod(ejs, type, ES_XMLList_name, (EjsProc) getXmlListNodeName);
    ejsBindMethod(ejs, type, ES_XMLList_XMLList, (EjsProc) xmlListConstructor);

    /*
        Override these methods
     */
    ejsBindMethod(ejs, type, ES_Object_toJSON, (EjsProc) xmlListToJson);
    ejsBindMethod(ejs, type, ES_Object_toString, (EjsProc) xmlListToString);

    ejsBindMethod(ejs, type, ES_Object_get, getXmlListIterator);
    ejsBindMethod(ejs, type, ES_Object_getValues, getXmlListValues);
#if FUTURE
    ejsBindMethod(ejs, type, "name", name, NULL);
    ejsBindMethod(ejs, type, "valueOf", valueOf, NULL);
#endif
}


/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2010. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2010. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    @end
 */
/************************************************************************/
/*
 *  End of file "../src/core/src/ejsXMLList.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../src/core/src/ejsXMLLoader.c"
 */
/************************************************************************/

/**
    ejsXMLLoader.c - Load and save XML data.
 *
    Copyright (c) All Rights Reserved. See details at the end of the file.
 */




static void indent(MprBuf *bp, int level);
static int  parserHandler(MprXml *xp, int state, cchar *tagName, cchar *attName, cchar *value);


MprXml *ejsCreateXmlParser(Ejs *ejs, EjsXML *xml, cchar *filename)
{
    EjsXmlState *parser;
    MprXml      *xp;
    
    xp = mprXmlOpen(ejs, MPR_BUFSIZE, EJS_XML_BUF_MAX);
    mprAssert(xp);

    /*
        Create the parser stack
     */
    parser = mprAllocObjZeroed(xp, EjsXmlState);
    if (parser == 0) {
        mprFree(xp);
        return 0;
    }
    parser->ejs = ejs;
    parser->nodeStack[0].obj = xml;
    
    //  TODO - these 2 are not really needed. Can use ejs->
    parser->xmlType = ejs->xmlType;
    parser->xmlListType = ejs->xmlListType;
    parser->filename = filename;

    mprXmlSetParseArg(xp, parser);
    mprXmlSetParserHandler(xp, parserHandler);

    return xp;
}


/*
    XML parsing callback. Called for each elt and attribute/value pair. 
    For speed, we handcraft the object model here rather than calling 
    putXmlProperty.
 *
    "<!-- txt -->"      parserHandler(, , MPR_XML_COMMENT);
    "<elt"              parserHandler(, , MPR_XML_NEW_ELT);
    "...att=value"      parserHandler(, , MPR_XML_NEW_ATT);
    "<elt ...>"         parserHandler(, , MPR_XML_ELT_DEFINED);
    "<elt/>"            parserHandler(, , MPR_XML_SOLO_ELT_DEFINED);
    "<elt> ...<"        parserHandler(, , MPR_XML_ELT_DATA);
    "...</elt>"         parserHandler(, , MPR_XML_END_ELT);
 *
    Note: we recurse on every new nested elt.
 */

static int parserHandler(MprXml *xp, int state, cchar *tagName, cchar *attName, cchar *value)
{
    Ejs             *ejs;
    EjsXmlState     *parser;
    EjsXmlTagState  *tos;
    EjsName         qname;
    EjsXML          *xml, *node, *parent;

    parser = (EjsXmlState*) xp->parseArg;
    ejs = parser->ejs;
    tos = &parser->nodeStack[parser->topOfStack];
    xml = tos->obj;
    
    mprAssert(xml);

    mprAssert(state >= 0);
    mprAssert(tagName && *tagName);

    switch (state) {
    case MPR_XML_PI:
        node = ejsCreateXML(ejs, EJS_XML_PROCESSING, NULL, xml, value);
        ejsAppendToXML(ejs, xml, node);
        break;

    case MPR_XML_COMMENT:
        node = ejsCreateXML(ejs, EJS_XML_COMMENT, NULL, xml, value);
        ejsAppendToXML(ejs, xml, node);
        break;

    case MPR_XML_NEW_ELT:
        if (parser->topOfStack > EJS_XML_MAX_NODE_DEPTH) {
            ejsThrowSyntaxError(ejs,  "XML nodes nested too deeply in %s at line %d", parser->filename, 
                mprXmlGetLineNumber(xp));
            return MPR_ERR_BAD_SYNTAX;
        }
        if (xml->kind <= 0) {
            ejsConfigureXML(ejs, xml, EJS_XML_ELEMENT, tagName, xml, NULL);
        } else {
            ejsName(&qname, 0, tagName);
            xml = ejsCreateXML(ejs, EJS_XML_ELEMENT, &qname, xml, NULL);
            tos = &parser->nodeStack[++(parser->topOfStack)];
            tos->obj = (EjsXML*) xml;
            tos->attributes = 0;
            tos->comments = 0;
        }
        break;

    case MPR_XML_NEW_ATT:
        ejsName(&qname, 0, attName);
        node = ejsCreateXML(ejs, EJS_XML_ATTRIBUTE, &qname, xml, value);
        //  TODO - rc
        ejsAppendAttributeToXML(ejs, xml, node);
        //  TODO RC
        break;

    case MPR_XML_SOLO_ELT_DEFINED:
        if (parser->topOfStack > 0) {
            parent = parser->nodeStack[parser->topOfStack - 1].obj;
            //  TODO - rc
            ejsAppendToXML(ejs, parent, xml);
            parser->topOfStack--;
            mprAssert(parser->topOfStack >= 0);
            tos = &parser->nodeStack[parser->topOfStack];
        }
        break;

    case MPR_XML_ELT_DEFINED:
        if (parser->topOfStack > 0) {
            parent = parser->nodeStack[parser->topOfStack - 1].obj;
            //  TODO - rc
            ejsAppendToXML(ejs, parent, xml);
        }
        break;

    case MPR_XML_ELT_DATA:
    case MPR_XML_CDATA:
        ejsName(&qname, 0, attName);
        node = ejsCreateXML(ejs, EJS_XML_TEXT, &qname, xml, value);
        //  TODO - rc
        ejsAppendToXML(ejs, xml, node);
        break;

    case MPR_XML_END_ELT:
        /*
            This is the closing element in a pair "<x>...</x>".
            Pop the stack frame off the elt stack
         */
        if (parser->topOfStack > 0) {
            parser->topOfStack--;
            mprAssert(parser->topOfStack >= 0);
            tos = &parser->nodeStack[parser->topOfStack];
        }
        break;

    default:
        ejsThrowSyntaxError(ejs, "XML error in %s at %d\nDetails %s", parser->filename, mprXmlGetLineNumber(xp), 
            mprXmlGetErrorMsg(xp));
        mprAssert(0);
        return MPR_ERR_BAD_SYNTAX;
    }
    return 0;
}


#if KEEP
static bool checkTagName(char *name)
{
    char    *cp;

    for (cp = name; *cp; cp++) {
        if (!isalnum(*cp) && *cp != '_' && *cp != '$' && *cp != '@') {
            return 0;
        }
    }
    return 1;
}
#endif


int ejsXMLToString(Ejs *ejs, MprBuf *buf, EjsXML *node, int indentLevel)
{
    EjsXML      *xml, *child, *attribute, *elt;
    int         sawElements, next;
    
    if (node->obj.visited) {
        return 0;
    }
    node->obj.visited = 1;

    if (node->kind == EJS_XML_LIST) {
        for (next = 0; (elt = mprGetNextItem(node->elements, &next)) != 0; ) {
            ejsXMLToString(ejs, buf, elt, indentLevel);
        }
        return 0;
    }
    
    mprAssert(ejsIsXML(ejs, node));
    xml = (EjsXML*) node;
    
    switch (xml->kind) {
    case EJS_XML_ELEMENT:
        /*
            XML object is complex (has elements) so return full XML content.
         */
        if (indentLevel > 0) {
            mprPutCharToBuf(buf, '\n');
        }
        indent(buf, indentLevel);

        mprPutFmtToBuf(buf, "<%s", xml->qname.name);
        if (xml->attributes) {
            for (next = 0; (attribute = mprGetNextItem(xml->attributes, &next)) != 0; ) {
                mprPutFmtToBuf(buf, " %s=\"%s\"",  attribute->qname.name, attribute->value);
            }
        }
        
        sawElements = 0;
        if (xml->elements) {
            mprPutStringToBuf(buf, ">"); 
            for (next = 0; (child = mprGetNextItem(xml->elements, &next)) != 0; ) {
                if (child->kind != EJS_XML_TEXT) {
                    sawElements++;
                }
    
                /* Recurse */
                if (ejsXMLToString(ejs, buf, child, indentLevel < 0 ? -1 : indentLevel + 1) < 0) {
                    return -1;
                }
            }
            if (sawElements && indentLevel >= 0) {
                mprPutCharToBuf(buf, '\n');
                indent(buf, indentLevel);
            }
            mprPutFmtToBuf(buf, "</%s>", xml->qname.name);
            
        } else {
            /* Solo */
            mprPutStringToBuf(buf, "/>");
        }
        break;
        
    case EJS_XML_COMMENT:
        mprPutCharToBuf(buf, '\n');
        indent(buf, indentLevel);
        mprPutFmtToBuf(buf, "<!--%s -->", xml->value);
        break;
        
    case EJS_XML_ATTRIBUTE:
        /*
            Only here when converting solo attributes to a string
         */
        mprPutStringToBuf(buf, xml->value);
        break;
        
    case EJS_XML_TEXT:
        mprPutStringToBuf(buf, xml->value);
        break;
    }
    node->obj.visited = 0;
    return 0;
}


static void indent(MprBuf *bp, int level)
{
    int     i;

    for (i = 0; i < level; i++) {
        mprPutCharToBuf(bp, '\t');
    }
}


/*
    @copy   default
    
    Copyright (c) Embedthis Software LLC, 2003-2010. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2010. All Rights Reserved.
    
    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire 
    a commercial license from Embedthis Software. You agree to be fully bound 
    by the terms of either license. Consult the LICENSE.TXT distributed with 
    this software for full details.
    
    This software is open source; you can redistribute it and/or modify it 
    under the terms of the GNU General Public License as published by the 
    Free Software Foundation; either version 2 of the License, or (at your 
    option) any later version. See the GNU General Public License for more 
    details at: http://www.embedthis.com/downloads/gplLicense.html
    
    This program is distributed WITHOUT ANY WARRANTY; without even the 
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
    
    This GPL license does NOT permit incorporating this software into 
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses 
    for this software and support services are available from Embedthis 
    Software at http://www.embedthis.com 
    
    @end
 */
/************************************************************************/
/*
 *  End of file "../src/core/src/ejsXMLLoader.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../src/jems/ejs.db.sqlite/src/ejsSqlite.c"
 */
/************************************************************************/

/*
    ejsSqlite.c -- SQLite Database class

    Copyright (c) All Rights Reserved. See details at the end of the file.

    Todo:
        - should handle SQLITE_BUSY for multiuser access. Need to set the default timeout
        Useful: SQLITE_API sqlite3_int64 sqlite3_last_insert_rowid(sqlite3*);
 */


#include    "sqlite3.h"

#if BLD_FEATURE_SQLITE

#define THREAD_STYLE SQLITE_CONFIG_MULTITHREAD
//#define THREAD_STYLE SQLITE_CONFIG_SERIALIZED

/*
    Map mutex locking onto Ejscript/MPR locking routines for platforms not supported by SQLite
 */
#if VXWORKS
#define MAP_MUTEXES 1
#else
#define MAP_MUTEXES 1
#endif

/*
    Map allocation routines to use Ejscript/MPR allocation. FUTURE, currently disabled.
 */
#define MAP_ALLOC 0

#if MAP_ALLOC
#if !VXWORKS
/*
    Thread Local Storage (TLS) is used so memory allocations from within SQLite can use the appropriate MPR memory
    context for the thread. VxWorks does not support TLS.
 */
#define USE_TLS 1
MprThreadLocal  *sqliteTls;
#define SET_CTX(ctx)  mprSetThreadData(sqliteTls, (void*) ctx)
#else
/*
    Single-threaded (or VxWorks). Use one single context for all threads. In this case, we must create a thread-safe arena.
 */
static MprCtx sqliteCtx;
#define SET_CTX(ctx)
#endif /* !VXWORKS */

#else
/*
    Using the native SQLite memory allocation and Not mapping allocation routines to the MPR alternatives.
 */
static MprCtx sqliteCtx;
#define SET_CTX(ctx)
#endif /* MAP_ALLOC */
    

/*
    Ejscript Sqlite class object
 */
typedef struct EjsSqlite {
    EjsObj       obj;                /* Extends Object */
    sqlite3         *sdb;               /* Sqlite handle */
    MprHeap         *arena;             /* Memory context arena */
    Ejs             *ejs;               /* Interp reference */
} EjsSqlite;


#if UNUSED
static int sqldbDestructor(EjsSqlite **db);
#endif

/*
    DB Constructor and also used for constructor for sub classes.

    function Sqlite(connectionString: String)
 */
static EjsVar *sqliteConstructor(Ejs *ejs, EjsSqlite *db, int argc, EjsVar **argv)
{
    sqlite3         *sdb;
    cchar           *path;

    path = ejsGetString(ejs, argv[0]);    
    db->ejs = ejs;
    
    /*
     *  Create a memory context for use by sqlite. This is a virtual paged memory region.
     *  TODO OPT - Could do better for running applications.
     */
#if MAP_ALLOC
    db->arena = mprAllocArena(ejs, "sqlite", EJS_MAX_SQLITE_MEM, !USE_TLS, 0);
    if (db->arena == 0) {
        return 0;
    }
    SET_CTX(db->arena);
#else
    db->arena = mprAllocHeap(ejs, "sqlite", EJS_MAX_SQLITE_MEM, 1, 0);
    if (db->arena == 0) {
        return 0;
    }
    SET_CTX(db->arena);
#endif
    
#if UNUSED
    EjsSqlite       **dbp;
    /*
     *  Create a destructor object so we can cleanup and close the database. Must create after the arena so it will be
     *  invoked before the arena is freed. 
     */
    if ((dbp = mprAllocWithDestructor(ejs, sizeof(void*), (MprDestructor) sqldbDestructor)) == 0) {
        ejsThrowMemoryError(ejs);
        return 0;
    }
    *dbp = db;
#endif

    sdb = 0;
    if (sqlite3_open(path, &sdb) != SQLITE_OK) {
        ejsThrowIOError(ejs, "Can't open database %s", path);
        return 0;
    }
    db->sdb = sdb;
    sqlite3_busy_timeout(sdb, EJS_SQLITE_TIMEOUT);

    //  TODO - should be configurable somewhere
    sqlite3_soft_heap_limit(2 * 1024 * 1024);
    return 0;
}


#if UNUSED
static int sqldbDestructor(EjsSqlite **dbp)
{
    EjsSqlite   *db;

    db = *dbp;

    if (db->sdb) {
        SET_CTX(db->arena);
        sqlite3_close(db->sdb);
        db->sdb = 0;
    }
    return 0;
}
#endif


/*
    function close(): Void
 */
static int sqliteClose(Ejs *ejs, EjsSqlite *db, int argc, EjsVar **argv)
{
    mprAssert(ejs);
    mprAssert(db);

    if (db->sdb) {
        SET_CTX(db->arena);
        sqlite3_close(db->sdb);
        db->sdb = 0;
    }
    return 0;
}


/*
    function sql(cmd: String): Array

    Will support multiple sql cmds but will only return one result table.
 */
static EjsVar *sqliteSql(Ejs *ejs, EjsSqlite *db, int argc, EjsVar **argv)
{
    sqlite3         *sdb;
    sqlite3_stmt    *stmt;
    EjsArray        *result;
    EjsObj       *row;
    EjsVar          *svalue;
    EjsName         qname;
    char            *tableName;
    cchar           *tail, *colName, *cmd, *value, *defaultTableName;
    int             i, ncol, rc, retries, rowNum, len;

    mprAssert(ejs);
    mprAssert(db);

    SET_CTX(db->arena);
    cmd = ejsGetString(ejs, argv[0]);
    retries = 0;
    sdb = db->sdb;
    if (sdb == 0) {
        ejsThrowIOError(ejs, "Database is closed");
        return 0;
    }
    mprAssert(sdb);

    result = ejsCreateArray(ejs, 0);
    if (result == 0) {
        return 0;
    }

    rc = SQLITE_OK;
    while (cmd && *cmd && (rc == SQLITE_OK || (rc == SQLITE_SCHEMA && ++retries < 2))) {
        stmt = 0;
        rc = sqlite3_prepare_v2(sdb, cmd, -1, &stmt, &tail);
        if (rc != SQLITE_OK) {
            continue;
        }
        if (stmt == 0) {
            /* Comment or white space */
            cmd = tail;
            continue;
        }
        defaultTableName = 0;
        ncol = sqlite3_column_count(stmt);
        for (rowNum = 0; ; rowNum++) {
            if ((rc = sqlite3_step(stmt)) == SQLITE_ROW) {
                row = ejsCreateSimpleObject(ejs);
                if (row == 0) {
                    sqlite3_finalize(stmt);
                    return 0;
                }
                if (ejsSetProperty(ejs, (EjsVar*) result, rowNum, (EjsVar*) row) < 0) {
                    ejsThrowIOError(ejs, "Can't update query result set");
                    return 0;
                }
#if MOB
                /* This will ensure we have a row->names memory context. This gets freed if the object is pooled. */
                ejsGrowObjectNames(row, rowNum + 1);
#endif
                for (i = 0; i < ncol; i++) {
                    tableName = (char*) sqlite3_column_table_name(stmt, i);
                    if (defaultTableName == 0) {
                        defaultTableName = tableName;
                    }
                    colName = sqlite3_column_name(stmt, i);
                    value = (cchar*) sqlite3_column_text(stmt, i);

                    if (tableName == 0 || strcmp(tableName, defaultTableName) == 0) {
                        ejsName(&qname, EJS_EMPTY_NAMESPACE, mprStrdup(row, colName));
                    } else {
                        /*
                         *  Append the table name for columns from foreign tables. Convert to camel case (tableColumn)
                         */
                        len = strlen(tableName) + 1;
                        tableName = mprStrcat(row, -1, "_", tableName, colName, NULL);
                        if (len > 3 && tableName[len - 1] == 's' && tableName[len - 2] == 'e' && tableName[len - 3] == 'i') {
                            tableName[len - 3] = 'y';
                            strcpy(&tableName[len - 2], colName);
                            len -= 2;
                        } else if (len > 2 && tableName[len - 1] == 's' && tableName[len - 2] == 'e') {
                            strcpy(&tableName[len - 2], colName);
                            len -= 2;
                        } else if (tableName[len - 1] == 's') {
                            strcpy(&tableName[len - 1], colName);
                            len--;
                        }
                        // tableName[0] = tolower((int) tableName[0]);
                        tableName[len] = toupper((int) tableName[len]);
                        ejsName(&qname, EJS_EMPTY_NAMESPACE, tableName);
                    }
                    if (ejsLookupProperty(ejs, (EjsVar*) row, &qname) < 0) {
                        svalue = (EjsVar*) ejsCreateString(ejs, mprStrdup(row, value));
                        if (ejsSetPropertyByName(ejs, (EjsVar*) row, &qname, svalue) < 0) {
                            ejsThrowIOError(ejs, "Can't update query result set name");
                            return 0;
                        }
                    } else {
                        mprFree((char*) qname.name);
                    }
                }
            } else {
                rc = sqlite3_finalize(stmt);
                stmt = 0;

                if (rc != SQLITE_SCHEMA) {
                    retries = 0;
                    for (cmd = tail; isspace((int) *cmd); cmd++) {
                        ;
                    }
                }
                break;
            }
        }
    }
    if (stmt) {
        rc = sqlite3_finalize(stmt);
    }
    if (rc != SQLITE_OK) {
        if (rc == sqlite3_errcode(sdb)) {
            ejsThrowIOError(ejs, "SQL error: %s", sqlite3_errmsg(sdb));
        } else {
            ejsThrowIOError(ejs, "Unspecified SQL error");
        }
        return 0;
    }
    return (EjsVar*) result;
}


/*
    This will be called by the GC when an instance is no-longer in use. It will always be called.
 */
static void destroySqliteDb(Ejs *ejs, EjsSqlite *db)
{
    mprAssert(db);

    if (db->sdb) {
        sqliteClose(ejs, db, 0, 0);
    }
    ejsFree(ejs, (EjsVar*) db, -1);
}

#if MAP_ALLOC

static void *allocBlock(int size)
{
    MprCtx      ctx;

#if USE_TLS
    mprAssert(sqliteTls);
    ctx = mprGetThreadData(sqliteTls);
#else
    ctx = sqliteCtx;
#endif
    return mprAlloc(ctx, size);
}


static void freeBlock(void *ptr)
{
    mprFree(ptr);
}


static void *reallocBlock(void *ptr, int size)
{
    MprCtx      ctx;

#if USE_TLS
    mprAssert(sqliteTls);
    ctx = mprGetThreadData(sqliteTls);
#else
    ctx = sqliteCtx;
#endif
    return mprRealloc(ctx, ptr, size);
}


static int blockSize(void *ptr)
{
    return mprGetBlockSize(ptr);
}


static int roundBlockSize(int size)
{
    return MPR_ALLOC_ALIGN(size);
}


static int initAllocator(void *data)
{
    return 0;
}


static void termAllocator(void *data)
{
}


struct sqlite3_mem_methods mem = {
    allocBlock, freeBlock, reallocBlock, blockSize, roundBlockSize, initAllocator, termAllocator, NULL 
};

#endif /* MAP_ALLOC */
/*
    Mutex mapping for platforms not yet supported by SQLite
 */
#if MAP_MUTEXES

static int initMutex(void) { 
    return 0; 
}


static int termMutex(void) { 
    return 0; 
}


static sqlite3_mutex *allocMutex(int kind)
{
    MprCtx      ctx;

#if USE_TLS
    mprAssert(sqliteTls);
    ctx = mprGetThreadData(sqliteTls);
#else
    ctx = sqliteCtx;
#endif
    return (sqlite3_mutex*) mprCreateLock(ctx);
}


static void freeMutex(sqlite3_mutex *mutex)
{
    mprFree(mutex);
}


static void enterMutex(sqlite3_mutex *mutex)
{
    mprLock((MprMutex*) mutex);
}


static int tryMutex(sqlite3_mutex *mutex)
{
    return mprTryLock((MprMutex*) mutex);
}


static void leaveMutex(sqlite3_mutex *mutex)
{
    mprUnlock((MprMutex*) mutex);
}


static int mutexIsHeld(sqlite3_mutex *mutex) { 
    mprAssert(0); 
    return 0; 
}


static int mutexIsNotHeld(sqlite3_mutex *mutex) { 
    mprAssert(0); 
    return 0; 
}


struct sqlite3_mutex_methods mut = {
    initMutex, termMutex, allocMutex, freeMutex, enterMutex, tryMutex, leaveMutex, mutexIsHeld, mutexIsNotHeld,
};

#endif /* MAP_MUTEXES */


static int configureSqliteTypes(Ejs *ejs)
{
    EjsType         *type;
    
    type = (EjsType*) ejsConfigureNativeType(ejs, "ejs.db", "Sqlite", sizeof(EjsSqlite));
    type->needFinalize = 1;

    type->helpers = ejsCloneObjectHelpers(ejs, "sqlite-helpers");
    type->helpers->destroy = (EjsDestroyHelper) destroySqliteDb;

    ejsBindMethod(ejs, type, ES_ejs_db_Sqlite_Sqlite, (EjsProc) sqliteConstructor);
    ejsBindMethod(ejs, type, ES_ejs_db_Sqlite_close, (EjsProc) sqliteClose);
    ejsBindMethod(ejs, type, ES_ejs_db_Sqlite_sql, (EjsProc) sqliteSql);

#if MAP_ALLOC
#if USE_TLS
    sqliteTls = mprCreateThreadLocal(ejs);
    if (sqliteTls == 0) {
        return;
    }
    SET_CTX(ejs);
#else
    sqliteCtx = ejs;
#endif
    sqlite3_config(SQLITE_CONFIG_MALLOC, &mem);
#else
    sqliteCtx = ejs;
#endif

#if MAP_MUTEXES
    sqlite3_config(SQLITE_CONFIG_MUTEX, &mut);
#endif
    sqlite3_config(THREAD_STYLE);
    if (sqlite3_initialize() != SQLITE_OK) {
        mprError(ejs, "Can't initialize SQLite");
        return MPR_ERR_CANT_INITIALIZE;
    }
    return 0;
}


int ejs_db_sqlite_Init(MprCtx ctx)
{
    return ejsAddNativeModule(ctx, "ejs.db.sqlite", configureSqliteTypes, _ES_CHECKSUM_ejs_db_sqlite, EJS_LOADER_ETERNAL);
}

#endif /* BLD_FEATURE_SQLITE */
/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2010. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2010. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    @end
 */
/************************************************************************/
/*
 *  End of file "../src/jems/ejs.db.sqlite/src/ejsSqlite.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../src/jems/ejs.web/src/ejsHttpServer.c"
 */
/************************************************************************/

/*
    ejsHttpServer.c -- Ejscript Http Server.

    Copyright (c) All Rights Reserved. See copyright notice at the bottom of the file.
 */



static void stateChangeNotifier(HttpConn *conn, int state, int notifyFlags);

/*  
    function HttpServer(serverRoot: Path = ".", documentRoot: Path = ".")
    Constructor function
 */
static EjsObj *hs_HttpServer(Ejs *ejs, EjsHttpServer *sp, int argc, EjsObj **argv)
{
    sp->ejs = ejs;
    if (argc >= 1) {
        ejsSetProperty(ejs, (EjsObj*) sp, ES_ejs_web_HttpServer_serverRoot, (EjsObj*) argv[0]);
    } else {
        ejsSetProperty(ejs, (EjsObj*) sp, ES_ejs_web_HttpServer_serverRoot, (EjsObj*) ejsCreateString(ejs, "."));
    }
    if (argc >= 2) {
        ejsSetProperty(ejs, (EjsObj*) sp, ES_ejs_web_HttpServer_documentRoot, (EjsObj*) argv[1]);
    } else {
        ejsSetProperty(ejs, (EjsObj*) sp, ES_ejs_web_HttpServer_documentRoot, (EjsObj*) ejsCreateString(ejs, "."));
    }
    return (EjsObj*) sp;
}


/*  
    function addListener(name: [String|Array], listener: Function): Void
 */
static EjsObj *hs_addListener(Ejs *ejs, EjsHttpServer *sp, int argc, EjsObj **argv)
{
    //  TODO -- should fire if currently readable / writable (also socket etc)
    ejsAddListener(ejs, &sp->emitter, argv[0], argv[1]);
    return 0;
}


/*  
    function get address(): Void
 */
static EjsObj *hs_address(Ejs *ejs, EjsHttpServer *sp, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateString(ejs, sp->ip);
}


/*  
    function get async(): Boolean
 */
static EjsObj *hs_async(Ejs *ejs, EjsHttpServer *sp, int argc, EjsObj **argv)
{
    return httpGetServerAsync(sp->server) ? (EjsObj*) ejs->trueValue : (EjsObj*) ejs->falseValue;
}


/*  
    function set async(enable: Boolean): Void
 */
static EjsObj *hs_set_async(Ejs *ejs, EjsHttpServer *sp, int argc, EjsObj **argv)
{
    httpSetServerAsync(sp->server, (argv[0] == (EjsObj*) ejs->trueValue));
    return 0;
}


/*  
    function attach(): Void
 */
static EjsObj *hs_attach(Ejs *ejs, EjsHttpServer *sp, int argc, EjsObj **argv)
{
    //  MOB -- would be great to require users to call attach
    if (ejs->location) {
        ejs->location->context = sp;
    } else {
        ejsThrowStateError(ejs, "attach can only be called when hosted inside a supported web server");
    }
    return 0;
}


/*  
    function close(): Void
 */
static EjsObj *hs_close(Ejs *ejs, EjsHttpServer *sp, int argc, EjsObj **argv)
{
    if (sp->server) {
        ejsSendEvent(ejs, sp->emitter, "close", (EjsObj*) sp);
        mprFree(sp->server);
        sp->server = 0;
    }
    return 0;
}


/*  
    function listen(address): Void
    Address Can be either a "ip", "ip:port" or port
 */
static EjsObj *hs_listen(Ejs *ejs, EjsHttpServer *sp, int argc, EjsObj **argv)
{
    HttpServer  *server;
    EjsString   *address;
    EjsPath     *root;

    if (sp->server) {
        mprFree(sp->server);
        sp->server = 0;
    }
    address = (EjsString*) argv[0];
    mprParseIp(ejs, address->value, &sp->ip, &sp->port, 80);

    /*
        The server uses the ejsDispatcher. This is VERY important. All connections will inherit this also.
        This serializes all activity on the one dispatcher.
     */
    if ((server = httpCreateServer(ejs->http, sp->ip, sp->port, ejs->dispatcher)) == 0) {
        ejsThrowIOError(ejs, "Can't create server object");
        return 0;
    }
    sp->server = server;

    root = (EjsPath*) ejsGetProperty(ejs, (EjsObj*) sp, ES_ejs_web_HttpServer_documentRoot);
    //  MOB -- why
    server->documentRoot = mprStrdup(server, root->path);

    //  MOB -- is this needed?
    root = (EjsPath*) ejsGetProperty(ejs, (EjsObj*) sp, ES_ejs_web_HttpServer_serverRoot);
    server->serverRoot = mprStrdup(server, root->path);

    httpSetServerContext(server, sp);
    httpSetServerNotifier(server, (HttpNotifier) stateChangeNotifier);
    if (httpStartServer(server) < 0) {
        ejsThrowIOError(ejs, "Can't listen on %s", address->value);
        mprFree(sp->server);
        sp->server = 0;
        return 0;
    }
    return 0;
}


/*  
    function get port(): Number
 */
static EjsObj *hs_port(Ejs *ejs, EjsHttpServer *sp, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateNumber(ejs, sp->port);
}


/*  
    function removeListener(name: [String|Array], listener: Function): Void
 */
static EjsObj *hs_removeListener(Ejs *ejs, EjsHttpServer *sp, int argc, EjsObj **argv)
{
    ejsRemoveListener(ejs, sp->emitter, argv[0], argv[1]);
    return 0;
}


/*  
    function get software(headers: Object = null): Void
 */
static EjsObj *hs_software(Ejs *ejs, EjsHttpServer *sp, int argc, EjsObj **argv)
{
    return (EjsObj*) ejsCreateString(ejs, HTTP_NAME);
}


/*
    Notification callback. This routine is called from the Http pipeline on connection state changes. 
    Readable/writable events come with state == 0 and notifyFlags set accordingly.
 */
static void stateChangeNotifier(HttpConn *conn, int state, int notifyFlags)
{
    Ejs             *ejs;
    EjsRequest      *req;

    mprAssert(conn);

    ejs = 0;
    if ((req = httpGetConnContext(conn)) == 0) {
        ejs = req->ejs;
    }

    switch (state) {
    case HTTP_STATE_PARSED:
        conn->transmitter->handler = conn->http->ejsHandler;
        break;

    case HTTP_STATE_ERROR:
        if (req && req->emitter) {
            ejsSendEvent(ejs, req->emitter, "error", (EjsObj*) req);
        }
        break;

    case HTTP_STATE_COMPLETE:
        if (req && req->emitter) {
            ejsSendEvent(ejs, req->emitter, "complete", (EjsObj*) req);
        }
        break;

    case 0:
        /*  IO event notification for the request.  */
        if (req && req->emitter) {
            if (notifyFlags & HTTP_NOTIFY_READABLE) {
                ejsSendEvent(ejs, req->emitter, "readable", (EjsObj*) req);
            } 
            if (notifyFlags & HTTP_NOTIFY_WRITABLE) {
                ejsSendEvent(ejs, req->emitter, "writable", (EjsObj*) req);
            }
        }
        break;
    }
}


static void closeEjs(HttpQueue *q)
{
    httpSetConnContext(q->conn, 0);
    httpSetRequestNotifier(q->conn, 0);
}


static void incomingEjsData(HttpQueue *q, HttpPacket *packet)
{
    HttpConn        *conn;
    HttpTransmitter *trans;
    HttpReceiver    *rec;

    conn = q->conn;
    trans = conn->transmitter;
    rec = conn->receiver;

    if (httpGetPacketLength(packet) == 0) {
        if (rec->remainingContent > 0) {
            httpError(conn, HTTP_CODE_BAD_REQUEST, "Client supplied insufficient body data");
        }
        if (rec->form) {
            httpAddVarsFromQueue(q);
        }
    } else if (trans->writeComplete) {
        httpFreePacket(q, packet);
    } else {
        httpJoinPacketForService(q, packet, 0);
    }
}


static void runEjs(HttpQueue *q)
{
    EjsHttpServer   *sp;
    EjsRequest      *req;
    EjsPath         *dirPath;
    Ejs             *ejs;
    HttpConn        *conn;
    HttpLocation    *location;
    cchar           *dir;

    conn = q->conn;
    if (!conn->error) {
        sp = httpGetServerContext(conn->server);
        if ((req = httpGetConnContext(conn)) == 0) {
            if (conn->transmitter->handler->match) {
                /*
                    Hosted handler. Must supply a location block which defines the HttpServer instance.
                 */
                location = conn->receiver->location;
                if (location == 0 || location->context == 0) {
                    mprError(q, "Location block is not defined for request");
                    return;
                }
                sp = (EjsHttpServer*) location->context;
                httpSetServerContext(conn->server, sp);
                httpSetRequestNotifier(conn, (HttpNotifier) stateChangeNotifier);
            }
            ejs = sp->ejs;
            dirPath = (EjsPath*) ejsGetProperty(ejs, (EjsObj*) sp, ES_ejs_web_HttpServer_documentRoot);
            dir = (dirPath && ejsIsPath(ejs, dirPath)) ? dirPath->path : ".";
            req = ejsCreateRequest(ejs, sp, conn, dir);
            httpSetConnContext(conn, req);
            conn->dispatcher = ejs->dispatcher;
            conn->documentRoot = conn->server->documentRoot;
            conn->transmitter->handler = ejs->http->ejsHandler;
        }
        ejsSendEvent(sp->ejs, sp->emitter, "readable", (EjsObj*) req);
    }
}


static void startEjs(HttpQueue *q)
{
    HttpReceiver    *rec;

    rec = q->conn->receiver;
    if (!rec->form && !rec->upload) {
        runEjs(q);
    }
}


static void processEjs(HttpQueue *q)
{
    HttpReceiver    *rec;

    rec = q->conn->receiver;
    if (rec->form || rec->upload) {
        runEjs(q);
    }
}


/* 
    One time initialization of the http pipeline handler
 */
HttpStage *ejsAddWebHandler(Http *http)
{
    HttpStage   *handler;

    mprAssert(http);

    if (http->ejsHandler) {
        return http->ejsHandler;
    }
    handler = httpCreateHandler(http, "ejsHandler",
        HTTP_STAGE_GET | HTTP_STAGE_HEAD | HTTP_STAGE_POST | HTTP_STAGE_PUT | HTTP_STAGE_VARS);
    if (handler == 0) {
        return 0;
    }
    http->ejsHandler = handler;
    handler->close = closeEjs;
    handler->incomingData = incomingEjsData;
    handler->start = startEjs;
    handler->process = processEjs;
    return handler;
}


/*  
    Mark the object properties for the garbage collector
 */
static void markHttpServer(Ejs *ejs, EjsHttpServer *sp)
{
    //  MOB -- not needed
    ejsMarkObject(ejs, (EjsObj*) sp);

    if (sp->emitter) {
        ejsMark(ejs, (EjsObj*) sp->emitter);
    }
}


void ejsConfigureHttpServerType(Ejs *ejs)
{
    EjsType     *type;

    type = ejsConfigureNativeType(ejs, "ejs.web", "HttpServer", sizeof(EjsHttpServer));
    type->helpers = ejsCloneObjectHelpers(ejs, "httpserver-helpers");
    type->helpers->mark = (EjsMarkHelper) markHttpServer;

    ejsBindMethod(ejs, type, ES_ejs_web_HttpServer_HttpServer, (EjsProc) hs_HttpServer);
    ejsBindMethod(ejs, type, ES_ejs_web_HttpServer_addListener, (EjsProc) hs_addListener);
    ejsBindMethod(ejs, type, ES_ejs_web_HttpServer_address, (EjsProc) hs_address);
    ejsBindMethod(ejs, type, ES_ejs_web_HttpServer_attach, (EjsProc) hs_attach);
    ejsBindAccess(ejs, type, ES_ejs_web_HttpServer_async, (EjsProc) hs_async, (EjsProc) hs_set_async);
    ejsBindMethod(ejs, type, ES_ejs_web_HttpServer_close, (EjsProc) hs_close);
    ejsBindMethod(ejs, type, ES_ejs_web_HttpServer_listen, (EjsProc) hs_listen);
    ejsBindMethod(ejs, type, ES_ejs_web_HttpServer_port, (EjsProc) hs_port);
    ejsBindMethod(ejs, type, ES_ejs_web_HttpServer_removeListener, (EjsProc) hs_removeListener);
    ejsBindMethod(ejs, type, ES_ejs_web_HttpServer_software, (EjsProc) hs_software);
    
    ejsAddWebHandler(ejs->http);
}


/*
    @copy   default
 
    Copyright (c) Embedthis Software LLC, 2003-2010. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2010. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    @end
 */
/************************************************************************/
/*
 *  End of file "../src/jems/ejs.web/src/ejsHttpServer.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../src/jems/ejs.web/src/ejsRequest.c"
 */
/************************************************************************/

/*
    ejsRequest.c -- Ejscript web framework.

    Copyright (c) All Rights Reserved. See copyright notice at the bottom of the file.
 */



static void defineParam(Ejs *ejs, EjsObj *params, cchar *key, cchar *value);

 
static void defineParam(Ejs *ejs, EjsObj *params, cchar *key, cchar *value)
{
    EjsName     qname;
    EjsObj      *vp;
    char        *subkey, *end;
    int         slotNum;

    mprAssert(params);

    /*  
        name.name.name
     */
    if (strchr(key, '.') == 0) {
        ejsName(&qname, "", key);
        ejsSetPropertyByName(ejs, params, &qname, (EjsObj*) ejsCreateString(ejs, value));

    } else {
        subkey = mprStrdup(ejs, key);
        for (end = strchr(subkey, '.'); end; subkey = end, end = strchr(subkey, '.')) {
            *end++ = '\0';
            ejsName(&qname, "", subkey);
            vp = ejsGetPropertyByName(ejs, params, &qname);
            if (vp == 0) {
                slotNum = ejsSetPropertyByName(ejs, params, &qname, (EjsObj*) ejsCreateSimpleObject(ejs));
                vp = ejsGetProperty(ejs, params, slotNum);
            }
            params = vp;
        }
        mprAssert(params);
        ejsName(&qname, "", subkey);
        ejsSetPropertyByName(ejs, params, &qname, (EjsObj*) ejsCreateString(ejs, value));
    }
}


static EjsObj *createParams(Ejs *ejs, EjsRequest *req)
{
    EjsObj          *params;
    MprHashTable    *formVars;
    MprHash         *hp;

    if ((params = req->params) == 0) {
        params = (EjsObj*) ejsCreateSimpleObject(ejs);
        if ((formVars = req->conn->receiver->formVars) != 0) {
            hp = 0;
            while ((hp = mprGetNextHash(formVars, hp)) != NULL) {
                defineParam(ejs, params, hp->key, hp->data);
            }
        }
    }
    return req->params = params;
}


static EjsObj *createCookies(Ejs *ejs, EjsRequest *req)
{
    EjsName     n;
    EjsObj      *argv[1];
    cchar       *cookieHeader;

    if (req->cookies) {
        return (EjsObj*) req->cookies;
    }
    if ((cookieHeader = mprLookupHash(req->conn->receiver->headers, "cookie")) == 0) {
        req->cookies = (EjsObj*) ejs->nullValue;
    } else {
        argv[0] = (EjsObj*) ejsCreateString(ejs, cookieHeader);
        req->cookies = ejsRunFunctionByName(ejs, ejs->global, ejsName(&n, "ejs.web", "parseCookies"), 
            ejs->global, 1, argv);
    }
    return (EjsObj*) req->cookies;
}


static EjsObj *createEnv(Ejs *ejs, EjsRequest *req)
{
    if (req->env) {
        req->env = ejsCreateSimpleObject(ejs);
    }
    return (EjsObj*) req->env;
}


static EjsObj *createSession(Ejs *ejs, EjsRequest *req)
{
    if (req->session) {
        return (EjsObj*) req->session;
    }
    req->session = ejsCreateSession(ejs, 0, 0);
    return (EjsObj*) req->session;
}


static EjsObj *createString(Ejs *ejs, cchar *value)
{
    if (value == 0) {
        return ejs->nullValue;
    }
    return (EjsObj*) ejsCreateString(ejs, value);
}


static EjsObj *createHeaders(Ejs *ejs, EjsRequest *req)
{
    MprHash     *hp;
    HttpConn    *conn;
    EjsName     n;
    
    conn = req->conn;
    if (req->headers == 0) {
        req->headers = (EjsObj*) ejsCreateSimpleObject(ejs);
        for (hp = 0; (hp = mprGetNextHash(conn->receiver->headers, hp)) != 0; ) {
            ejsSetPropertyByName(ejs, req->headers, EN(&n, hp->key), (EjsObj*) ejsCreateString(ejs, hp->data));
        }
    }
    return (EjsObj*) req->headers;
}


static EjsObj *createFiles(Ejs *ejs, EjsRequest *req)
{
    HttpUploadFile  *up;
    HttpConn        *conn;
    EjsObj          *files, *file;
    EjsName         n;
    MprHash         *hp;
    int             index;

    if (req->files == 0) {
        conn = req->conn;
        if (conn->receiver->files == 0) {
            return ejs->nullValue;
        }
        req->files = files = (EjsObj*) ejsCreateSimpleObject(ejs);
        for (index = 0, hp = 0; (hp = mprGetNextHash(conn->receiver->files, hp)) != 0; index++) {
            up = (HttpUploadFile*) hp->data;
            file = (EjsObj*) ejsCreateSimpleObject(ejs);
            ejsSetPropertyByName(ejs, file, EN(&n, "filename"), (EjsObj*) ejsCreateString(ejs, up->filename));
            ejsSetPropertyByName(ejs, file, EN(&n, "clientFilename"), (EjsObj*) ejsCreateString(ejs, up->clientFilename));
            ejsSetPropertyByName(ejs, file, EN(&n, "contentType"), (EjsObj*) ejsCreateString(ejs, up->contentType));
            ejsSetPropertyByName(ejs, file, EN(&n, "name"), (EjsObj*) ejsCreateString(ejs, hp->key));
            ejsSetPropertyByName(ejs, file, EN(&n, "size"), (EjsObj*) ejsCreateNumber(ejs, up->size));
            ejsSetPropertyByName(ejs, files, EN(&n, hp->key), file);
        }
    }
    return (EjsObj*) req->files;
}


static char *makeRelativeHome(Ejs *ejs, EjsRequest *req)
{
    HttpReceiver    *rec;
    cchar           *path, *end, *sp;
    char            *home, *cp;
    int             slashes;

    rec = req->conn->receiver;
    mprAssert(rec->pathInfo);

    path = rec->pathInfo;
    end = &path[strlen(path)];
    slashes = 0;
    for (slashes = 0, sp = &path[1]; sp < end; sp++) {
        if (*sp == '/' && sp[-1] != '/') {
            slashes++;
        }
    }
    home = mprAlloc(req, slashes * 3 + 2);
    if (slashes) {
        for (cp = home; slashes > 0; slashes--) {
            strcpy(cp, "../");
            cp += 3;
        }
        *cp = '\0';
    } else {
        strcpy(home, ".");
    }
    return home;
}


/*
    Lookup a property. These properties are virtualized.
 */
static EjsObj *getRequestProperty(Ejs *ejs, EjsRequest *req, int slotNum)
{
    HttpConn        *conn;
    HttpReceiver    *rec;
    EjsName         n;
    EjsObj          *value;

    conn = req->conn;
    rec = conn->receiver;

    switch (slotNum) {
    case ES_ejs_web_Request_absHome:
        return (EjsObj*) ejsCreateUri(ejs, req->absHome);

    case ES_ejs_web_Request_authGroup:
        return createString(ejs, conn->authGroup);

    case ES_ejs_web_Request_authType:
        return createString(ejs, conn->authType);

    case ES_ejs_web_Request_authUser:
        return createString(ejs, conn->authUser);

    case ES_ejs_web_Request_chunkSize:
        return (EjsObj*) ejsCreateBoolean(ejs, httpGetChunkSize(conn));

    case ES_ejs_web_Request_config:
        value = ejs->objectType->helpers->getProperty(ejs, (EjsObj*) req, slotNum);
        if (value == (EjsObj*) ejs->nullValue) {
            /* Default to App.config */
            value = ejsGetProperty(ejs, (EjsObj*) ejs->appType, ES_App_config);
        }
        return value;

    case ES_ejs_web_Request_contentLength:
        return (EjsObj*) ejsCreateNumber(ejs, rec->length);

    case ES_ejs_web_Request_contentType:
        createHeaders(ejs, req);
        return ejsGetPropertyByName(ejs, req->headers, EN(&n, "content-type"));

    case ES_ejs_web_Request_cookies:
        return createCookies(ejs, req);

    case ES_ejs_web_Request_dir:
        return (EjsObj*) ejsCreatePath(ejs, req->dir);

    case ES_ejs_web_Request_env:
        return createEnv(ejs, req);

    case ES_ejs_web_Request_files:
        return createFiles(ejs, req);

    case ES_ejs_web_Request_headers:
        return createHeaders(ejs, req);

    case ES_ejs_web_Request_home:
        return (EjsObj*) ejsCreateUri(ejs, req->home);

    case ES_ejs_web_Request_host:
        return createString(ejs, rec->hostName);

    case ES_ejs_web_Request_method:
        return createString(ejs, rec->method);

    case ES_ejs_web_Request_params:
        return createParams(ejs, req);

    case ES_ejs_web_Request_pathInfo:
        return createString(ejs, rec->pathInfo);

    case ES_ejs_web_Request_query:
        return createString(ejs, rec->parsedUri->query);

    case ES_ejs_web_Request_referrer:
        return createString(ejs, rec->referer);

    case ES_ejs_web_Request_remoteAddress:
        return createString(ejs, conn->ip);

    case ES_ejs_web_Request_scheme:
        return createString(ejs, conn->protocol);

    case ES_ejs_web_Request_scriptName:
        return createString(ejs, rec->scriptName);

    case ES_ejs_web_Request_secure:
        return (EjsObj*) ejsCreateBoolean(ejs, conn->secure);

    case ES_ejs_web_Request_server:
        return (EjsObj*) req->server;

    case ES_ejs_web_Request_session:
        return createSession(ejs, req);

    case ES_ejs_web_Request_sessionID:
        if (req->session) {
            return createString(ejs, req->session->id);
        } else return ejs->nullValue;

    case ES_ejs_web_Request_status:
        return (EjsObj*) ejsCreateNumber(ejs, conn->transmitter->status);

    case ES_ejs_web_Request_timeout:
        return (EjsObj*) ejsCreateNumber(ejs, conn->timeout);

    case ES_ejs_web_Request_uri:
        return (EjsObj*) ejsCreateUri(ejs, rec->uri);

    case ES_ejs_web_Request_userAgent:
        return createString(ejs, rec->userAgent);

    default:
        if (slotNum < req->obj.numSlots) {
            return ejs->objectType->helpers->getProperty(ejs, (EjsObj*) req, slotNum);
        }
    }
    return 0;
}


static int getRequestPropertyCount(Ejs *ejs, EjsRequest *req)
{
    return ES_ejs_web_Request_NUM_INSTANCE_PROP;
}


static EjsName getRequestPropertyName(Ejs *ejs, EjsRequest *req, int slotNum)
{
    return ejsGetPropertyName(ejs, (EjsObj*) req->obj.type->prototype, slotNum);
}


static int lookupRequestProperty(Ejs *ejs, EjsRequest *req, EjsName *qname)
{
    return ejsLookupProperty(ejs, (EjsObj*) req->obj.type->prototype, qname);
}


static int getNum(Ejs *ejs, EjsObj *vp)
{
    if (!ejsIsNumber(vp) && (vp = (EjsObj*) ejsToNumber(ejs, vp)) == 0) {
        return 0;
    }
    return (int) ((EjsNumber*) vp)->value;
}


static cchar *getString(Ejs *ejs, EjsObj *vp)
{
    if (!ejsIsString(vp) && (vp = (EjsObj*) ejsToString(ejs, vp)) == 0) {
        return 0;
    }
    return ((EjsString*) vp)->value;
}


static int setRequestProperty(Ejs *ejs, EjsRequest *req, int slotNum,  EjsObj *value)
{
    HttpConn        *conn;
    HttpReceiver    *rec;

    conn = req->conn;
    rec = conn->receiver;

    switch (slotNum) {
    case ES_ejs_web_Request_absHome:
        req->absHome = mprStrdup(req, getString(ejs, value));
        break;

    case ES_ejs_web_Request_chunkSize:
        httpSetChunkSize(conn, getNum(ejs, value));
        break;

    case ES_ejs_web_Request_dir:
        req->dir = mprStrdup(req, getString(ejs, value));
        break;

    case ES_ejs_web_Request_home:
        req->home = mprStrdup(req, getString(ejs, value));
        break;

    case ES_ejs_web_Request_pathInfo:
        mprFree(rec->pathInfo);
        rec->pathInfo = mprStrdup(rec, getString(ejs, value));
        break;

    case ES_ejs_web_Request_scriptName:
        mprFree(rec->scriptName);
        rec->scriptName = mprStrdup(rec, getString(ejs, value));
        break;

    case ES_ejs_web_Request_server:
        //  MOB -- should validate type
        req->server = (EjsHttpServer*) value;
        break;

    case ES_ejs_web_Request_status:
        httpSetStatus(conn, getNum(ejs, value));
        break;

    case ES_ejs_web_Request_timeout:
        httpSetTimeout(conn, getNum(ejs, value));
        break;

    case ES_ejs_web_Request_authGroup:
    case ES_ejs_web_Request_authType:
    case ES_ejs_web_Request_authUser:
    case ES_ejs_web_Request_contentLength:
    case ES_ejs_web_Request_contentType:
    case ES_ejs_web_Request_cookies:
    case ES_ejs_web_Request_env:
    case ES_ejs_web_Request_files:
    case ES_ejs_web_Request_headers:
    case ES_ejs_web_Request_host:
    case ES_ejs_web_Request_method:
    case ES_ejs_web_Request_params:
    case ES_ejs_web_Request_query:
    case ES_ejs_web_Request_referrer:
    case ES_ejs_web_Request_remoteAddress:
    case ES_ejs_web_Request_scheme:
    case ES_ejs_web_Request_secure:
    case ES_ejs_web_Request_session:
    case ES_ejs_web_Request_sessionID:
    case ES_ejs_web_Request_uri:
    case ES_ejs_web_Request_userAgent:
        ejsThrowReferenceError(ejs, "Property is readonly");
        break;

    case ES_ejs_web_Request_config:
    default:
        return ejs->objectType->helpers->setProperty(ejs, (EjsObj*) req, slotNum, value);
    }
    return 0;
}


/*  
    function addListener(name: [String|Array], listener: Function): Void
 */
static EjsObj *req_addListener(Ejs *ejs, EjsRequest *req, int argc, EjsObj **argv)
{
    //  MOB - must issue writable + readable if data available
    ejsAddListener(ejs, &req->emitter, argv[0], argv[1]);
    return 0;
}


/*  
    function get async(): Boolean
 */
static EjsObj *req_async(Ejs *ejs, EjsRequest *req, int argc, EjsObj **argv)
{
    return httpGetAsync(req->conn) ? (EjsObj*) ejs->trueValue : (EjsObj*) ejs->falseValue;
}


/*  
    function set async(enable: Boolean): Void
 */
static EjsObj *req_set_async(Ejs *ejs, EjsRequest *req, int argc, EjsObj **argv)
{
    httpSetAsync(req->conn, (argv[0] == (EjsObj*) ejs->trueValue));
    return 0;
}


/*  
    function close(): Void
 */
static EjsObj *req_close(Ejs *ejs, EjsRequest *req, int argc, EjsObj **argv)
{
    ejsSendEvent(ejs, req->emitter, "close", (EjsObj*) req);
    httpCloseConn(req->conn);
    return 0;
}


/*  
    function getResponseHeaders(): Object
 */
static EjsObj *req_getResponseHeaders(Ejs *ejs, EjsRequest *req, int argc, EjsObj **argv)
{
    MprHash     *hp;
    HttpConn    *conn;
    EjsObj      *headers;
    EjsName     n;
    
    conn = req->conn;
    headers = (EjsObj*) ejsCreateSimpleObject(ejs);
    for (hp = 0; (hp = mprGetNextHash(conn->transmitter->headers, hp)) != 0; ) {
        ejsSetPropertyByName(ejs, headers, EN(&n, hp->key), (EjsObj*) ejsCreateString(ejs, hp->data));
    }
    return (EjsObj*) headers;
}


/*  
    function destroySession(): Void
 */
static EjsObj *req_destroySession(Ejs *ejs, EjsRequest *req, int argc, EjsObj **argv)
{
    ejsDestroySession(ejs, req->session);
    return 0;
}


/*  
    function finalize(): Void
 */
static EjsObj *req_finalize(Ejs *ejs, EjsRequest *req, int argc, EjsObj **argv)
{
    httpFinalize(req->conn);
    return 0;
}


/*  
    function read(buffer, offset, count): Number
 */
static EjsObj *req_read(Ejs *ejs, EjsRequest *req, int argc, EjsObj **argv)
{
    EjsByteArray    *ba;
    int             offset, count, nbytes;

    ba = (EjsByteArray*) argv[0];
    offset = (argc >= 1) ? ejsGetInt(ejs, argv[1]) : 0;
    count = (argc >= 2) ? ejsGetInt(ejs, argv[2]) : -1;

    if (offset < 0) {
        offset = ba->writePosition;
    }
    if (count < 0) {
        count = ba->length - offset;
    }
    if (count < 0) {
        ejsThrowStateError(ejs, "Read count is negative");
        return 0;
    }
    nbytes = httpRead(req->conn, (char*) &ba->value[offset], count);
    if (nbytes < 0) {
        ejsThrowIOError(ejs, "Can't read from socket");
        return 0;
    }
    if (nbytes == 0) {
        if (httpIsEof(req->conn)) {
            return (EjsObj*) ejs->nullValue;
        }
    }
    ba->writePosition += nbytes;
    return (EjsObj*) ejsCreateNumber(ejs, nbytes);
}


/*  
    function removeListener(name: [String|Array], listener: Function): Void
 */
static EjsObj *req_removeListener(Ejs *ejs, EjsRequest *req, int argc, EjsObj **argv)
{
    ejsRemoveListener(ejs, req->emitter, argv[0], argv[1]);
    return 0;
}


/*  
    function setHeader(key: String, value: String, overwrite: Boolean = true): Void
 */
static EjsObj *req_setHeader(Ejs *ejs, EjsRequest *req, int argc, EjsObj **argv)
{
    cchar   *key, *value;
    int     overwrite;

    key = ejsGetString(ejs, argv[0]);
    value = ejsGetString(ejs, argv[1]);
    overwrite = argc < 3 || argv[2] == (EjsObj*) ejs->trueValue;
    if (overwrite) {
        httpSetSimpleHeader(req->conn, key, value);
    } else {
        httpAppendHeader(req->conn, key, "%s", value);
    }
    return 0;
}


/*  
    Write text to the client. This call writes the arguments back to the client's browser. 
    function write(data: Object): Void
 */
static EjsObj *req_write(Ejs *ejs, EjsRequest *req, int argc, EjsObj **argv)
{
    EjsString       *s;
    EjsObj          *data;
    EjsByteArray    *ba;
    HttpQueue       *q;
    HttpConn        *conn;
    int             err, len;

    err = 0;
    data = argv[0];
    conn = req->conn;
    q = conn->writeq;

    if (httpIsFinalized(conn)) {
        ejsThrowIOError(ejs, "Response already finalized");
        return 0;
    }

    switch (data->type->id) {
    case ES_String:
        s = (EjsString*) data;
        //  MOB -- this is blocking
        if (httpWriteBlock(q, s->value, s->length, 1) != s->length) {
            err++;
        }
        break;

    case ES_ByteArray:
        ba = (EjsByteArray*) data;
        len = ba->writePosition - ba->readPosition;
        if (httpWriteBlock(q, (char*) &ba->value[ba->readPosition], len, 1) != len) {
            err++;
        }
        break;

    default:
        s = (EjsString*) ejsToString(ejs, data);
        if (s && httpWriteBlock(q, s->value, s->length, 1) != s->length) {
            err++;
        }
    }
    if (ejs->exception) {
        return 0;
    }
    if (err) {
        ejsThrowIOError(ejs, "Can't write to browser");
    }
    return 0;
}



//  MOB - standardize on either Copy or Clone
//  MOB -- who is using this?

EjsRequest *ejsCloneRequest(Ejs *ejs, EjsRequest *req, bool deep)
{
    EjsRequest  *newReq;
    HttpConn    *conn;

    newReq = (EjsRequest*) ejsCloneObject(ejs, (EjsObj*) req, deep);
    if (newReq == 0) {
        ejsThrowMemoryError(ejs);
        return 0;
    }
    conn = req->conn;
    newReq->conn = conn;
    newReq->ejs = req->ejs;
#if UNUSED
    newReq->pathInfo = conn->receiver->pathInfo;
    newReq->scriptName = conn->receiver->scriptName;
#endif
    newReq->dir = mprStrdup(newReq, req->dir);
    newReq->home = mprStrdup(newReq, req->home);
    newReq->absHome = mprStrdup(newReq, req->absHome);

    //  MOB -- problematic. This is a cross-interp link
    newReq->server = req->server;
    return newReq;
}


EjsRequest *ejsCreateRequest(Ejs *ejs, EjsHttpServer *server, HttpConn *conn, cchar *dir)
{
    EjsRequest      *req;
    EjsType         *type;
    HttpReceiver    *rec;
    cchar           *scheme;

    type = ejsGetTypeByName(ejs, "ejs.web", "Request");
    if ((req = (EjsRequest*) ejsCreate(ejs, type, 0)) == NULL) {
        return 0;
    }
    req->conn = conn;
    req->ejs = ejs;
    req->server = server;
    rec = conn->receiver;
#if UNUSED
    req->pathInfo = rec->pathInfo;
    req->scriptName = rec->scriptName;
#endif
    req->dir = mprGetAbsPath(req, dir);
    req->home = makeRelativeHome(ejs, req);
    scheme = conn->secure ? "https" : "http";
    //  MOB -- should there be a way to get a symbolic server name?
    req->absHome = mprAsprintf(req, -1, "%s://%s:%d%s/", scheme, server->ip, server->port, rec->scriptName);
    return req;
}


/*  
    Mark the object properties for the garbage collector
 */
static void markRequest(Ejs *ejs, EjsRequest *req)
{
    ejsMarkObject(ejs, (EjsObj*) req);
    if (req->cookies) {
        ejsMark(ejs, (EjsObj*) req->cookies);
    }
    if (req->emitter) {
        ejsMark(ejs, (EjsObj*) req->emitter);
    }
    if (req->env) {
        ejsMark(ejs, (EjsObj*) req->env);
    }
    if (req->files) {
        ejsMark(ejs, (EjsObj*) req->files);
    }
    if (req->headers) {
        ejsMark(ejs, (EjsObj*) req->headers);
    }
    if (req->params) {
        ejsMark(ejs, (EjsObj*) req->params);
    }
    if (req->server) {
        ejsMark(ejs, (EjsObj*) req->server);
    }
    if (req->session) {
        ejsMark(ejs, (EjsObj*) req->session);
    }
}


void ejsConfigureRequestType(Ejs *ejs)
{
    EjsType     *type;

    type = ejs->requestType = ejsConfigureNativeType(ejs, "ejs.web", "Request", sizeof(EjsRequest));

    type->helpers = ejsCloneObjectHelpers(ejs, "request-helpers");
    type->helpers->mark = (EjsMarkHelper) markRequest;
    type->helpers->clone = (EjsCloneHelper) ejsCloneRequest;
    type->helpers->getProperty = (EjsGetPropertyHelper) getRequestProperty;
    type->helpers->getPropertyCount = (EjsGetPropertyCountHelper) getRequestPropertyCount;
    type->helpers->getPropertyName = (EjsGetPropertyNameHelper) getRequestPropertyName;
    type->helpers->lookupProperty = (EjsLookupPropertyHelper) lookupRequestProperty;
    type->helpers->setProperty = (EjsSetPropertyHelper) setRequestProperty;

    ejsBindMethod(ejs, type, ES_ejs_web_Request_addListener, (EjsProc) req_addListener);
    ejsBindAccess(ejs, type, ES_ejs_web_Request_async, (EjsProc) req_async, (EjsProc) req_set_async);
    ejsBindMethod(ejs, type, ES_ejs_web_Request_close, (EjsProc) req_close);
    ejsBindMethod(ejs, type, ES_ejs_web_Request_destroySession, (EjsProc) req_destroySession);
    ejsBindMethod(ejs, type, ES_ejs_web_Request_finalize, (EjsProc) req_finalize);
    ejsBindMethod(ejs, type, ES_ejs_web_Request_getResponseHeaders, (EjsProc) req_getResponseHeaders);
    ejsBindMethod(ejs, type, ES_ejs_web_Request_read, (EjsProc) req_read);
    ejsBindMethod(ejs, type, ES_ejs_web_Request_removeListener, (EjsProc) req_removeListener);
    ejsBindMethod(ejs, type, ES_ejs_web_Request_setHeader, (EjsProc) req_setHeader);
    ejsBindMethod(ejs, type, ES_ejs_web_Request_write, (EjsProc) req_write);

#if UNUSED
    for (i = 0; i < ES_ejs_web_Request_NUM_INSTANCE_PROP; i++) {
        if ((trait = ejsGetTrait((EjsObj*) type->prototype, i)) != 0) {
            trait->attributes &= ~EJS_TRAIT_HIDDEN;
        }
    }
#endif
}


/*
    @copy   default
 
    Copyright (c) Embedthis Software LLC, 2003-2010. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2010. All Rights Reserved.
 
    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.
 
    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html
 
    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 
    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com
 
    @end
 */
/************************************************************************/
/*
 *  End of file "../src/jems/ejs.web/src/ejsRequest.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../src/jems/ejs.web/src/ejsSession.c"
 */
/************************************************************************/

/**
    ejsSession.c - Native code for the Session class.
    This provides an in-memory, server-local session state store. It is fast, non-durable, non-scalable.

    The Session class serializes objects that are stored to the session object.

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */




static void noteSessionActivity(Ejs *ejs, EjsSession *sp);
static void sessionTimer(Ejs *ejs, MprEvent *event);


static EjsVar *getSessionProperty(Ejs *ejs, EjsSession *sp, int slotNum)
{
    EjsVar      *vp;
    Ejs         *master;

    master = ejs->master ? ejs->master : ejs;
    ejsLockVm(master);
    vp = ejs->objectType->helpers->getProperty(ejs, (EjsVar*) sp, slotNum);
    if (vp) {
        vp = ejsDeserialize(ejs, (EjsString*) vp);
    }
    if (vp == ejs->undefinedValue) {
        vp = (EjsVar*) ejs->emptyStringValue;
    }
    noteSessionActivity(ejs, sp);
    ejsUnlockVm(master);
    return vp;
}


static EjsVar *getSessionPropertyByName(Ejs *ejs, EjsSession *sp, EjsName *qname)
{
    EjsVar      *vp;
    Ejs         *master;
    int         slotNum;

    qname->space = EJS_EMPTY_NAMESPACE;
    master = ejs->master ? ejs->master : ejs;
    ejsLockVm(master);

    slotNum = ejs->objectType->helpers->lookupProperty(ejs, (EjsVar*) sp, qname);
    if (slotNum < 0) {
        /*  
            Return empty string so that web pages can access session values without having to test for null/undefined
         */
        vp = (EjsVar*) ejs->emptyStringValue;
    } else {
        vp = ejs->objectType->helpers->getProperty(ejs, (EjsVar*) sp, slotNum);
        if (vp) {
            vp = ejsDeserialize(ejs, (EjsString*) vp);
        }
    }
    noteSessionActivity(ejs, sp);
    ejsUnlockVm(master);
    return vp;
}


static int setSessionProperty(Ejs *ejs, EjsSession *sp, int slotNum, EjsVar *value)
{
    Ejs     *master;
    
    /*  
        Allocate the serialized object using the master interpreter
     */
    master = ejs->master ? ejs->master : ejs;
    ejsLockVm(master);

    value = (EjsVar*) ejsToJSON(master, value, NULL);
    slotNum = master->objectType->helpers->setProperty(master, (EjsVar*) sp, slotNum, value);
    noteSessionActivity(ejs, sp);
    ejsUnlockVm(master);
    return slotNum;
}


/*  
    Update the session expiration time due to activity
 */
static void noteSessionActivity(Ejs *ejs, EjsSession *sp)
{
    sp->expire = mprGetTime(ejs) + sp->timeout * MPR_TICKS_PER_SEC;
}


/*  
    Check for expired sessions
 */
static void sessionTimer(Ejs *ejs, MprEvent *event)
{
    Ejs             *master;
    EjsObj          *sessions;
    EjsSession      *session;
    MprTime         now;
    int             i, count, deleted;

    now = mprGetTime(ejs);

    sessions = ejs->sessions;
    master = ejs->master;
    if (master == 0) {
        mprAssert(master);
        return;
    }

    /*  
        This could be on the primary event thread. Can't block long.
     */
    if (mprTryLock(master->mutex)) {
        count = ejsGetPropertyCount(master, (EjsVar*) sessions);
        deleted = 0;
        for (i = count - 1; i >= 0; i--) {
            session = (EjsSession*) ejsGetProperty(master, (EjsVar*) sessions, i);
            if (session->obj.type == ejs->sessionType) {
                if (session && session->expire <= now) {
                    ejsDeleteProperty(master, (EjsVar*) sessions, i);
                    deleted++;
                }
            }
        }
        if (deleted) {
            ejsCollectGarbage(master, EJS_GEN_NEW);
        }
        if (count == 0) {
            ejs->sessionTimer = 0;
            mprFree(event);
        }
        mprUnlock(master->mutex);
    }
}


#if UNUSED
void ejsParseWebSessionCookie(EjsRequest *req)
{
    EjsName         qname;
    char            *cookie, *id, *cp, *value;
    int             quoted, len;

    cookie = req->cookie;
    while (cookie && (value = strstr(cookie, EJS_SESSION)) != 0) {
        value += strlen(EJS_SESSION);
        while (isspace((int) *value) || *value == '=') {
            value++;
        }
        quoted = 0;
        if (*value == '"') {
            value++;
            quoted++;
        }
        for (cp = value; *cp; cp++) {
            if (quoted) {
                if (*cp == '"' && cp[-1] != '\\') {
                    break;
                }
            } else {
                if ((*cp == ',' || *cp == ';') && cp[-1] != '\\') {
                    break;
                }
            }
        }
        len = cp - value;
        id = mprMemdup(req, value, len + 1);
        id[len] = '\0';

        if (ejs->master) {
            ejsName(&qname, "", id);
            req->session = (EjsSession*) ejsGetPropertyByName(ejs->master, (EjsVar*) ejs->sessions, &qname);
        }
        mprFree(id);
        cookie = value;
    }
}
#endif


/*  
    Create a new session object. This is created in the master interpreter and will persist past the life 
    of the current request. This will allocate a new session ID. Timeout is in seconds.
 */
EjsSession *ejsCreateSession(Ejs *ejs, int timeout, bool secure)
{
    Ejs             *master;
    EjsSession      *session;
    EjsName         qname;
    MprTime         now, expire;
    char            idBuf[64], *id;
    int             slotNum, next;

    master = ejs->master;
    if (master == 0) {
        return 0;
    }
    if (timeout <= 0) {
        timeout = ejs->sessionTimeout;
    }
    now = mprGetTime(ejs);
    expire = now + timeout * MPR_TICKS_PER_SEC;

    ejsLockVm(master);
    session = (EjsSession*) ejsCreateObject(master, ejs->sessionType, 0);
    if (session == 0) {
        ejsUnlockVm(master);
        return 0;
    }
    session->timeout = timeout;
    session->expire = mprGetTime(ejs) + timeout * MPR_TICKS_PER_SEC;
    /*  
        Use an MD5 prefix of "x" to avoid the hash being interpreted as a numeric index.
     */
    next = ejs->nextSession++;
    mprSprintf(idBuf, sizeof(idBuf), "%08x%08x%d", PTOI(ejs) + + PTOI(expire), (int) now, next);
    id = mprGetMD5Hash(session, idBuf, sizeof(idBuf), "x");
    if (id == 0) {
        mprFree(session);
        ejsUnlockVm(master);
        return 0;
    }
    session->id = mprStrdup(session, id);

    slotNum = ejsSetPropertyByName(ejs->master, (EjsVar*) ejs->sessions, EN(&qname, session->id), (EjsVar*) session);
    if (slotNum < 0) {
        mprFree(session);
        ejsUnlockVm(master);
        return 0;
    }
    session->index = slotNum;

    if (ejs->sessionTimer == 0) {
        ejs->sessionTimer = mprCreateTimerEvent(mprGetDispatcher(ejs), "sessionTimer", EJS_TIMER_PERIOD, 
            (MprEventProc) sessionTimer, ejs, MPR_EVENT_CONTINUOUS);
    }
    ejsUnlockVm(master);

    mprLog(ejs, 3, "Created new session %s", id);

#if TODO
    //  TODO - need to set out of band 
    /*  
        Create a cookie that will only live while the browser is not exited. (Set timeout to zero).
     */
    ejsSetCookie(ejs, EJS_SESSION, id, "/", NULL, 0, secure);
#endif
    ejsSendEvent(ejs, ejs->emitter, "createSession", (EjsObj*) session);
    return session;
}


/*  
    Destroy a session. Return true if destroyed. Return 0 if cancelled. 
 */
int ejsDestroySession(Ejs *ejs, EjsSession *session)
{
    EjsName     qname;
    MprTime     now;

    if (session) {
        //  MOB -- but users can't do anything with a bare session. They really need the request object.
        ejsSendEvent(ejs, ejs->emitter, "destroySession", (EjsObj*) session);
        now = mprGetTime(ejs);
        if (session->expire <= now) {
            ejsDeletePropertyByName(ejs->master, (EjsVar*) ejs->sessions, EN(&qname, session->id));
            return 1;
        }
    }
    return 0;
}


/*  
    function addListener(name: [String|Array], listener: Function): Void
 */
static EjsObj *sess_addListener(Ejs *ejs, EjsSession *sp, int argc, EjsObj **argv)
{
    ejsAddListener(ejs, &ejs->emitter, argv[0], argv[1]);
    return 0;
}


/*  
    function get count(): Number
 */
static EjsObj *sess_count(Ejs *ejs, EjsSession *sp, int argc, EjsObj **argv)
{
    return 0;
}


/*  
    function removeListener(name: [String|Array], listener: Function): Void
 */
static EjsObj *sess_removeListener(Ejs *ejs, EjsSession *sp, int argc, EjsObj **argv)
{
    ejsRemoveListener(ejs, ejs->emitter, argv[0], argv[1]);
    return 0;
}


void ejsConfigureSessionType(Ejs *ejs)
{
    EjsType     *type;

    type = ejs->sessionType = ejsConfigureNativeType(ejs, "ejs.web", "Session", sizeof(EjsSession));

    type->helpers = ejsCloneObjectHelpers(ejs, "session-helpers");
    type->helpers->getProperty = (EjsGetPropertyHelper) getSessionProperty;
    type->helpers->getPropertyByName = (EjsGetPropertyByNameHelper) getSessionPropertyByName;
    type->helpers->setProperty = (EjsSetPropertyHelper) setSessionProperty;

    ejsBindMethod(ejs, type, ES_ejs_web_Session_addListener, (EjsFun) sess_addListener);
    ejsBindMethod(ejs, type, ES_ejs_web_Session_count, (EjsFun) sess_count);
    ejsBindMethod(ejs, type, ES_ejs_web_Session_removeListener, (EjsFun) sess_removeListener);
}


/*
    @copy   default
 
    Copyright (c) Embedthis Software LLC, 2003-2010. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2010. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    @end
 */
/************************************************************************/
/*
 *  End of file "../src/jems/ejs.web/src/ejsSession.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../src/jems/ejs.web/src/ejsWeb.c"
 */
/************************************************************************/

/*
    ejsWeb.c -- Ejscript web framework.

    Copyright (c) All Rights Reserved. See copyright notice at the bottom of the file.
 */



static int configureWebTypes(Ejs *ejs);


static int requestWorker(EjsRequest *req)
{
    Ejs         *ejs;
    EjsObj      *argv[1];

    ejs = req->ejs;
    argv[0] = (EjsObj*) req;
    ejsRunFunctionBySlot(ejs, ejs->global, ES_ejs_web_Web_workerHelper, 1, argv);
    return 0; 
}


static EjsObj *req_worker(Ejs *ejs, EjsRequest *req, int argc, EjsObj **argv)
{
    Ejs         *nejs;
    EjsRequest  *nreq;
    HttpConn    *conn;

#if TRY
    if ((nejs = ejsCreateVm(ejsService, ejs, NULL, NULL, 0)) == 0) {
        //  THROW
        return 0;
    }
#else
    //  Cloning ejs would be faster
    //  MOB -- need to pick up service
    if ((nejs = ejsCreateVm(ejsGetService(req), NULL, NULL, NULL, EJS_FLAG_MASTER)) == 0) {
        //  THROW
        return 0;
    }
    nejs->location = ejs->location;
    if (ejsLoadModule(ejs, "ejs.web", -1, -1, 0) < 0) {
        mprError(ejs, "Can't load ejs.web.mod: %s", ejsGetErrorMsg(ejs, 1));
        return 0;
    }
#endif
    conn = req->conn;
    nreq = ejsCloneRequest(ejs, req, 1);
    httpSetConnContext(req->conn, nreq);
    conn->dispatcher = nejs->dispatcher;

    //  MOB -- need to schedule event to pick up the request
    //  MOB -- missing server object **** Remove from Request.server
    //      may need documentRoot and serverRoot in Request then
    if (mprCreateEvent(nejs->dispatcher, "RequestWorker", 0, (MprEventProc) requestWorker, nreq, 0) < 0) {
        ejsThrowStateError(ejs, "Can't create worker event");
    }
    return 0;
}


static int configureWebTypes(Ejs *ejs)
{
    EjsType     *type;

    type = ejsGetTypeByName(ejs, "ejs.web", "Web");
    if (type == 0) {
        mprError(ejs, "Can't find Web class");
        ejs->hasError = 1;
        return MPR_ERR_CANT_INITIALIZE;
    }
    ejs->webType = type;

    ejsBindMethod(ejs, type, ES_ejs_web_Web_worker, (EjsProc) req_worker);

    ejsConfigureHttpServerType(ejs);
    ejsConfigureRequestType(ejs);
    ejsConfigureSessionType(ejs);
    return 0;
}


/*  
    Module load entry point
 */
int ejs_web_Init(MprCtx ctx)
{
    return ejsAddNativeModule(ctx, "ejs.web", configureWebTypes, _ES_CHECKSUM_ejs_web, EJS_LOADER_ETERNAL);
}


/*
    @copy   default
 
    Copyright (c) Embedthis Software LLC, 2003-2010. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2010. All Rights Reserved.
 
    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.
 
    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html
 
    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 
    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com
 
    @end
 */
/************************************************************************/
/*
 *  End of file "../src/jems/ejs.web/src/ejsWeb.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../src/compiler/ecAst.c"
 */
/************************************************************************/

/**
    ecAst.c - Process AST nodes and define all variables.

    Note on error handling. If a non-recoverable error occurs, then EcCompiler.hasFatalError will be set and
    processing will be aborted. If a recoverable error occurs, then hasError will be set and processing will continue.

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */



/*
    State level macros. Enter/Leave manage state and inheritance of state.
 */
#undef ENTER
#define ENTER(cp) if (ecEnterState(cp) < 0) { return; } else

#undef LEAVE
#define LEAVE(cp) ecLeaveState(cp)


static void     addGlobalProperty(EcCompiler *cp, EcNode *np, EjsName *qname);
static void     addScope(EcCompiler *cp, EjsBlock *block);
static void     allocName(Ejs *ejs, EjsName *qname);
static void     astBinaryOp(EcCompiler *cp, EcNode *np);
static void     astBindName(EcCompiler *cp, EcNode *np);
static void     astBlock(EcCompiler *cp, EcNode *np);
static void     astBreak(EcCompiler *cp, EcNode *np);
static void     astCall(EcCompiler *cp, EcNode *np);
static void     astCaseElements(EcCompiler *cp, EcNode *np);
static void     astCaseLabel(EcCompiler *cp, EcNode *np);
static void     astCatch(EcCompiler *cp, EcNode *np);
static void     astClass(EcCompiler *cp, EcNode *np);
static void     astDirectives(EcCompiler *cp, EcNode *np);
static void     astDot(EcCompiler *cp, EcNode *np);
static void     astDo(EcCompiler *cp, EcNode *np);
static void     astError(EcCompiler *cp, EcNode *np, char *fmt, ...);
static void     astExpressions(EcCompiler *cp, EcNode *np);
static void     astField(EcCompiler *cp, EcNode *np);
static void     astFor(EcCompiler *cp, EcNode *np);
static void     astForIn(EcCompiler *cp, EcNode *np);
static void     astFunction(EcCompiler *cp, EcNode *np);
static void     astHash(EcCompiler *cp, EcNode *np);
static void     astIf(EcCompiler *cp, EcNode *np);
static void     astName(EcCompiler *cp, EcNode *np);
static void     astNew(EcCompiler *cp, EcNode *np);
static void     astObjectLiteral(EcCompiler *cp, EcNode *np);
static void     astPostfixOp(EcCompiler *cp, EcNode *np);
static void     astPragmas(EcCompiler *cp, EcNode *np);
static void     astPragma(EcCompiler *cp, EcNode *np);
static void     astProgram(EcCompiler *cp, EcNode *np);
static void     astReturn(EcCompiler *cp, EcNode *np);
static void     astSuper(EcCompiler *cp, EcNode *np);
static void     astSwitch(EcCompiler *cp, EcNode *np);
static void     astThis(EcCompiler *cp, EcNode *np);
static void     astThrow(EcCompiler *cp, EcNode *np);
static void     astTry(EcCompiler *cp, EcNode *np);
static void     astUnaryOp(EcCompiler *cp, EcNode *np);
static void     astModule(EcCompiler *cp, EcNode *np);
static void     astUseNamespace(EcCompiler *cp, EcNode *np);
static void     astVar(EcCompiler *cp, EcNode *np, int varKind, EjsObj *value);
static void     astVarDefinition(EcCompiler *cp, EcNode *np, int *codeRequired, int *instanceCode);
static void     astVoid(EcCompiler *cp, EcNode *np);
static void     astWarn(EcCompiler *cp, EcNode *np, char *fmt, ...);
static void     astWith(EcCompiler *cp, EcNode *np);
static void     badAst(EcCompiler *cp, EcNode *np);
static void     bindVariableDefinition(EcCompiler *cp, EcNode *np);
static void     closeBlock(EcCompiler *cp);
static EjsNamespace *createHoistNamespace(EcCompiler *cp, EjsObj *obj);
static EjsModule    *createModule(EcCompiler *cp, EcNode *np);
static EjsFunction *createModuleInitializer(EcCompiler *cp, EcNode *np, EjsModule *mp);
static int      defineParameters(EcCompiler *cp, EcNode *np);
static void     defineVar(EcCompiler *cp, EcNode *np, int varKind, EjsObj *value);
static void     fixupTypeSlots(EcCompiler *cp, EjsType *type);
static EcNode   *getNextAstNode(EcCompiler *cp, EcNode *np, int *next);
static EjsObj   *getTypeProperty(EcCompiler *cp, EjsObj *vp, EjsName *name);
static bool     hoistBlockVar(EcCompiler *cp, EcNode *np);
static void     openBlock(EcCompiler *cp, EcNode *np, EjsBlock *block);
static void     processAstNode(EcCompiler *cp, EcNode *np);
static void     removeProperty(EcCompiler *cp, EjsObj *block, EcNode *np);
static EjsNamespace *resolveNamespace(EcCompiler *cp, EcNode *np, EjsObj *block, bool *modified);
static void     removeScope(EcCompiler *cp);
static int      resolveName(EcCompiler *cp, EcNode *node, EjsObj *vp,  EjsName *name);
static void     setAstDocString(Ejs *ejs, EcNode *np, EjsObj *block616G, int slotNum);
static EjsNamespace *ejsLookupNamespace(Ejs *ejs, cchar *namespace);
static int      ecLookupVarWithNamespaces(Ejs *ejs, EjsObj *originalObj, EjsObj *vp, EjsName *name, EjsLookup *lookup);

/*
    Top level AST node processing.
 */
static int astProcess(EcCompiler *cp, EcNode *np)
{
    Ejs     *ejs;
    int     phase;

    if (ecEnterState(cp) < 0) {
        return EJS_ERR;
    }

    ejs = cp->ejs;
    cp->blockState = cp->state;

    /*
        We do 5 phases over all the nodes: define, conditional, fixup, bind and erase
     */
    for (phase = 0; phase < EC_AST_PHASES && cp->errorCount == 0; phase++) {
        /*
            Looping through the input source files. A single top level node describes the source file.
         */
        cp->phase = phase;
        cp->fileState = cp->state;
        cp->fileState->strict = cp->strict;
        processAstNode(cp, np);
    }
    ecLeaveState(cp);
    cp->fileState = 0;
    cp->blockState = 0;
    cp->error = 0;
    return (cp->errorCount > 0) ? EJS_ERR : 0;
}


int ecAstProcess(EcCompiler *cp, int argc, EcNode **nodes)
{
    Ejs         *ejs;
    EcNode      *np;
    int         phase, i;

    if (ecEnterState(cp) < 0) {
        return EJS_ERR;
    }

    ejs = cp->ejs;
    cp->blockState = cp->state;

    /*
        We do 5 phases over all the nodes: define, load, fixup, block vars and bind
     */
    for (phase = 0; phase < EC_AST_PHASES && cp->errorCount == 0; phase++) {
        cp->phase = phase;

        /*
            Loop over each source file
         */
        for (i = 0; i < argc && !cp->fatalError; i++) {
            /*
                Looping through the input source files. A single top level node describes the source file.
             */
            np = nodes[i];
            if (np == 0) {
                continue;
            }

            cp->fileState = cp->state;
            cp->fileState->strict = cp->strict;
            processAstNode(cp, np);
        }
    }
    ecLeaveState(cp);
    cp->fileState = 0;
    cp->blockState = 0;
    cp->error = 0;
    return (cp->errorCount > 0) ? EJS_ERR : 0;
}


static void astArgs(EcCompiler *cp, EcNode *np)
{
    EcNode      *child;
    int         next;

    ENTER(cp);

    mprAssert(np->kind == N_ARGS);

    next = 0;
    while ((child = getNextAstNode(cp, np, &next))) {
        processAstNode(cp, child);
    }
    LEAVE(cp);
}


/*
    Generate an assignment expression
 */
static void astAssignOp(EcCompiler *cp, EcNode *np)
{
    EcState     *state;
    EjsFunction *fun;
    int         rc, next;

    ENTER(cp);

    state = cp->state;
    rc = 0;
    next = 0;

    mprAssert(np->kind == N_ASSIGN_OP);
    mprAssert(np->left);
    mprAssert(np->right);

    if (state->inSettings && cp->phase >= EC_PHASE_BIND) {
        /*
            Assignment in a class initializer. The lhs must be scoped outside the block. The rhs must be scoped inside.
         */
        fun = state->currentFunction;
        openBlock(cp, state->currentFunctionNode->function.body, (EjsBlock*) fun);
        ejsDefineReservedNamespace(cp->ejs, (EjsBlock*) fun, 0, EJS_PRIVATE_NAMESPACE);
        processAstNode(cp, np->right);
        closeBlock(cp);

    } else {
        processAstNode(cp, np->right);
    }

    state->onLeft = 1;
    processAstNode(cp, np->left);
    LEAVE(cp);
}


/*
    Handle a binary operator. We recursively process left and right nodes.
 */
static void astBinaryOp(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);

    mprAssert(np->kind == N_BINARY_OP);

    if (np->left) {
        processAstNode(cp, np->left);
    }
    if (np->right) {
        processAstNode(cp, np->right);
    }
    LEAVE(cp);
}


static void defineBlock(EcCompiler *cp, EcNode *np)
{
    Ejs         *ejs;
    EcState     *state;
    EjsBlock    *block;
    EjsObj      *letBlock;
    int         slotNum;

    ejs = cp->ejs;
    state = cp->state;
    letBlock = state->letBlock;

    mprAssert(cp->phase == EC_PHASE_CONDITIONAL);
    mprAssert(np->kind == N_BLOCK || np->kind == N_MODULE);

    block = np->blockRef;

    if (np->createBlockObject) {
        allocName(ejs, &np->qname);
        slotNum = ejsDefineProperty(ejs, letBlock, -1, &np->qname, block->obj.type, 0, (EjsObj*) block);
        if (slotNum < 0) {
            astError(cp, np, "Can't define block");

        } else {
            np->blockCreated = 1;
            if (letBlock == ejs->global) {
                addGlobalProperty(cp, np, &np->qname);
            }
        }
    } else {
        block->obj.hidden = 1;
    }
}


static void bindBlock(EcCompiler *cp, EcNode *np)
{
    Ejs         *ejs;
    EjsBlock    *block;
    int         rc;
    
    mprAssert(cp->phase == EC_PHASE_BIND);
    mprAssert(np->kind == N_BLOCK || np->kind == N_MODULE);

    ejs = cp->ejs;
    block = np->blockRef;
    mprAssert(block);

    rc = resolveName(cp, np, 0, &np->qname);

    if (np->blockCreated) {
        if (! np->createBlockObject) {
            mprAssert(cp->lookup.obj);
            mprAssert(np->lookup.slotNum >= 0);
            ejsDeleteProperty(ejs, np->lookup.obj, np->lookup.slotNum);
            np->blockCreated = 0;
            np->lookup.ref->hidden = 1;

        } else {
            /*
                Mark the parent block as needing to be created to hold this block.
             */
            if (cp->state->prev->letBlockNode) {
                cp->state->prev->letBlockNode->createBlockObject = 1;
            }
        }
    }
}


static void astBlock(EcCompiler *cp, EcNode *np)
{
    EcNode      *child;
    int         next;

    ENTER(cp);
    
    if (cp->phase == EC_PHASE_BIND) {
        /*
            Bind the block here before processing the child nodes so we can mark the block as hidden if it will be expunged.
         */
        bindBlock(cp, np);
    }

    /*
        Open block will change state->letBlock which we need preserved in defineBlock. Use ENTER/LEAVE to save and restore.
     */
    ENTER(cp);
    openBlock(cp, np, NULL);

    next = 0;
    while ((child = getNextAstNode(cp, np, &next))) {
        processAstNode(cp, child);
    }

    closeBlock(cp);
    LEAVE(cp);

    if (cp->phase == EC_PHASE_CONDITIONAL) {
        /*
            Do define block after the variables have been processed. This allows us to determine if the block is 
            really needed.
         */
        defineBlock(cp, np);

        /*
            Try to hoist the block object itself
         */
        if (np->blockCreated && !hoistBlockVar(cp, np)) {
            cp->state->letBlockNode->createBlockObject = 1;
        }
    }
    LEAVE(cp);
}


static void astBreak(EcCompiler *cp, EcNode *np)
{
    mprAssert(np->kind == N_BREAK);
}


static void astCall(EcCompiler *cp, EcNode *np)
{
    EcState         *state;

    mprAssert(np->kind == N_CALL);

    ENTER(cp);
    
    state = cp->state;

    if (state->onLeft) {
        astError(cp, np, "Invalid call expression on the left hand side of assignment");
        LEAVE(cp);
        return;
    }
    if (np->right) {
        mprAssert(np->right->kind == N_ARGS);
        astArgs(cp, np->right);
    }
    processAstNode(cp, np->left);

    /*
        Propagate up the right side qname and lookup.
     */
    if (cp->phase >= EC_PHASE_BIND) {
        if (np->left) {
            np->lookup = np->left->lookup;
            np->qname = np->left->qname;
        }
    }
    LEAVE(cp);
}


static void astCaseElements(EcCompiler *cp, EcNode *np)
{
    EcNode      *child;
    int         next;

    ENTER(cp);

    mprAssert(np->kind == N_CASE_ELEMENTS);

    next = 0;
    while ((child = getNextAstNode(cp, np, &next))) {
        processAstNode(cp, child);
    }
    LEAVE(cp);
}


static void astCaseLabel(EcCompiler *cp, EcNode *np)
{
    EcNode      *child;
    int         next;

    ENTER(cp);

    mprAssert(np->kind == N_CASE_LABEL);

    if (np->caseLabel.kind == EC_SWITCH_KIND_CASE) {
        mprAssert(np->caseLabel.expression);
        processAstNode(cp, np->caseLabel.expression);

    } else {
        mprAssert(np->caseLabel.kind == EC_SWITCH_KIND_DEFAULT);
    }

    /*
        Process the directives for this case label
     */
    next = 0;
    while ((child = getNextAstNode(cp, np, &next))) {
        processAstNode(cp, child);
    }
    LEAVE(cp);
}


static void astCatch(EcCompiler *cp, EcNode *np)
{
    EjsBlock    *block;

    ENTER(cp);

    block = ejsCreateBlock(cp->ejs, 0);
    ejsSetDebugName(block, "catch");
    addScope(cp, block);

    processAstNode(cp, np->left);
    removeScope(cp);
    LEAVE(cp);
}


static EjsType *defineClass(EcCompiler *cp, EcNode *np)
{
    Ejs             *ejs;
    EjsType         *type;
    EcState         *state;
    EcNode          *constructor;
    EjsName         qname;
    EjsNamespace    *nsp;
    int             fatt, attributes, slotNum;
    
    mprAssert(np->kind == N_CLASS);

    ejs = cp->ejs;
    state = cp->state;
    type = np->klass.ref;
    
    if ((slotNum = ecLookupVar(cp, ejs->global, &np->qname, 0)) >= 0) {
        if (cp->fileState->strict) {
            astError(cp, np, "%s Class %s is already defined.", np->qname.space, np->qname.name);
            return 0;
        }
    } else {
        slotNum = ejsGetPropertyCount(ejs, ejs->global);
    }
    attributes = np->attributes | EJS_TYPE_FIXUP;
    if (np->klass.isInterface) {
        attributes |= EJS_TYPE_INTERFACE;
    }

    /*
        Create the class type object
     */
    allocName(ejs, &np->qname);
    type = ejsCreateType(ejs, &np->qname, state->currentModule, NULL, sizeof(EjsObj), slotNum, 0, 0, attributes, np);
    if (type == 0) {
        astError(cp, np, "Can't create type %s", type->qname.name);
        return 0;
    }
    np->klass.ref = type;

    nsp = ejsDefineReservedNamespace(ejs, (EjsBlock*) type, &type->qname, EJS_PROTECTED_NAMESPACE);
    nsp->flags |= EJS_NSP_PROTECTED;

    nsp = ejsDefineReservedNamespace(ejs, (EjsBlock*) type, &type->qname, EJS_PRIVATE_NAMESPACE);
    nsp->flags |= EJS_NSP_PRIVATE;

    /*
        Define a property for the type in global
     */
    allocName(ejs, &np->qname);
    slotNum = ejsDefineProperty(ejs, ejs->global, slotNum, &np->qname, ejs->typeType, attributes, (EjsObj*) type);
    if (slotNum < 0) {
        astError(cp, np, "Can't install type %s",  np->qname.name);
        return 0;
    }

    /*
        Reserve two slots for the constructor and static initializer to ensure they are the first two non-inherited slots.
        These slots may be reclaimed during fixup if not required. Instance initializers are prepended to the constructor.
        Set a dummy name for the constructor as it will be defined by calling defineFunction from astClass.
     */
    if (!type->isInterface) {
        ejsSetProperty(ejs, (EjsObj*) type, 0, ejs->nullValue);
        ejsSetPropertyName(ejs, (EjsObj*) type, 0, ejsName(&qname, "", ""));

        qname.name = mprStrcat(type, -1, type->qname.name, "-initializer", NULL);
        qname.space = EJS_INIT_NAMESPACE;
        fatt = EJS_TRAIT_HIDDEN | EJS_PROP_STATIC;
        ejsDefineProperty(ejs, (EjsObj*) type, 1, &qname, ejs->functionType, fatt, ejs->nullValue);

        constructor = np->klass.constructor;
        if (constructor && !constructor->function.isDefaultConstructor) {
            type->hasConstructor = 1;
        }
    }
    return type;
}


static void validateFunction(EcCompiler *cp, EcNode *np, EjsFunction *spec, EjsFunction *fun)
{
}

static void validateClass(EcCompiler *cp, EcNode *np)
{
    Ejs         *ejs;
    EjsType     *type, *iface, *baseType;
    EjsName     qname;
    EjsFunction *fun;
    EjsObj      *vp;
    EcState     *state;
    int         next, i, count;

    ejs = cp->ejs;
    state = cp->state;
    type = np->klass.ref;

    baseType = type->baseType;
    if (baseType && baseType->final) {
        astError(cp, np, "Class \"%s\" is attempting to subclass a final class \"%s\"", type->qname.name, 
            baseType->qname.name);
    }

    /*
        Ensure the class implements all required implemented methods
     */
    for (next = 0; ((iface = (EjsType*) mprGetNextItem(type->implements, &next)) != 0); ) {
        count = ejsGetNumTraits((EjsObj*) iface);
        for (i = 0; i < count; i++) {
            fun = (EjsFunction*) ejsGetProperty(ejs, (EjsObj*) iface, i);
            if (!ejsIsFunction(fun) || fun->isInitializer) {
                continue;
            }
            qname = ejsGetPropertyName(ejs, (EjsObj*) iface, i);
            vp = ejsGetPropertyByName(ejs, (EjsObj*) type, &qname);
            if (vp == 0 || !ejsIsFunction(vp)) {
                astError(cp, np, "Missing method \"%s\" required by interface \"%s\"", qname.name, iface->qname.name);
            } else {
                validateFunction(cp, np, fun, (EjsFunction*) vp);
            }
        }
    }
    if (type->implements) {
        if (mprGetListCount(type->implements) > 1 || (type->baseType && strcmp(type->baseType->qname.name, "Object") != 0)) {
            astError(cp, np, "Only one implements or one extends supported");
        }
    }        
}


/*
    Lookup the set of open namespaces for the required namespace for this class
 */
static void bindClass(EcCompiler *cp, EcNode *np)
{
    Ejs         *ejs;
    EjsType     *type;
    EjsFunction *fun;
    EjsModule   *mp;
    EcState     *state;
    int         slotNum;
    bool        modified;

    ejs = cp->ejs;
    state = cp->state;
    type = np->klass.ref;

    mprAssert(cp->phase == EC_PHASE_BIND);

    if (type->hasStaticInitializer) {
        /*
            Create the static initializer function. Code gen will fill out the code. The type must be on the scope chain.
         */
        mp = state->currentModule;
        fun = ejsCreateFunction(ejs, NULL, -1, 0, 0, 0, cp->ejs->voidType, EJS_FUN_INITIALIZER, mp->constants, NULL, 
            cp->fileState->strict);
        np->klass.initializer = fun;
        slotNum = type->numInherited;
        if (type->hasConstructor) {
            slotNum++;
        }
        //  MOB -- better to use DefineProperty and set traits for initializer
        ejsSetProperty(ejs, (EjsObj*) type, slotNum, (EjsObj*) fun);
        ejsSetFunctionLocation(fun, (EjsObj*) type, slotNum);
    }

    modified = 0;
    if (!np->literalNamespace && resolveNamespace(cp, np, ejs->global, &modified) == 0) {
        return;
    }
    if (modified) {
        ejsSetTypeName(ejs, type, &np->qname);
    }
    addGlobalProperty(cp, np, &type->qname);

    if (np->klass.constructor == 0 && type->hasBaseConstructors) {
        mprAssert(type->hasConstructor == 1);
        type->hasConstructor = 1;
    }

    if (resolveName(cp, np, ejs->global, &type->qname) < 0) {
        return;
    }
    
    /*
        Now that all the properties are defined, make the entire class permanent.
     */
    if (!type->block.obj.dynamic) {
        ejsMakePermanent(ejs, (EjsObj*) type);
        if (type->prototype) {
            ejsMakePermanent(ejs, (EjsObj*) type->prototype);
        }
    }
     setAstDocString(ejs, np, np->lookup.obj, np->lookup.slotNum);
}


/*
    Process a class node
 */
static void astClass(EcCompiler *cp, EcNode *np)
{
    Ejs             *ejs;
    EjsType         *type;
    EcState         *state;
    EcNode          *constructor;
    bool            hasStaticInitializer;

    mprAssert(np->kind == N_CLASS);
    
    ENTER(cp);

    ejs = cp->ejs;
    state = cp->state;
    cp->classState = state;
    type = np->klass.ref;
    
    if (state->inClass || state->inFunction) {
        astError(cp, np, "Classes must be top level and not nested inside other classes or functions.");
        LEAVE(cp);
        return;
    }

    if (np->klass.implements) {
        processAstNode(cp, np->klass.implements);
    }        
    if (state->disabled) {
        if (cp->phase == EC_PHASE_CONDITIONAL) {
            removeProperty(cp, ejs->global, np);
        }
        LEAVE(cp);
        return;
    }

    if (cp->phase == EC_PHASE_DEFINE) {
        type = defineClass(cp, np);

    } else if (cp->phase == EC_PHASE_FIXUP) {
        fixupTypeSlots(cp, type);

    } else if (cp->phase >= EC_PHASE_BIND) {
        validateClass(cp, np);
        bindClass(cp, np);
    }

    if (cp->error) {
        LEAVE(cp);
        return;
    }

    state->currentClass = type;
    state->currentClassNode = np;
    state->currentClassName = type->qname;
    state->inClass = 1;

    /*
        Add the type to the scope chain and the static initializer if present. Use push frame to make it eaiser to
        pop the type off the scope chain later.
     */
    hasStaticInitializer = 0;
    addScope(cp, (EjsBlock*) type);
    if (np->klass.initializer) {
        openBlock(cp, np, (EjsBlock*) np->klass.initializer);
        hasStaticInitializer++;
    }

    if (cp->phase == EC_PHASE_FIXUP && type->baseType) {
        ejsInheritBaseClassNamespaces(ejs, type, type->baseType);
    }

    state->optimizedLetBlock = (EjsObj*) type;
    state->letBlock = (EjsObj*) type;
    state->varBlock = (EjsObj*) type;

    /*
        Process the class body
     */
    mprAssert(np->left->kind == N_DIRECTIVES);
    processAstNode(cp, np->left);

    /*
        Only need to do this if this is a default constructor, ie. does not exist in the class body.
     */
    constructor = np->klass.constructor;
    if (constructor && constructor->function.isDefaultConstructor) {
        astFunction(cp, constructor);
    }
    if (hasStaticInitializer) {
        closeBlock(cp);
    }
    removeScope(cp);
    LEAVE(cp);
}


static void astDirectives(EcCompiler *cp, EcNode *np)
{
    EcNode      *child;
    Ejs         *ejs;
    int         next;

    mprAssert(np->kind == N_DIRECTIVES);

    ENTER(cp);

    ejs = cp->ejs;
    cp->state->blockNestCount++;
    next = 0;
    while ((child = getNextAstNode(cp, np, &next))) {
        processAstNode(cp, child);
    }
    cp->state->blockNestCount--;
    LEAVE(cp);
}


/*
    Handle a do statement
 */
static void astDo(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);

    mprAssert(np->kind == N_DO);

    if (np->forLoop.cond) {
        processAstNode(cp, np->forLoop.cond);
    }
    if (np->forLoop.body) {
        processAstNode(cp, np->forLoop.body);
    }
    LEAVE(cp);
}


/*
    Handle property dereferencing via "." and "[". This routine will bind a
    name path reference into slot bindings if possible. The dot node is a
    binary node.

            local.a.b.c
            arg.a.b.c
            obj.a.b.c
            static.a.b.c
            any[expression]
            unqualifiedName         - dynamic bound
            expression              - dynamic bound
 */
static void astDot(EcCompiler *cp, EcNode *np)
{
    EcState     *state;
    EcNode      *left;

    mprAssert(np->kind == N_DOT);
    mprAssert(np->left);
    mprAssert(np->right);

    ENTER(cp);

    state = cp->state;
    state->onLeft = 0;
    left = np->left;

    /*
        Optimize to assist with binding. Remove an expressions node which has a sole QNAME.
     */
    if (left && left->kind == N_EXPRESSIONS && left->left && left->left->kind == N_QNAME && left->right == 0) {
        np->left = np->left->left;
    }

    /*
        Process the left of the "."
     */
    processAstNode(cp, np->left);

    state->currentObjectNode = np->left;
    
    /*
        If the right is a terminal node, then assume the parent state's onLeft status
     */
    switch (np->right->kind) {
    case N_QNAME:
/*
    Need to allow obj[fun()] = 7
    case N_EXPRESSIONS: 
 */
    case N_LITERAL:
    case N_OBJECT_LITERAL:
        cp->state->onLeft = cp->state->prev->onLeft;
        break;

    default:
        break;
    }
    processAstNode(cp, np->right);

    /*
        Propagate up the right side qname and lookup.
     */
    if (cp->phase >= EC_PHASE_BIND) {
        np->lookup = np->right->lookup;
        np->qname = np->right->qname;
    }
    LEAVE(cp);
}


/*
    Process an expressions node
 */
static void astExpressions(EcCompiler *cp, EcNode *np)
{
    EcNode      *child;
    int         next;

    mprAssert(np->kind == N_EXPRESSIONS);

    ENTER(cp);

    /*
        No current object when computing an expression. E.g. obj[a + b]
        We don't want obj set as the context object for a or b.
     */
    cp->state->currentObjectNode = 0;

    next = 0;
    while ((child = getNextAstNode(cp, np, &next)) != 0) {
        processAstNode(cp, child);
    }
    /*
        Propagate up the right side qname and lookup.
     */
    if (cp->phase >= EC_PHASE_BIND) {
        child = mprGetLastItem(np->children);
        if (child) {
            np->lookup = child->lookup;
            np->qname = child->qname;
        }
    }
    LEAVE(cp);
}


static EjsFunction *defineFunction(EcCompiler *cp, EcNode *np)
{
    Ejs             *ejs;
    EcState         *state;
    EcNode          *parameters;
    EjsFunction     *fun;
    EjsObj          *block;
    int             numArgs;
    int             slotNum, attributes;

    mprAssert(np->kind == N_FUNCTION);
    mprAssert(cp->phase == EC_PHASE_DEFINE);

    ejs = cp->ejs;
    state = cp->state;

    if (np->function.isMethod) {
        block = state->varBlock;
        np->attributes |= EJS_TRAIT_FIXED | EJS_TRAIT_READONLY;
        if (!(np->attributes & EJS_PROP_ENUMERABLE) && !(state->currentClassNode->attributes & EJS_PROP_ENUMERABLE)) {
            np->attributes |= EJS_TRAIT_HIDDEN;
        }
    } else {
        block = state->optimizedLetBlock;
        if (state->optimizedLetBlock != state->varBlock) {
            state->letBlockNode->createBlockObject = 1;
        }
    }
    parameters = np->function.parameters;
    numArgs = (parameters) ? mprGetListCount(parameters->children) : 0;
    
    if (np->function.resultType) {
        np->attributes |= np->function.resultType->attributes;
    }
    /*
        Create a function object. Don't have code yet so we create without it. Can't resolve the return type yet, so we 
        leave it unset. The numDefault and numExceptions will be fixed when the function is bound.
     */
    fun = ejsCreateFunction(ejs, 0, 0, numArgs, 0, 0, 0, np->attributes, state->currentModule->constants, NULL, 
        cp->fileState->strict);
    if (fun == 0) {
        astError(cp, np, "Can't create function \"%s\"", np->qname.name);
        return 0;
    }    
    ejsSetDebugName(fun, np->qname.name);
    np->function.functionVar = fun;

    /*
        Check if this function has already been defined in this block. Can't check base classes yes. Must wait till 
        bindFunction()
     */
    slotNum = ejsLookupProperty(ejs, block, &np->qname);

    if (slotNum >= 0 && cp->fileState->strict) {
        if ((np->function.setter && ejsHasTrait(block, slotNum, EJS_TRAIT_SETTER)) ||
            (np->function.getter && ejsHasTrait(block, slotNum, EJS_TRAIT_GETTER))) {
            astError(cp, np, "Property \"%s\" is already defined.", np->qname);
            return 0;
        }
    }
    attributes = np->attributes;
    if (np->function.isConstructor) {
        slotNum = 0;
        attributes |= EJS_FUN_CONSTRUCTOR;
        np->qname.space = EJS_CONSTRUCTOR_NAMESPACE;
    }
    allocName(ejs, &np->qname);
    slotNum = ejsDefineProperty(ejs, block, slotNum, &np->qname, fun->block.obj.type, attributes, (EjsObj*) fun);
    if (slotNum < 0) {
        astError(cp, np, "Can't define function in type \"%s\"", state->currentClass->qname.name);
        return 0;
    }
    return fun;
}


/*
    Define function parameters during the DEFINE phase.
 */
static int defineParameters(EcCompiler *cp, EcNode *np)
{
    Ejs             *ejs;
    EjsFunction     *fun;
    EcNode          *nameNode, *child, *parameters;
    EjsName         qname;
    int             attributes, next, slotNum, numDefault;

    ejs = cp->ejs;
    parameters = np->function.parameters;
    if (parameters == 0) {
        return 0;
    }
    fun = np->function.functionVar;
    slotNum = 0;
    next = 0;
    numDefault = 0;

    while ((child = getNextAstNode(cp, parameters, &next))) {
        mprAssert(child->kind == N_VAR_DEFINITION);

        attributes = 0;
        nameNode = 0;

        if (child->left->kind == N_QNAME) {
            nameNode = child->left;
        } else if (child->left->kind == N_ASSIGN_OP) {
            numDefault++;
            nameNode = child->left->left;
        }
        attributes |= nameNode->attributes;

        ejsName(&qname, EJS_PRIVATE_NAMESPACE, nameNode->qname.name);
        allocName(ejs, &qname);
        slotNum = ejsDefineProperty(ejs, (EjsObj*) fun, slotNum, &qname, NULL, attributes, NULL);
        mprAssert(slotNum >= 0);

        /*
            We can assign the lookup information here as these never need fixups.
         */
        nameNode->lookup.slotNum = slotNum;
        nameNode->lookup.obj = (EjsObj*) fun;
        nameNode->lookup.trait = ejsGetPropertyTrait(ejs, (EjsObj*) fun, slotNum);
        mprAssert(nameNode->lookup.trait);
        slotNum++;
    }
    fun->numDefault = numDefault;
    if (np->function.getter && fun->numArgs != 0) {
        astError(cp, np, "Getter function \"%s\" must not define parameters.", np->qname.name);
    }
    if (np->function.setter && fun->numArgs != 1) {
        astError(cp, np, "Setter function \"%s\" must define exactly one parameter.", np->qname.name);
    }
    return 0;
}


/*
    Bind the function parameter types. Local variables get bound as the block gets traversed.
 */
static void bindParameters(EcCompiler *cp, EcNode *np)
{
    Ejs             *ejs;
    EcNode          *child, *varNode, *assignNode, *parameters, *localType;
    EjsTrait        *trait;
    EjsFunction     *fun;
    EjsName         qname;
    int             next, slotNum, attributes;

    ejs = cp->ejs;
    fun = np->function.functionVar;
    next = 0;
    parameters = np->function.parameters;

    if (parameters) {
        while ((child = getNextAstNode(cp, parameters, &next))) {
            mprAssert(child->kind == N_VAR_DEFINITION);
            trait = ejsGetPropertyTrait(ejs, (EjsObj*) fun, next - 1);
            attributes = trait->attributes;
            
            varNode = 0;
            if (child->left->kind == N_QNAME) {
                varNode = child->left;

            } else if (child->left->kind == N_ASSIGN_OP) {
                /*
                    Bind defaulting parameters. Only need to do if there is a body. Native functions ignore this code as they
                    have no body. The lhs must be scoped inside the function. The rhs must be scoped outside.
                 */
                if (np->function.body) {
                    assignNode = child->left;
                    openBlock(cp, np->function.body, (EjsBlock*) fun);
                    ejsDefineReservedNamespace(ejs, (EjsBlock*) fun, 0, EJS_PRIVATE_NAMESPACE);
                    processAstNode(cp, assignNode->left);
                    closeBlock(cp);
                    processAstNode(cp, assignNode->right);
                }
                varNode = child->left->left;
            }
            mprAssert(varNode);
            mprAssert(varNode->kind == N_QNAME);

            if (varNode->typeNode == 0) {
                if (varNode->name.isRest) {
                    ejsName(&qname, EJS_EJS_NAMESPACE, "Array");
                    slotNum = ejsLookupProperty(ejs, ejs->global, &qname);
                    mprAssert(slotNum >= 0);
                    ejsSetTraitType(trait, (EjsType*) ejsGetProperty(ejs, ejs->global, slotNum));
                    fun->rest = 1;
                }

            } else {
                localType = varNode->typeNode;
                processAstNode(cp, localType);
                if (localType->lookup.ref) {
                    ejsSetTraitType(trait, (EjsType*) localType->lookup.ref);
                    attributes |= (localType->attributes & (EJS_TRAIT_CAST_NULLS | EJS_TRAIT_THROW_NULLS));
                    ejsSetTraitAttributes(trait, attributes);
                }
            }
        }
    }
}


/*
    Utility routine to bind function return type and locals/args
 */
static EjsFunction *bindFunction(EcCompiler *cp, EcNode *np)
{
    Ejs             *ejs;
    EcNode          *resultTypeNode;
    EcState         *state;
    EjsType         *iface;
    EjsFunction     *fun;
    EjsObj          *block;
    int             slotNum, next;

    mprAssert(cp->phase >= EC_PHASE_BIND);
    mprAssert(np->kind == N_FUNCTION);
    mprAssert(np->qname.name);

    state = cp->state;
    ejs = cp->ejs;
    fun = np->function.functionVar;
    mprAssert(fun);

    block = (np->function.isMethod) ? state->varBlock: state->optimizedLetBlock;
    resultTypeNode = np->function.resultType;

    if (cp->phase == EC_PHASE_BIND) {
        /*
            Exclude a literalNamespace as the empty phase as the namespace name is changed for the URI.
            Exclude constructors which are hidden in the virtual constructor namespace.
         */
        if (!np->literalNamespace && !np->function.isConstructor) {
            if (resolveNamespace(cp, np, block, 0) == 0) {
                return 0;
            }
        }
        if (block == ejs->global) {
            addGlobalProperty(cp, np, &np->qname);
        }
    }
    
    /*
        Test for clashes with non-overridden methods in base classes.
     */
    if (state->currentClass && state->currentClass->baseType) {
        slotNum = ecLookupVar(cp, (EjsObj*) state->currentClass->baseType, &np->qname, 0);
        if (slotNum >= 0 && cp->lookup.obj == (EjsObj*) state->currentClass->baseType) {
            if (!(np->attributes & EJS_FUN_OVERRIDE) && !state->currentClass->baseType->isInterface) {
                astError(cp, np, 
                    "Function \"%s\" is already defined in a base class. Try using \"override\" keyword.", np->qname.name);
                return 0;
            }
            /*
                Install the new function into the v-table by overwriting the method from the closest base class.
                Must now define the name of the property and attributes.
             */
            allocName(ejs, &np->qname);
            ejsDefineProperty(ejs, (EjsObj*) block, slotNum, &np->qname, 0, np->attributes, (EjsObj*) fun);
        }
    }

    /*
        Test for clashes with non-overridden methods in base classes and implemented classes.
     */
    if (state->currentClass && state->currentClass->implements) {
        next = 0;
        while ((iface = (EjsType*) mprGetNextItem(state->currentClass->implements, &next))) {
            slotNum = ecLookupVar(cp, (EjsObj*) iface, &np->qname, 0);
            if (slotNum >= 0 && cp->lookup.obj == (EjsObj*) iface) {
                if (!iface->isInterface) {
                    if (!(np->attributes & EJS_FUN_OVERRIDE)) {
                        astError(cp, np, 
                            "Function \"%s\" is already defined in an implemented class. Use the \"override\" keyword.", 
                            np->qname.name);
                        return 0;
                    }

                    /*
                        Install the new function into the v-table by overwriting the inherited implemented method.
                     */
                    allocName(ejs, &np->qname);
                    ejsDefineProperty(ejs, (EjsObj*) block, slotNum, &np->qname, 0, np->attributes, 
                        (EjsObj*) fun);
                }
            }
        }
    }

    if (resultTypeNode) {
        if (resolveName(cp, resultTypeNode, cp->ejs->global, &resultTypeNode->qname) < 0) {
            if (STRICT_MODE(cp)) {
                astError(cp, np, "Can't find type \"%s\". All variables must be declared and typed in strict mode.", 
                    resultTypeNode->qname.name);
            }
        } else {
            resultTypeNode->qname.space = resultTypeNode->lookup.name.space;
        }
    }

    /*
        We dont have a trait for the function return type.
     */
    if (resolveName(cp, np, block, &np->qname) < 0) {
        astError(cp, np, "Internal error. Can't bind function %s", np->qname.name);
        resolveName(cp, np, block, &np->qname);
    }
    if (np->lookup.slotNum >= 0) {
        ejsSetFunctionLocation(fun, block, np->lookup.slotNum);
        if (np->function.getter) {
            if (fun->setter) {
                ejsSetFunctionLocation(fun->setter, block, np->lookup.slotNum);
            }
        }
        setAstDocString(ejs, np, np->lookup.obj, np->lookup.slotNum);
    }

    /*
        Bind the result type. Set the result type in np->trait->type
     */
    if (resultTypeNode) {
        mprAssert(resultTypeNode->lookup.ref == 0 || ejsIsType(resultTypeNode->lookup.ref));
        fun->resultType = (EjsType*) resultTypeNode->lookup.ref;
    }

    /*
        Optimize away closures
     */
    if (fun->owner == ejs->global || np->function.isMethod || np->attributes & EJS_PROP_NATIVE) {
        fun->fullScope = 0;
    } else {
        fun->fullScope = 1;
    }
    fun->block.scopeChain = ejs->state->bp->scopeChain;
    return fun;
}


/*
    Process the N_FUNCTION node and bind the return type and parameter types
 */
static void astFunction(EcCompiler *cp, EcNode *np)
{
    Ejs             *ejs;
    EjsFunction     *fun;
    EcState         *state;

    mprAssert(np->kind == N_FUNCTION);
    ENTER(cp);

    ejs = cp->ejs;
    state = cp->state;
    fun = np->function.functionVar;

    if (state->disabled) {
        if (cp->phase == EC_PHASE_CONDITIONAL) {
            removeProperty(cp, state->optimizedLetBlock, np);
        }
        LEAVE(cp);
        return;
    }

    /*
        Process the function definition (no parameters yet)
     */
    if (cp->phase == EC_PHASE_DEFINE) {
        fun = defineFunction(cp, np);
    } else if (cp->phase >= EC_PHASE_BIND) {
        fun = bindFunction(cp, np);
    }
    if (fun == 0) {
        LEAVE(cp);
        return;
    }

    /*
        Define and bind the parameters and their types
     */
    if (cp->phase == EC_PHASE_DEFINE) {
        defineParameters(cp, np);

    } else if (cp->phase >= EC_PHASE_BIND) {
        bindParameters(cp, np);
    }

    state->currentFunction = fun;
    state->currentFunctionNode = np;

    state->inFunction = 1;
    state->inMethod = state->inMethod || np->function.isMethod;
    state->blockIsMethod = np->function.isMethod;

    state->optimizedLetBlock = (EjsObj*) fun;
    state->letBlock = (EjsObj*) fun;
    state->varBlock = (EjsObj*) fun;

    if (np->function.body) {
        openBlock(cp, np->function.body, (EjsBlock*) fun);
        ejsDefineReservedNamespace(ejs, (EjsBlock*) fun, 0, EJS_PRIVATE_NAMESPACE);
        mprAssert(np->function.body->kind == N_DIRECTIVES);
        processAstNode(cp, np->function.body);
        closeBlock(cp);
    }

    if (np->function.constructorSettings) {
        /*
            TODO The constructor settings need special namespace treatment. Consider:
            class Shape {
                var x
                function Shape(arg1) : this.x = arg1 {}
            }
        
            Note the left hand side can use "this" whereas the right hand side must not.
            The right hand side can see the parameters wheres the left hand side must not.
         */
        state->inSettings = 1;
        processAstNode(cp, np->function.constructorSettings);
        state->inSettings = 0;
    }

    /*
        TODO -- No need to add this namespace to be emitted as all function variables are bound (always)
        Process the parameters. Scope for default initialization code for the parameters is as follows:
            left hand side:  inside the function block
            right hand side: outside the function block.
    
        Namespaces are done on each phase because pragmas must apply only from the point of declaration onward 
        (use namespace)
     */
    if (cp->phase >= EC_PHASE_BIND) {
        if (!np->function.hasReturn && (np->function.resultType != 0)) {
            if (fun->resultType == 0 || fun->resultType != ejs->voidType) {
                /*
                    Native classes have no body defined in script, so we can't verify whether or not it has 
                    an appropriate return.
                 */
                if (!(state->currentClass && state->currentClass->isInterface) && !(np->attributes & EJS_PROP_NATIVE)) {
                    /*
                        When building slots for the core VM (empty mode), we can't test ejs->voidType as this won't equal
                        the parsed Void class
                     */
                    if (ejs->initialized || fun->resultType == 0 || strcmp(fun->resultType->qname.name, "Void") != 0) {
                        astError(cp, np, "Function \"%s\" must return a value",  np->qname.name);
                    }
                }
            }
        }
        ejsCompleteFunction(ejs, fun);
    }
    LEAVE(cp);
}


/*
    Handle a for statement
 */
static void astFor(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);

    mprAssert(np->kind == N_FOR);

    if (np->forLoop.initializer) {
        processAstNode(cp, np->forLoop.initializer);
    }
    if (np->forLoop.cond) {
        processAstNode(cp, np->forLoop.cond);
    }
    if (np->forLoop.perLoop) {
        processAstNode(cp, np->forLoop.perLoop);
    }
    if (np->forLoop.body) {
        processAstNode(cp, np->forLoop.body);
    }
    LEAVE(cp);
}


/*
    Handle a for/in statement
 */
static void astForIn(EcCompiler *cp, EcNode *np)
{
    Ejs         *ejs;
    EjsName     qname;
    int         rc;

    ENTER(cp);

    mprAssert(np->kind == N_FOR_IN);
    
    ejs = cp->ejs;

    if (np->forInLoop.iterVar) {
        processAstNode(cp, np->forInLoop.iterVar);
    }
    if (np->forInLoop.iterGet) {
        processAstNode(cp, np->forInLoop.iterGet);
    }

    /*
        Link to the iterGet node so we can bind the "next" call.
     */
    if (cp->phase >= EC_PHASE_BIND) {
#if UNUSED || 1
        EjsType     *iteratorType;
        ejsName(&qname, "iterator", "Iterator");
        iteratorType = (EjsType*) ejsGetPropertyByName(ejs, ejs->global, &qname);
        mprAssert(iteratorType);
        if (iteratorType == 0) {
            astError(cp, np, "Can't find Iterator class");
        } else {
            /*
                TODO MOB - this assumes that iterators use Iterator and it is bindable. What if an operator that
                implements an Iterable/Iterator interface
             */
            ejsName(&qname, "public", "next");
            rc = resolveName(cp, np->forInLoop.iterNext, (EjsObj*) iteratorType, &qname);
            if (rc < 0) {
                astError(cp, np, "Can't find Iterator.next method");
            }
        }
        
#else
        ejsName(&qname, "public", "next");
        resolveName(cp, np->forInLoop.iterNext, (EjsObj*) ejs->iterator, &qname);
#endif
    }
    if (np->forInLoop.body) {
        processAstNode(cp, np->forInLoop.body);
    }
    LEAVE(cp);
}


static EjsObj *evalNode(EcCompiler *cp, EcNode *np)
{
    Ejs         *ejs;
    EjsModule   *mp;
    EjsObj      *result;

    ejs = cp->ejs;
    mprAssert(ejs->exception == 0);
    
    mp = ejsCreateModule(cp->ejs, "__conditional__", 0);
    if (mp == 0) {
        return 0;
    }
    mp->initializer = createModuleInitializer(cp, np, mp);
    mp->initializer->isInitializer = 1;
    mp->hasInitializer = 1;

    if (astProcess(cp, np) < 0) {
        return 0;
    }
    ecResetParser(cp);
    ecGenConditionalCode(cp, np, mp);
    if (cp->errorCount > 0) {
        return 0;
    }
    result = ejsRunInitializer(ejs, mp);
    if (result == 0) {
        ejsClearException(ejs);
        return 0;
    }
    return result;
}


/*
    Handle an hash statement (conditional compilation)
 */
static void astHash(EcCompiler *cp, EcNode *np)
{
    EjsObj          *result;
    int             savePhase;

    ENTER(cp);

    mprAssert(np->kind == N_HASH);
    mprAssert(np->hash.expr);
    mprAssert(np->hash.body);

    cp->state->inHashExpression = 1;

    if (cp->phase < EC_PHASE_CONDITIONAL) {
        processAstNode(cp, np->hash.expr);

    } else if (cp->phase == EC_PHASE_CONDITIONAL) {
        ENTER(cp);
        savePhase = cp->phase;
        result = evalNode(cp, np->hash.expr);
        cp->phase = savePhase;
        LEAVE(cp);

        if (result) {
            result = (EjsObj*) ejsToBoolean(cp->ejs, result);
            if (result && !ejsGetBoolean(cp->ejs, result)) {
                result = 0;
            }
        }
        if (result == 0) {
            np->hash.disabled = 1;
        }
    }
    if (np->hash.disabled) {
        cp->state->disabled = 1;
    }
    cp->state->inHashExpression = 0;
    processAstNode(cp, np->hash.body);
    LEAVE(cp);
}


/*
    Handle an if statement (tenary node)
 */
static void astIf(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);

    mprAssert(np->kind == N_IF);

    mprAssert(np->tenary.cond);
    mprAssert(np->tenary.thenBlock);

    processAstNode(cp, np->tenary.cond);
    processAstNode(cp, np->tenary.thenBlock);

    if (np->tenary.elseBlock) {
        processAstNode(cp, np->tenary.elseBlock);
    }
    LEAVE(cp);
}


static void astImplements(EcCompiler *cp, EcNode *np)
{
    EcNode      *child;
    int         next;
    
    ENTER(cp);
    
    mprAssert(np->kind == N_TYPE_IDENTIFIERS);
    
    next = 0;
    while ((child = getNextAstNode(cp, np, &next))) {
        processAstNode(cp, child);
    }
    LEAVE(cp);
}


/*
    Generate a name reference. This routine will bind a name path reference into slot bindings if possible.
    The node and its children represent a  name path.
 */
static void astName(EcCompiler *cp, EcNode *np)
{
    if (np->name.qualifierExpr) {
        processAstNode(cp, np->name.qualifierExpr);
    }
    if (np->name.nameExpr) {
        processAstNode(cp, np->name.nameExpr);
    }
    if (cp->phase >= EC_PHASE_BIND) {
        astBindName(cp, np);
        return;
    }
}


static void astBindName(EcCompiler *cp, EcNode *np)
{
    Ejs             *ejs;
    EjsLookup       *lookup;
    EjsType         *type;
    EjsFunction     *fun, *currentFunction;
    EcNode          *left;
    EcState         *state;
    int             rc;

    mprAssert(cp->phase >= EC_PHASE_BIND);
    mprAssert(np->kind == N_QNAME);
    
    if (np->qname.name == 0 || np->name.qualifierExpr || np->name.nameExpr) {
        return;
    }
    ENTER(cp);
    state = cp->state;

    /*
        If resolving a name to the right of a "." or "[", then only search relative to the object to the left of the dot.
     */
    left = state->currentObjectNode;
    ejs = cp->ejs;
    rc = -1;

    if (np->name.isType) {
        rc = resolveName(cp, np, ejs->global, &np->qname);
        if (rc < 0) {
            //  NOTE: np->qname.space may be null
            astError(cp, np, "Can't find class \"%s\". Ensure the class is visible.", np->qname.name);
        }

    } else if (left) {
        if (left->kind == N_THIS) {
            /*
                Explicit "this.property"
                TODO - does not yet handle "this function, this callee, this function, this type"
             */
            if (state->currentClass) {
                rc = resolveName(cp, np, (EjsObj*) state->currentClass, &np->qname);
                if (rc < 0 && STRICT_MODE(cp)) {
                    astError(cp, np, "Can't find property \"%s\" in this class %s.", np->qname.name, 
                             state->currentClass->qname.name);
                }
            }

        /*
            Do we know the type of the left side?
         */
        } else if (left->lookup.trait && left->lookup.trait->type) {
            /*
                We must handle 2 cases differently:
                    1. obj.property
                    2. Type.property
            
                This is because in the first case, we must extract the type of an object, whereas in the 2nd case,
                we already have the type via an explicit type reference.
             */
            if (left->lookup.ref && (ejsIsType(left->lookup.ref) || ejsIsPrototype(left->lookup.ref))) {
                /*
                    Case 2. Type.property. We have resolved the type reference.
                 */
                np->lookup.ownerIsType = 1;
                rc = resolveName(cp, np, left->lookup.ref, &np->qname);
                if (rc < 0 && STRICT_MODE(cp) && !((EjsType*) left->lookup.ref)->dynamicInstance) {
                    astError(cp, np, "Can't find property \"%s\" in class \"%s\".", np->qname.name,
                        ((EjsType*) left->lookup.ref)->qname.name);

                } else if (np->lookup.trait && !(np->lookup.trait->attributes & EJS_PROP_STATIC) &&
                        np->lookup.obj != ejs->global) {
                    if (np->lookup.slotNum >= ES_Object_NUM_CLASS_PROP) {
                        /* Exclude the case of calling a function (constructor) to create a new instance */
                        if (!(left->kind == N_CALL || left->kind == N_EXPRESSIONS)) {
                            astError(cp, np, "Accessing instance level propery \"%s\" without an instance", np->qname.name);
                        }
                    }
                    
                } else if (left->kind == N_CALL) {
                    /*
                        Calling a constructor as a function. This will return an instance
                     */
                    np->lookup.nthBase++;
                }

            } else {
                fun = (EjsFunction*) left->lookup.ref;
                if (fun && ejsIsFunction(fun)) {
                    /* 
                        Can't use a getter to bind to as the value is determined at run time.
                     */
                    rc = -1;

                } else {

                    /*
                        Case 1: Left side is a normal object. We use the type of the lhs to search for name.
                     */
                    rc = resolveName(cp, np, (EjsObj*) left->lookup.trait->type, &np->qname);
                    if (rc == 0) {
                        /*
                            Since we searched above on the type of the object and the lhs is an object, increment nthBase.
                            BUG: but what if lhs is a type? then nthBase is one too many
                         */
                        if (!np->lookup.instanceProperty) {
                            np->lookup.nthBase++;
                        }
                    }
                }
            }

        } else if (left->kind == N_EXPRESSIONS) {
            /* 
                Suppress error message below. We can't know the left because it is an expression. 
                So we can't bind the variable 
             */
            rc = 0;
        }

    } else {
        /*
            No left side, so search the scope chain
         */
        rc = resolveName(cp, np, 0, &np->qname);

        /*
            Check for static function code accessing instance properties or instance methods
         */
        lookup = &np->lookup;
        if (rc == 0 && state->inClass && !state->instanceCode) {
            if (lookup->obj->isPrototype || 
                    (ejsIsType(lookup->obj) && (lookup->trait && !(lookup->trait->attributes & EJS_PROP_STATIC)))) {
                if (!state->inFunction || (state->currentFunctionNode->attributes & EJS_PROP_STATIC)) {
                    astError(cp, np, "Accessing instance level property \"%s\" without an instance", np->qname.name);
                    rc = -1;
                }
            }
        }
    }

    if (rc < 0) {
#if FUTURE
        //  TODO - need propert expression calculation and propagation
        if (left && left->lookup.trait && left->lookup.trait->type) {
            type = left->lookup.trait->type;
            if (!type->dynamicInstance) {
                astError(cp, np, "Can't find a declaration for \"%s\".", np->qname.name);
            }
        }
#endif
        if (STRICT_MODE(cp) && !cp->error) {
            astError(cp, np, "Can't find a declaration for \"%s\". All variables must be declared and typed in strict mode.",
                np->qname.name);
        }

    } else {
        if (np->lookup.trait) {
            /* Copy traits of property into the reference. Not sure if all are needed */
            np->attributes |= np->lookup.trait->attributes;
        }
    }

    /*
        Disable binding of names in certain cases.
     */
    lookup = &np->lookup;
    if (lookup->slotNum >= 0) {
        /*
            Unbind if slot number won't fit in one byte or the object is not a standard Object. The bound op codes 
            require one byte slot numbers.
         */
        if (lookup->slotNum >= 256) {
            lookup->slotNum = -1;
        }

        if (lookup->obj == ejs->global && !cp->bind) {
            /*
                Unbind non-core globals
             */
            if ((lookup->slotNum >= ES_global_NUM_CLASS_PROP) && !(lookup->ref && lookup->ref->builtin)) {
                lookup->slotNum = -1;
            }
        }

        if (ejsIsType(np->lookup.obj)) {
            type = (EjsType*) np->lookup.obj;
            if (type->block.nobind || type->isInterface) {
                /*
                    Type requires non-bound access. Types that implement interfaces will have different slots.
                 */
                lookup->slotNum = -1;

            } else if (type->dynamicInstance && !type->block.obj.builtin) {
                /*
                    Don't bind non-core dynamic properties
                 */
                lookup->slotNum = -1;

            } else {
                /*
                    Ugly (but effective) hack just for XML to discriminate between length and length()
                    TODO - refactor away
                 */
                if (type == ejs->xmlType || type == ejs->xmlListType) {
                    if (np->parent == 0 || np->parent->parent == 0 || np->parent->parent->kind != N_CALL) {
                        lookup->slotNum = -1;
                    }
                }
            }

        } else if (ejsIsPrototype(np->lookup.obj)) {
            if (!np->lookup.obj->builtin) {
                lookup->slotNum = -1;
            }
        }
        if (lookup->trait && lookup->trait->attributes & EJS_TRAIT_GETTER) {
            lookup->slotNum = -1;
        }
    }

    /*
        If accessing unbound variables, then the function will require full scope if a closure is ever required.
     */
    currentFunction = state->currentFunction;
    if (lookup->slotNum < 0) {
        if (cp->phase == EC_PHASE_BIND && cp->warnLevel > 5) {
            astWarn(cp, np, "Using unbound variable reference for \"%s\"", np->qname.name);
        }
    }
    LEAVE(cp);
}


static void astNew(EcCompiler *cp, EcNode *np)
{
    EjsType     *type;
    EcNode      *left;

    mprAssert(np->kind == N_NEW);
    mprAssert(np->left);
    mprAssert(np->left->kind == N_QNAME || np->left->kind == N_DOT);
    mprAssert(np->right == 0);

    ENTER(cp);

    left = np->left;
    processAstNode(cp, left);

    if (cp->phase != EC_PHASE_BIND) {
        LEAVE(cp);
        return;
    }

    mprAssert(cp->phase >= EC_PHASE_BIND);

    np->newExpr.callConstructors = 1;

    if (left->lookup.ref) {
        type = (EjsType*) left->lookup.ref;
        if (type && ejsIsType(type)) {
            /* Type is bound, has no constructor or base class constructors */
            if (!type->hasConstructor && !type->hasBaseConstructors) {
                np->newExpr.callConstructors = 0;
            }
            
            /*
                Propagate up the left side. Increment nthBase because it is an instance.
             */
            np->qname = left->qname;
            np->lookup = left->lookup;
            np->lookup.trait = mprAllocObj(cp->ejs, EjsTrait);
            np->lookup.trait->type = (EjsType*) np->lookup.ref;
            np->lookup.ref = 0;
            np->lookup.instanceProperty = 1;
        }
    }
    LEAVE(cp);
}


static void astObjectLiteral(EcCompiler *cp, EcNode *np)
{
    EcNode      *child;
    int         next;

    mprAssert(np->kind == N_OBJECT_LITERAL);

    processAstNode(cp, np->objectLiteral.typeNode);
    next = 0;
    while ((child = getNextAstNode(cp, np, &next)) != 0) {
        processAstNode(cp, child);
    }
}


static void astField(EcCompiler *cp, EcNode *np)
{
    if (np->field.fieldKind == FIELD_KIND_VALUE) {
        processAstNode(cp, np->field.expr);
    }
}


static void astPragmas(EcCompiler *cp, EcNode *np)
{
    Ejs         *ejs;
    EcNode      *child;
    int         next;

    mprAssert(np->kind == N_PRAGMAS);

    ENTER(cp);

    ejs = cp->ejs;

    next = 0;
    while ((child = getNextAstNode(cp, np, &next))) {
        processAstNode(cp, child);
    }
    LEAVE(cp);
}


static void astPragma(EcCompiler *cp, EcNode *np)
{
    mprAssert(np->kind == N_PRAGMA);

    ENTER(cp);
    if (np->pragma.strict) {
        cp->fileState->strict = np->pragma.strict;
    }
    LEAVE(cp);
}



static void astPostfixOp(EcCompiler *cp, EcNode *np)
{
    EcNode      *left;
    
    mprAssert(np->kind == N_POSTFIX_OP);

    ENTER(cp);

    left = np->left;
    if (left->kind == N_LITERAL) {
        astError(cp, np, "Invalid postfix operand");
    } else {
        processAstNode(cp, np->left);
    }
    LEAVE(cp);
}


static void astProgram(EcCompiler *cp, EcNode *np)
{
    Ejs             *ejs;
    EcState         *state;
    EcNode          *child;
    int             next;

    ENTER(cp);

    ejs = cp->ejs;
    state = cp->state;
    state->namespace = np->qname.name;

    next = 0;
    while ((child = getNextAstNode(cp, np, &next)) != 0) {
        processAstNode(cp, child);
    }
    LEAVE(cp);
}


static void astReturn(EcCompiler *cp, EcNode *np)
{
    EjsFunction     *fun;
    EcNode          *functionNode;
    EcState         *state;

    ENTER(cp);

    state = cp->state;

    mprAssert(state->currentFunctionNode->kind == N_FUNCTION);
    state->currentFunctionNode->function.hasReturn = 1;

    if (np->left) {
        processAstNode(cp, np->left);
    }

    if (cp->phase >= EC_PHASE_BIND) {
        mprAssert(state->currentFunction);
        mprAssert(state->currentFunction);
        functionNode = state->currentFunctionNode;
        state->currentFunction->hasReturn = functionNode->function.hasReturn;

        fun = state->currentFunction;
        if (fun->hasReturn) {
            if (np->left) {
                if (fun->resultType && fun->resultType == cp->ejs->voidType) {
                    /*
                        Allow block-less function expressions where a return node was generated by the parser.
                     */
                    if (!np->ret.blockLess) {
                        astError(cp, np, "Void function \"%s\" can't return a value", functionNode->qname.name);
                    }
                }

            } else {
                if (fun->resultType && fun->resultType != cp->ejs->voidType) {
                    if (! (!cp->ejs->initialized && strcmp(fun->resultType->qname.name, "Void") == 0)) {
                        astError(cp, np, "Return in function \"%s\" must return a value", functionNode->qname.name);
                    }
                }
            }
        }
    }
    LEAVE(cp);
}


static void astSuper(EcCompiler *cp, EcNode *np)
{
    EcState     *state;

    ENTER(cp);

    state = cp->state;
    if (state->currentObjectNode == 0) {

        if (state->currentFunction == 0) {
            if (cp->phase == EC_PHASE_DEFINE) {
                astError(cp, np, "Can't use unqualified \"super\" outside a method");
            }
            LEAVE(cp);
            return;
        }
        if (!state->currentFunction->constructor) {
            if (cp->phase == EC_PHASE_DEFINE) {
                astError(cp, np, "Can't use unqualified \"super\" outside a constructor");
            }
            LEAVE(cp);
            return;
        }
        if (cp->phase >= EC_PHASE_BIND) {
            if (state->currentClass->hasBaseConstructors == 0) {
                astError(cp, np, "No base class constructors exist to call via super");
                LEAVE(cp);
                return;
            }
        }
        state->currentClass->callsSuper = 1;
        if (np->left && np->left->kind != N_NOP) {
            processAstNode(cp, np->left);
        }

    } else {
        astError(cp, np, "Can't use unqualified \"super\" outside a method");
    }
    LEAVE(cp);
}


static void astSwitch(EcCompiler *cp, EcNode *np)
{
    EcNode      *child;
    int         next;

    ENTER(cp);

    mprAssert(np->kind == N_SWITCH);
    mprAssert(np->right->kind == N_CASE_ELEMENTS);

    next = 0;
    while ((child = getNextAstNode(cp, np, &next))) {
        processAstNode(cp, child);
    }
    LEAVE(cp);
}


static void astThis(EcCompiler *cp, EcNode *np)
{
    EcState     *state;

    ENTER(cp);
    state = cp->state;

    switch (np->thisNode.thisKind) {
    case N_THIS_GENERATOR:
        //  TODO - binding not implemented
        break;

    case N_THIS_CALLEE:
        //  TODO - binding not implemented
        break;

    case N_THIS_TYPE:
        //  TODO - binding not implemented
        if (!state->inClass) {
            astError(cp, np, "\"this type\" is only valid inside a class");
        } else {
            np->lookup.obj = (EjsObj*) state->currentClass;
            np->lookup.slotNum = 0;
        }
        break;

    case N_THIS_FUNCTION:
        //  TODO - binding not implemented
        if (!state->inFunction) {
            astError(cp, np, "\"this function\" is not valid outside a function");
        } else {
            np->lookup.obj = (EjsObj*) state->currentFunction;
            np->lookup.slotNum = 0;
        }
        break;

    default:
        np->lookup.obj = (EjsObj*) state->currentClass;
        np->lookup.slotNum = 0;
    }
    LEAVE(cp);
}


static void astThrow(EcCompiler *cp, EcNode *np)
{
    mprAssert(np->left);
    processAstNode(cp, np->left);
}


/*
    Try, catch, finally
 */
static void astTry(EcCompiler *cp, EcNode *np)
{
    Ejs         *ejs;
    EcNode      *child;
    EjsBlock    *block;
    int         next, count;

    ENTER(cp);

    mprAssert(np->kind == N_TRY);
    mprAssert(np->exception.tryBlock);

    ejs = cp->ejs;
    np->exception.tryBlock->createBlockObject = 1;

    processAstNode(cp, np->exception.tryBlock);

    if (cp->phase == EC_PHASE_BIND) {
        /*
            Calculate the number of lexical blocks in the try block. These must be discarded by the VM when executing
            catch and finally blocks.
         */
        for (count = 0, block = ejs->state->bp->scopeChain; block && !ejsIsFunction(block); block = block->scopeChain) {
            if (!block->obj.hidden) {
                count++;
            }
        }
        np->exception.numBlocks = count;
    }

    if (np->exception.catchClauses) {
        next = 0;
        while ((child = getNextAstNode(cp, np->exception.catchClauses, &next))) {
            processAstNode(cp, child);
        }
    }
    if (np->exception.finallyBlock) {
        block = ejsCreateBlock(cp->ejs, 0);
        ejsSetDebugName(block, "finally");
        addScope(cp, block);
        processAstNode(cp, np->exception.finallyBlock);
        removeScope(cp);
    }
    LEAVE(cp);
}


/*
    Handle a unary operator.
 */
static void astUnaryOp(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);

    mprAssert(np->kind == N_UNARY_OP);
    mprAssert(np->left);

    if (np->left->kind == N_LITERAL && (np->tokenId == T_PLUS_PLUS || np->tokenId == T_MINUS_MINUS)) {
        astError(cp, np, "Invalid prefix operand");
    } else {
        processAstNode(cp, np->left);
    }
    LEAVE(cp);
}


/*
    Create a module defined via a module directive.
 */
static void astModule(EcCompiler *cp, EcNode *np)
{
    EjsModule       *mp, *core;
    Ejs             *ejs;
    EcState         *state;
    EcNode          *child;
    EjsBlock        *saveChain;
    int             next;

    mprAssert(np->kind == N_MODULE);

    ENTER(cp);

    ejs = cp->ejs;
    state = cp->state;
    
    if (cp->phase == EC_PHASE_DEFINE) {
        mp = createModule(cp, np);
    } else {
        mp = np->module.ref;
        mprAssert(mp);
    }
    if (mp == 0) {
        return;
    }
    mprAssert(mp->initializer);

    /*
        Start a new scope chain for this module. ie. Don't nest modules in the scope chain.
     */
    saveChain = ejs->state->bp->scopeChain;
    ejs->state->bp->scopeChain = mp->scopeChain;

    /*
        Create a block for the module initializer. There is also a child block but that is to hide namespace declarations 
        from other compilation units. Open the block explicitly rather than using astBlock. We do this because we need 
        varBlock to be set to ejs->global and let block to be mp->initializer. The block is really only used to scope 
        namespaces.
     */
    openBlock(cp, np, (EjsBlock*) mp->initializer);
    
    if (cp->phase == EC_PHASE_BIND) {
        /*
            Bind the block here before processing the child nodes so we can mark the block as hidden if it will be expunged.
         */
        bindBlock(cp, np->left);
    }
    
    /*
        Open the child block here so we can set the letBlock and varBlock values inside the block.
     */
    mprAssert(np->left->kind == N_BLOCK);
    openBlock(cp, np->left, NULL);
    
    state->optimizedLetBlock = ejs->global;
    state->varBlock = ejs->global;
    state->letBlock = (EjsObj*) mp->initializer;
    state->currentModule = mp;

    if (mp->dependencies == 0) {
        mp->dependencies = mprCreateList(mp);
        core = ejsLookupModule(ejs, "ejs", 0, 0);
        if (core && core != mp && mprLookupItem(mp->dependencies, core) < 0) {
            mprAddItem(mp->dependencies, core);
        }
    }

    /*
        Skip the first (block) child that was processed manually above.
     */
    for (next = 0; (child = getNextAstNode(cp, np->left, &next)); ) {
        processAstNode(cp, child);
    }

    closeBlock(cp);
    closeBlock(cp);
    
    if (cp->phase == EC_PHASE_CONDITIONAL) {
        /*
            Define block after the variables have been processed. This allows us to determine if the block is really needed.
         */
        defineBlock(cp, np->left);
    }

    ejs->state->bp->scopeChain = saveChain;
    LEAVE(cp);
}


/*
    Use Namespace
 */
static void astUseNamespace(EcCompiler *cp, EcNode *np)
{
    Ejs             *ejs;
    EjsNamespace    *namespace;
    EcState         *state, *s;

    ENTER(cp);

    state = cp->state;

    mprAssert(np->kind == N_USE_NAMESPACE);

    ejs = cp->ejs;
    namespace = 0;

    if (cp->phase == EC_PHASE_CONDITIONAL) {
        /*
            At the define phase, we create a dummy namespace assuming that it will exist somewhere in this block or an 
            outer block. At the fixup phase, we actually resolve the reference to the namespace unless it is a string 
            literal namespace.
         */
        namespace = ejsCreateNamespace(ejs, np->qname.name, np->qname.name);
        np->namespaceRef = namespace;

    } else if (cp->phase >= EC_PHASE_BIND) {
        if (np->useNamespace.isLiteral) {
            namespace = np->namespaceRef;

        } else {
            /*
                Resolve the real namespace. Must be visible in the current scope (even in standard mode). 
                Then update the URI. URI not used.
             */
            if (resolveName(cp, np, 0, &np->qname) < 0) {
                astError(cp, np, "Can't find namespace \"%s\"", np->qname.name);

            } else {
                namespace = (EjsNamespace*) np->lookup.ref;
                np->namespaceRef->uri = namespace->uri;

                if (!ejsIsNamespace(namespace)) {
                    astError(cp, np, "The variable \"%s\" is not a namespace", np->qname.name);
                } else {
                    np->namespaceRef = namespace;
                }
            }
            if (namespace && np->useNamespace.isDefault) {
                /*
                    Apply the namespace URI to all upper blocks
                 */
                for (s = cp->state; s; s = s->prev) {
                    s->namespace = (char*) namespace->uri;
                    if (s == cp->blockState) {
                        break;
                    }
                }
            }
        }

    } else {
        namespace = np->namespaceRef;
    }

    if (namespace) {
        if (state->letBlockNode) {
            state->letBlockNode->createBlockObject = 1;
        }
        if (state->inClass && !state->inFunction) {
            /*
                Must attach to the class itself and not to the outermost block
             */
            ejsAddNamespaceToBlock(ejs, (EjsBlock*) state->currentClass, namespace);
        } else {
            ejsAddNamespaceToBlock(ejs, (EjsBlock*) state->letBlock, namespace);
        }
    }
    LEAVE(cp);
}


/*
    Module depenency
 */
static void astRequire(EcCompiler *cp, EcNode *np)
{
    Ejs         *ejs;
    EjsModule   *currentModule, *mp;
    int         flags;

    mprAssert(np->kind == N_USE_MODULE);
    mprAssert(np->qname.name);

    ENTER(cp);

    ejs = cp->ejs;
    currentModule = cp->state->currentModule;
    mprAssert(currentModule);

    if (cp->phase == EC_PHASE_CONDITIONAL) {
        /*
            Is this a module we are currently compiling?
         */
        mp = ecLookupModule(cp, np->qname.name, np->useModule.minVersion, np->useModule.maxVersion);
        if (mp == 0) {
            /*
                Is this module already loaded by the vm?
             */
            mp = ejsLookupModule(ejs, np->qname.name, np->useModule.minVersion, np->useModule.maxVersion);
            if (mp == 0) {
                flags = cp->fileState->strict ? EJS_LOADER_STRICT : 0;
                if (ejsLoadModule(ejs, np->qname.name, np->useModule.minVersion, np->useModule.maxVersion, flags) < 0) {
                    astError(cp, np, "Error loading module \"%s\"\n%s", np->qname.name, ejsGetErrorMsg(ejs, 0));
                    cp->fatalError = 1;
                    LEAVE(cp);
                    return;
                }
                mp = ejsLookupModule(ejs, np->qname.name, np->useModule.minVersion, np->useModule.maxVersion);
            }
        }

        if (mp == 0) {
            astError(cp, np, "Can't find required module \"%s\"", np->qname.name);

        } else if (mp != currentModule) {
            if (currentModule->dependencies == 0) {
                currentModule->dependencies = mprCreateList(currentModule);
            }
            if (mprLookupItem(currentModule->dependencies, mp) < 0 && mprAddItem(currentModule->dependencies, mp) < 0) {
                mprAssert(0);
            }
        }
        mprAssert(np->left->kind == N_USE_NAMESPACE);
        np->left->qname.name = mp->vname;
    }
    mprAssert(np->left->kind == N_USE_NAMESPACE);
    processAstNode(cp, np->left);
    LEAVE(cp);
}


static void astWith(EcCompiler *cp, EcNode *np)
{
    Ejs         *ejs;
    EjsLookup   *lookup;
    bool        pushed;

    ENTER(cp);

    ejs = cp->ejs;
    pushed = 0;

    processAstNode(cp, np->with.object);

    if (cp->phase >= EC_PHASE_BIND) {
        processAstNode(cp, np->with.object);
        /*
            To permit early binding, if the object is typed, then add that type to the scope chain.
         */
        lookup = &np->with.object->lookup;
        if (lookup->trait && lookup->trait->type) {
            addScope(cp, (EjsBlock*) lookup->trait->type);
            pushed++;
        }
    }

    processAstNode(cp, np->with.statement);

    if (pushed) {
        removeScope(cp);
    }
    LEAVE(cp);

}


/*
    Determine the block in which to define a variable.
 */
static EjsObj *getBlockForDefinition(EcCompiler *cp, EcNode *np, EjsObj *block, int *attributes)
{
    EcState     *state;
    EjsType     *type;

    state = cp->state;

    if (ejsIsType(block) && state->inClass) {
        if (!(*attributes & EJS_PROP_STATIC) && !state->inFunction &&
            cp->classState->blockNestCount == (cp->state->blockNestCount - 1)) {
            /*
                If not static, outside a function and in the top level block.
             */
            type = (EjsType*) block;
            if (type->prototype == 0) {
                type->prototype = (EjsObj*) ejsCreatePrototype(cp->ejs, type, 0);
            }
            block = (EjsObj*) type->prototype;
            np->name.instanceVar = 1;
        }
    }
    return block;
}


static bool typeIsCompatible(EcCompiler *cp, EjsType *first, EjsType *second)
{
    Ejs     *ejs;

    ejs = cp->ejs;
    if (first == 0 || second == 0) {
        return 1;
    }
    if (strcmp(first->qname.name, second->qname.name) == 0 && strcmp(first->qname.space, second->qname.space) == 0) {
        return 1;
    }
    return 0;
}


/*
    Define a variable
 */
static void defineVar(EcCompiler *cp, EcNode *np, int varKind, EjsObj *value)
{
    Ejs             *ejs;
    EjsFunction     *method;
    EjsObj          *obj;
    EcState         *state;
    int             slotNum, attributes;

    ejs = cp->ejs;
    mprAssert(cp->phase == EC_PHASE_DEFINE);

    state = cp->state;
    method = state->currentFunction;

    if (state->inClass) {
        np->attributes |= EJS_TRAIT_FIXED;
        if (!(np->attributes & EJS_PROP_ENUMERABLE) && !(state->currentClassNode->attributes & EJS_PROP_ENUMERABLE)) {
            np->attributes |= EJS_TRAIT_HIDDEN;
        }
    }
    attributes = np->attributes;

    /*
        Only create block scope vars if the var block is different to the let block. This converts global let vars to vars.
     */
    np->name.letScope = 0;
    if (varKind & KIND_LET && (state->varBlock != state->optimizedLetBlock)) {
        np->name.letScope = 1;
    }

    if (np->name.letScope) {
        mprAssert(varKind & KIND_LET);
        /*
            Look in the current block scope but only one level deep. We lookup without any namespace decoration
            so we can prevent users defining variables in more than once namespace. (ie. public::x and private::x).
         */
        obj = getBlockForDefinition(cp, np, state->optimizedLetBlock, &attributes);
        if (ecLookupScope(cp, &np->qname, 1) >= 0 && cp->lookup.obj == obj) {
            obj = cp->lookup.obj;
            slotNum = cp->lookup.slotNum;
            if (cp->fileState->strict) {
                astError(cp, np, "Variable \"%s\" is already defined", np->qname.name);
                return;
            }
        } else {
            //  TODO - could / should change context to be obj for the names
            allocName(ejs, &np->qname);
            slotNum = ejsDefineProperty(ejs, obj, -1, &np->qname, 0, attributes, value);
        }

    } else {
        if (ecLookupVar(cp, state->varBlock, &np->qname, 1) >= 0) {
            obj = cp->lookup.obj;
            slotNum = cp->lookup.slotNum;
            if (cp->fileState->strict) {
                astError(cp, np, "Variable \"%s\" is already defined.", np->qname.name);
                return;
            }
        }
        /*
            Var declarations are hoisted to the nearest function, class or global block (never nested block scope)
         */
        obj = getBlockForDefinition(cp, np, (EjsObj*) state->varBlock, &attributes);
        allocName(ejs, &np->qname);
        slotNum = ejsDefineProperty(ejs, obj, -1, &np->qname, 0, attributes, value);
    }
    if (slotNum < 0) {
        astError(cp, np, "Can't define variable %s", np->qname.name);
        return;
    }
}


/*
    Hoist a block scoped variable and define in the nearest function, class or global block. This runs during the
    Hoist conditional phase. We hoist the variable by defining with a "-hoisted-%d" namespace which is added to the set of
    Hoist open namespaces. This namespace is only used when compiling and not at runtime. All access to the variable is bound
 */
static bool hoistBlockVar(EcCompiler *cp, EcNode *np)
{
    Ejs         *ejs;
    EcState     *state;
    EjsObj      *block, *obj, *vp;
    int         slotNum, attributes;

    mprAssert(cp->phase == EC_PHASE_CONDITIONAL);

    if (cp->optimizeLevel == 0) {
        return 0;
    }
    ejs = cp->ejs;
    state = cp->state;
    block = (np->kind == N_BLOCK) ? state->letBlock : state->optimizedLetBlock;
    attributes = np->attributes;

    if (state->inClass && state->inFunction) {
        obj = state->varBlock;
    } else {
        /*
            Global or class level block
         */
        mprAssert(!state->instanceCode);
        obj = state->varBlock;
        attributes |= EJS_PROP_STATIC;
    }

    if (!cp->bind && obj == ejs->global) {
        /* Can't hoist variables to global scope if not binding */
        return 0;
    }

    /*
        Delete the property from the original block. Don't reclaim slot, delete will set to 0.
        This lookup may fail it there were more than one declaration in a block. ie. already hoisted.
     */
    slotNum = ejsLookupProperty(ejs, block, &np->qname);
    if (slotNum < 0) {
        mprAssert(state->letBlockNode->namespaceRef);
        np->namespaceRef = state->letBlockNode->namespaceRef;
        np->qname.space = np->namespaceRef->uri;
    } else {
        vp = ejsGetProperty(ejs, block, slotNum);
        ejsDeleteProperty(ejs, block, slotNum);

        /*
            Redefine hoisted in the outer var block. Use a unique hoisted namespace to avoid clashes with other
            hoisted variables of the same name. Save the generated namespace for this block and reuse for any
            other hoisted vars from this block.
         */
        if (state->letBlockNode->namespaceRef) {
            np->namespaceRef = state->letBlockNode->namespaceRef;
        } else {
            np->namespaceRef = createHoistNamespace(cp, obj);
            state->letBlockNode->namespaceRef = np->namespaceRef;
        }
        np->qname.space = np->namespaceRef->uri;

        allocName(ejs, &np->qname);
        slotNum = ejsDefineProperty(ejs, obj, -1, &np->qname, 0, attributes, vp);
        if (slotNum < 0) {
            astError(cp, np, "Can't define local variable %s::%s", np->qname.space, np->qname.name);
            return 0;
        }
        if (obj == ejs->global) {
            addGlobalProperty(cp, np, &np->qname);
        }
    }
    np->name.letScope = 0;
    return 1;
}


/*
    Fully bind a variable definition. We already know the owning type and the slot number.
    We now need to  bind the variable type and set the trait reference.
 */
static void bindVariableDefinition(EcCompiler *cp, EcNode *np)
{
    Ejs             *ejs;
    EjsFunction     *fun;
    EjsObj          *block;
    EjsTrait        *trait;
    EcState         *state;
    EcNode          *typeNode;

    ENTER(cp);

    mprAssert(cp->phase >= EC_PHASE_BIND);

    ejs = cp->ejs;
    state = cp->state;
    fun = state->currentFunction;
    block = (np->name.letScope) ? state->optimizedLetBlock : state->varBlock;
    if (!state->inFunction) {
        if (!np->literalNamespace && resolveNamespace(cp, np, block, 0) == 0) {
            LEAVE(cp);
            return;
        }
    }
    if (cp->phase == EC_PHASE_BIND && block == ejs->global) {
        addGlobalProperty(cp, np, &np->qname);
    }
    /*
        Check if there is a name clash with any subclasses. Must do after fixup so that the base type has been defined.
        Look in the current type for any public property of the same name.
     */
    if (state->inClass && !state->inFunction && state->currentClass->baseType) {
        if (ecLookupVar(cp, (EjsObj*) state->currentClass->baseType, &np->qname, 0) >= 0) {
            astError(cp, np, "Public property %s is already defined in a base class", np->qname.name);
            LEAVE(cp);
            return;
        }
    }
    if (resolveName(cp, np, block, &np->qname) < 0) {
        astError(cp, np, "Can't find variable \"%s::%s\"", np->qname.space, np->qname.name);
    }
    typeNode = np->typeNode;
    if (typeNode && np->lookup.trait) {
        if (typeNode->lookup.ref) {
            if (!cp->fileState->strict) {
                /*
                    Allow variable redefinitions providing they are compatible
                 */
                trait = ejsGetPropertyTrait(ejs, np->lookup.obj, np->lookup.slotNum);
                if (!typeIsCompatible(cp, trait->type, (EjsType*) typeNode->lookup.ref)) {
                    astError(cp, np, "Redefinition of \"%s\" is not compatible with prior definition", np->qname.name);
                    LEAVE(cp);
                    return;
                }
            }
            ejsSetTraitType(np->lookup.trait, (EjsType*) typeNode->lookup.ref);
        }
    }
    setAstDocString(ejs, np, np->lookup.obj, np->lookup.slotNum);
    LEAVE(cp);
}


/*
    Define a variable
 */
static void astVar(EcCompiler *cp, EcNode *np, int varKind, EjsObj *value)
{
    EcState     *state;
    Ejs         *ejs;
    EjsObj      *obj;

    ejs = cp->ejs;
    state = cp->state;

    if (state->disabled) {
        if (cp->phase == EC_PHASE_CONDITIONAL) {
            obj = getBlockForDefinition(cp, np, (EjsObj*) state->varBlock, &np->attributes);
            removeProperty(cp, obj, np);
        }
        return;
    }

    state->instanceCode = 0;
    if (state->inClass && !(np->attributes & EJS_PROP_STATIC)) {
        if (state->inMethod) {
            state->instanceCode = 1;

        } else if (cp->classState->blockNestCount == (cp->state->blockNestCount - 1)) {
            /*
                Top level var declaration without a static attribute
             */
            state->instanceCode = 1;
        }

    } else {
        mprAssert(state->instanceCode == 0);
    }

    if (np->typeNode) {
        if (np->typeNode->kind != N_QNAME) {
            astError(cp, np, "Bad type name");
            return;
        }
        if (strcmp(np->typeNode->qname.name, "*") != 0) {
            processAstNode(cp, np->typeNode);
        }
    }
    if (cp->phase == EC_PHASE_DEFINE) {
        defineVar(cp, np, varKind, value);

    } else if (cp->phase == EC_PHASE_CONDITIONAL && np->name.letScope) {
        if (!hoistBlockVar(cp, np)) {
            /*
                Unhoisted let scoped variable.
             */
            state->letBlockNode->createBlockObject = 1;
        }

    } else if (cp->phase >= EC_PHASE_BIND) {
        if (np->namespaceRef) {
            /*
                Add any hoist namespaces that were defined in hoistBlockVar in the conditional phase
             */
            ejsAddNamespaceToBlock(ejs, (EjsBlock*) cp->state->optimizedLetBlock, np->namespaceRef);
        }
        bindVariableDefinition(cp, np);
    }
}


/*
    Define variables
 */
static void astVarDefinition(EcCompiler *cp, EcNode *np, int *codeRequired, int *instanceCode)
{
    Ejs         *ejs;
    EcNode      *child, *var, *right;
    EcState     *state;
    int         next, varKind, slotNum;

    mprAssert(np->kind == N_VAR_DEFINITION);

    ENTER(cp);

    ejs = cp->ejs;
    state = cp->state;
    mprAssert(state);

    varKind = np->def.varKind;

    next = 0;
    while ((child = getNextAstNode(cp, np, &next))) {
        if (child->kind == N_ASSIGN_OP) {
            var = child->left;
        } else {
            var = child;
        }
        astVar(cp, var, np->def.varKind, var->name.value);
        
        if (state->disabled) {
            continue;
        }
        if (child->kind == N_ASSIGN_OP) {
            *instanceCode = state->instanceCode;
            *codeRequired = 1;
        }
        if (child->kind == N_ASSIGN_OP) {
            astAssignOp(cp, child);

            right = child->right;
            mprAssert(right);

            /*
                Define constants here so they can be used for conditional compilation and "use namespace". We erase after the
                conditional phase.
             */
            if (right->kind == N_LITERAL && !(np->def.varKind & KIND_LET) && !(var->attributes & EJS_PROP_NATIVE)) {
                mprAssert(var->kind == N_QNAME);
                mprAssert(right->literal.var);
                /* Exclude class instance variables */
                if (! (state->inClass && !(var->attributes & EJS_PROP_STATIC))) {
                    slotNum = ejsLookupProperty(ejs, state->varBlock, &var->qname);
                    if (cp->phase == EC_PHASE_DEFINE) {
                        ejsSetProperty(ejs, state->varBlock, slotNum, right->literal.var);

                    } else if (cp->phase >= EC_PHASE_BIND && !var->name.isNamespace && slotNum >= 0) {
                        /*
                            Erase the value incase being run in the ejs shell. Must not prematurely define values.
                         */
                        ejsSetProperty(ejs, state->varBlock, slotNum, ejs->nullValue);
                    }
                }
            }
        }
    }
    LEAVE(cp);
}


/*
    Void type node
 */
static void astVoid(EcCompiler *cp, EcNode *np)
{
    EjsName     qname;

    mprAssert(np->kind == N_VOID);

    ENTER(cp);

    if (cp->phase >= EC_PHASE_BIND) {
        qname.name = "Void";
        qname.space = EJS_EJS_NAMESPACE;

        if (resolveName(cp, np, 0, &qname) < 0) {
            astError(cp, np, "Can't find variable \"%s::%s\"", qname.space, qname.name);
        }
    }
    LEAVE(cp);
}


/*
    Create a function to hold the module initialization code. Set a basic scope chain here incase running in ejs.
 */

static EjsFunction *createModuleInitializer(EcCompiler *cp, EcNode *np, EjsModule *mp)
{
    Ejs             *ejs;
    EjsFunction     *fun;

    ejs = cp->ejs;
    fun = ejsCreateFunction(ejs, 0, -1, 0, 0, 0, ejs->voidType, EJS_FUN_INITIALIZER, mp->constants, mp->scopeChain, 
        cp->state->strict);
    if (fun == 0) {
        astError(cp, np, "Can't create initializer function");
        return 0;
    }
    ejsSetDebugName(fun, mp->name);
    return fun;
}


/*
    Create the required module
 */
static EjsModule *createModule(EcCompiler *cp, EcNode *np)
{
    Ejs             *ejs;
    EjsModule       *mp;
    ejs = cp->ejs;

    mprAssert(np->kind == N_MODULE);

    if (np->module.version == 0 && cp->modver && strcmp(np->qname.name, EJS_DEFAULT_MODULE) != 0) {
        np->module.version = cp->modver;
    }
    mp = ecLookupModule(cp, np->qname.name, np->module.version, np->module.version);
    if (mp == 0) {
        mp = ejsCreateModule(cp->ejs, np->qname.name, np->module.version);
        if (mp == 0) {
            astError(cp, np, "Can't create module %s", np->qname.name);
            return 0;
        }
        mp->scopeChain = ejs->globalBlock;
        if (ecAddModule(cp, mp) < 0) {
            astError(cp, 0, "Can't insert module");
            return 0;
        }
        /*
            This will prevent the loading of any module that uses this module.
         */
        if (strcmp(mp->name, EJS_DEFAULT_MODULE) != 0) {
            mp->compiling = 1;
        }
    }

    if (mp->initializer == 0) {
        mp->initializer = createModuleInitializer(cp, np, mp);
    }
    np->module.ref = mp;

    if (cp->outputFile) {
        np->module.filename = cp->outputFile;
    } else {
        np->module.filename = mprStrcat(np, -1, np->qname.name, EJS_MODULE_EXT, NULL);
    }
    return mp;
}


static void astError(EcCompiler *cp, EcNode *np, char *fmt, ...)
{
    va_list     arg;
    char        *msg;

    va_start(arg, fmt);

    if ((msg = mprVasprintf(cp, 0, fmt, arg)) == NULL) {
        msg = "Memory allocation error";
    }
    cp->errorCount++;
    cp->error = 1;
    cp->noout = 1;
    
    if (np) {
        ecReportError(cp, "error", np->filename, np->lineNumber, np->currentLine, np->column, msg);
    } else {
        ecReportError(cp, "error", 0, 0, 0, 0, msg);
    }
    mprFree(msg);
    va_end(arg);
}


static void astWarn(EcCompiler *cp, EcNode *np, char *fmt, ...)
{
    va_list     arg;
    char        *msg;

    va_start(arg, fmt);

    if ((msg = mprVasprintf(cp, 0, fmt, arg)) == NULL) {
        msg = "Memory allocation error";
        cp->errorCount++;
        cp->error = 1;
    }
    cp->warningCount++;
    ecReportError(cp, "warning", np->filename, np->lineNumber, np->currentLine, np->column, msg);
    mprFree(msg);
    va_end(arg);
}


static void badAst(EcCompiler *cp, EcNode *np)
{
    cp->fatalError = 1;
    cp->errorCount++;
    mprError(cp, "Unsupported language feature\nUnknown AST node kind %d",  np->kind);
}


static EcNode *getNextAstNode(EcCompiler *cp, EcNode *np, int *next)
{
    if (cp->fatalError) {
        return 0;
    }
    if (np == 0 || np->children == 0) {
        return 0;
    }
    return (EcNode*) mprGetNextItem(np->children, next);
}


static void processAstNode(EcCompiler *cp, EcNode *np)
{
    EcState     *state;
    EjsType     *type;
    int         codeRequired, instanceCode;

    ENTER(cp);
    mprAssert(np->parent || np->kind == N_PROGRAM);

    state = cp->state;
    codeRequired = 0;
    instanceCode = state->instanceCode;
    
    switch (np->kind) {
    case N_ARGS:
        astArgs(cp, np);
        codeRequired++;
        break;

    case N_ARRAY_LITERAL:
        processAstNode(cp, np->left);
        codeRequired++;
        break;

    case N_ASSIGN_OP:
        astAssignOp(cp, np);
        codeRequired++;
        break;

    case N_BINARY_OP:
        astBinaryOp(cp, np);
        codeRequired++;
        break;

    case N_BLOCK:
        astBlock(cp, np);
        break;

    case N_BREAK:
        astBreak(cp, np);
        break;

    case N_CALL:
        astCall(cp, np);
        codeRequired++;
        break;

    case N_CASE_ELEMENTS:
        astCaseElements(cp, np);
        codeRequired++;
        break;

    case N_CASE_LABEL:
        astCaseLabel(cp, np);
        codeRequired++;
        break;

    case N_CATCH:
        astCatch(cp, np);
        codeRequired++;
        break;

    case N_CATCH_ARG:
        codeRequired++;
        break;

    case N_CLASS:
        astClass(cp, np);
        type = np->klass.ref;
        codeRequired++;
        break;

    case N_CONTINUE:
        break;

    case N_DIRECTIVES:
        astDirectives(cp, np);
        break;

    case N_DO:
        astDo(cp, np);
        codeRequired++;
        break;

    case N_DOT:
        astDot(cp, np);
        codeRequired++;
        break;

    case N_END_FUNCTION:
        break;

    case N_EXPRESSIONS:
        astExpressions(cp, np);
        break;

    case N_FOR:
        astFor(cp, np);
        codeRequired++;
        break;

    case N_FOR_IN:
        astForIn(cp, np);
        codeRequired++;
        break;

    case N_FUNCTION:
        astFunction(cp, np);
        break;

    case N_LITERAL:
        codeRequired++;
        break;

    case N_OBJECT_LITERAL:
        astObjectLiteral(cp, np);
        codeRequired++;
        break;

    case N_FIELD:
        astField(cp, np);
        codeRequired++;
        break;

    case N_QNAME:
        astName(cp, np);
        // codeRequired++;
        break;

    case N_NEW:
        astNew(cp, np);
        codeRequired++;
        break;

    case N_NOP:
        break;

    case N_POSTFIX_OP:
        astPostfixOp(cp, np);
        codeRequired++;
        break;

    case N_PRAGMAS:
        astPragmas(cp, np);
        break;

    case N_PRAGMA:
        astPragma(cp, np);
        break;

    case N_PROGRAM:
        astProgram(cp, np);
        break;

    case N_REF:
        codeRequired++;
        break;

    case N_RETURN:
        astReturn(cp, np);
        codeRequired++;
        break;

    case N_SUPER:
        astSuper(cp, np);
        codeRequired++;
        break;

    case N_SWITCH:
        astSwitch(cp, np);
        codeRequired++;
        break;

    case N_HASH:
        astHash(cp, np);
        break;

    case N_IF:
        astIf(cp, np);
        codeRequired++;
        break;

    case N_THIS:
        astThis(cp, np);
        codeRequired++;
        break;

    case N_THROW:
        astThrow(cp, np);
        codeRequired++;
        break;

    case N_TRY:
        astTry(cp, np);
        break;

    case N_UNARY_OP:
        astUnaryOp(cp, np);
        codeRequired++;
        break;

    case N_MODULE:
        astModule(cp, np);
        break;
            
    case N_TYPE_IDENTIFIERS:
        astImplements(cp, np);
        break;

    case N_USE_NAMESPACE:
        astUseNamespace(cp, np);
        /*
            Namespaces by themselves don't required code. Need something to use the namespace.
         */
        break;

    case N_USE_MODULE:
        astRequire(cp, np);
        break;

    case N_VAR_DEFINITION:
        astVarDefinition(cp, np, &codeRequired, &instanceCode);
        break;

    case N_VOID:
        astVoid(cp, np);
        break;

    case N_WITH:
        astWith(cp, np);
        break;

    default:
        mprAssert(0);
        badAst(cp, np);
    }
    
    /*
        Determine if classes need initializers. If class code is generated outside of a method, then some form of
        initialization will be required. Either a class constructor, initializer or a global initializer.
     */
    if (cp->phase == EC_PHASE_DEFINE && codeRequired && !state->inMethod && !state->inHashExpression) {

        if (state->inClass && !state->currentClass->isInterface) {
            if (instanceCode) {
                state->currentClass->hasConstructor = 1;
                state->currentClass->hasInitializer = 1;
            } else {
                state->currentClass->hasStaticInitializer = 1;
            }
        } else {
            state->currentModule->hasInitializer = 1;
        }
    }
    mprAssert(state == cp->state);
    LEAVE(cp);
}


static void removeProperty(EcCompiler *cp, EjsObj *obj, EcNode *np)
{
    Ejs             *ejs;
    EjsName         *prop;
    MprList         *globals;
    int             next, slotNum;

    mprAssert(obj);
    ejs = cp->ejs;

    if (np->globalProp) {
        globals = cp->state->currentModule->globalProperties;
        mprAssert(globals);

        for (next = 0; ((prop = (EjsName*) mprGetNextItem(globals, &next)) != 0); ) {
            if (strcmp(np->qname.space, prop->space) == 0 && strcmp(np->qname.name, prop->name) == 0) {
                mprRemoveItem(globals, prop);
                break;
            }
        }
    }
    slotNum = ejsLookupProperty(ejs, obj, &np->qname);
    if (slotNum >= 0) {
        ejsRemoveProperty(ejs, obj, slotNum);
    }
}


/*
    Fixup all slot definitions in types. When types are first created, they do not reserve space for inherited slots.
    Now that all types should have been resolved, we can reserve room for inherited slots. Override functions also 
    must be removed.
 */
static void fixupTypeSlots(EcCompiler *cp, EjsType *type)
{
    Ejs             *ejs;
    EjsType         *baseType, *iface, *owner;
    EjsFunction     *fun;
    EcNode          *np, *child;
    EjsName         qname;
    EjsTrait        *trait;
    int             rc, slotNum, attributes, next;

    if (type->block.obj.visited || !type->needFixup) {
        return;
    }
    type->needFixup = 0;

    mprAssert(cp);
    mprAssert(type);
    mprAssert(ejsIsType(type));

    ENTER(cp);

    rc = 0;
    ejs = cp->ejs;
    type->block.obj.visited = 1;
    np = (EcNode*) type->typeData;
    baseType = type->baseType;

    if (baseType == 0) {
        if (np && np->kind == N_CLASS && !np->klass.isInterface) {
            if (np->klass.extends) {
                ejsName(&qname, 0, np->klass.extends);
                baseType = (EjsType*) getTypeProperty(cp, ejs->global, &qname);
            } else {
                if (! (!ejs->initialized && strcmp(type->qname.name, "Object") == 0)) {
                    ejsName(&qname, EJS_EJS_NAMESPACE, "Object");
                    baseType = (EjsType*) getTypeProperty(cp, ejs->global, &qname);
                }
            }
        }
    }

    if (np->klass.implements) {
        type->implements = mprCreateList(type);
        next = 0;
        while ((child = getNextAstNode(cp, np->klass.implements, &next))) {
            iface = (EjsType*) getTypeProperty(cp, ejs->global, &child->qname);
            if (iface) {
                mprAddItem(type->implements, iface);
            } else {
                astError(cp, np, "Can't find interface \"%s\"", child->qname.name);
                type->block.obj.visited = 0;
                LEAVE(cp);
                return;
            }
        }
    }

    if (baseType == 0) {
        if (! (!ejs->initialized && strcmp(type->qname.name, "Object") == 0) && !np->klass.isInterface) {
            astError(cp, np, "Can't find base type for %s", type->qname.name);
            type->block.obj.visited = 0;
            LEAVE(cp);
            return;
        }
    }

    if (baseType) {
        if (baseType->needFixup) {
            fixupTypeSlots(cp, baseType);
        }
        if (baseType->hasConstructor) {
            type->hasBaseConstructors = 1;
        }
        if (baseType->hasInitializer) {
            type->hasBaseInitializers = 1;
        }
        if (baseType->hasStaticInitializer) {
            type->hasBaseStaticInitializers = 1;
        }
    }

    if (type->implements) {
        for (next = 0; ((iface = mprGetNextItem(type->implements, &next)) != 0); ) {
            if (iface->needFixup) {
                fixupTypeSlots(cp, iface);
            }
            if (iface->hasConstructor) {
                type->hasBaseConstructors = 1;
            }
            if (iface->hasInitializer) {
                type->hasBaseInitializers = 1;
            }
            if (iface->hasStaticInitializer) {
                type->hasBaseStaticInitializers = 1;
            }
        }
    }

    if (!type->block.obj.isPrototype && (EjsObj*) type != ejs->global && !type->isInterface) {
        /*
            Remove the static initializer slot if this class does not require a static initializer
            By convention, it is installed in slot number 1.
         */
        if (type->hasBaseStaticInitializers) {
            type->hasStaticInitializer = 1;
        }
        if (!type->hasStaticInitializer) {
            ejsRemoveProperty(ejs, (EjsObj*) type, 1);
        }

        /*
            Remove the constructor slot if this class does not require a constructor. ie. no base classes have constructors,
         */
        if (type->hasBaseConstructors) {
            type->hasConstructor = 1;
        }
        if (!type->hasConstructor) {
            if (np && np->klass.constructor && np->klass.constructor->function.isDefaultConstructor) {
                ejsRemoveProperty(ejs, (EjsObj*) type, 0);
                np->klass.constructor = 0;
            }
        }
    }

    if (!ejs->initialized) {
        if (type->hasConstructor && strcmp("Object", type->qname.name) == 0 && 
                strcmp(EJS_EJS_NAMESPACE, type->qname.space) == 0) {
            astWarn(cp, np, "Object class requires a constructor, but the native class does not implement one.");
        }
    }

    if (baseType) {
        ejsFixupType(ejs, type, baseType, 1);
    }
    
    /*
        Mark all inherited methods implemented for interfaces as implicitly overridden
     */
    for (slotNum = 0; slotNum < type->numInherited; slotNum++) {
        qname = ejsGetPropertyName(ejs, (EjsObj*) type, slotNum);
        fun = (EjsFunction*) ejsGetProperty(ejs, (EjsObj*) type, slotNum);
        if (fun && ejsIsFunction(fun)) {
            owner = (EjsType*) fun->owner;
            if (owner != type && ejsIsType(owner) && owner->isInterface) {
                fun->override = 1;
            }
        }
    }
    
    /*
        Remove the original overridden method slots. Set the inherited slot to the overridden method.
     */
    for (slotNum = type->numInherited; slotNum < type->block.obj.numSlots; slotNum++) {
        trait = ejsGetPropertyTrait(ejs, (EjsObj*) type, slotNum);
        if (trait == 0) {
            continue;
        }
        attributes = trait->attributes;
        if (attributes & EJS_FUN_OVERRIDE) {
            fun = (EjsFunction*) ejsGetProperty(ejs, (EjsObj*) type, slotNum);
            mprAssert(fun && ejsIsFunction(fun));
            qname = ejsGetPropertyName(ejs, (EjsObj*) type, slotNum);
            ejsRemoveProperty(ejs, (EjsObj*) type, slotNum);
            slotNum--;
            if (resolveName(cp, 0, (EjsObj*) type, &qname) < 0 || cp->lookup.slotNum < 0) {
                astError(cp, 0, "Can't find method \"%s::%s\" in base type of \"%s\" to override", qname.space, qname.name, 
                    type->qname.name);
            } else {
                fun->slotNum = cp->lookup.slotNum;
                ejsSetProperty(ejs, (EjsObj*) type, cp->lookup.slotNum, (EjsObj*) fun);
                trait = ejsGetTrait((EjsObj*) type, cp->lookup.slotNum);
                ejsSetTraitAttributes(trait, attributes);
            }
        }
    }
    type->block.obj.visited = 0;
    LEAVE(cp);
}


/*
    Lookup a namespace in the current scope. We look for the namespace variable declaration if it is a user
    defined namespace. Otherwise, we trust that if the set of open namespaces has the namespace -- it must exist.
 */
static EjsNamespace *resolveNamespace(EcCompiler *cp, EcNode *np, EjsObj *block, bool *modified)
{
    Ejs             *ejs;
    EjsName         qname;
    EjsNamespace    *namespace;
    int             slotNum;

    ejs = cp->ejs;

    if (modified) {
        *modified = 0;
    }

    /*
        Resolve the namespace. Must be visible in the current scope. Then update the URI.
     */
    qname.name = np->qname.space;
    qname.space = 0;
    namespace = (EjsNamespace*) getTypeProperty(cp, 0, &qname);
    if (namespace == 0 || !ejsIsNamespace(namespace)) {
        namespace = ejsLookupNamespace(cp->ejs, np->qname.space);
    }

    if (namespace == 0) {
        if (strcmp(cp->state->namespace, np->qname.space) == 0) {
            namespace = ejsCreateNamespace(ejs, np->qname.space, np->qname.space);
        }
    }

    if (namespace == 0) {
        if (!np->literalNamespace) {
            astError(cp, np, "Can't find namespace \"%s\"", qname.name);
        }

    } else {
        if (strcmp(namespace->uri, np->qname.space) != 0) {
            slotNum = ejsLookupProperty(ejs, block, &np->qname);
            mprAssert(slotNum >= 0);
            if (slotNum >= 0) {
                mprFree((char*) np->qname.space);
                /*
                    Change the name to use the namespace URI. This will change the property name and set
                    "modified" so that the caller can modify the type name if block is a type.
                 */
                np->qname.space = mprStrdup(np, namespace->uri);
                ejsSetPropertyName(ejs, block, slotNum, &np->qname);
                if (modified) {
                    *modified = 1;
                }
            }
        }
    }

    return namespace;
}


/*
    Locate a property via lookup and determine the best way to address the property.
 */
static int resolveName(EcCompiler *cp, EcNode *np, EjsObj *vp, EjsName *qname)
{
    Ejs         *ejs;
    EjsLookup   *lookup;
    EjsType     *type, *currentClass, *tp;
    EcState     *state;
    EjsBlock    *block;

    ejs = cp->ejs;
    state = cp->state;
    lookup = &cp->lookup;

    if (vp) {
        if (ecLookupVar(cp, vp, qname, 1) < 0) {
            return EJS_ERR;
        }
        lookup->originalObj = vp;

    } else {
        if (ecLookupScope(cp, qname, 1) < 0) {
            return EJS_ERR;
        }
        lookup->originalObj = lookup->obj;
    }

    /*
        Revise the nth block to account for blocks that will be erased
     */
    lookup->nthBlock = 0;
    for (block = ejs->state->bp->scopeChain; block; block = block->scopeChain) {
        if ((EjsObj*) block == lookup->obj) {
            break;
        }
        if (ejsIsType(block)) {
            type = (EjsType*) block;
            if ((EjsObj*) type->prototype == lookup->obj) {
                break;
            }
        }
        if (!block->obj.hidden) {
            lookup->nthBlock++;
        }
    }
    if (block == 0) {
        lookup->nthBlock = 0;
    }

    lookup->ref = ejsGetProperty(ejs, lookup->obj, lookup->slotNum);
    
    if (lookup->ref == ejs->nullValue) {
        lookup->ref = 0;
    }

    mprAssert(lookup->trait == 0);
    lookup->trait = ejsGetPropertyTrait(ejs, lookup->obj, lookup->slotNum);

    if ((ejsIsType(lookup->obj) || ejsIsPrototype(lookup->obj)) && state->currentObjectNode == 0) {
        mprAssert(lookup->obj != ejs->global);
        //  NOTE: could potentially do this for static properties as well
        if (lookup->trait) {
            /*
                class instance or method properties
             */
            type = (EjsType*) lookup->obj;
            currentClass = state->currentClass;
            if (currentClass) {
                mprAssert(state->inClass);
                for (tp = currentClass; tp; tp = tp->baseType) {
                    if ((EjsObj*) tp == lookup->obj || (EjsObj*) tp->prototype == lookup->obj) {
                        /*
                            Method code or class level instance initialization code. This is code that is a subtype of the 
                            type owning the property, so we can use the thisObj to access it.
                         */
                        if (state->inClass) {
                            lookup->useThis = 1;
                        }
                    }
                }
            }
        }
    }

    if (np) {
        np->lookup = cp->lookup;
#if DISABLE || 1
        if (np->lookup.slotNum >= 0) {
            /*
                Once we have resolved the name, we now know the selected namespace. Update it in "np" so that if
                --nobind is selected, we still get the variable of the correct namespace.
             */
            np->qname.space = np->lookup.name.space;
        }
#endif
    }
    return 0;
}


/*
    Locate a property in context. NOTE this only works for type properties not instance properties.
 */
static EjsObj *getTypeProperty(EcCompiler *cp, EjsObj *vp, EjsName *name)
{
    EcNode      node;

    mprAssert(cp);

    if (resolveName(cp, &node, vp, name) < 0) {
        return 0;
    }
    /*
        NOTE: ref may be null if searching for an instance property.
     */
    return node.lookup.ref;
}


/*
    Wrap the define property routine. Need to keep a module to property mapping
 */
static void addGlobalProperty(EcCompiler *cp, EcNode *np, EjsName *qname)
{
    Ejs             *ejs;
    EjsModule       *up;
    EjsName         *prop, *p;
    int             next;

    ejs = cp->ejs;

    up = cp->state->currentModule;
    mprAssert(up);

    prop = mprAllocObjZeroed(cp, EjsName);
    *prop = *qname;

    if (up->globalProperties == 0) {
        up->globalProperties = mprCreateList(up);
    }

    for (next = 0; (p = (EjsName*) mprGetNextItem(up->globalProperties, &next)) != 0; ) {
        if (strcmp(p->name, prop->name) == 0 && strcmp(p->space, prop->space) == 0) {
            return;
        }
    }
    next = mprAddItem(up->globalProperties, prop);
    if (np) {
        np->globalProp = prop;
    }
}


static void setAstDocString(Ejs *ejs, EcNode *np, EjsObj *block, int slotNum)
{
    mprAssert(block);

    if (np->doc && slotNum >= 0 && ejsIsBlock(block)) {
        ejsCreateDoc(ejs, (EjsBlock*) block, slotNum, np->doc);
    }
}


static void addScope(EcCompiler *cp, EjsBlock *block)
{
    block->scopeChain = cp->ejs->state->bp->scopeChain;
    cp->ejs->state->bp->scopeChain = block;
}


static void removeScope(EcCompiler *cp)
{
    EjsBlock    *block;

    block = cp->ejs->state->bp;
    block->scopeChain = block->scopeChain->scopeChain;
}


/*
    Create a new lexical block scope and open it
 */
static void openBlock(EcCompiler *cp, EcNode *np, EjsBlock *block)
{
    Ejs             *ejs;
    EcState         *state;
    EjsNamespace    *namespace;
    char            *debugName;
    int             next;

    ejs = cp->ejs;
    state = cp->state;

    if (cp->phase == EC_PHASE_DEFINE) {
        if (block == 0) {
            static int index = 0;
            if (np->filename == 0) {
                debugName = mprAsprintf(np, -1, "block_%04d", index++);
            } else {
                debugName = mprAsprintf(np, -1, "block_%04d_%d", np->lineNumber, index++);
            }
            block = ejsCreateBlock(cp->ejs, 0);
            ejsSetDebugName(block, debugName);
            np->qname.name = debugName;
            np->qname.space = EJS_BLOCK_NAMESPACE;
        }
        np->blockRef = block;

    } else {
        /*
            Must reset the namespaces each phase. This is because pragmas must apply from the point of use in a block onward
            only. Except for hoisted variable namespaces which must apply from the start of the block. They are applied below
         */
        if (block == 0) {
            block = np->blockRef;
        }
        mprAssert(block != ejs->globalBlock);
        ejsResetBlockNamespaces(ejs, block);
    }
    
    state->namespaceCount = ejsGetNamespaceCount(block);

    /*
        Special case for the outermost module block. The module (file) block is created to provide a compilation unit
        level scope. However, we do not use the block for the let or var scope, rather we use the global scope.
        Namespaces always use this new block.
     */
    if (! (state->letBlock == ejs->global && np->parent->kind == N_MODULE)) {
        state->optimizedLetBlock = (EjsObj*) block;
    }
    state->letBlock = (EjsObj*) block;
    state->letBlockNode = np;

    /*
        Add namespaces that must apply from the start of the block. Current users: hoisted let vars.
     */
    if (np->namespaces) {
        for (next = 0; (namespace = (EjsNamespace*) mprGetNextItem(np->namespaces, &next)) != 0; ) {
            ejsAddNamespaceToBlock(ejs, block, namespace);
        }
    }
    /*
        Mark the state corresponding to the last opened block
     */
    state->prevBlockState = cp->blockState;
    cp->blockState = state;
    addScope(cp, block);
}


static void closeBlock(EcCompiler *cp)
{
    ejsPopBlockNamespaces((EjsBlock*) cp->state->letBlock, cp->state->namespaceCount);
    cp->blockState = cp->state->prevBlockState;
    removeScope(cp);
}


static EjsNamespace *createHoistNamespace(EcCompiler *cp, EjsObj *obj)
{
    EjsNamespace    *namespace;
    Ejs             *ejs;
    EcNode          *letBlockNode;
    char            *spaceName;

    ejs = cp->ejs;
    spaceName = mprAsprintf(cp, -1, "-hoisted-%d", ejsGetPropertyCount(ejs, obj));
    namespace = ejsCreateNamespace(ejs, spaceName, spaceName);

    letBlockNode = cp->state->letBlockNode;
    if (letBlockNode->namespaces == 0) {
        letBlockNode->namespaces = mprCreateList(letBlockNode);
    }
    mprAddItem(letBlockNode->namespaces, namespace);
    ejsAddNamespaceToBlock(ejs, (EjsBlock*) cp->state->optimizedLetBlock, namespace);
    return namespace;
}


static EjsNamespace *ejsLookupNamespace(Ejs *ejs, cchar *namespace)
{
    EjsList         *namespaces;
    EjsNamespace    *nsp;
    EjsBlock        *block;
    int             nextNamespace;

    /*
        Lookup the scope chain considering each block and the open namespaces at that block scope.
     */
    for (block = ejs->state->bp; block; block = block->scopeChain) {
        if (!ejsIsBlock(block)) {
            continue;
        }

        namespaces = &block->namespaces;
        if (namespaces == 0) {
            namespaces = &ejs->globalBlock->namespaces;
        }

#if BLD_DEBUG
        mprLog(ejs, 7, "ejsLookupNamespace in %s", ejsGetDebugName(block));
        for (nextNamespace = 0; (nsp = (EjsNamespace*) ejsGetNextItem(namespaces, &nextNamespace)) != 0; ) {
            mprLog(ejs, 7, "    scope \"%s\"", nsp->uri);
        }
#endif

        mprLog(ejs, 7, "    SEARCH for qname \"%s\"", namespace);
        for (nextNamespace = -1; (nsp = (EjsNamespace*) ejsGetPrevItem(namespaces, &nextNamespace)) != 0; ) {
            if (strcmp(nsp->uri, namespace) == 0) {
                return nsp;
            }
        }
    }

    return 0;
}


/*
    Look for a variable by name in the scope chain and return the location in "cp->lookup" and a positive slot 
    number if found.  If the name.space is non-null/non-empty, then only the given namespace will be used. 
    otherwise the set of open namespaces will be used. The lookup structure will contain details about the location 
    of the variable.
 */
int ecLookupScope(EcCompiler *cp, EjsName *name, bool anySpace)
{
    Ejs             *ejs;
    EjsBlock        *block;
    EjsLookup       *lookup;
    int             slotNum, nth;

    mprAssert(name);

    ejs = cp->ejs;
    slotNum = -1;

    if (name->space == 0) {
        name->space = "";
    }
    lookup = &cp->lookup;
    lookup->ref = 0;
    lookup->trait = 0;
    lookup->name.name = 0;
    lookup->name.space = 0;

    /*
        Look in the scope chain considering each block scope. LookupVar will consider base classes and namespaces.
        Skip the first dummy block created in compileInner.
     */
    for (nth = 1, block = ejs->state->bp->scopeChain; block; block = block->scopeChain) {
        if ((slotNum = ecLookupVar(cp, (EjsObj*) block, name, anySpace)) >= 0) {
            lookup->nthBlock = nth;
            break;
        }
        nth++;
    }
    lookup->slotNum = slotNum;
    return slotNum;
}


/*
    Find a property in an object or type and its base classes.
 */
int ecLookupVar(EcCompiler *cp, EjsObj *vp, EjsName *name, bool anySpace)
{
    Ejs             *ejs;
    EjsLookup       *lookup;
    EjsObj          *originalObj;
    EjsType         *type;
    int             slotNum;

    mprAssert(vp);
    mprAssert(vp->type);
    mprAssert(name);

    ejs = cp->ejs;

    if (name->space == 0) {
        name->space = "";
    }    
    lookup = &cp->lookup;
    lookup->ref = 0;
    lookup->trait = 0;
    lookup->name.name = 0;
    lookup->name.space = 0;

    /*
        OPT - bit field initialization
     */
    lookup->nthBase = 0;
    lookup->nthBlock = 0;
    lookup->useThis = 0;
    lookup->instanceProperty = 0;
    lookup->ownerIsType = 0;
    originalObj = vp;

    /*
        Search through the inheritance chain of base classes.
        nthBase is incremented from zero for every subtype that must be traversed. 
     */
    for (slotNum = -1, lookup->nthBase = 0; vp; lookup->nthBase++) {
        if ((slotNum = ecLookupVarWithNamespaces(ejs, originalObj, vp, name, lookup)) >= 0) {
            break;
        }
        if (! ejsIsType(vp)) {
            vp = (EjsObj*) vp->type;
            continue;
        }
        type = (EjsType*) vp;
        if (type->prototype && type->prototype->numSlots > 0) {
            if ((slotNum = ecLookupVarWithNamespaces(ejs, originalObj, (EjsObj*) type->prototype, name, lookup)) >= 0) {
                lookup->instanceProperty = 1;
                break;
            }
        }
        vp = (EjsObj*) ((EjsType*) vp)->baseType;
    }
    return lookup->slotNum = slotNum;
}


/*
    Find a variable in a block. Scope blocks are provided by the global object, types, functions and statement blocks.
    This is a copy of the code from the VM with the exception that we allow the access to instance methods from
    type objects.
 */
static int ecLookupVarWithNamespaces(Ejs *ejs, EjsObj *originalObj, EjsObj *vp, EjsName *name, EjsLookup *lookup)
{
    EjsNamespace    *nsp;
    EjsName         qname;
    EjsBlock        *b;
    EjsObj          *owner;
    EjsFunction     *ref;
    int             slotNum, nextNsp;

    mprAssert(vp);
    mprAssert(name);
    mprAssert(name->name);
    mprAssert(name->space);
    mprAssert(lookup);

    if ((slotNum = ejsLookupProperty(ejs, vp, name)) < 0 && name->space[0] != EJS_EMPTY_NAMESPACE[0]) {
        /* Explicit namespace - not need to search the set of open namespaces */
        return slotNum;
    }
    if (slotNum >= 0) {
        ref = (EjsFunction*) ejsGetProperty(ejs, vp, slotNum);
        if (!(ejsIsType(vp) && originalObj != vp && !ejsIsType(originalObj) && (!ejsIsFunction(ref) || ref->staticMethod))) {
            /* Not accessing a static method from an instance */
            lookup->name = *name;
            lookup->obj = vp;
            lookup->slotNum = slotNum;
            return slotNum;
        }
    }
    qname = *name;
    for (b = ejs->state->bp; b; b = b->scopeChain) {
        for (nextNsp = -1; (nsp = (EjsNamespace*) ejsGetPrevItem(&b->namespaces, &nextNsp)) != 0; ) {

            if (nsp->flags & EJS_NSP_PROTECTED && vp->isType && ejs->state->fp) {
                /*
                    Protected access. See if the type containing the method we are executing is a sub class of the type 
                    containing the property ie. Can we see protected properties?
                 */
                owner = (EjsObj*) ejs->state->fp->function.owner;
                if (owner && !ejsIsA(ejs, owner, (EjsType*) vp)) {
                    continue;
                }
            }
            qname.space = nsp->uri;
            mprAssert(qname.space);
            if (qname.space) {
                slotNum = ejsLookupProperty(ejs, vp, &qname);
                if (slotNum >= 0) {
                    //  MOB -- since we need to get the trait anyway, better to determine this from the trait
                    lookup->name = qname;
                    lookup->obj = vp;
                    lookup->slotNum = slotNum;
                    return slotNum;
                }
            }
        }
    }
    return -1;
}


static void allocName(Ejs *ejs, EjsName *qname)
{
    qname->space = mprStrdup(ejs, qname->space);
    qname->name = mprStrdup(ejs, qname->name);
}

/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2010. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2010. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    @end
 */
/************************************************************************/
/*
 *  End of file "../src/compiler/ecAst.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../src/compiler/ecCodeGen.c"
 */
/************************************************************************/

/**
    ecCodeGen.c - Ejscript code generator
  
    This module generates code for a program that is represented by an in-memory AST set of nodes.
  
    Copyright (c) All Rights Reserved. See details at the end of the file.
 */




/*
    State level macros. Enter/Leave manage state and inheritance of state.
 */
#undef ENTER
#define ENTER(a)    if (ecEnterState(a) < 0) { return; } else

#undef LEAVE
#define LEAVE(cp)   ecLeaveState(cp)

#define SAVE_ONLEFT(cp)                                     \
    if (1) {                                                \
            cp->state->saveOnLeft = cp->state->onLeft;      \
            cp->state->onLeft = 0;                          \
    } else

#define RESTORE_ONLEFT(cp)                                  \
    cp->state->onLeft = cp->state->saveOnLeft


static void     addDebugInstructions(EcCompiler *cp, EcNode *np);
static void     addException(EcCompiler *cp, uint tryStart, uint tryEnd, EjsType *catchType, uint handlerStart, 
                    uint handlerEnd, int numBlocks, int numStack, int flags);
static void     addJump(EcCompiler *cp, EcNode *np, int kind);
static void     addModule(EcCompiler *cp, EjsModule *mp);
static EcCodeGen *allocCodeBuffer(EcCompiler *cp);
static void     badNode(EcCompiler *cp, EcNode *np);
static void     copyCodeBuffer(EcCompiler *cp, EcCodeGen *dest, EcCodeGen *code);
static void     createInitializer(EcCompiler *cp, EjsModule *mp);
static void     emitNamespace(EcCompiler *cp, EjsNamespace *nsp);
static void     emptyStack(EcCompiler *cp, int preserve);
static int      flushModule(MprFile *file, EcCodeGen *code);
static void     genBinaryOp(EcCompiler *cp, EcNode *np);
static void     genBlock(EcCompiler *cp, EcNode *np);
static void     genBreak(EcCompiler *cp, EcNode *np);
static void     genBoundName(EcCompiler *cp, EcNode *np);
static void     genCall(EcCompiler *cp, EcNode *np);
static void     genCatchArg(EcCompiler *cp, EcNode *np);
static void     genClass(EcCompiler *cp, EcNode *child);
static void     genClassName(EcCompiler *cp, EjsType *type);
static int      getCodeLength(EcCompiler *cp, EcCodeGen *code);
static void     genContinue(EcCompiler *cp, EcNode *np);
static void     genDirectives(EcCompiler *cp, EcNode *np, bool resetStack);
static void     genDo(EcCompiler *cp, EcNode *np);
static void     genDot(EcCompiler *cp, EcNode *np, EcNode **rightMost);
static void     genError(EcCompiler *cp, EcNode *np, char *fmt, ...);
static void     genEndFunction(EcCompiler *cp, EcNode *np);
static void     genExpressions(EcCompiler *cp, EcNode *np);
static void     genFor(EcCompiler *cp, EcNode *np);
static void     genForIn(EcCompiler *cp, EcNode *np);
static void     genFunction(EcCompiler *cp, EcNode *np);
static void     genHash(EcCompiler *cp, EcNode *np);
static void     genIf(EcCompiler *cp, EcNode *np);
static void     genLeftHandSide(EcCompiler *cp, EcNode *np);
static void     genLiteral(EcCompiler *cp, EcNode *np);
static void     genLogicalOp(EcCompiler *cp, EcNode *np);
static void     genModule(EcCompiler *cp, EcNode *np);
static void     genName(EcCompiler *cp, EcNode *np);
static void     genNameExpr(EcCompiler *cp, EcNode *np);
static void     genNew(EcCompiler *cp, EcNode *np);
static void     genObjectLiteral(EcCompiler *cp, EcNode *np);
static void     genProgram(EcCompiler *cp, EcNode *np);
static void     genPragmas(EcCompiler *cp, EcNode *np);
static void     genPostfixOp(EcCompiler *cp, EcNode *np);
static void     genReturn(EcCompiler *cp, EcNode *np);
static void     genSuper(EcCompiler *cp, EcNode *np);
static void     genSwitch(EcCompiler *cp, EcNode *np);
static void     genThis(EcCompiler *cp, EcNode *np);
static void     genThrow(EcCompiler *cp, EcNode *np);
static void     genTry(EcCompiler *cp, EcNode *np);
static void     genUnaryOp(EcCompiler *cp, EcNode *np);
static void     genUnboundName(EcCompiler *cp, EcNode *np);
static void     genUseNamespace(EcCompiler *cp, EcNode *np);
static void     genVar(EcCompiler *cp, EcNode *np);
static void     genVarDefinition(EcCompiler *cp, EcNode *np);
static void     genWith(EcCompiler *cp, EcNode *np);
static EcNode   *getNextNode(EcCompiler *cp, EcNode *np, int *next);
static EcNode   *getPrevNode(EcCompiler *cp, EcNode *np, int *next);
static int      mapToken(EcCompiler *cp, EjsOpCode tokenId);
static MprFile  *openModuleFile(EcCompiler *cp, cchar *filename);
static void     orderModule(EcCompiler *cp, MprList *list, EjsModule *mp);
static void     patchJumps(EcCompiler *cp, int kind, int target);
static void     popStack(EcCompiler *cp, int count);
static void     processNode(EcCompiler *cp, EcNode *np);
static void     processModule(EcCompiler *cp, EjsModule *mp);
static void     pushStack(EcCompiler *cp, int count);
static void     resetStack(EcCompiler *cp);
static void     setCodeBuffer(EcCompiler *cp, EcCodeGen *saveCode);
static void     setFunctionCode(EcCompiler *cp, EjsFunction *fun, EcCodeGen *code);
static void     setStack(EcCompiler *cp, int count);

/*
    Generate code for evaluating conditional compilation directives
 */
void ecGenConditionalCode(EcCompiler *cp, EcNode *np, EjsModule *mp)
{
    EcState         *state;

    ENTER(cp);

    state = cp->state;
    mprAssert(state);

    addModule(cp, mp);
    genDirectives(cp, np, 0);

    /*
        Save the expression result from the stack into ejs->frame->returnValue
     */
    ecEncodeOpcode(cp, EJS_OP_SAVE_RESULT);

    if (cp->errorCount > 0) {
        ecRemoveModule(cp, mp);
        LEAVE(cp);
        return;
    }
    createInitializer(cp, mp);
    ecRemoveModule(cp, mp);
    LEAVE(cp);
}


/*
    Top level for code generation. Loop through the AST nodes recursively.
 */
int ecCodeGen(EcCompiler *cp, int argc, EcNode **nodes)
{
    EjsModule   *mp;
    EcNode      *np;
    MprList       *modules;
    int         i, version, next;

    if (ecEnterState(cp) < 0) {
        return EJS_ERR;
    }
    for (i = 0; i < argc; i++) {
        np = nodes[i];
        cp->fileState = cp->state;
        cp->fileState->strict = cp->strict;
        if (np) {
            processNode(cp, np);
        }
    }

    /*
        Open once if merging into a single output file
     */
    if (cp->outputFile) {
        for (version = next = 0; (mp = mprGetNextItem(cp->modules, &next)) != 0; ) {
            mprAssert(!mp->loaded);
            if (next <= 1 || mp->globalProperties || mp->hasInitializer || strcmp(mp->name, EJS_DEFAULT_MODULE) != 0) {
                version = mp->version;
                break;
            }
        }
        if (openModuleFile(cp, cp->outputFile) == 0) {
            return EJS_ERR;
        }
    }

    /*
        Now generate code for all the modules
     */
    modules = mprCreateList(cp);
    for (next = 0; (mp = mprGetNextItem(cp->modules, &next)) != 0; ) {
        orderModule(cp, modules, mp);
    }
    for (next = 0; (mp = mprGetNextItem(modules, &next)) != 0; ) {
        if (mp->loaded) {
            continue;
        }
        /*
            Don't generate the default module unless it contains some real code or definitions and 
            we have more than one module.
         */
        if (mprGetListCount(cp->modules) == 1 || mp->globalProperties || mp->hasInitializer || 
                strcmp(mp->name, EJS_DEFAULT_MODULE) != 0) {
            mp->initialized = 0;
            processModule(cp, mp);
        }
    }
    mprFree(cp->modules);
    cp->modules = modules;

    if (cp->outputFile) {
        if (flushModule(cp->file, cp->state->code) < 0) {
            genError(cp, 0, "Can't write to module file %s", cp->outputFile);
        }
        mprFree(cp->file);
        cp->file = 0;
    }
    cp->file = 0;
    ecLeaveState(cp);
    return (cp->fatalError) ? EJS_ERR : 0;
}


static void orderModule(EcCompiler *cp, MprList *list, EjsModule *mp)
{
    EjsModule   *dp;
    int         next;
    
    for (next = 0; (dp = mprGetNextItem(mp->dependencies, &next)) != 0; ) {
        if (mprLookupItem(list, dp) < 0 && mprLookupItem(cp->modules, dp) >= 0) {
            orderModule(cp, list, dp);
        }
    }
    if (mprLookupItem(list, mp) < 0) {
        mprAddItem(list, mp);
    }
}


static void genArgs(EcCompiler *cp, EcNode *np)
{
    EcNode      *child;
    int         next;

    ENTER(cp);

    mprAssert(np->kind == N_ARGS);

    cp->state->needsValue = 1;

    next = 0;
    while ((child = getNextNode(cp, np, &next)) && !cp->error) {
        if (child->kind == N_ASSIGN_OP) {
            child->needDup = 1;
        }
        processNode(cp, child);
        child->needDup = 0;
    }
    LEAVE(cp);
}


static void genArrayLiteral(EcCompiler *cp, EcNode *np)
{
    EcNode      *child;
    int         next;

    ENTER(cp);

    next = 0;
    while ((child = getNextNode(cp, np, &next)) != 0) {
        /* Don't propagate needsValue here. We have a new and that will take care of the residual value */
        cp->state->needsValue = 0;
        processNode(cp, child);
    }
    LEAVE(cp);
}


/*
    Generate an assignment expression
 */
static void genAssignOp(EcCompiler *cp, EcNode *np)
{
    EcState     *state;
    int         rc, next;

    ENTER(cp);

    state = cp->state;
    rc = 0;
    next = 0;

    mprAssert(np->kind == N_ASSIGN_OP);
    mprAssert(np->left);
    mprAssert(np->right);

    state->onLeft = 0;

    /*
        Dup the object on the stack so it is available for subsequent operations
     */
    if (np->needDupObj) {
        ecEncodeOpcode(cp, EJS_OP_DUP);
        pushStack(cp, 1);
    }

    /*
        Process the expression on the right. Leave the result on the stack.
     */
    if (np->right->kind == N_ASSIGN_OP) {
        np->right->needDup = 1;
    }

    state->needsValue = 1;
    processNode(cp, np->right);
    state->needsValue = 0;

    if (np->needDupObj) {
        /*
            Get the object on the top above the value
         */
        ecEncodeOpcode(cp, EJS_OP_SWAP);
    }

    /*
        If this expression is part of a function argument, the result must be preserved.
     */
    if (np->needDup || state->prev->needsValue) {
        ecEncodeOpcode(cp, EJS_OP_DUP);
        pushStack(cp, 1);
    }

    /*
        Store to the left hand side
     */
    genLeftHandSide(cp, np->left);
    LEAVE(cp);
}


static void genBinaryOp(EcCompiler *cp, EcNode *np)
{
    EcState     *state;

    ENTER(cp);

    state = cp->state;
    state->needsValue = 1;

    mprAssert(np->kind == N_BINARY_OP);

    switch (np->tokenId) {
    case T_LOGICAL_AND:
    case T_LOGICAL_OR:
        genLogicalOp(cp, np);
        break;

    default:
        if (np->left) {
            processNode(cp, np->left);
        }
        if (np->right) {
            processNode(cp, np->right);
        }
        ecEncodeOpcode(cp, mapToken(cp, np->tokenId));
        popStack(cp, 2);
        pushStack(cp, 1);
        break;
    }

    mprAssert(state == cp->state);
    LEAVE(cp);
}


static void genBreak(EcCompiler *cp, EcNode *np)
{
    EcState     *state;

    ENTER(cp);

    state = cp->state;

    if (state->captureBreak) {
        ecEncodeOpcode(cp, EJS_OP_FINALLY);
    }

    if (state->code->jumps == 0 || !(state->code->jumpKinds & EC_JUMP_BREAK)) {
        genError(cp, np, "Illegal break statement");

    } else {
        emptyStack(cp, 0);
        ecEncodeOpcode(cp, EJS_OP_GOTO);
        addJump(cp, np, EC_JUMP_BREAK);
        ecEncodeWord(cp, 0);
    }
    LEAVE(cp);
}


static void genBlock(EcCompiler *cp, EcNode *np)
{
    Ejs             *ejs;
    EjsNamespace    *namespace;
    EcState         *state;
    EjsBlock        *block;
    EjsLookup       *lookup;
    EcNode          *child;
    int             next;

    ENTER(cp);

    state = cp->state;
    ejs = cp->ejs;
    block = (EjsBlock*) np->blockRef;

    if (block && np->createBlockObject) {
        state->prevBlockState = cp->blockState;
        cp->blockState = state;

        lookup = &np->lookup;
        if (lookup->slotNum >= 0) {
            ecEncodeOpcode(cp, EJS_OP_OPEN_BLOCK);
            ecEncodeNumber(cp, lookup->slotNum);
            ecEncodeNumber(cp, lookup->nthBlock);
        }

        /*
            Emit block namespaces
         */
        if (block->namespaces.length > 0) {
            for (next = 0; ((namespace = (EjsNamespace*) ejsGetNextItem(&block->namespaces, &next)) != 0); ) {
                if (namespace->name[0] == '-') {
                    emitNamespace(cp, namespace);
                }
            }
        }

        state->letBlock = (EjsObj*) block;
        state->letBlockNode = np;

        next = 0;
        while ((child = getNextNode(cp, np, &next))) {
            processNode(cp, child);
        }

        if (lookup->slotNum >= 0) {
            ecEncodeOpcode(cp, EJS_OP_CLOSE_BLOCK);
        }
        cp->blockState = state->prevBlockState;
        ecAddNameConstant(cp, &np->qname);

    } else {
        next = 0;
        mprAssert(cp->state->code->stackCount == 0);

        while ((child = getNextNode(cp, np, &next))) {
            mprAssert(cp->state->code->stackCount == 0);
            processNode(cp, child);
        }
    }
    LEAVE(cp);
}


/*
    Block scope variable reference
 */
static void genBlockName(EcCompiler *cp, int slotNum, int nthBlock)
{
    int         code;

    mprAssert(slotNum >= 0);

#if FUTURE
    if (slotNum < 10) {
        code = (!cp->state->onLeft) ?  EJS_OP_GET_BLOCK_SLOT_0 :  EJS_OP_PUT_BLOCK_SLOT_0;
        ecEncodeOpcode(cp, code + slotNum);

    } else {
#endif

        code = (!cp->state->onLeft) ?  EJS_OP_GET_BLOCK_SLOT :  EJS_OP_PUT_BLOCK_SLOT;
        ecEncodeOpcode(cp, code);
        ecEncodeNumber(cp, slotNum);
        ecEncodeNumber(cp, nthBlock);
#if FUTURE
    }
#endif
    pushStack(cp, (cp->state->onLeft) ? -1 : 1);
}


static void genContinue(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);

    if (cp->state->captureBreak) {
        ecEncodeOpcode(cp, EJS_OP_FINALLY);
    }
    if (cp->state->code->jumps == 0 || !(cp->state->code->jumpKinds & EC_JUMP_CONTINUE)) {
        genError(cp, np, "Illegal continue statement");

    } else {
        ecEncodeOpcode(cp, EJS_OP_GOTO);
        addJump(cp, np, EC_JUMP_CONTINUE);
        ecEncodeWord(cp, 0);
    }
    LEAVE(cp);
}


static void genDelete(EcCompiler *cp, EcNode *np)
{
    EcNode      *left, *lright;

    ENTER(cp);

    mprAssert(np);

    left = np->left;
    mprAssert(left);

    switch (left->kind) {
    case N_DOT:
        processNode(cp, left->left);
        lright = left->right;
        if (lright->kind == N_QNAME) {
            /* delete obj.name */
            genNameExpr(cp, lright);
            ecEncodeOpcode(cp, EJS_OP_DELETE_NAME_EXPR);
            popStack(cp, 3);
        } else {
            /* delete obj[expr] */
            ecEncodeOpcode(cp, EJS_OP_LOAD_STRING);
            ecEncodeString(cp, EJS_EMPTY_NAMESPACE);
            processNode(cp, lright);
            ecEncodeOpcode(cp, EJS_OP_DELETE_NAME_EXPR);
            popStack(cp, 2);
        }
        break;

    case N_QNAME:
        /* delete space::name */
        genNameExpr(cp, left);
        ecEncodeOpcode(cp, EJS_OP_DELETE_SCOPED_NAME_EXPR);
        popStack(cp, 2);
        break;

    default:
        mprAssert(0);
    }
    LEAVE(cp);
}


/*
    Global variable
 */
static void genGlobalName(EcCompiler *cp, int slotNum)
{
    int     code;

    mprAssert(slotNum >= 0);

    code = (!cp->state->onLeft) ?  EJS_OP_GET_GLOBAL_SLOT :  EJS_OP_PUT_GLOBAL_SLOT;
    ecEncodeOpcode(cp, code);
    ecEncodeNumber(cp, slotNum);

    pushStack(cp, (cp->state->onLeft) ? -1 : 1);
}


/*
    Function local variable or argument reference
 */
static void genLocalName(EcCompiler *cp, int slotNum)
{
    int     code;

    mprAssert(slotNum >= 0);

    if (slotNum < 10) {
        code = (!cp->state->onLeft) ?  EJS_OP_GET_LOCAL_SLOT_0 :  EJS_OP_PUT_LOCAL_SLOT_0;
        ecEncodeOpcode(cp, code + slotNum);

    } else {
        code = (!cp->state->onLeft) ?  EJS_OP_GET_LOCAL_SLOT :  EJS_OP_PUT_LOCAL_SLOT;
        ecEncodeOpcode(cp, code);
        ecEncodeNumber(cp, slotNum);
    }
    pushStack(cp, (cp->state->onLeft) ? -1 : 1);
}


/*
    Generate code for a logical operator. Called by genBinaryOp
  
    (expression OP expression)
 */
static void genLogicalOp(EcCompiler *cp, EcNode *np)
{
    EcState     *state;
    EcCodeGen   *saveCode;
    int         doneIfTrue, rightLen;

    ENTER(cp);

    state = cp->state;
    saveCode = state->code;

    mprAssert(np->kind == N_BINARY_OP);

    switch (np->tokenId) {
    case T_LOGICAL_AND:
        doneIfTrue = 0;
        break;

    case T_LOGICAL_OR:
        doneIfTrue = 1;
        break;

    default:
        doneIfTrue = 1;
        mprAssert(0);
        ecEncodeOpcode(cp, mapToken(cp, np->tokenId));
        break;
    }

    /*
        Process the conditional test. Put the pop for the branch here prior to the right hand side.
     */
    processNode(cp, np->left);
    ecEncodeOpcode(cp, EJS_OP_DUP);
    pushStack(cp, 1);
    popStack(cp, 1);

    if (np->right) {
        state->code = allocCodeBuffer(cp);
        np->binary.rightCode = state->code;
        /*
            Evaluating right hand side, so we must pop the left side duped value.
         */
        ecEncodeOpcode(cp, EJS_OP_POP);
        popStack(cp, 1);
        processNode(cp, np->right);
    }

    rightLen = mprGetBufLength(np->binary.rightCode->buf);

    /*
        Now copy the code to the output code buffer
     */
    setCodeBuffer(cp, saveCode);

    /*
        Jump to done if we know the result due to lazy evalation.
     */
    if (rightLen > 0 && rightLen < 0x7f && cp->optimizeLevel > 0) {
        ecEncodeOpcode(cp, (doneIfTrue) ? EJS_OP_BRANCH_TRUE_8: EJS_OP_BRANCH_FALSE_8);
        ecEncodeByte(cp, rightLen);
    } else {
        ecEncodeOpcode(cp, (doneIfTrue) ? EJS_OP_BRANCH_TRUE: EJS_OP_BRANCH_FALSE);
        ecEncodeWord(cp, rightLen);
    }

    copyCodeBuffer(cp, state->code, np->binary.rightCode);
    mprAssert(state == cp->state);
    LEAVE(cp);
}


/*
    Generate a property name reference based on the object already pushed.
    The owning object (pushed on the VM stack) may be an object or a type.
 */
static void genPropertyName(EcCompiler *cp, int slotNum)
{
    EcState     *state;
    int         code;

    mprAssert(slotNum >= 0);

    state = cp->state;

    if (slotNum < 10) {
        code = (!state->onLeft) ?  EJS_OP_GET_OBJ_SLOT_0 :  EJS_OP_PUT_OBJ_SLOT_0;
        ecEncodeOpcode(cp, code + slotNum);

    } else {
        code = (!state->onLeft) ?  EJS_OP_GET_OBJ_SLOT :  EJS_OP_PUT_OBJ_SLOT;
        ecEncodeOpcode(cp, code);
        ecEncodeNumber(cp, slotNum);
    }

    popStack(cp, 1);
    pushStack(cp, (state->onLeft) ? -1 : 1);
}


/*
    Generate a class property name reference
    The owning object (pushed on the VM stack) may be an object or a type. We must access its base class.
 */
static void genBaseClassPropertyName(EcCompiler *cp, int slotNum, int nthBase)
{
    EcState     *state;
    int         code;

    mprAssert(slotNum >= 0);

    state = cp->state;

    code = (!cp->state->onLeft) ?  EJS_OP_GET_TYPE_SLOT : EJS_OP_PUT_TYPE_SLOT;

    ecEncodeOpcode(cp, code);
    ecEncodeNumber(cp, slotNum);
    ecEncodeNumber(cp, nthBase);

    popStack(cp, 1);
    pushStack(cp, (state->onLeft) ? -1 : 1);
}


/*
    Generate a class property name reference
    The owning object (pushed on the VM stack) may be an object or a type. We must access its base class.
 */
static void genThisBaseClassPropertyName(EcCompiler *cp, EjsType *type, int slotNum)
{
    Ejs         *ejs;
    EcState     *state;
    int         code, nthBase;

    mprAssert(slotNum >= 0);
    mprAssert(type && ejsIsType(type));

    ejs = cp->ejs;
    state = cp->state;

    /*
        Count based up from object 
     */
    for (nthBase = 0; type->baseType; type = type->baseType) {
        nthBase++;
    }
    code = (!state->onLeft) ?  EJS_OP_GET_THIS_TYPE_SLOT :  EJS_OP_PUT_THIS_TYPE_SLOT;
    ecEncodeOpcode(cp, code);
    ecEncodeNumber(cp, slotNum);
    ecEncodeNumber(cp, nthBase);
    pushStack(cp, (state->onLeft) ? -1 : 1);
}


/*
    Generate a class name reference or a global reference.
 */
static void genClassName(EcCompiler *cp, EjsType *type)
{
    Ejs         *ejs;
    int         slotNum;

    mprAssert(type);

    ejs = cp->ejs;

    if (type == (EjsType*) ejs->global) {
        ecEncodeOpcode(cp, EJS_OP_LOAD_GLOBAL);
        pushStack(cp, 1);
        return;
    }

    //  TODO - check
    if (cp->bind || type->block.obj.builtin) {
        slotNum = ejsLookupProperty(ejs, ejs->global, &type->qname);
        mprAssert(slotNum >= 0);
        genGlobalName(cp, slotNum);

    } else {
        ecEncodeOpcode(cp, EJS_OP_LOAD_GLOBAL);
        pushStack(cp, 1);
        ecEncodeOpcode(cp, EJS_OP_GET_OBJ_NAME);
        ecEncodeName(cp, &type->qname);
        popStack(cp, 1);
        pushStack(cp, 1);
    }
}


/*
    Generate a property reference in the current object
 */
static void genPropertyViaThis(EcCompiler *cp, int slotNum)
{
    Ejs             *ejs;
    EcState         *state;
    int             code;

    mprAssert(slotNum >= 0);

    ejs = cp->ejs;
    state = cp->state;

    /*
        Property in the current "this" object
     */
    if (slotNum < 10) {
        code = (!state->onLeft) ?  EJS_OP_GET_THIS_SLOT_0 :  EJS_OP_PUT_THIS_SLOT_0;
        ecEncodeOpcode(cp, code + slotNum);

    } else {
        code = (!state->onLeft) ?  EJS_OP_GET_THIS_SLOT :  EJS_OP_PUT_THIS_SLOT;
        ecEncodeOpcode(cp, code);
        ecEncodeNumber(cp, slotNum);
    }
    pushStack(cp, (cp->state->onLeft) ? -1 : 1);
}


/*
    Generate code for a bound name reference. We already know the slot for the property and its owning type.
 */
static void genBoundName(EcCompiler *cp, EcNode *np)
{
    Ejs         *ejs;
    EcState     *state;
    EjsLookup   *lookup;

    ENTER(cp);

    ejs = cp->ejs;
    state = cp->state;
    lookup = &np->lookup;

    mprAssert(lookup->slotNum >= 0);

    if (lookup->obj == ejs->global) {
        /*
            Global variable.
         */
        //  TODO -- this logic looks strange
        if (lookup->slotNum < 0 || 
                (!cp->bind && (lookup->ref == 0 || !lookup->ref->builtin))) {
            lookup->slotNum = -1;
            genUnboundName(cp, np);

        } else {
            genGlobalName(cp, lookup->slotNum);
        }

    } else if (ejsIsFunction(lookup->obj) && lookup->nthBlock == 0) {
        genLocalName(cp, lookup->slotNum);

    } else if ((ejsIsBlock(lookup->obj) || ejsIsFunction(lookup->obj)) && 
            (!ejsIsType(lookup->obj) && !ejsIsPrototype(lookup->obj))) {
        genBlockName(cp, lookup->slotNum, lookup->nthBlock);

    } else if (lookup->useThis) {
        if (lookup->instanceProperty) {
            /*
                Property being accessed via the current object "this" or an explicit object?
             */
            genPropertyViaThis(cp, lookup->slotNum);

        } else {
            genThisBaseClassPropertyName(cp, (EjsType*) lookup->obj, lookup->slotNum);
        }

    } else if (!state->currentObjectNode) {
        if (lookup->instanceProperty) {
            genBlockName(cp, lookup->slotNum, lookup->nthBlock);

        } else {
            /*
                Static property with no explicit object. ie. Not "obj.property". The property was found via a scope search.
                We ignore nthBase as we use the actual type (lookup->obj) where the property was found.
             */
            if (state->inClass && state->inFunction && state->currentFunction->staticMethod) {
                genThisBaseClassPropertyName(cp, (EjsType*) lookup->obj, lookup->slotNum);
                
            } else {
                if (state->inFunction && ejsIsA(ejs, (EjsObj*) state->currentClass, (EjsType*) lookup->obj)) {
                    genThisBaseClassPropertyName(cp, (EjsType*) lookup->obj, lookup->slotNum);
                    
                } else {
                    SAVE_ONLEFT(cp);
                    genClassName(cp, (EjsType*) lookup->obj);
                    RESTORE_ONLEFT(cp);
                    genPropertyName(cp, lookup->slotNum);
                }
            }
        }

    } else {
        /*
            Explicity object. ie. "obj.property". The object in a dot expression is already pushed on the stack.
            Determine if we can access the object itself or if we need to use the type of the object to access
            static properties.
         */
        if (lookup->instanceProperty) {
            genPropertyName(cp, lookup->slotNum);

        } else {
            /*
                Property is in the nth base class from the object already pushed on the stack (left hand side).
             */
            genBaseClassPropertyName(cp, lookup->slotNum, lookup->nthBase);
        }
    }
    LEAVE(cp);
}


static void processNodeGetValue(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);
    cp->state->needsValue = 1;
    processNode(cp, np);
    LEAVE(cp);
}


static int genCallArgs(EcCompiler *cp, EcNode *np) 
{
    if (np == 0) {
        return 0;
    }
    processNode(cp, np);
    return mprGetListCount(np->children);
}


static void genCallSequence(EcCompiler *cp, EcNode *np)
{
    Ejs             *ejs;
    EjsType         *type;
    EcNode          *left, *right;
    EcState         *state;
    EjsFunction     *fun;
    EjsLookup       *lookup;
    int             fast, argc, staticMethod;    
        
    ejs = cp->ejs;
    state = cp->state;
    left = np->left;
    right = np->right;
    lookup = &np->left->lookup;
    argc = 0;
    
    if (lookup->slotNum < 0) {
        /*
            Unbound or Function expression or instance variable containing a function. Can't use fast path op codes below.
         */
        if (left->kind == N_QNAME) {
            argc = genCallArgs(cp, right);
            ecEncodeOpcode(cp, EJS_OP_CALL_SCOPED_NAME);
            ecEncodeName(cp, &np->qname);
            
        } else if (left->kind == N_DOT && left->right->kind == N_QNAME) {
            processNodeGetValue(cp, left->left);
            argc = genCallArgs(cp, right);
            ecEncodeOpcode(cp, EJS_OP_CALL_OBJ_NAME);
            ecEncodeName(cp, &np->qname);
            popStack(cp, 1);
            
        } else {
            ecEncodeOpcode(cp, EJS_OP_LOAD_GLOBAL);
            pushStack(cp, 1);
            processNodeGetValue(cp, left);
            argc = genCallArgs(cp, right);
            ecEncodeOpcode(cp, EJS_OP_CALL);
            popStack(cp, 2);
        }
        ecEncodeNumber(cp, argc); 
        popStack(cp, argc);
        return;
    }
        
    fun = (EjsFunction*) lookup->ref;
    staticMethod = (ejsIsFunction(fun) && fun->staticMethod);
        
    /*
        Use fast opcodes when the call sequence is bindable and either:
            expression.name()
            name
     */
    fast = (left->kind == N_DOT && left->right->kind == N_QNAME) || left->kind == N_QNAME;      
        
    if (!fast) {
        /*
            Resolve a reference to a function expression
            TODO REFACTOR needThis. Example: (function (s) { print(s);})("hello");
         */
        if (left->kind == N_EXPRESSIONS) {
            if (left->right == 0) {
                left->left->needThis = 1;
            } else {
                left->right->needThis = 1;
            }
        } else {
            left->needThis = 1;
        }
        processNodeGetValue(cp, left);
        argc = genCallArgs(cp, right);
        ecEncodeOpcode(cp, EJS_OP_CALL);
        popStack(cp, 2);
        ecEncodeNumber(cp, argc); 
        popStack(cp, argc);
        return;
    }
    
    if (staticMethod) {
        mprAssert(ejsIsType(lookup->obj));
        if (state->currentClass && state->inFunction && 
                ejsIsTypeSubType(ejs, state->currentClass, (EjsType*) lookup->originalObj)) {
            /*
                Calling a static method from within a class or subclass. So we can use "this".
             */
            argc = genCallArgs(cp, right);
            ecEncodeOpcode(cp, EJS_OP_CALL_THIS_STATIC_SLOT);
            ecEncodeNumber(cp, lookup->slotNum);
            /*
                If searching the scope chain (i.e. without a qualifying obj.property), and if the current class is not the 
                original object, then see how far back on the inheritance chain we must go.
             */
            if (lookup->originalObj != lookup->obj) {
                for (type = state->currentClass; type != (EjsType*) lookup->originalObj; type = type->baseType) {
                    lookup->nthBase++;
                }
            }
            if (!state->currentFunction->staticMethod) {
                /*
                    If calling from within an instance function, need to step over the instance also
                 */
                lookup->nthBase++;
            }
            ecEncodeNumber(cp, lookup->nthBase);
            
        } else if (left->kind == N_DOT && left->right->kind == N_QNAME) {
            /*
                Calling a static method with an explicit object or expression. Call via the object.
             */
            processNode(cp, left->left);
            argc = genCallArgs(cp, right);
            ecEncodeOpcode(cp, EJS_OP_CALL_OBJ_STATIC_SLOT);
            ecEncodeNumber(cp, lookup->slotNum);
            if (lookup->ownerIsType) {
                lookup->nthBase--;
            }
            ecEncodeNumber(cp, lookup->nthBase);
            popStack(cp, 1);
            
        } else {
            /*
                Foreign static method. Call directly on the correct class type object.
             */
            genClassName(cp, (EjsType*) lookup->obj);
            argc = genCallArgs(cp, right);
            ecEncodeOpcode(cp, EJS_OP_CALL_OBJ_STATIC_SLOT);
            ecEncodeNumber(cp, lookup->slotNum);
            ecEncodeNumber(cp, 0);
            popStack(cp, 1);
        }
        
    } else {
        // pushStack(cp, 1);
        if (left->kind == N_DOT && left->right->kind == N_QNAME) {
            if (left->left->kind == N_THIS) {
                lookup->useThis = 1;
            }
        }
        
        if (lookup->useThis && !lookup->instanceProperty) {
            argc = genCallArgs(cp, right);
            ecEncodeOpcode(cp, EJS_OP_CALL_THIS_SLOT);
            ecEncodeNumber(cp, lookup->slotNum);
            
        } else if (lookup->obj == ejs->global) {
            /*
                Instance function or type being invoked as a constructor (e.g. Reflect(obj))
             */
            argc = genCallArgs(cp, right);
            ecEncodeOpcode(cp, EJS_OP_CALL_GLOBAL_SLOT);
            ecEncodeNumber(cp, lookup->slotNum);
            
        } else if (lookup->instanceProperty && left->left) {
            processNodeGetValue(cp, left->left);
            argc = genCallArgs(cp, right);
            ecEncodeOpcode(cp, EJS_OP_CALL_OBJ_INSTANCE_SLOT);
            ecEncodeNumber(cp, lookup->slotNum);
            popStack(cp, 1);
            
        } else if (ejsIsType(lookup->obj) || ejsIsPrototype(lookup->obj)) {
            if (left->kind == N_DOT && left->right->kind == N_QNAME) {
                processNodeGetValue(cp, left->left);
                argc = genCallArgs(cp, right);
                ecEncodeOpcode(cp, EJS_OP_CALL_OBJ_SLOT);
                mprAssert(lookup->slotNum >= 0);
                ecEncodeNumber(cp, lookup->slotNum);
                popStack(cp, 1);
                
            } else {
                left->needThis = 1;
                processNodeGetValue(cp, left);
                argc = genCallArgs(cp, right);
                ecEncodeOpcode(cp, EJS_OP_CALL);
                popStack(cp, 2);
            }
            
        } else if (ejsIsBlock(lookup->obj)) {
            argc = genCallArgs(cp, right);
            ecEncodeOpcode(cp, EJS_OP_CALL_BLOCK_SLOT);
            ecEncodeNumber(cp, lookup->slotNum);
            ecEncodeNumber(cp, lookup->nthBlock);
        }
    }
    ecEncodeNumber(cp, argc); 
    popStack(cp, argc);
}


/*
    Code generation for function calls
 */
static void genCall(EcCompiler *cp, EcNode *np)
{
    Ejs             *ejs;
    EcNode          *left, *right;
    EcState         *state;
    EjsFunction     *fun;
    int             argc, hasResult;

    ENTER(cp);

    ejs = cp->ejs;
    state = cp->state;
    left = np->left;
    right = np->right;
    fun = (EjsFunction*) np->lookup.ref;    
    
    if (left->kind == N_NEW && !left->newExpr.callConstructors) {
        processNode(cp, left);
        LEAVE(cp);
        return;
    }

    if (left->kind == N_NEW) {
        processNode(cp, left);
        argc = genCallArgs(cp, right);
        ecEncodeOpcode(cp, EJS_OP_CALL_CONSTRUCTOR);
        ecEncodeNumber(cp, argc);
        popStack(cp, argc);
        LEAVE(cp);
        return;
    }
    
    genCallSequence(cp, np);

    /*
        Process the function return value. Call by ref has a this pointer plus method reference plus args
     */
    hasResult = 0;
    if (fun && ejsIsFunction(fun)) {
        if (fun->resultType && fun->resultType != ejs->voidType) {
            hasResult = 1;

        } else if (fun->hasReturn) {
            /*
                Untyped function, but it has a return stmt.
                We don't do data flow to make sure all return cases have returns (sorry).
             */
            hasResult = 1;
        }
        if (state->needsValue && !hasResult) {
            genError(cp, np, "Function call does not return a value.");
        }
    }

    /*
        If calling a type as a constructor (Date()), must push result
     */
    if (state->needsValue || ejsIsType(np->lookup.ref)) {
        ecEncodeOpcode(cp, EJS_OP_PUSH_RESULT);
        pushStack(cp, 1);
    }
    LEAVE(cp);
}


static void genCatchArg(EcCompiler *cp, EcNode *np)
{
    ecEncodeOpcode(cp, EJS_OP_PUSH_CATCH_ARG);
    pushStack(cp, 1);
}


/*
    Process a class node.
 */
static void genClass(EcCompiler *cp, EcNode *np)
{
    Ejs             *ejs;
    EjsType         *type, *baseType;
    EjsFunction     *constructor;
    EjsEx           *ex;
    EcCodeGen       *code;
    EcState         *state;
    EcNode          *constructorNode;
    EjsName         qname;
    MprBuf          *codeBuf;
    uchar           *buf;
    int             next, len, initializerLen, constructorLen, slotNum, i;

    ENTER(cp);

    mprAssert(np->kind == N_CLASS);

    ejs = cp->ejs;
    state = cp->state;
    type = (EjsType*) np->klass.ref;
    mprAssert(type);

    state->inClass = 1;

    /*
        Op code to define the class. This goes into the module code buffer. DefineClass will capture the current scope
        including the internal namespace for this file.
        OPT See above todo
     */
    ecEncodeOpcode(cp, EJS_OP_DEFINE_CLASS);
    ecEncodeGlobal(cp, (EjsObj*) type, &type->qname);

    state->letBlock = (EjsObj*) type;
    state->varBlock = (EjsObj*) type;
    state->currentClass = type;
    state->currentClassNode = np;

    constructorNode = np->klass.constructor;

    /*
        Create code buffers to hold the static and instance level initialization code. The AST module will always
        create a constructor node for us if there is instance level initialization code. We currently put the class
        initialization code in the constructor. Static variable initialization code will go into the current
        module buffer (cp->currentModule) and will be run when the module is loaded. 
        BUG - CLASS INITIALIZATION ORDERING.
     */
    mprAssert(state->code == state->currentModule->code);

    /*
        Create a code buffer for static initialization code and set it as the default buffer
     */
    state->code = state->staticCodeBuf = allocCodeBuffer(cp);

    if (type->hasConstructor) {
        state->instanceCodeBuf = allocCodeBuffer(cp);
    }

    /*
        The current code buffer is the static initializer buffer. genVar will redirect to the instanceCodeBuf as required.
     */
    if (!type->isInterface) {
        mprAssert(np->left->kind == N_DIRECTIVES);
        processNode(cp, np->left);
    }

    if (type->hasStaticInitializer) {
        /*
            Create the static initializer
         */
        ecEncodeOpcode(cp, EJS_OP_RETURN);
        setFunctionCode(cp, np->klass.initializer, state->staticCodeBuf);
    }

    if (type->hasConstructor) {
        mprAssert(constructorNode);
        mprAssert(state->instanceCodeBuf);
        code = state->code = state->instanceCodeBuf;
        codeBuf = code->buf;

        constructor = state->currentFunction = constructorNode->function.functionVar;
        mprAssert(constructor);
        state->currentFunctionName = constructorNode->qname.name;

        if (constructorNode->function.isDefaultConstructor) {
            /*
                Generate the default constructor. Append the default constructor instructions after any initialization code.
             */
            baseType = type->baseType;
            if (baseType && baseType->hasConstructor) {
                ecEncodeOpcode(cp, EJS_OP_CALL_NEXT_CONSTRUCTOR);
                ecEncodeNumber(cp, 0);
            }
            ecEncodeOpcode(cp, EJS_OP_RETURN);
            setFunctionCode(cp, constructor, code);
            ecAddConstant(cp, EJS_PUBLIC_NAMESPACE);
            ecAddConstant(cp, EJS_CONSTRUCTOR_NAMESPACE);

        } else if (type->hasInitializer) {

            /*
                Inject initializer code into the pre-existing constructor code. It is injected before any constructor code.
             */
            initializerLen = mprGetBufLength(codeBuf);
            mprAssert(initializerLen >= 0);
            constructorLen = constructor->body.code.codeLen;
            mprAssert(constructorLen >= 0);

            len = initializerLen + constructorLen;
            if (len > 0) {
                buf = (uchar*) mprAlloc(state, len);
                if (buf == 0) {
                    genError(cp, np, "Can't allocate code buffer");
                    LEAVE(cp);
                }

                mprMemcpy((char*) buf, initializerLen, mprGetBufStart(codeBuf), initializerLen);
                if (constructorLen) {
                    mprMemcpy((char*) &buf[initializerLen], constructorLen, (char*) constructor->body.code.byteCode, 
                        constructorLen);
                }
                ejsSetFunctionCode(constructor, buf, len);

                /*
                    Adjust existing exception blocks to accomodate injected code.
                    Then define new try/catch blocks encountered.
                 */
                for (i = 0; i < constructor->body.code.numHandlers; i++) {
                    ex = constructor->body.code.handlers[i];
                    ex->tryStart += initializerLen;
                    ex->tryEnd += initializerLen;
                    ex->handlerStart += initializerLen;
                    ex->handlerEnd += initializerLen;
                }
                for (next = 0; (ex = (EjsEx*) mprGetNextItem(code->exceptions, &next)) != 0; ) {
                    ejsAddException(constructor, ex->tryStart, ex->tryEnd, ex->catchType, ex->handlerStart, ex->handlerEnd, 
                        ex->numBlocks, ex->numStack, ex->flags, -1);
                }
            }
        }
    }

    /*
        Add extra constants
     */
    ecAddNameConstant(cp, &np->qname);

    if (type->hasStaticInitializer) {
        slotNum = type->numInherited;
        if (type->hasConstructor) {
            slotNum++;
        }
        qname = ejsGetPropertyName(ejs, (EjsObj*) type, slotNum);
        ecAddNameConstant(cp, &qname);
    }
    if (type->baseType) {
        ecAddNameConstant(cp, &type->baseType->qname);
    }

    /*
        Emit any properties implemented via another class (there is no Node for these)
     */
    ecAddBlockConstants(cp, (EjsBlock*) type);
    if (type->prototype) {
        ecAddBlockConstants(cp, (EjsBlock*) type->prototype);
    }
    if (cp->ejs->flags & EJS_FLAG_DOC) {
        ecAddDocConstant(cp, np->lookup.trait, ejs->global, np->lookup.slotNum);
    }
    LEAVE(cp);
}


static void genDirectives(EcCompiler *cp, EcNode *np, bool resetStack)
{
    EcState     *lastDirectiveState;
    EcNode      *child;
    int         next, lastKind;

    ENTER(cp);

    //  TODO - directiveState appears to be not used
    lastDirectiveState = cp->directiveState;
    mprAssert(cp->state->code->stackCount == 0);

    lastKind = -1;
    next = 0;
    while ((child = getNextNode(cp, np, &next)) && !cp->error) {
        lastKind = child->kind;
        cp->directiveState = cp->state;
        processNode(cp, child);
        if (resetStack) {
            emptyStack(cp, 0);
        }
    }
    cp->directiveState = lastDirectiveState;
    LEAVE(cp);
}


/*
    Handle property dereferencing via "." and "[". This routine generates code for bound properties where we know
    the slot offsets and also for unbound references. Return the right most node in right.
 */
static void genDot(EcCompiler *cp, EcNode *np, EcNode **rightMost)
{
    EcState     *state;
    EcNode      *left, *right;
    int         put;

    ENTER(cp);

    state = cp->state;
    state->onLeft = 0;
    left = np->left;
    right = np->right;

    /*
        Process the left of the dot and leave an object reference on the stack
     */
    switch (left->kind) {
    case N_DOT:
    case N_EXPRESSIONS:
    case N_LITERAL:
    case N_THIS:
    case N_REF:
    case N_QNAME:
    case N_CALL:
    case N_SUPER:
    case N_OBJECT_LITERAL:
        state->needsValue = 1;
        processNode(cp, left);
        state->needsValue = state->prev->needsValue;
        break;

    case N_ARRAY_LITERAL:
        processNode(cp, left);
        break;

    default:
        mprAssert(0);
    }

    state->currentObjectNode = np->left;

    if (np->needThis) {
        ecEncodeOpcode(cp, EJS_OP_DUP);
        pushStack(cp, 1);
        np->needThis = 0;
    }

    put = state->prev->onLeft;

    /*
        Process the right
     */
    switch (right->kind) {
    case N_CALL:
        state->needsValue = state->prev->needsValue;
        genCall(cp, right);
        state->needsValue = 0;
        break;

    case N_QNAME:
        state->onLeft = state->prev->onLeft;
        genName(cp, right);
        break;

    case N_SUPER:
        ecEncodeOpcode(cp, EJS_OP_SUPER);
        break;

    case N_LITERAL:
    case N_OBJECT_LITERAL:
    default:
        state->currentObjectNode = 0;
        state->needsValue = 1;
        ecEncodeOpcode(cp, EJS_OP_LOAD_STRING);
        ecEncodeString(cp, EJS_EMPTY_NAMESPACE);
        pushStack(cp, 1);
        if (right->kind == N_LITERAL) {
            genLiteral(cp, right);
        } else if (right->kind == N_OBJECT_LITERAL) {
            genObjectLiteral(cp, right);
        } else {
            processNode(cp, right);
        }
        state->onLeft = state->prev->onLeft;
        ecEncodeOpcode(cp, put ? EJS_OP_PUT_OBJ_NAME_EXPR :  EJS_OP_GET_OBJ_NAME_EXPR);
        popStack(cp, (put) ? 4 : 2);
        break;
    }

    if (rightMost) {
        *rightMost = right;
    }
    LEAVE(cp);
}


static void genEndFunction(EcCompiler *cp, EcNode *np)
{
    EjsFunction     *fun;

    ENTER(cp);

    mprAssert(np);

    fun = cp->state->currentFunction;
    
    if (cp->lastOpcode != EJS_OP_RETURN_VALUE && cp->lastOpcode != EJS_OP_RETURN) {
        /*
            Ensure code cannot run off the end of a method.
            TODO OPT - must do a better job of basic block analysis and check if all paths out of a function have a return.
         */
        if (fun->resultType == 0) {
            if (fun->hasReturn) {
                //  TODO - OPT. Should be able to avoid this somehow. We put it here now to ensure that all
                //  paths out of the function terminate with a return.
                ecEncodeOpcode(cp, EJS_OP_LOAD_NULL);
                ecEncodeOpcode(cp, EJS_OP_RETURN_VALUE);
            } else {
                ecEncodeOpcode(cp, EJS_OP_RETURN);
            }

        } else if (fun->resultType == cp->ejs->voidType) {
            ecEncodeOpcode(cp, EJS_OP_RETURN);

        } else {
            //  TODO - OPT. Should be able to avoid this somehow.
            ecEncodeOpcode(cp, EJS_OP_LOAD_NULL);
            ecEncodeOpcode(cp, EJS_OP_RETURN_VALUE);
        }

        addDebugInstructions(cp, np);
    }
    LEAVE(cp);
}


static void genExpressions(EcCompiler *cp, EcNode *np)
{
    EcNode      *child;
    int         next;

    mprAssert(np->kind == N_EXPRESSIONS);

    ENTER(cp);

    next = 0;
    while ((child = getNextNode(cp, np, &next)) != 0) {
        processNode(cp, child);
    }
    LEAVE(cp);
}


/*
    This handles "do { ... } while" constructs.
  
    do {
         body
    } while (conditional)
  
    Labels:
        topOfLoop:
            body
        continueLabel:
            conditional
            bxx topOfLoop
        endLoop:
 */
static void genDo(EcCompiler *cp, EcNode *np)
{
    EcCodeGen   *outerBlock, *code;
    EcState     *state;
    int         condLen, bodyLen, len, condShortJump, continueLabel, breakLabel;

    ENTER(cp);

    state = cp->state;
    state->captureBreak = 0;

    mprAssert(np->kind == N_DO);

    outerBlock = state->code;
    code = state->code = allocCodeBuffer(cp);

    ecStartBreakableStatement(cp, EC_JUMP_BREAK | EC_JUMP_CONTINUE);

    if (np->forLoop.body) {
        np->forLoop.bodyCode = state->code = allocCodeBuffer(cp);
        setStack(cp, 0);
        processNode(cp, np->forLoop.body);
        emptyStack(cp, 0);
    }

    if (np->forLoop.cond) {
        np->forLoop.condCode = state->code = allocCodeBuffer(cp);
        processNode(cp, np->forLoop.cond);
        /* Leaves one item on the stack */
    }

    /*
        Get the lengths of code blocks
     */
    condLen = bodyLen = 0;

    if (np->forLoop.condCode) {
        condLen = mprGetBufLength(np->forLoop.condCode->buf);
    }
    if (np->forLoop.bodyCode) {
        bodyLen = mprGetBufLength(np->forLoop.bodyCode->buf);
    }

    /*
        Now that we know the body length, we can calculate the jump back to the top.
     */
    condShortJump = 0;
    len = bodyLen + condLen;
    if (len > 0) {
        if (len < 0x7f && cp->optimizeLevel > 0) {
            condShortJump = 1;
            condLen += 2;

        } else {
            condLen += 5;
        }
    }

    setCodeBuffer(cp, code);
    continueLabel = mprGetBufLength(cp->state->code->buf);

    /*
        Add the body
     */
    if (np->forLoop.bodyCode) {
        copyCodeBuffer(cp, state->code, np->forLoop.bodyCode);
    }


    /*
        Copy the conditional code and add condition jump to the end of the for loop, then copy the body code.
     */
    if (np->forLoop.condCode) {
        copyCodeBuffer(cp, state->code, np->forLoop.condCode);
        setStack(cp, 1);
        len = bodyLen + condLen;
        if (condShortJump) {
            ecEncodeOpcode(cp, EJS_OP_BRANCH_TRUE_8);
            ecEncodeByte(cp, -len);
        } else {
            ecEncodeOpcode(cp, EJS_OP_BRANCH_TRUE);
            ecEncodeWord(cp, -len);
        }
        popStack(cp, 1);
    }

    breakLabel = mprGetBufLength(cp->state->code->buf);
    patchJumps(cp, EC_JUMP_BREAK, breakLabel);
    patchJumps(cp, EC_JUMP_CONTINUE, continueLabel);

    copyCodeBuffer(cp, outerBlock, state->code);
    LEAVE(cp);
}


/*
    This handles "for" and while" constructs but not "for .. in"
  
    for (initializer; conditional; perLoop) { body }
  
    Labels:
            initializer
        topOfLoop:
            conditional
            bxx endLoop
        topOfBody:
            body
        continueLabel:
            perLoop
        endIteration:
            goto topOfLoop
        endLoop:
 */
static void genFor(EcCompiler *cp, EcNode *np)
{
    EcCodeGen   *outerBlock, *code;
    EcState     *state;
    int         condLen, bodyLen, perLoopLen, len, condShortJump, perLoopShortJump, continueLabel, breakLabel;

    ENTER(cp);

    mprAssert(np->kind == N_FOR);

    state = cp->state;
    outerBlock = state->code;
    code = state->code = allocCodeBuffer(cp);
    state->captureBreak = 0;

    /*
        initializer is outside the loop
     */
    if (np->forLoop.initializer) {
        processNode(cp, np->forLoop.initializer);
        emptyStack(cp, 0);
    }

    /*
        For conditional
     */
    ecStartBreakableStatement(cp, EC_JUMP_BREAK | EC_JUMP_CONTINUE);

    if (np->forLoop.cond) {
        np->forLoop.condCode = state->code = allocCodeBuffer(cp);
        state->needsValue = 1;
        processNode(cp, np->forLoop.cond);
        /* Leaves one item on the stack */
        state->needsValue = 0;
    }

    if (np->forLoop.body) {
        np->forLoop.bodyCode = state->code = allocCodeBuffer(cp);
        setStack(cp, 0);
        processNode(cp, np->forLoop.body);
        emptyStack(cp, 0);
    }

    /*
        Per loop iteration
     */
    if (np->forLoop.perLoop) {
        np->forLoop.perLoopCode = state->code = allocCodeBuffer(cp);
        processNode(cp, np->forLoop.perLoop);
        emptyStack(cp, 0);
    }

    /*
        Get the lengths of code blocks
     */
    perLoopLen = condLen = bodyLen = 0;

    if (np->forLoop.condCode) {
        condLen = mprGetBufLength(np->forLoop.condCode->buf);
    }
    if (np->forLoop.bodyCode) {
        bodyLen = mprGetBufLength(np->forLoop.bodyCode->buf);
    }
    if (np->forLoop.perLoopCode) {
        perLoopLen = mprGetBufLength(np->forLoop.perLoopCode->buf);
    }

    /*
        Now that we know the body length, we can calculate the jump at the top. This is the shorter of
        the two jumps as it does not span the conditional code, so we optimize it first incase the saving
        of 3 bytes allows us to also optimize the branch back to the top. Subtract 5 to the test with 0x7f to
        account for the worst-case jump at the bottom back to the top
     */
    condShortJump = 0;
    if (condLen > 0) {
        len = bodyLen + perLoopLen;
        if (len < (0x7f - 5) && cp->optimizeLevel > 0) {
            condShortJump = 1;
            condLen += 2;
        } else {
            condLen += 5;
        }
    }

    /*
        Calculate the jump back to the top of the loop (per-iteration jump). Subtract 5 to account for the worst case
        where the per loop jump is a long jump.
     */
    len = condLen + bodyLen + perLoopLen;
    if (len < (0x7f - 5) && cp->optimizeLevel > 0) {
        perLoopShortJump = 1;
        perLoopLen += 2;
    } else {
        perLoopShortJump = 0;
        perLoopLen += 5;
    }

    /*
        Copy the conditional code and add condition jump to the end of the for loop, then copy the body code.
     */
    setCodeBuffer(cp, code);
    if (np->forLoop.condCode) {
        copyCodeBuffer(cp, state->code, np->forLoop.condCode);
        setStack(cp, 1);
        len = bodyLen + perLoopLen;
        if (condShortJump) {
            ecEncodeOpcode(cp, EJS_OP_BRANCH_FALSE_8);
            ecEncodeByte(cp, len);
        } else {
            ecEncodeOpcode(cp, EJS_OP_BRANCH_FALSE);
            ecEncodeWord(cp, len);
        }
        popStack(cp, 1);
    }

    /*
        Add the body and per loop code
     */
    if (np->forLoop.bodyCode) {
        copyCodeBuffer(cp, state->code, np->forLoop.bodyCode);
    }
    continueLabel = mprGetBufLength(state->code->buf);
    if (np->forLoop.perLoopCode) {
        copyCodeBuffer(cp, state->code, np->forLoop.perLoopCode);
    }

    /*
        Add the per-loop jump back to the top of the loop
     */
    len = condLen + bodyLen + perLoopLen;
    if (perLoopShortJump) {
        ecEncodeOpcode(cp, EJS_OP_GOTO_8);
        ecEncodeByte(cp, -len);
    } else {
        ecEncodeOpcode(cp, EJS_OP_GOTO);
        ecEncodeWord(cp, -len);
    }

    breakLabel = mprGetBufLength(state->code->buf);
    emptyStack(cp, 0);

    patchJumps(cp, EC_JUMP_BREAK, breakLabel);
    patchJumps(cp, EC_JUMP_CONTINUE, continueLabel);

    copyCodeBuffer(cp, outerBlock, state->code);
    LEAVE(cp);
}


/*
    This routine is a little atypical in that it hand-crafts an exception block.
 */
static void genForIn(EcCompiler *cp, EcNode *np)
{
    EcCodeGen   *outerBlock, *code;
    EcState     *state;
    int         len, breakLabel, tryStart, tryEnd, handlerStart;

    ENTER(cp);

    mprAssert(cp->state->code->stackCount == 0);
    mprAssert(np->kind == N_FOR_IN);

    state = cp->state;
    outerBlock = state->code;
    code = state->code = allocCodeBuffer(cp);
    state->captureBreak = 0;

    ecStartBreakableStatement(cp, EC_JUMP_BREAK | EC_JUMP_CONTINUE);

    processNode(cp, np->forInLoop.iterVar);

    /*
        Consider:
            for (i in obj.get())
                body
      
        Now process the obj.get()
     */
    np->forInLoop.initCode = state->code = allocCodeBuffer(cp);
    mprAssert(cp->state->code->stackCount == 0);

    processNode(cp, np->forInLoop.iterGet);
    ecEncodeOpcode(cp, EJS_OP_PUSH_RESULT);
    pushStack(cp, 1);
    mprAssert(cp->state->code->stackCount == 1);

    /*
        Process the iter.next()
     */
    np->forInLoop.bodyCode = state->code = allocCodeBuffer(cp);

    /*
        Dup the iterator reference each time round the loop as iter.next() will consume the object.
        TODO - OPT. Consider having a CALL op code that does not consume the object.
     */
    ecEncodeOpcode(cp, EJS_OP_DUP);
    pushStack(cp, 1);

    /*
        Emit code to invoke the iterator
     */
    tryStart = getCodeLength(cp, np->forInLoop.bodyCode);

    ecEncodeOpcode(cp, EJS_OP_CALL_OBJ_SLOT);
    mprAssert(np->forInLoop.iterNext->lookup.slotNum >= 0);
    ecEncodeNumber(cp, np->forInLoop.iterNext->lookup.slotNum);
    ecEncodeNumber(cp, 0);
    popStack(cp, 1);
    
    if (np->forInLoop.each) {
        /*
            getObjName
         */
    }
    tryEnd = getCodeLength(cp, np->forInLoop.bodyCode);

    /*
        Save the result of the iter.next() call
     */
    ecEncodeOpcode(cp, EJS_OP_PUSH_RESULT);
    pushStack(cp, 1);
    genLeftHandSide(cp, np->forInLoop.iterVar->left);

    if (np->forInLoop.iterVar->kind == N_VAR_DEFINITION && np->forInLoop.iterVar->def.varKind == KIND_LET) {
        ecAddConstant(cp, np->forInLoop.iterVar->left->qname.name);
        ecAddConstant(cp, np->forInLoop.iterVar->left->qname.space);
    }

    /*
        Now the loop body. Must hide the pushed iterator on the stack as genDirectives will clear the stack.
     */
    if (np->forInLoop.body) {
        state->code->stackCount--;
        mprAssert(state->code->stackCount == 0);
        processNode(cp, np->forInLoop.body);
        state->code->stackCount++;
    }
    emptyStack(cp, 1);

    len = getCodeLength(cp, np->forInLoop.bodyCode);
    if (len < (0x7f - 5)) {
        ecEncodeOpcode(cp, EJS_OP_GOTO_8);
        len += 2;
        ecEncodeByte(cp, -len);
    } else {
        ecEncodeOpcode(cp, EJS_OP_GOTO);
        len += 5;
        ecEncodeWord(cp, -len);
    }

    /*
        Create exception catch block around iter.next() to catch the StopIteration exception.
        Note: we have a zero length handler (noop)
     */
    handlerStart = ecGetCodeOffset(cp);
    addException(cp, tryStart, tryEnd, cp->ejs->stopIterationType, handlerStart, handlerStart, 0, 0,
        EJS_EX_CATCH | EJS_EX_ITERATION);

    /*
        Patch break/continue statements
     */
    breakLabel = mprGetBufLength(state->code->buf);
    emptyStack(cp, 0);

    patchJumps(cp, EC_JUMP_BREAK, breakLabel);
    patchJumps(cp, EC_JUMP_CONTINUE, 0);

    /*
        Copy the code fragments to the outer code buffer
     */
    setCodeBuffer(cp, code);
    copyCodeBuffer(cp, state->code, np->forInLoop.initCode);
    copyCodeBuffer(cp, state->code, np->forInLoop.bodyCode);

    copyCodeBuffer(cp, outerBlock, state->code);
    LEAVE(cp);
}


/*
    Generate code for default parameters. Native classes must handle this themselves. We
    generate the code for all default parameters in sequence with a computed goto at the front.
 */
static void genDefaultParameterCode(EcCompiler *cp, EcNode *np, EjsFunction *fun)
{
    EcNode          *parameters, *child;
    EcState         *state;
    EcCodeGen       **buffers, *saveCode;
    int             next, len, needLongJump, count, firstDefault;

    state = cp->state;
    saveCode = state->code;

    parameters = np->function.parameters;
    mprAssert(parameters);

    count = mprGetListCount(parameters->children);
    buffers = (EcCodeGen**) mprAllocZeroed(state, count * sizeof(EcCodeGen*));

    for (next = 0; (child = getNextNode(cp, parameters, &next)) && !cp->error; ) {
        mprAssert(child->kind == N_VAR_DEFINITION);

        if (child->left->kind == N_ASSIGN_OP) {
            buffers[next - 1] = state->code = allocCodeBuffer(cp);
            genAssignOp(cp, child->left);
        }
    }

    firstDefault = fun->numArgs - fun->numDefault;
    mprAssert(firstDefault >= 0);
    needLongJump = cp->optimizeLevel > 0 ? 0 : 1;

    /*
        Compute the worst case jump size. Start with 4 because the table is always one larger than the
        number of default args.
     */
    len = 4;
    for (next = firstDefault; next < count; next++) {
        if (buffers[next]) {
            len = mprGetBufLength(buffers[next]->buf) + 4;
            if (len >= 0x7f) {
                needLongJump = 1;
                break;
            }
        }
    }

    setCodeBuffer(cp, saveCode);

    /*
        This is a jump table where each parameter initialization segments falls through to the next one.
        We have one more entry in the table to jump over the entire computed jump section.
     */
    ecEncodeOpcode(cp, (needLongJump) ? EJS_OP_INIT_DEFAULT_ARGS: EJS_OP_INIT_DEFAULT_ARGS_8);
    ecEncodeByte(cp, fun->numDefault + 1);

    len = (fun->numDefault + 1) * ((needLongJump) ? 4 : 1);

    for (next = firstDefault; next < count; next++) {
        if (buffers[next] == 0) {
            continue;
        }
        if (needLongJump) {
            ecEncodeWord(cp, len);
        } else {
            ecEncodeByte(cp, len);
        }
        len += mprGetBufLength(buffers[next]->buf);
    }
    /*
        Add one more jump to jump over the entire jump table
     */
    if (needLongJump) {
        ecEncodeWord(cp, len);
    } else {
        ecEncodeByte(cp, len);
    }

    /*
        Now copy all the initialization code
     */
    for (next = firstDefault; next < count; next++) {
        if (buffers[next]) {
            copyCodeBuffer(cp, state->code, buffers[next]);
        }
    }
    mprFree(buffers);
}


static void genFunction(EcCompiler *cp, EcNode *np)
{
    Ejs             *ejs;
    EjsEx           *ex;
    EcState         *state;
    EcCodeGen       *code;
    EjsFunction     *fun;
    EjsType         *baseType;
    EjsName         qname;
    EjsTrait        *trait;
    EjsLookup       *lookup;
    EjsObj          *activation;
    int             i, numSlots;

    ENTER(cp);

    mprAssert(np->kind == N_FUNCTION);
    
    ejs = cp->ejs;
    state = cp->state;
    mprAssert(state);

    mprAssert(np->function.functionVar);
    fun = np->function.functionVar;
    activation = fun->activation;
    numSlots = activation ? activation->numSlots: 0;

    state->inFunction = 1;
    state->inMethod = state->inMethod || np->function.isMethod;
    state->blockIsMethod = np->function.isMethod;
    state->currentFunctionName = np->qname.name;
    state->currentFunction = fun;

    /*
        Capture the scope chain by the defineFunction op code. Emit this into the existing code buffer. 
        Don't do if a method as they get scope via other means.. Native methods also don't use this as an optimization.
        Native methods must handle scope explicitly.
      
        We only need to define the function if it needs full scope (unbound property access) or it is a nested function.
     */
    if (fun->fullScope) {
        lookup = &np->lookup;
        mprAssert(lookup->slotNum >= 0);
        ecEncodeOpcode(cp, EJS_OP_DEFINE_FUNCTION);
        ecEncodeNumber(cp, lookup->slotNum);
        ecEncodeNumber(cp, lookup->nthBlock);
    }
    code = state->code = allocCodeBuffer(cp);
    addDebugInstructions(cp, np);

    /*
        Generate code for any parameter default initialization.
        Native classes must do default parameter initialization themselves.
     */
    if (fun->numDefault > 0 && !(np->attributes & EJS_PROP_NATIVE)) {
        genDefaultParameterCode(cp, np, fun);
    }
    if (np->function.constructorSettings) {
        genDirectives(cp, np->function.constructorSettings, 1);
    }
    state->letBlock = (EjsObj*) fun;
    state->varBlock = (EjsObj*) fun;

    if (np->function.isConstructor) {
        /*
            Function is a constructor. Call any default constructors if required.
            Should this be before or after default variable initialization?
         */
        mprAssert(state->currentClass);
        baseType = state->currentClass->baseType;
        if (!state->currentClass->callsSuper && baseType && baseType->hasConstructor && 
                !(np->attributes & EJS_PROP_NATIVE)) {
            ecEncodeOpcode(cp, EJS_OP_CALL_NEXT_CONSTRUCTOR);
            ecEncodeNumber(cp, 0);
        }
    }

    /*
        May be no body for native functions
     */
    if (np->function.body) {
        mprAssert(np->function.body->kind == N_DIRECTIVES);
        processNode(cp, np->function.body);
    }
    if (cp->errorCount > 0) {
        LEAVE(cp);
        return;
    }
    setFunctionCode(cp, fun, code);

    /*
        Add string constants
     */
    ecAddNameConstant(cp, &np->qname);

    for (i = 0; i < numSlots; i++) {
        qname = ejsGetPropertyName(ejs, activation, i);
        ecAddNameConstant(cp, &qname);
        trait = ejsGetPropertyTrait(ejs, activation, i);
        if (trait && trait->type) {
            ecAddNameConstant(cp, &trait->type->qname);
        }
    }
    for (i = 0; i < fun->block.obj.numSlots; i++) {
        qname = ejsGetPropertyName(ejs, (EjsObj*) fun, i);
        ecAddNameConstant(cp, &qname);
        trait = ejsGetPropertyTrait(ejs, (EjsObj*) fun, i);
        if (trait && trait->type) {
            ecAddNameConstant(cp, &trait->type->qname);
        }
    }
    if (fun->resultType) {
        ecAddNameConstant(cp, &fun->resultType->qname);
    }
    for (i = 0; i < fun->body.code.numHandlers; i++) {
        ex = fun->body.code.handlers[i];
        if (ex && ex->catchType) {
            ecAddNameConstant(cp, &ex->catchType->qname);
        }
    }
    if (cp->ejs->flags & EJS_FLAG_DOC) {
        //  MOB -- could move outside to avoid using owner
        ecAddDocConstant(cp, 0, fun->owner, fun->slotNum);
    }
    LEAVE(cp);
}


static void genHash(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);

    if (!np->hash.disabled) {
        processNode(cp, np->hash.body);
    }
    LEAVE(cp);
}


static void genIf(EcCompiler *cp, EcNode *np)
{
    EcCodeGen   *saveCode;
    EcState     *state;
    int         thenLen, elseLen;

    ENTER(cp);

    mprAssert(np->kind == N_IF);

    state = cp->state;
    saveCode = state->code;

    /*
        Process the conditional. Put the popStack for the branch here so the stack is correct for the "then" and 
        "else" blocks.
     */
    state->needsValue = 1;
    processNode(cp, np->tenary.cond);
    state->needsValue = 0;
    popStack(cp, 1);

    /*
        Process the "then" block.
     */
    np->tenary.thenCode = state->code = allocCodeBuffer(cp);
    resetStack(cp);
    
    //  CHANGE: Added for return (cond) ? call(): other;
    state->needsValue = state->prev->needsValue;
    processNode(cp, np->tenary.thenBlock);
    if (state->prev->needsValue) {
        /* Part of a tenary expression */
        if (state->code->stackCount != 1) {
            genError(cp, np, "Then expression does not evaluate to a value. Check if operands are void");
        }
        emptyStack(cp, 1);
    } else {
        emptyStack(cp, 0);
    }

    /*
        Else block (optional)
     */
    if (np->tenary.elseBlock) {
        np->tenary.elseCode = state->code = allocCodeBuffer(cp);
        resetStack(cp);
        state->needsValue = state->prev->needsValue;
        processNode(cp, np->tenary.elseBlock);
        state->needsValue = 0;
        if (state->prev->needsValue) {
            if (state->code->stackCount < 1) {
                genError(cp, np, "Else expression does not evaluate to a value. Check if operands are void");
            }
            emptyStack(cp, 1);
        } else {
            emptyStack(cp, 0);
        }
    }

    /*
        Calculate jump lengths. Then length will vary depending on if the jump at the end of the "then" block
        can jump over the "else" block with a short jump.
     */
    elseLen = (np->tenary.elseCode) ? mprGetBufLength(np->tenary.elseCode->buf) : 0;
    thenLen = mprGetBufLength(np->tenary.thenCode->buf);
    thenLen += (elseLen < 0x7f && cp->optimizeLevel > 0) ? 2 : 5;

    /*
        Now copy the basic blocks into the output code buffer, starting with the jump around the "then" code.
     */
    setCodeBuffer(cp, saveCode);

    if (thenLen < 0x7f && cp->optimizeLevel > 0) {
        ecEncodeOpcode(cp, EJS_OP_BRANCH_FALSE_8);
        ecEncodeByte(cp, thenLen);
    } else {
        ecEncodeOpcode(cp, EJS_OP_BRANCH_FALSE);
        ecEncodeWord(cp, thenLen);
    }

    /*
        Copy the then code
     */
    copyCodeBuffer(cp, state->code, np->tenary.thenCode);

    /*
        Create the jump to the end of the if statement
     */
    if (elseLen < 0x7f && cp->optimizeLevel > 0) {
        ecEncodeOpcode(cp, EJS_OP_GOTO_8);
        ecEncodeByte(cp, elseLen);
    } else {
        ecEncodeOpcode(cp, EJS_OP_GOTO);
        ecEncodeWord(cp, elseLen);
    }

    if (np->tenary.elseCode) {
        copyCodeBuffer(cp, state->code, np->tenary.elseCode);
    }
    if (state->prev->needsValue) {
        pushStack(cp, 1);
    }
    LEAVE(cp);
}


/*
    Expect data on the stack already to assign
 */
static void genLeftHandSide(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);

    mprAssert(cp);
    mprAssert(np);

    cp->state->onLeft = 1;

    switch (np->kind) {
    case N_DOT:
    case N_QNAME:
    case N_SUPER:
    case N_EXPRESSIONS:
        processNode(cp, np);
        break;

    case N_CALL:
    default:
        genError(cp, np, "Illegal left hand side");
    }
    LEAVE(cp);
}


static void genLiteral(EcCompiler *cp, EcNode *np)
{
    EjsNamespace    *nsp;
    EjsBoolean      *bp;
    EjsNumber       *ip;
    EjsString       *pattern;
    Ejs             *ejs;
    int64           n;
    int             id;

    ENTER(cp);
    ejs = cp->ejs;

    if (np->literal.var->type == ejs->xmlType) {
        ecEncodeOpcode(cp, EJS_OP_LOAD_XML);
        ecEncodeString(cp, mprGetBufStart(np->literal.data));
        pushStack(cp, 1);
        LEAVE(cp);
        return;
    }

    /*
        Map Numbers to the configured real type
     */
    id = np->literal.var->type->id;

    switch (id) {
    case ES_Boolean:
        bp = (EjsBoolean*) np->literal.var;
        if (bp->value) {
            ecEncodeOpcode(cp, EJS_OP_LOAD_TRUE);
        } else {
            ecEncodeOpcode(cp, EJS_OP_LOAD_FALSE);
        }
        break;

    case ES_Number:
        /*
            These are signed values
         */
        ip = (EjsNumber*) np->literal.var;
        n = (int64) floor(ip->value);
        if (ip->value != floor(ip->value) || ip->value <= -MAXINT || ip->value >= MAXINT) {
            ecEncodeOpcode(cp, EJS_OP_LOAD_DOUBLE);
            ecEncodeDouble(cp, ip->value);
        } else {
            n = (int64) ip->value;
            if (0 <= n && n <= 9) {
                ecEncodeOpcode(cp, EJS_OP_LOAD_0 + (int) n);
            } else {
                ecEncodeOpcode(cp, EJS_OP_LOAD_INT);
                ecEncodeNumber(cp, n);
            }
        }
        break;

    case ES_Namespace:
        ecEncodeOpcode(cp, EJS_OP_LOAD_NAMESPACE);
        nsp = (EjsNamespace*) np->literal.var;
        ecEncodeString(cp, nsp->uri);
        break;

    case ES_Null:
        ecEncodeOpcode(cp, EJS_OP_LOAD_NULL);
        break;

    case ES_String:
        ecEncodeOpcode(cp, EJS_OP_LOAD_STRING);
        ecEncodeString(cp, ((EjsString*) np->literal.var)->value);
        break;

    case ES_RegExp:
        ecEncodeOpcode(cp, EJS_OP_LOAD_REGEXP);
        pattern = (EjsString*) ejsRegExpToString(cp->ejs, (EjsRegExp*) np->literal.var);
        ecEncodeString(cp, pattern->value);
        mprFree(pattern);
        break;

    case ES_Void:
        ecEncodeOpcode(cp, EJS_OP_LOAD_UNDEFINED);
        break;

    default:
        mprAssert(0);
        break;
    }
    pushStack(cp, 1);
    LEAVE(cp);
}


/*
    Generate code for name reference. This routine handles both loads and stores.
 */
static void genName(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);

    mprAssert(np->kind == N_QNAME || np->kind == N_USE_NAMESPACE);

    if (np->needThis) {
        if (np->lookup.useThis) {
            ecEncodeOpcode(cp, EJS_OP_LOAD_THIS);

        } else if (np->lookup.obj == cp->ejs->global){
            ecEncodeOpcode(cp, EJS_OP_LOAD_GLOBAL);

        } else if (cp->state->currentObjectNode) {
            ecEncodeOpcode(cp, EJS_OP_DUP);

        } else {
            /*
                Unbound function
             */
            ecEncodeOpcode(cp, EJS_OP_LOAD_GLOBAL);
        }
        pushStack(cp, 1);
        np->needThis = 0;
    }
    if (np->lookup.slotNum >= 0) {
        genBoundName(cp, np);

    } else {
        genUnboundName(cp, np);
    }
    LEAVE(cp);
}


static void genNew(EcCompiler *cp, EcNode *np)
{
    EcState     *state;
    int         argc;

    ENTER(cp);

    mprAssert(np->kind == N_NEW);

    state = cp->state;
    argc = 0;

    /*
        Process the type reference to instantiate
     */
    processNode(cp, np->left);
    ecEncodeOpcode(cp, EJS_OP_NEW);
    popStack(cp, 1);
    pushStack(cp, 1);
    LEAVE(cp);
}


static void genObjectLiteral(EcCompiler *cp, EcNode *np)
{
    EcNode      *child, *typeNode;
    EjsType     *type;
    int         next, argc;

    ENTER(cp);

    /*
        Push all the literal args
     */
    next = 0;
    while ((child = getNextNode(cp, np, &next)) != 0) {
        processNode(cp, child);
    }
    argc = next;
    ecEncodeOpcode(cp, EJS_OP_NEW_OBJECT);
    typeNode = np->objectLiteral.typeNode;
    type = (EjsType*) typeNode->lookup.ref;
    ecEncodeGlobal(cp, (EjsObj*) type, (type) ? &type->qname: 0);
    ecEncodeNumber(cp, argc);
    next = 0;
    while ((child = getNextNode(cp, np, &next)) != 0) {
        ecEncodeNumber(cp, child->attributes);
    }
    pushStack(cp, 1);
    popStack(cp, argc * 3);
    LEAVE(cp);
}


static void genField(EcCompiler *cp, EcNode *np)
{
    EcNode      *fieldName;

    fieldName = np->field.fieldName;

    if (fieldName->kind == N_QNAME) {
        ecEncodeOpcode(cp, EJS_OP_LOAD_STRING);
        ecEncodeString(cp, np->field.fieldName->qname.space);
        ecEncodeOpcode(cp, EJS_OP_LOAD_STRING);
        ecEncodeString(cp, np->field.fieldName->qname.name);
        pushStack(cp, 2);

    } else if (fieldName->kind == N_LITERAL) {
        ecEncodeOpcode(cp, EJS_OP_LOAD_STRING);
        ecEncodeString(cp, EJS_EMPTY_NAMESPACE);
        pushStack(cp, 1);
        genLiteral(cp, fieldName);

    } else {
        mprAssert(0);
        processNode(cp, fieldName);
    }

    if (np->field.fieldKind == FIELD_KIND_VALUE || np->field.fieldKind == FIELD_KIND_FUNCTION) {
        processNode(cp, np->field.expr);
    } else {
        processNode(cp, np->field.fieldName);
    }
}


static void genPostfixOp(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);

    /*
        Dup before inc
     */
    processNode(cp, np->left);
    ecEncodeOpcode(cp, EJS_OP_DUP);
    ecEncodeOpcode(cp, EJS_OP_INC);
    ecEncodeByte(cp, (np->tokenId == T_PLUS_PLUS) ? 1 : -1);
    genLeftHandSide(cp, np->left);
    pushStack(cp, 1);
    LEAVE(cp);
}


static void genProgram(EcCompiler *cp, EcNode *np)
{
    Ejs         *ejs;
    EcNode      *child;
    int         next;

    ENTER(cp);

    ejs = cp->ejs;

    next = 0;
    while ((child = getNextNode(cp, np, &next)) && !cp->error) {

        switch (child->kind) {
        case N_MODULE:
            genModule(cp, child);
            break;

        case N_DIRECTIVES:
            genDirectives(cp, child, 1);
            break;

        default:
            badNode(cp, np);
        }
    }
    LEAVE(cp);
}


static void genPragmas(EcCompiler *cp, EcNode *np)
{
    EcNode  *child;
    int     next;

    next = 0;
    while ((child = getNextNode(cp, np, &next))) {
        processNode(cp, child);
    }
}


/*
    Generate code for function returns
 */
static void genReturn(EcCompiler *cp, EcNode *np)
{
    EjsFunction     *fun;

    ENTER(cp);

    if (cp->state->captureBreak) {
        ecEncodeOpcode(cp, EJS_OP_FINALLY);
    }
    if (np->left) {
        fun = cp->state->currentFunction;
        if (fun->resultType == NULL || fun->resultType != cp->ejs->voidType) {
            cp->state->needsValue = 1;
            processNode(cp, np->left);
            cp->state->needsValue = 0;
            ecEncodeOpcode(cp, EJS_OP_RETURN_VALUE);
            popStack(cp, 1);

        } else if (np->ret.blockLess) {
            /*
                The return was inserted by the parser. So we must still process the statement
             */
            processNode(cp, np->left);
        }

    } else {
        /*
            return;
         */
        ecEncodeOpcode(cp, EJS_OP_RETURN);
    }
    emptyStack(cp, 0);
    LEAVE(cp);
}


/*
    Load the super pointer. Super function calls (super()) are handled via N_CALL.
 */
static void genSuper(EcCompiler *cp, EcNode *np)
{
    int     argc;

    ENTER(cp);

    mprAssert(np->kind == N_SUPER);

    if (np->left) {
        argc = mprGetListCount(np->left->children);
        if (argc > 0) {
            processNode(cp, np->left);
        }
        ecEncodeOpcode(cp, EJS_OP_CALL_NEXT_CONSTRUCTOR);
        ecEncodeNumber(cp, argc);        
        popStack(cp, argc);
    } else {
        ecEncodeOpcode(cp, EJS_OP_SUPER); 
        pushStack(cp, 1);
    }
    LEAVE(cp);
}


static void genSwitch(EcCompiler *cp, EcNode *np)
{
    EcNode      *caseItem, *elements;
    EcCodeGen   *code, *outerBlock;
    EcState     *state;
    int         next, len, nextCaseLen, nextCodeLen, totalLen;

    ENTER(cp);

    state = cp->state;
    state->captureBreak = 0;

    outerBlock = state->code;
    code = state->code = allocCodeBuffer(cp);

    ecStartBreakableStatement(cp, EC_JUMP_BREAK);

    /*
        Generate code for the switch (expression)
     */
    processNode(cp, np->left);

    /*
        Generate the code for each case label expression and case statements.
        next set to one to skip the switch expression.
     */
    elements = np->right;
    mprAssert(elements->kind == N_CASE_ELEMENTS);

    next = 0;
    while ((caseItem = getNextNode(cp, elements, &next)) && !cp->error) {

        /*
            Allocate a buffer for the case expression and generate that code
         */
        mprAssert(caseItem->kind == N_CASE_LABEL);
        if (caseItem->caseLabel.kind == EC_SWITCH_KIND_CASE) {
            caseItem->caseLabel.expressionCode = state->code = allocCodeBuffer(cp);
            /*
                Dup the switch expression value to preserve it for later cases.
                OPT - don't need to preserve for default cases or if this is the last case
             */
            addDebugInstructions(cp, caseItem->caseLabel.expression);
            ecEncodeOpcode(cp, EJS_OP_DUP);

            setStack(cp, 0);

            mprAssert(caseItem->caseLabel.expression);
            processNode(cp, caseItem->caseLabel.expression);
        }

        /*
            Generate code for the case directives themselves.
         */
        caseItem->code = state->code = allocCodeBuffer(cp);
        mprAssert(caseItem->left->kind == N_DIRECTIVES);

        setStack(cp, 0);
        processNode(cp, caseItem->left);
    }

    /*
        Calculate jump lengths. Start from the last case and work backwards.
     */
    nextCaseLen = 0;
    nextCodeLen = 0;
    totalLen = 0;

    next = -1;
    while ((caseItem = getPrevNode(cp, elements, &next)) && !cp->error) {

        if (caseItem->kind != N_CASE_LABEL) {
            break;
        }

        /*
            CODE jump
            Jump to the code block of the next case. In the last block, we just fall out the bottom.
         */
        caseItem->caseLabel.nextCaseCode = nextCodeLen;
        if (nextCodeLen > 0) {
            len = (caseItem->caseLabel.nextCaseCode < 0x7f && cp->optimizeLevel > 0) ? 2 : 5;
            nextCodeLen += len;
            nextCaseLen += len;
            totalLen += len;
        }

        /*
            CASE jump
            Jump to the next case expression evaluation.
         */
        len = getCodeLength(cp, caseItem->code);
        nextCodeLen += len;
        nextCaseLen += len;
        totalLen += len;

        caseItem->jumpLength = nextCaseLen;
        nextCodeLen = 0;

        if (caseItem->caseLabel.kind == EC_SWITCH_KIND_CASE) {
            /*
                Jump to the next case expression test. Increment the length depending on whether we are using a
                goto_8 (2 bytes) or goto (4 bytes). Add one for the CMPEQ instruction (3 vs 6)
             */
            len = (caseItem->jumpLength < 0x7f && cp->optimizeLevel > 0) ? 3 : 6;
            nextCodeLen += len;
            totalLen += len;

            if (caseItem->caseLabel.expressionCode) {
                len = getCodeLength(cp, caseItem->caseLabel.expressionCode);
                nextCodeLen += len;
                totalLen += len;
            }
        }
        nextCaseLen = 0;
    }

    /*
        Now copy the basic blocks into the output code buffer.
     */
    setCodeBuffer(cp, code);

    next = 0;
    while ((caseItem = getNextNode(cp, elements, &next)) && !cp->error) {

        if (caseItem->caseLabel.expressionCode) {
            copyCodeBuffer(cp, state->code, caseItem->caseLabel.expressionCode);
        }

        /*
            Encode the jump to the next case
         */
        if (caseItem->caseLabel.kind == EC_SWITCH_KIND_CASE) {
            setStack(cp, 2);
            ecEncodeOpcode(cp, EJS_OP_COMPARE_STRICTLY_EQ);
            popStack(cp, 2);

            if (caseItem->jumpLength < 0x7f && cp->optimizeLevel > 0) {
                ecEncodeOpcode(cp, EJS_OP_BRANCH_FALSE_8);
                ecEncodeByte(cp, caseItem->jumpLength);
            } else {
                ecEncodeOpcode(cp, EJS_OP_BRANCH_FALSE);
                ecEncodeWord(cp, caseItem->jumpLength);
            }
        }

        mprAssert(caseItem->code);
        copyCodeBuffer(cp, state->code, caseItem->code);

        /*
            Encode the jump to the next case's code. Last case/default block may have zero length jump.
         */
        if (caseItem->caseLabel.nextCaseCode > 0) {
            if (caseItem->caseLabel.nextCaseCode < 0x7f && cp->optimizeLevel > 0) {
                ecEncodeOpcode(cp, EJS_OP_GOTO_8);
                ecEncodeByte(cp, caseItem->caseLabel.nextCaseCode);
            } else {
                ecEncodeOpcode(cp, EJS_OP_GOTO);
                ecEncodeWord(cp, caseItem->caseLabel.nextCaseCode);
            }
        }
    }

    totalLen = mprGetBufLength(state->code->buf);
    patchJumps(cp, EC_JUMP_BREAK, totalLen);

    /*
        Pop the switch value
     */
    ecEncodeOpcode(cp, EJS_OP_POP);
    copyCodeBuffer(cp, outerBlock, state->code);
    LEAVE(cp);
}


/*
    Load the this pointer.
 */
static void genThis(EcCompiler *cp, EcNode *np)
{
    EcState     *state;

    ENTER(cp);

    state = cp->state;

    switch (np->thisNode.thisKind) {
    case N_THIS_GENERATOR:
        //  TODO
        break;

    case N_THIS_CALLEE:
        //  TODO
        break;

    case N_THIS_TYPE:
        genClassName(cp, state->currentClass);
        break;

    case N_THIS_FUNCTION:
        genName(cp, state->currentFunctionNode);
        break;

    default:
        ecEncodeOpcode(cp, EJS_OP_LOAD_THIS);
        pushStack(cp, 1);
    }
    LEAVE(cp);
}


/*
  
 */
static void genThrow(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);

    cp->state->needsValue = 1;
    processNode(cp, np->left);
    ecEncodeOpcode(cp, EJS_OP_THROW);
    popStack(cp, 1);
    LEAVE(cp);
}


/*
    Try, catch, finally.
 */
static void genTry(EcCompiler *cp, EcNode *np)
{
    EjsFunction *fun;
    EcNode      *child, *arg, *assignOp;
    EcCodeGen   *saveCode;
    EcState     *state;
    EjsType     *catchType;
    uint        tryStart, tryEnd, handlerStart, handlerEnd;
    int         next, len, numStack;

    ENTER(cp);

//  MOB
    numStack = 0;

    state = cp->state;
    fun = state->currentFunction;
    mprAssert(fun);

    /*
        Switch to a new code buffer for the try block
     */
    saveCode = state->code;
    mprAssert(saveCode);
    np->exception.tryBlock->code = state->code = allocCodeBuffer(cp);

    addDebugInstructions(cp, np);

    /*
        Process the try block. Will add a goto into either the finally block or if no finally block,
        to after the last catch.
     */
    processNode(cp, np->exception.tryBlock);

    if (np->exception.catchClauses) {
        next = 0;
        /*
            If there is a finally block it must be invoked before acting on any break/continue and return statements 
         */
        state->captureBreak = np->exception.finallyBlock ? 1 : 0;
        while ((child = getNextNode(cp, np->exception.catchClauses, &next)) && !cp->error) {
            child->code = state->code = allocCodeBuffer(cp);
            mprAssert(child->left);

            processNode(cp, child->left);
            if (np->exception.finallyBlock == 0) {
                ecEncodeOpcode(cp, EJS_OP_END_EXCEPTION);
            }
            /* Add jumps below */
        }
        state->captureBreak = 0;
    }

    if (np->exception.finallyBlock) {
        np->exception.finallyBlock->code = state->code = allocCodeBuffer(cp);
        processNode(cp, np->exception.finallyBlock);
        ecEncodeOpcode(cp, EJS_OP_END_EXCEPTION);
    }

    /*
        Calculate jump lengths for the catch block into a finally block. Start from the last catch block and work backwards.
     */
    len = 0;
    if (np->exception.catchClauses) {
        next = -1;
        while ((child = getPrevNode(cp, np->exception.catchClauses, &next)) && !cp->error) {
            child->jumpLength = len;
            if (child->jumpLength > 0 && np->exception.finallyBlock) {
                /*
                    Add jumps if there is a finally block. Otherwise, we use and end_ecception instruction
                    Increment the length depending on whether we are using a goto_8 (2 bytes) or goto (4 bytes)
                 */
                len += (child->jumpLength < 0x7f && cp->optimizeLevel > 0) ? 2 : 5;
            }
            len += getCodeLength(cp, child->code);
        }
    }

    /*
        Now copy the code. First the try block. Restore the primary code buffer and copy try/catch/finally
        code blocks into the code buffer.
     */
    setCodeBuffer(cp, saveCode);

    tryStart = ecGetCodeOffset(cp);

    /*
        Copy the try code and add a jump
     */
    copyCodeBuffer(cp, state->code, np->exception.tryBlock->code);

    if (np->exception.finallyBlock) {
        ecEncodeOpcode(cp, EJS_OP_FINALLY);
    }
    if (len < 0x7f && cp->optimizeLevel > 0) {
        ecEncodeOpcode(cp, EJS_OP_GOTO_8);
        ecEncodeByte(cp, len);
    } else {
        ecEncodeOpcode(cp, EJS_OP_GOTO);
        ecEncodeWord(cp, len);
    }
    tryEnd = ecGetCodeOffset(cp);


    /*
        Now the copy the catch blocks and add jumps
     */
    if (np->exception.catchClauses) {
        next = 0;
        while ((child = getNextNode(cp, np->exception.catchClauses, &next)) && !cp->error) {
            handlerStart = ecGetCodeOffset(cp);
            copyCodeBuffer(cp, state->code, child->code);
            if (child->jumpLength > 0 && np->exception.finallyBlock) {
                if (child->jumpLength < 0x7f && cp->optimizeLevel > 0) {
                    ecEncodeOpcode(cp, EJS_OP_GOTO_8);
                    ecEncodeByte(cp, child->jumpLength);
                } else {
                    //  TODO - GOTO_16
                    ecEncodeOpcode(cp, EJS_OP_GOTO);
                    ecEncodeWord(cp, child->jumpLength);
                }
            }
            handlerEnd = ecGetCodeOffset(cp);

            /*
                Create exception handler record
             */
            catchType = 0;
            arg = 0;
            if (child->catchBlock.arg && child->catchBlock.arg->left) {
                assignOp = child->catchBlock.arg->left;
                arg = assignOp->left;
            }
            if (arg && arg->typeNode && ejsIsType(arg->typeNode->lookup.ref)) {
                catchType = (EjsType*) arg->typeNode->lookup.ref;
            }
            if (catchType == 0) {
                catchType = cp->ejs->voidType;
            }
            ecAddNameConstant(cp, &catchType->qname);
            addException(cp, tryStart, tryEnd, catchType, handlerStart, handlerEnd, np->exception.numBlocks, 
                numStack, EJS_EX_CATCH);
        }
    }

    /*
        Finally, the finally block
     */
    if (np->exception.finallyBlock) {
        handlerStart = ecGetCodeOffset(cp);
        copyCodeBuffer(cp, state->code, np->exception.finallyBlock->code);
        handlerEnd = ecGetCodeOffset(cp);
        addException(cp, tryStart, tryEnd, cp->ejs->voidType, handlerStart, handlerEnd, np->exception.numBlocks, 
            numStack, EJS_EX_FINALLY);
    }
    LEAVE(cp);
}


static void genUnaryOp(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);

    mprAssert(np->kind == N_UNARY_OP);
    mprAssert(np->left);

    switch (np->tokenId) {
    case T_DELETE:
        genDelete(cp, np);
        break;

    case T_LOGICAL_NOT:
        cp->state->needsValue = 1;
        processNode(cp, np->left);
        ecEncodeOpcode(cp, EJS_OP_LOGICAL_NOT);
        break;

    case T_PLUS:
        /* Just ignore the plus */
        processNode(cp, np->left);
        break;

    case T_PLUS_PLUS:
        processNode(cp, np->left);
        ecEncodeOpcode(cp, EJS_OP_INC);
        ecEncodeByte(cp, 1);
        ecEncodeOpcode(cp, EJS_OP_DUP);
        pushStack(cp, 1);
        genLeftHandSide(cp, np->left);
        break;

    case T_MINUS:
        processNode(cp, np->left);
        ecEncodeOpcode(cp, EJS_OP_NEG);
        break;

    case T_MINUS_MINUS:
        processNode(cp, np->left);
        ecEncodeOpcode(cp, EJS_OP_INC);
        ecEncodeByte(cp, -1);
        ecEncodeOpcode(cp, EJS_OP_DUP);
        pushStack(cp, 1);
        genLeftHandSide(cp, np->left);
        break;

    case T_TILDE:
        /* Bitwise not */
        cp->state->needsValue = 1;
        processNode(cp, np->left);
        ecEncodeOpcode(cp, EJS_OP_NOT);
        break;

    case T_TYPEOF:
        cp->state->needsValue = 1;
        processNode(cp, np->left);
        ecEncodeOpcode(cp, EJS_OP_TYPE_OF);
        break;

    case T_VOID:
        /* Ignore the node and just push a void */
        ecEncodeOpcode(cp, EJS_OP_LOAD_UNDEFINED);
        pushStack(cp, 1);
        break;
    }
    LEAVE(cp);
}


static void genNameExpr(EcCompiler *cp, EcNode *np)
{
    EcState     *state;
    
    ENTER(cp);
    
    state = cp->state;
    state->currentObjectNode = 0;
    state->onLeft = 0;
    
    if (np->name.qualifierExpr) {
        processNode(cp, np->name.qualifierExpr);
    } else {
        ecEncodeOpcode(cp, EJS_OP_LOAD_STRING);
        ecEncodeString(cp, np->qname.space);
        pushStack(cp, 1);
    }
    if (np->name.nameExpr) {
        processNode(cp, np->name.nameExpr);
    } else {
        ecEncodeOpcode(cp, EJS_OP_LOAD_STRING);
        ecEncodeString(cp, np->qname.name);
        pushStack(cp, 1);
    }
    LEAVE(cp);
}


/*
    Generate code for an unbound name reference. We don't know the slot.
 */
static void genUnboundName(EcCompiler *cp, EcNode *np)
{
    Ejs         *ejs;
    EcState     *state;
    EjsObj      *owner;
    EjsLookup   *lookup;
    int         code;

    ENTER(cp);

    ejs = cp->ejs;
    state = cp->state;

    mprAssert(np->lookup.slotNum < 0 || !cp->bind);

    lookup = &np->lookup;
    owner = lookup->obj;
    
    if (state->currentObjectNode && np->needThis) {
        ecEncodeOpcode(cp, EJS_OP_DUP);
        pushStack(cp, 1);
        np->needThis = 0;
    }

    if (np->name.qualifierExpr || np->name.nameExpr) {
        genNameExpr(cp, np);
        if (state->currentObjectNode) {
            code = (!cp->state->onLeft) ? EJS_OP_GET_OBJ_NAME_EXPR :  EJS_OP_PUT_OBJ_NAME_EXPR;
            popStack(cp, (cp->state->onLeft) ? 4 : 2);
        } else {
            code = (!cp->state->onLeft) ? EJS_OP_GET_SCOPED_NAME_EXPR :  EJS_OP_PUT_SCOPED_NAME_EXPR;
            popStack(cp, (cp->state->onLeft) ? 3 : 1);
        }
        ecEncodeOpcode(cp, code);
        LEAVE(cp);
        return;
    }

    if (state->currentObjectNode) {
        /*
            Property name (requires obj on stack)
            Store: -2, load: 0
         */
        code = (!state->onLeft) ?  EJS_OP_GET_OBJ_NAME :  EJS_OP_PUT_OBJ_NAME;
        ecEncodeOpcode(cp, code);
        ecEncodeName(cp, &np->qname);

        popStack(cp, 1);
        pushStack(cp, (state->onLeft) ? -1 : 1);

    } else if (owner == ejs->global) {
        if (np->needThis) {
            mprAssert(0);
            ecEncodeOpcode(cp, EJS_OP_LOAD_GLOBAL);
            pushStack(cp, 1);
            np->needThis = 0;
        }

        ecEncodeOpcode(cp, EJS_OP_LOAD_GLOBAL);
        pushStack(cp, 1);

        code = (!state->onLeft) ?  EJS_OP_GET_OBJ_NAME :  EJS_OP_PUT_OBJ_NAME;
        ecEncodeOpcode(cp, code);
        ecEncodeName(cp, &np->qname);

        /*
            Store: -2, load: 0
         */
        popStack(cp, 1);
        pushStack(cp, (state->onLeft) ? -1 : 1);

    } else if (lookup->useThis) {
        ecEncodeOpcode(cp, EJS_OP_LOAD_THIS);
        pushStack(cp, 1);
        if (np->needThis) {
            mprAssert(0);
            ecEncodeOpcode(cp, EJS_OP_DUP);
            pushStack(cp, 1);
            np->needThis = 0;
        }

        code = (!state->onLeft) ?  EJS_OP_GET_OBJ_NAME :  EJS_OP_PUT_OBJ_NAME;
        ecEncodeOpcode(cp, code);
        ecEncodeName(cp, &np->qname);

        /*
            Store: -2, load: 0
         */
        popStack(cp, 1);
        pushStack(cp, (state->onLeft) ? -1 : 1);

    } else if (owner && ejsIsType(owner)) {
        SAVE_ONLEFT(cp);
        genClassName(cp, (EjsType*) owner);
        RESTORE_ONLEFT(cp);

        if (np->needThis) {
            mprAssert(0);
            ecEncodeOpcode(cp, EJS_OP_DUP);
            pushStack(cp, 1);
            np->needThis = 0;
        }
        code = (!state->onLeft) ?  EJS_OP_GET_OBJ_NAME :  EJS_OP_PUT_OBJ_NAME;
        ecEncodeOpcode(cp, code);
        ecEncodeName(cp, &np->qname);

        /*
            Store: -2, load: 0
         */
        popStack(cp, 1);
        pushStack(cp, (state->onLeft) ? -1 : 1);

    } else {
        /*
            Unqualified name
         */
        if (np->needThis) {
            mprAssert(0);
            ecEncodeOpcode(cp, EJS_OP_LOAD_THIS);
            pushStack(cp, 1);
            np->needThis = 0;
        }
        code = (!state->onLeft) ?  EJS_OP_GET_SCOPED_NAME :  EJS_OP_PUT_SCOPED_NAME;
        ecEncodeOpcode(cp, code);
        ecEncodeName(cp, &np->qname);

        /*
            Store: -1, load: 1
         */
        pushStack(cp, (state->onLeft) ? -1 : 1);
    }
    LEAVE(cp);
}


static void genModule(EcCompiler *cp, EcNode *np)
{    
    ENTER(cp);

    mprAssert(np->kind == N_MODULE);

    addModule(cp, np->module.ref);
    genBlock(cp, np->left);
    LEAVE(cp);
}


static void genUseModule(EcCompiler *cp, EcNode *np)
{
    EcNode      *child;
    Ejs         *ejs;
    int         next;

    ENTER(cp);

    ejs = cp->ejs;

    mprAssert(np->kind == N_USE_MODULE);

    next = 0;
    while ((child = getNextNode(cp, np, &next))) {
        processNode(cp, child);
    }
    LEAVE(cp);
}


static void genUseNamespace(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);

    mprAssert(np->kind == N_USE_NAMESPACE);

    /*
        Load the namespace reference. NOTE: use default space; will not add a namespace to the set of open spaces.
     */
    if (np->useNamespace.isLiteral) {
        ecEncodeOpcode(cp, EJS_OP_ADD_NAMESPACE);
        ecEncodeString(cp, np->qname.name);

    } else {
        genName(cp, np);
        ecEncodeOpcode(cp, EJS_OP_ADD_NAMESPACE_REF);
        popStack(cp, 1);
    }
    LEAVE(cp);
}


static void genVar(EcCompiler *cp, EcNode *np)
{
    EcState     *state;

    ENTER(cp);

    mprAssert(np->kind == N_QNAME);

    state = cp->state;

    /*
        Add string constants
     */
    ecAddNameConstant(cp, &np->qname);

    if (np->lookup.trait && np->lookup.trait->type) {
        ecAddConstant(cp, np->lookup.trait->type->qname.name);
    }
    if (cp->ejs->flags & EJS_FLAG_DOC) {
        ecAddDocConstant(cp, np->lookup.trait, np->lookup.obj, np->lookup.slotNum);
    }
    LEAVE(cp);
}


static void genVarDefinition(EcCompiler *cp, EcNode *np)
{
    EcState     *state;
    EcNode      *child, *var;
    int         next, varKind;

    ENTER(cp);

    mprAssert(np->kind == N_VAR_DEFINITION);

    state = cp->state;
    varKind = np->def.varKind;

    for (next = 0; (child = getNextNode(cp, np, &next)) != 0; ) {

        var = (child->kind == N_ASSIGN_OP) ? child->left : child;
        mprAssert(var->kind == N_QNAME);

        genVar(cp, var);

        if (child->kind == N_ASSIGN_OP) {
            /*
                Class level variable initializations must go into the instance code buffer.
             */
            if (var->name.instanceVar) {
                state->instanceCode = 1;
                mprAssert(state->instanceCodeBuf);
                state->code = state->instanceCodeBuf;
            }
            genAssignOp(cp, child);

        } else {
            addDebugInstructions(cp, var);
        }
    }
    LEAVE(cp);
}


static void genWith(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);

    processNode(cp, np->with.object);
    ecEncodeOpcode(cp, EJS_OP_OPEN_WITH);
    popStack(cp, 1);
    processNode(cp, np->with.statement);
    ecEncodeOpcode(cp, EJS_OP_CLOSE_BLOCK);
    LEAVE(cp);
}


/*
    Create the module file.
 */

static MprFile *openModuleFile(EcCompiler *cp, cchar *filename)
{
    EcState     *state;

    mprAssert(cp);
    mprAssert(filename && *filename);

    state = cp->state;

    if (cp->noout) {
        return 0;
    }
    if ((cp->file = mprOpen(cp, filename,  O_CREAT | O_WRONLY | O_TRUNC | O_BINARY, 0664)) == 0) {
        genError(cp, 0, "Can't create %s", filename);
        return 0;
    }

    /*
        Create a module header once per file instead of per-module in the file
     */
    state->code = allocCodeBuffer(cp);
    if (ecCreateModuleHeader(cp) < 0) {
        genError(cp, 0, "Can't write module file header");
        return 0;
    }
    return cp->file;
}


/*
    Create a new code buffer
 */
static EcCodeGen *allocCodeBuffer(EcCompiler *cp)
{
    EcState     *state;
    EcCodeGen   *code;

    mprAssert(cp);

    state = cp->state;
    mprAssert(state);

    code = mprAllocObjZeroed(state, EcCodeGen);
    if (code == 0) {
        cp->fatalError = 1;
        return 0;
    }
    code->buf = mprCreateBuf(cp, EC_CODE_BUFSIZE, 0);
    if (code->buf == 0) {
        mprAssert(0);
        cp->fatalError = 1;
        return 0;
    }

    code->exceptions = mprCreateList(code);
    if (code->exceptions == 0) {
        mprAssert(0);
        return 0;
    }

    /*
        Jumps are fully processed before the state is freed
     */
    code->jumps = mprCreateList(code);
    if (code->jumps == 0) {
        mprAssert(0);
        return 0;
    }

    /*
        Inherit the allowable jump kinds and stack level
     */
    if (state->code) {
        code->jumpKinds = state->code->jumpKinds;
        code->stackCount = state->code->stackCount;
    }
    return code;
}


static int getCodeLength(EcCompiler *cp, EcCodeGen *code)
{
    return mprGetBufLength(code->buf);
}


static void copyCodeBuffer(EcCompiler *cp, EcCodeGen *dest, EcCodeGen *src)
{
    EjsEx           *exception;
    EcJump          *jump;
    EcState         *state;
    uint            baseOffset;
    int             len, next;

    state = cp->state;
    mprAssert(state);
    mprAssert(dest != src);

    len = getCodeLength(cp, src);
    if (len <= 0) {
        return;
    }

    /*
        Copy the code
     */
    baseOffset = mprGetBufLength(dest->buf);
    if (mprPutBlockToBuf(dest->buf, mprGetBufStart(src->buf), len) != len) {
        mprAssert(0);
        return;
    }

    /*
        Copy and fix the jump offset of jump patch records. jump->offset starts out being relative to the current code src.
        We add the original length of dest to make it absolute to the new dest buffer.
     */
    if (src->jumps) {
        if (src->jumps != dest->jumps) {
            next = 0;
            while ((jump = (EcJump*) mprGetNextItem(src->jumps, &next)) != 0) {
                jump->offset += baseOffset;
                mprAddItem(dest->jumps, jump);
                mprStealBlock(dest->jumps, jump);
            }
        }
    }

    /*
        Copy and fix exception target addresses
     */
    if (src->exceptions) {
        next = 0;
        while ((exception = (EjsEx*) mprGetNextItem(src->exceptions, &next)) != 0) {
            exception->tryStart += baseOffset;
            exception->tryEnd += baseOffset;
            exception->handlerStart += baseOffset;
            exception->handlerEnd += baseOffset;
            mprAddItem(dest->exceptions, exception);
        }
    }
}


/*
    Patch jump addresses a code buffer. Kind is the kind of jump (break | continue)
 */
static void patchJumps(EcCompiler *cp, int kind, int target)
{
    EcJump      *jump;
    EcCodeGen   *code;
    uchar       *pos;
    int         next;
    int         offset;

    code = cp->state->code;
    mprAssert(code);

rescan:
    next = 0;
    while ((jump = (EcJump*) mprGetNextItem(code->jumps, &next)) != 0) {
        if (jump->kind == kind) {
            offset = target - jump->offset - 4;
            mprAssert(-10000 < offset && offset < 10000);
            mprAssert(jump->offset < mprGetBufLength(code->buf));
            pos = (uchar*) mprGetBufStart(code->buf) + jump->offset;
            mprLog(cp, 7, "Patch 0x%x at address %d", offset, jump->offset);
            ecEncodeWordAtPos(cp, pos, offset);
            mprRemoveItem(code->jumps, jump);
            goto rescan;
        }
    }
}


/*
    Write the module contents
 */
static int flushModule(MprFile *file, EcCodeGen *code)
{
    int         len;

    len = mprGetBufLength(code->buf);
    if (len > 0) {
        if (mprWrite(file, mprGetBufStart(code->buf), len) != len) {
            return EJS_ERR;
        }
        mprFlushBuf(code->buf);
    }
    return 0;
}


/*
    Create the module initializer
 */
static void createInitializer(EcCompiler *cp, EjsModule *mp)
{
    Ejs             *ejs;
    EjsFunction     *fun;
    EcState         *state;
    EcCodeGen       *code;
    int             len;

    ENTER(cp);

    ejs = cp->ejs;
    state = cp->state;
    mprAssert(state);

    /*
        Note: if hasInitializer is false, we may still have some code in the buffer if --debug is used.
        We can safely just ignore this debug code.
     */
    if (! mp->hasInitializer) {
        LEAVE(cp);
        return;
    }
    mprAssert(mprGetBufLength(mp->code->buf) > 0);

    if (cp->errorCount > 0) {
        LEAVE(cp);
        return;
    }
    state->code = mp->code;
    cp->directiveState = state;
    code = cp->state->code;
    len = mprGetBufLength(code->buf);
    mprAssert(len > 0);
    ecEncodeOpcode(cp, EJS_OP_END_CODE);

    /*
        Extract the initialization code
     */
    fun = state->currentFunction = mp->initializer;
    if (fun) {
        setFunctionCode(cp, fun, code);
    }
    ejsCompleteFunction(ejs, fun);
    LEAVE(cp);
}


static void genError(EcCompiler *cp, EcNode *np, char *fmt, ...)
{
    va_list     arg;
    char        *msg;

    va_start(arg, fmt);

    if ((msg = mprVasprintf(cp, 0, fmt, arg)) == NULL) {
        msg = "Memory allocation error";
    }

    cp->errorCount++;
    cp->error = 1;
    cp->noout = 1;

    if (np) {
        ecReportError(cp, "error", np->filename, np->lineNumber, np->currentLine, np->column, msg);
    } else {
        ecReportError(cp, "error", 0, 0, 0, 0, msg);
    }
    mprFree(msg);
    va_end(arg);
}


static void badNode(EcCompiler *cp, EcNode *np)
{
    cp->fatalError = 1;
    cp->errorCount++;
    mprError(cp, "Unsupported language feature\nUnknown AST node kind %d", np->kind);
}


static EcNode *getNextNode(EcCompiler *cp, EcNode *np, int *next)
{
    if (cp->error) {
        return 0;
    }
    return (EcNode*) mprGetNextItem(np->children, next);
}


static EcNode *getPrevNode(EcCompiler *cp, EcNode *np, int *next)
{
    if (cp->fatalError || cp->error) {
        return 0;
    }
    return (EcNode*) mprGetPrevItem(np->children, next);
}


/*
    Map a lexical token to an op code
 */
static int mapToken(EcCompiler *cp, EjsOpCode tokenId)
{
    int     cond;

    cond = cp->state->conditional;

    switch (tokenId) {
    case T_BIT_AND:
        return EJS_OP_AND;

    case T_BIT_OR:
        return EJS_OP_OR;

    case T_BIT_XOR:
        return EJS_OP_XOR;

    case T_DIV:
        return EJS_OP_DIV;

    case T_EQ:
        return (cond) ? EJS_OP_BRANCH_EQ : EJS_OP_COMPARE_EQ;

    case T_NE:
        return (cond) ? EJS_OP_BRANCH_NE : EJS_OP_COMPARE_NE;

    case T_GT:
        return (cond) ? EJS_OP_BRANCH_GT : EJS_OP_COMPARE_GT;

    case T_GE:
        return (cond) ? EJS_OP_BRANCH_GE : EJS_OP_COMPARE_GE;

    case T_LT:
        return (cond) ? EJS_OP_BRANCH_LT : EJS_OP_COMPARE_LT;

    case T_LE:
        return (cond) ? EJS_OP_BRANCH_LE : EJS_OP_COMPARE_LE;

    case T_STRICT_EQ:
        return (cond) ? EJS_OP_BRANCH_STRICTLY_EQ : EJS_OP_COMPARE_STRICTLY_EQ;

    case T_STRICT_NE:
        return (cond) ? EJS_OP_BRANCH_STRICTLY_NE : EJS_OP_COMPARE_STRICTLY_NE;

    case T_LSH:
        return EJS_OP_SHL;

    case T_LOGICAL_NOT:
        return EJS_OP_NOT;

    case T_MINUS:
        return EJS_OP_SUB;

    case T_MOD:
        return EJS_OP_REM;

    case T_MUL:
        return EJS_OP_MUL;

    case T_PLUS:
        return EJS_OP_ADD;

    case T_RSH:
        return EJS_OP_SHR;

    case T_RSH_ZERO:
        return EJS_OP_USHR;

    case T_IS:
        return EJS_OP_IS_A;

    case T_INSTANCEOF:
        return EJS_OP_INST_OF;

    case T_LIKE:
        return EJS_OP_LIKE;

    case T_CAST:
        return EJS_OP_CAST;

    case T_IN:
        return EJS_OP_IN;

    default:
        mprAssert(0);
        return -1;
    }
}


static void addDebugInstructions(EcCompiler *cp, EcNode *np)
{
    if (!cp->debug || cp->state->code == 0) {
        return;
    }
    if (np->lineNumber != cp->currentLineNumber) {
        ecEncodeOpcode(cp, EJS_OP_DEBUG);
        ecEncodeString(cp, np->filename);
        ecEncodeNumber(cp, np->lineNumber);
        ecEncodeString(cp, np->currentLine);
        cp->currentLineNumber = np->lineNumber;
    }
}


static void processNode(EcCompiler *cp, EcNode *np)
{
    EcState     *state;

    ENTER(cp);
    state = cp->state;

    mprAssert(np->parent || np->kind == N_PROGRAM || np->kind == N_MODULE);

    if (np->kind != N_TRY && np->kind != N_END_FUNCTION && np->kind != N_HASH) {
        addDebugInstructions(cp, np);
    }
    switch (np->kind) {
    case N_ARGS:
        state->needsValue = 1;
        genArgs(cp, np);
        break;

    case N_ARRAY_LITERAL:
        genArrayLiteral(cp, np);
        break;

    case N_ASSIGN_OP:
        genAssignOp(cp, np);
        break;

    case N_BINARY_OP:
        genBinaryOp(cp, np);
        break;

    case N_BLOCK:
        genBlock(cp, np);
        break;

    case N_BREAK:
        genBreak(cp, np);
        break;

    case N_CALL:
        genCall(cp, np);
        break;

    case N_CLASS:
        genClass(cp, np);
        break;

    case N_CATCH_ARG:
        genCatchArg(cp, np);
        break;

    case N_CONTINUE:
        genContinue(cp, np);
        break;

    case N_DIRECTIVES:
        genDirectives(cp, np, 1);
        break;

    case N_DO:
        genDo(cp, np);
        break;

    case N_DOT:
        genDot(cp, np, 0);
        break;

    case N_END_FUNCTION:
        genEndFunction(cp, np);
        break;

    case N_EXPRESSIONS:
        genExpressions(cp, np);
        break;

    case N_FOR:
        genFor(cp, np);
        break;

    case N_FOR_IN:
        genForIn(cp, np);
        break;

    case N_FUNCTION:
        genFunction(cp, np);
        break;

    case N_HASH:
        genHash(cp, np);
        break;

    case N_IF:
        genIf(cp, np);
        break;

    case N_LITERAL:
        genLiteral(cp, np);
        break;

    case N_OBJECT_LITERAL:
        genObjectLiteral(cp, np);
        break;

    case N_FIELD:
        genField(cp, np);
        break;

    case N_QNAME:
        genName(cp, np);
        break;

    case N_NEW:
        genNew(cp, np);
        break;

    case N_NOP:
        break;

    case N_POSTFIX_OP:
        genPostfixOp(cp, np);
        break;

    case N_PRAGMA:
        break;

    case N_PRAGMAS:
        genPragmas(cp, np);
        break;

    case N_PROGRAM:
        genProgram(cp, np);
        break;

    case N_REF:
        break;

    case N_RETURN:
        genReturn(cp, np);
        break;

    case N_SUPER:
        genSuper(cp, np);
        break;

    case N_SWITCH:
        genSwitch(cp, np);
        break;

    case N_THIS:
        genThis(cp, np);
        break;

    case N_THROW:
        genThrow(cp, np);
        break;

    case N_TRY:
        genTry(cp, np);
        break;

    case N_UNARY_OP:
        genUnaryOp(cp, np);
        break;

    case N_USE_NAMESPACE:
        genUseNamespace(cp, np);
        break;

    case N_VAR_DEFINITION:
        genVarDefinition(cp, np);
        break;

    case N_MODULE:
        genModule(cp, np);
        break;

    case N_USE_MODULE:
        genUseModule(cp, np);
        break;

    case N_WITH:
        genWith(cp, np);
        break;

    default:
        mprAssert(0);
        badNode(cp, np);
    }

    mprAssert(state == cp->state);
    LEAVE(cp);
}


/*
    Oputput one module.
 */
static void processModule(EcCompiler *cp, EjsModule *mp)
{
    Ejs         *ejs;
    EcState     *state;
    EcCodeGen   *code;
    char        *path;

    ENTER(cp);

    ejs = cp->ejs;
    state = cp->state;
    state->currentModule = mp;

    createInitializer(cp, mp);

    if (cp->noout) {
        return;
    }
    if (! cp->outputFile) {
        if (mp->version) {
            path = mprAsprintf(cp->state, -1, "%s-%d.%d.%d%s", mp->name, 
                EJS_MAJOR(mp->version), EJS_MINOR(mp->version), EJS_PATCH(mp->version), EJS_MODULE_EXT);
        } else {
            path = mprStrcat(cp->state, -1, mp->name, EJS_MODULE_EXT, NULL);
        }
        if ((mp->file = openModuleFile(cp, path)) == 0) {
            mprFree(path);
            LEAVE(cp);
            return;
        }
        mprFree(path);

    } else {
        mp->file = cp->file;
    }
    mprAssert(mp->code);
    mprAssert(mp->file);

    code = state->code;

    if (mp->hasInitializer) {
        ecAddConstant(cp, EJS_INITIALIZER_NAME);
        ecAddConstant(cp, EJS_EJS_NAMESPACE);
    }
    if (ecCreateModuleSection(cp) < 0) {
        genError(cp, 0, "Can't write module sections");
        LEAVE(cp);
        return;
    }
    if (flushModule(mp->file, code) < 0) {
        genError(cp, 0, "Can't write to module file %s", mp->name);
        LEAVE(cp);
        return;
    }
    if (! cp->outputFile) {
        mprFree(mp->file);
        mp->file = 0;
        mp->code = 0;

    } else {
        mprFree(mp->code);
        mp->code = 0;
    }
    mp->file = 0;
}


/*
    Keep a list of modules potentially containing generated code and declarations.
 */
static void addModule(EcCompiler *cp, EjsModule *mp)
{
    EjsModule       *module;
    Ejs             *ejs;
    EcState         *state;
    int             count, i;

    mprAssert(cp);

    state = cp->state;
    ejs = cp->ejs;

    if (mp->code == 0 || cp->interactive) {
        mprFree(mp->code);
        mp->code = state->code = allocCodeBuffer(cp);
        mprStealBlock(mp, mp->code);
    }
    mp->loaded = 0;

    state->code = mp->code;

    mprAssert(mp->code);
    mprAssert(mp->code->buf);

    state->currentModule = mp;
    state->varBlock = ejs->global;
    state->letBlock = ejs->global;

    mprAssert(mp->initializer);
    state->currentFunction = mp->initializer;

    /*
        Merge means aggregate dependent input modules with the output
     */
    if (mp->dependencies && !cp->merge) {
        count = mprGetListCount(mp->dependencies);
        for (i = 0; i < count; i++) {
            module = (EjsModule*) mprGetItem(mp->dependencies, i);
            ecAddConstant(cp, module->name);
        }
    }
}


static int level = 8;

static void pushStack(EcCompiler *cp, int count)
{
    EcCodeGen       *code;

    code = cp->state->code;

    mprAssert(code);

    mprAssert(code->stackCount >= 0);
    code->stackCount += count;
    mprAssert(code->stackCount >= 0);

    mprLog(cp, level, "Stack %d, after push %d", code->stackCount, count);
}


static void popStack(EcCompiler *cp, int count)
{
    EcCodeGen       *code;

    code = cp->state->code;

    mprAssert(code);
    mprAssert(code->stackCount >= 0);

    code->stackCount -= count;
    mprAssert(code->stackCount >= 0);

    mprLog(cp, level, "Stack %d, after pop %d", code->stackCount, count);
}


static void resetStack(EcCompiler *cp)
{
    EcCodeGen       *code;

    code = cp->state->code;

    mprAssert(code);

    code->stackCount = 0;
}


static void setStack(EcCompiler *cp, int count)
{
    EcCodeGen       *code;

    code = cp->state->code;

    mprAssert(code);

    code->stackCount = count;
}


static void emptyStack(EcCompiler *cp, int preserve)
{
    EcCodeGen       *code;
    int             count;

    code = cp->state->code;

    mprAssert(code);
    count = code->stackCount - preserve;

    mprAssert(count >= 0);

    if (count <= 0) {
        return;
    }
    if (count == 1) {
        ecEncodeOpcode(cp, EJS_OP_POP);
    } else {
        ecEncodeOpcode(cp, EJS_OP_POP_ITEMS);
        ecEncodeByte(cp, count);
    }
    code->stackCount = 0;

    mprLog(cp, level, "Stack %d, after empty\n", code->stackCount);

}


/*
    Set the default code buffer
 */
static void setCodeBuffer(EcCompiler *cp, EcCodeGen *saveCode)
{
    cp->state->code = saveCode;
    mprLog(cp, level, "Stack %d, after restore code buffer\n", cp->state->code->stackCount);
}


static void addException(EcCompiler *cp, uint tryStart, uint tryEnd, EjsType *catchType, uint handlerStart, uint handlerEnd, 
    int numBlocks, int numStack, int flags)
{
    EcCodeGen       *code;
    EcState         *state;
    EjsEx           *exception;

    state = cp->state;
    mprAssert(state);

    code = state->code;
    mprAssert(code);

    exception = mprAllocObjZeroed(cp, EjsEx);
    if (exception == 0) {
        mprAssert(0);
        return;
    }
    exception->tryStart = tryStart;
    exception->tryEnd = tryEnd;
    exception->catchType = catchType;
    exception->handlerStart = handlerStart;
    exception->handlerEnd = handlerEnd;
    exception->numBlocks = numBlocks;
    exception->numStack = numStack;
    exception->flags = flags;
    mprAddItem(code->exceptions, exception);
}


static void addJump(EcCompiler *cp, EcNode *np, int kind)
{
    EcJump      *jump;

    ENTER(cp);

    jump = mprAllocObjZeroed(cp, EcJump);
    mprAssert(jump);

    jump->kind = kind;
    jump->node = np;
    jump->offset = ecGetCodeOffset(cp);

    mprAddItem(cp->state->code->jumps, jump);

    LEAVE(cp);
}


static void setFunctionCode(EcCompiler *cp, EjsFunction *fun, EcCodeGen *code)
{
    EjsEx       *ex;
    int         next, len;

    /*
        Define any try/catch blocks encountered
     */
    next = 0;
    while ((ex = (EjsEx*) mprGetNextItem(code->exceptions, &next)) != 0) {
        ejsAddException(fun, ex->tryStart, ex->tryEnd, ex->catchType, ex->handlerStart, ex->handlerEnd, ex->numBlocks, 
            ex->numStack, ex->flags, -1);
    }

    /*
        Define the code for the function
     */
    len = mprGetBufLength(code->buf);
    mprAssert(len >= 0);

    if (len > 0) {
        ejsSetFunctionCode(fun, (uchar*) mprGetBufStart(code->buf), len);
    }
}


static void emitNamespace(EcCompiler *cp, EjsNamespace *nsp)
{
    ecEncodeOpcode(cp, EJS_OP_ADD_NAMESPACE);
    ecEncodeString(cp, nsp->uri);
}


/*
    Aggregate the allowable kinds of jumps
 */
void ecStartBreakableStatement(EcCompiler *cp, int kinds)
{
    EcState     *state;

    mprAssert(cp);

    state = cp->state;
    state->code->jumpKinds |= kinds;
    state->breakState = state;
}

/*
    @copy   default
  
    Copyright (c) Embedthis Software LLC, 2003-2010. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2010. All Rights Reserved.
  
    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.
  
    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html
  
    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
  
    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com
  
    @end
 */

/************************************************************************/
/*
 *  End of file "../src/compiler/ecCodeGen.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../src/compiler/ecCompile.c"
 */
/************************************************************************/

/**
    ecCompile.c - Interface to the compiler

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */




static EjsObj *loadScriptLiteral(Ejs *ejs, cchar *script, cchar *cache);
static EjsObj *loadScriptFile(Ejs *ejs, cchar *path, cchar *cache);


int ejsInitCompiler(EjsService *service)
{
    service->loadScriptLiteral = loadScriptLiteral;
    service->loadScriptFile = loadScriptFile;
    return 0;
}


/*
    Load a script file. This indirect routine is used by the core VM to compile a file when required.
 */
static EjsObj *loadScriptFile(Ejs *ejs, cchar *path, cchar *cache)
{
    if (ejsLoadScriptFile(ejs, path, cache, EC_FLAGS_NO_OUT | EC_FLAGS_DEBUG | EC_FLAGS_BIND | EC_FLAGS_THROW) < 0) {
        return 0;
    }
    return ejs->result;
}


/*
    Function for ejs->loadScriptLiteral. This indirect routine is used by the core VM to compile a script when required.
 */
static EjsObj *loadScriptLiteral(Ejs *ejs, cchar *script, cchar *cache)
{
    if (ejsLoadScriptLiteral(ejs, script, cache, EC_FLAGS_NO_OUT | EC_FLAGS_DEBUG | EC_FLAGS_BIND | EC_FLAGS_THROW) < 0) {
        return 0;
    }
    return ejs->result;
}


/*
    Load and initialize a script file
 */
int ejsLoadScriptFile(Ejs *ejs, cchar *path, cchar *cache, int flags)
{
    EcCompiler      *ec;

    if ((ec = ecCreateCompiler(ejs, flags)) == 0) {
        return MPR_ERR_NO_MEMORY;
    }
    if (cache) {
        ec->noout = 0;
        ecSetOutputFile(ec, cache);
    } else {
        ec->noout = 1;
    }
    if (ecCompile(ec, 1, (char**) &path, 0) < 0) {
        if (flags & EC_FLAGS_THROW) {
            ejsThrowSyntaxError(ejs, "%s", ec->errorMsg ? ec->errorMsg : "Can't parse script");
        }
        mprFree(ec);
        return EJS_ERR;
    }
    mprFree(ec);
    if (ejsRun(ejs) < 0) {
        return EJS_ERR;
    }
    return 0;
}


/*
    Load and initialize a script literal
 */
int ejsLoadScriptLiteral(Ejs *ejs, cchar *script, cchar *cache, int flags)
{
    EcCompiler      *ec;
    cchar           *path;

    if ((ec = ecCreateCompiler(ejs, EC_FLAGS_NO_OUT | EC_FLAGS_DEBUG | EC_FLAGS_BIND)) == 0) {
        return MPR_ERR_NO_MEMORY;
    }
    if (cache) {
        ec->noout = 0;
        ecSetOutputFile(ec, cache);
    } else {
        ec->noout = 1;
    }
    if (ecOpenMemoryStream(ec->lexer, (uchar*) script, (int) strlen(script)) < 0) {
        mprError(ejs, "Can't open memory stream");
        mprFree(ec);
        return EJS_ERR;
    }
    path = "__script__";
    if (ecCompile(ec, 1, (char**) &path, 0) < 0) {
        if (flags & EC_FLAGS_THROW) {
            ejsThrowSyntaxError(ejs, "%s", ec->errorMsg ? ec->errorMsg : "Can't parse script");
        }
        mprFree(ec);
        return EJS_ERR;
    }
    ecCloseStream(ec->lexer);
    if (ejsRun(ejs) < 0) {
        mprFree(ec);
        return EJS_ERR;
    }
    mprFree(ec);
    return 0;
}


/*
    One-line embedding. Evaluate a file. This will compile and interpret the given Ejscript source file.
 */
int ejsEvalFile(cchar *path)
{
    EjsService      *service;   
    Ejs             *ejs;
    Mpr             *mpr;

    mpr = mprCreate(0, NULL, NULL);
    if ((service = ejsCreateService(mpr)) == 0) {
        mprFree(mpr);
        return MPR_ERR_NO_MEMORY;
    }
    if ((ejs = ejsCreateVm(service, NULL, NULL, NULL, 0)) == 0) {
        mprFree(mpr);
        return MPR_ERR_NO_MEMORY;
    }
    if (ejsLoadScriptFile(ejs, path, NULL, EC_FLAGS_NO_OUT | EC_FLAGS_DEBUG | EC_FLAGS_BIND) == 0) {
        ejsReportError(ejs, "Error in program");
        mprFree(mpr);
        return MPR_ERR;
    }
    mprFree(mpr);
    return 0;
}


/*
    One-line embedding. Evaluate a script. This will compile and interpret the given script.
 */
int ejsEvalScript(cchar *script)
{
    EjsService      *service;   
    Ejs             *ejs;
    Mpr             *mpr;

    mpr = mprCreate(0, NULL, NULL);
    if ((service = ejsCreateService(mpr)) == 0) {
        mprFree(mpr);
        return MPR_ERR_NO_MEMORY;
    }
    if ((ejs = ejsCreateVm(service, NULL, NULL, NULL, 0)) == 0) {
        mprFree(mpr);
        return MPR_ERR_NO_MEMORY;
    }
    if (ejsLoadScriptLiteral(ejs, script, NULL, EC_FLAGS_NO_OUT | EC_FLAGS_DEBUG | EC_FLAGS_BIND) == 0) {
        ejsReportError(ejs, "Error in program");
        mprFree(mpr);
        return MPR_ERR;
    }
    mprFree(mpr);
    return 0;
}


/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2010. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2010. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    @end
 */
/************************************************************************/
/*
 *  End of file "../src/compiler/ecCompile.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../src/compiler/ecLex.c"
 */
/************************************************************************/

/**
    ecLex.c - Lexical analyzer

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */

/*
    TODO - must preserve inter-token white space for XML literals
 */




typedef struct ReservedWord
{
    char    *name;
    int     groupMask;
    int     tokenId;
    int     subId;
} ReservedWord;


/*
    Reserved keyword table
    The "true", "false", "null" and "undefined" are handled as global variables
 */
static ReservedWord keywords[] =
{
  { "break",            G_RESERVED,         T_BREAK,                    0, },
  { "case",             G_RESERVED,         T_CASE,                     0, },
  { "cast",             G_CONREV,           T_CAST,                     0, },
  { "catch",            G_RESERVED,         T_CATCH,                    0, },
  { "class",            G_RESERVED,         T_CLASS,                    0, },
  { "const",            G_CONREV,           T_CONST,                    0, },
  { "continue",         G_RESERVED,         T_CONTINUE,                 0, },
  { "default",          G_RESERVED,         T_DEFAULT,                  0, },
  { "delete",           G_RESERVED,         T_DELETE,                   0, },
  { "do",               G_RESERVED,         T_DO,                       0, },
  { "dynamic",          G_CONREV,           T_ATTRIBUTE,                T_DYNAMIC, },
  { "each",             G_CONREV,           T_EACH,                     0, },
  { "else",             G_RESERVED,         T_ELSE,                     0, },
  { "enumerable",       G_CONREV,           T_ATTRIBUTE,                T_ENUMERABLE, },
  { "extends",          G_RESERVED,         T_EXTENDS,                  0, },
  { "false",            G_RESERVED,         T_FALSE,                    0, },
  { "final",            G_CONREV,           T_ATTRIBUTE,                T_FINAL, },
  { "finally",          G_RESERVED,         T_FINALLY,                  0, },
  { "for",              G_RESERVED,         T_FOR,                      0, },
  { "function",         G_RESERVED,         T_FUNCTION,                 0, },
  { "get",              G_CONREV,           T_GET,                      0, },
  { "goto",             G_CONREV,           T_GOTO,                     0, },
  { "if",               G_RESERVED,         T_IF,                       0, },
  { "implements",       G_CONREV,           T_IMPLEMENTS,               0, },
  { "in",               G_RESERVED,         T_IN,                       0, },
  { "include",          G_CONREV,           T_INCLUDE,                  0, },
  { "instanceof",       G_RESERVED,         T_INSTANCEOF,               0, },
  { "interface",        G_CONREV,           T_INTERFACE,                0, },
  { "internal",         G_CONREV,           T_RESERVED_NAMESPACE,       T_INTERNAL, },
  { "intrinsic",        G_CONREV,           T_RESERVED_NAMESPACE,       T_INTRINSIC, },
  { "is",               G_CONREV,           T_IS,                       0, },
  { "let",              G_CONREV,           T_LET,                      0, },
  { "module",           G_CONREV,           T_MODULE,                   0, },
  { "namespace",        G_CONREV,           T_NAMESPACE,                0, },
  { "native",           G_CONREV,           T_ATTRIBUTE,                T_NATIVE, },
  { "new",              G_RESERVED,         T_NEW,                      0, },
  { "null",             G_RESERVED,         T_NULL,                     0, },
  { "override",         G_CONREV,           T_ATTRIBUTE,                T_OVERRIDE, },
  { "private",          G_CONREV,           T_RESERVED_NAMESPACE,       T_PRIVATE, },
  { "protected",        G_CONREV,           T_RESERVED_NAMESPACE,       T_PROTECTED, },
  { "prototype",        G_CONREV,           T_ATTRIBUTE,                T_PROTOTYPE, },
  { "public",           G_CONREV,           T_RESERVED_NAMESPACE,       T_PUBLIC, },
  { "require",          G_CONREV,           T_REQUIRE,                  0, },
  { "return",           G_RESERVED,         T_RETURN,                   0, },
  { "set",              G_CONREV,           T_SET,                      0, },
  { "shared",           G_CONREV,           T_ATTRIBUTE,                T_SHARED, },
  { "standard",         G_CONREV,           T_STANDARD,                 0, },
  { "static",           G_CONREV,           T_ATTRIBUTE,                T_STATIC, },
  { "strict",           G_CONREV,           T_STRICT,                   0, },
  { "super",            G_RESERVED,         T_SUPER,                    0, },
  { "switch",           G_RESERVED,         T_SWITCH,                   0, },
  { "this",             G_RESERVED,         T_THIS,                     0, },
  { "throw",            G_RESERVED,         T_THROW,                    0, },
  { "to",               G_CONREV,           T_TO,                       0, },
  { "true",             G_RESERVED,         T_TRUE,                     0, },
  { "try",              G_RESERVED,         T_TRY,                      0, },
  { "typeof",           G_RESERVED,         T_TYPEOF,                   0, },
  { "var",              G_RESERVED,         T_VAR,                      0, },
  { "undefined",        G_CONREV,           T_UNDEFINED,                0, },
  { "use",              G_CONREV,           T_USE,                      0, },
  { "void",             G_RESERVED,         T_VOID,                     0, },
  { "while",            G_RESERVED,         T_WHILE,                    0, },
  { "with",             G_RESERVED,         T_WITH,                     0, },

#if UNUSED && KEEP
  /*
        Reserved but not implemented
   */
  { "abstract",         G_RESERVED,         T_ABSTRACT,                 0, },
  { "callee",           G_CONREV,           T_CALLEE,                   0, },
  { "enum",             G_RESERVED,         T_ENUM,                     T_ENUM, },
  { "generator",        G_CONREV,           T_GENERATOR,                0, },
  { "has",              G_CONREV,           T_HAS,                      0, },
  { "like",             G_CONREV,           T_LIKE,                     0, },
  { "readonly",         G_RESERVED,         T_ATTRIBUTE,                T_READONLY, },
  { "synchronized",     G_RESERVED,         T_ATTRIBUTE,                T_SYNCHRONIZED, },
  { "type",             G_CONREV,           T_TYPE,                     0, },
  { "volatile",         G_CONREV,           T_VOLATILE,                 0, },
  { "yield",            G_CONREV,           T_YIELD,                    0, },
#endif
  { 0,                  0,                  0, },
};


static int  addCharToToken(EcToken *tp, int c);
static int  addFormattedStringToToken(EcToken *tp, char *fmt, ...);
static int  addStringToToken(EcToken *tp, char *str);
static int  decodeNumber(EcInput *input, int radix, int length);
static void initializeToken(EcToken *tp, EcStream *stream);
static int  destroyLexer(EcLexer *lp);
static int  finishToken(EcToken *tp, int tokenId, int subId, int groupMask);
static int  getNumberToken(EcInput *input, EcToken *tp, int c);
static int  getAlphaToken(EcInput *input, EcToken *tp, int c);
static int  getComment(EcInput *input, EcToken *tp, int c);
static int  getNextChar(EcStream *stream);
static int  getQuotedToken(EcInput *input, EcToken *tp, int c);
static int  makeSubToken(EcToken *tp, int c, int tokenId, int subId, int groupMask);
static int  makeToken(EcToken *tp, int c, int tokenId, int groupMask);
static void putBackChar(EcStream *stream, int c);
static void setTokenCurrentLine(EcToken *tp);



EcLexer *ecCreateLexer(EcCompiler *cp)
{
    EcLexer         *lp;
    ReservedWord    *rp;
    int             size;

    lp = mprAllocObjWithDestructorZeroed(cp, EcLexer, destroyLexer);
    if (lp == 0) {
        return 0;
    }
    lp->input = mprAllocObjZeroed(lp, EcInput);
    if (lp->input == 0) {
        mprFree(lp);
        return 0;
    }
    lp->input->lexer = lp;
    lp->input->compiler = cp;
    lp->compiler = cp;

    size = sizeof(keywords) / sizeof(ReservedWord);
    lp->keywords = mprCreateHash(lp, size);
    if (lp->keywords == 0) {
        mprFree(lp);
        return 0;
    }
    for (rp = keywords; rp->name; rp++) {
        mprAddHash(lp->keywords, rp->name, rp);
    }
    return lp;
}


static int destroyLexer(EcLexer *lp)
{
    return 0;
}


void ecDestroyLexer(EcCompiler *cp)
{
    mprFree(cp->lexer);
    cp->lexer = 0;
}


int ecGetToken(EcInput *input)
{
    EcToken     *token, *tp;
    EcStream    *stream;
    int         c;

    token = input->token;

    if ((tp = input->putBack) != 0) {
        input->putBack = tp->next;
        input->token = tp;

        /*
            Move any old token to free list
         */
        if (token) {
            token->next = input->freeTokens;
            input->freeTokens = token;
        }
        return tp->tokenId;
    }

    if (token == 0) {
        //  TBD -- need an API for this
        input->token = mprAllocObjZeroed(input, EcToken);
        if (input->token == 0) {
            //  TBD -- err code
            return -1;
        }
        input->token->lineNumber = 1;
    }

    stream = input->stream;
    tp = input->token;
    mprAssert(tp);

    initializeToken(tp, stream);

    while (1) {

        c = getNextChar(stream);

        /*
            Overloadable operators
          
            + - ~ * / % < > <= >= == << >> >>> & | === != !==
          
            TODO FUTURE, we could allow also:  ".", "[", "(" and unary !, ^
         */
        switch (c) {
        default:
            if (isdigit(c)) {
                return getNumberToken(input, tp, c);

            } else if (c == '\\') {
                c = getNextChar(stream);
                if (c == '\n') {
                    break;
                }
                putBackChar(stream, c);
                c = '\n';
            }
            if (isalpha(c) || c == '_' || c == '\\' || c == '$') {
                return getAlphaToken(input, tp, c);
            }
            return makeToken(tp, 0, T_ERR, 0);

        case -1:
            return makeToken(tp, 0, T_ERR, 0);

        case 0:
            if (stream->flags & EC_STREAM_EOL) {
                return makeToken(tp, 0, T_NOP, 0);
            } else {
                return makeToken(tp, 0, T_EOF, 0);
            }

        case ' ':
        case '\t':
            break;

        case '\r':
        case '\n':
            if (tp->textLen == 0 && tp->lineNumber != stream->lineNumber) {
                tp->currentLine = 0;
            }
            break;

        case '"':
        case '\'':
            return getQuotedToken(input, tp, c);

        case '#':
            return makeToken(tp, c, T_HASH, 0);

        case '[':
            //  EJS extension to consider this an operator
            return makeToken(tp, c, T_LBRACKET, G_OPERATOR);

        case ']':
            return makeToken(tp, c, T_RBRACKET, 0);

        case '(':
            //  EJS extension to consider this an operator
            return makeToken(tp, c, T_LPAREN, G_OPERATOR);

        case ')':
            return makeToken(tp, c, T_RPAREN, 0);

        case '{':
            return makeToken(tp, c, T_LBRACE, 0);

        case '}':
            return makeToken(tp, c, T_RBRACE, 0);

        case '@':
            return makeToken(tp, c, T_AT, 0);

        case ';':
            return makeToken(tp, c, T_SEMICOLON, 0);

        case ',':
            return makeToken(tp, c, T_COMMA, 0);

        case '?':
            return makeToken(tp, c, T_QUERY, 0);

        case '~':
            return makeToken(tp, c, T_TILDE, G_OPERATOR);

        case '+':
            c = getNextChar(stream);
            if (c == '+') {
                addCharToToken(tp, '+');
                return makeToken(tp, c, T_PLUS_PLUS, G_OPERATOR);
            } else if (c == '=') {
                addCharToToken(tp, '+');
                return makeSubToken(tp, c, T_ASSIGN, T_PLUS_ASSIGN, G_OPERATOR | G_COMPOUND_ASSIGN);
            }
            putBackChar(stream, c);
            return makeToken(tp, '+', T_PLUS, G_OPERATOR);

        case '-':
            c = getNextChar(stream);
            if (isdigit(c)) {
                putBackChar(stream, c);
                return makeToken(tp, '-', T_MINUS, G_OPERATOR);

            } else if (c == '-') {
                addCharToToken(tp, '-');
                return makeToken(tp, c, T_MINUS_MINUS, G_OPERATOR);

            } else if (c == '=') {
                addCharToToken(tp, '-');
                return makeSubToken(tp, c, T_ASSIGN, T_MINUS_ASSIGN, G_OPERATOR | G_COMPOUND_ASSIGN);
            }
            putBackChar(stream, c);
            return makeToken(tp, '-', T_MINUS, G_OPERATOR);

        case '*':
            c = getNextChar(stream);
            if (c == '=') {
                addCharToToken(tp, '*');
                return makeSubToken(tp, c, T_ASSIGN, T_MUL_ASSIGN, G_OPERATOR | G_COMPOUND_ASSIGN);
            }
            putBackChar(stream, c);
            return makeToken(tp, '*', T_MUL, G_OPERATOR);

        case '/':
            c = getNextChar(stream);
            if (c == '=') {
                addCharToToken(tp, '/');
                return makeSubToken(tp, c, T_ASSIGN, T_DIV_ASSIGN, G_OPERATOR | G_COMPOUND_ASSIGN);

            } else if (c == '>') {
                addCharToToken(tp, '/');
                return makeToken(tp, c, T_SLASH_GT, G_OPERATOR);

            } else if (c == '*' || c == '/') {
                /*
                    C and C++ comments
                 */
                if (getComment(input, tp, c) < 0) {
                    return tp->tokenId;
                }
                if (tp->text && tp->text[0] == '*') {
                    mprFree(input->doc);
                    input->doc = mprStrdup(input, (char*) tp->text);
                }
                initializeToken(tp, stream);
                break;
            }
            putBackChar(stream, c);
            return makeToken(tp, '/', T_DIV, G_OPERATOR);

        case '%':
            c = getNextChar(stream);
            if (c == '=') {
                addCharToToken(tp, '%');
                return makeSubToken(tp, c, T_ASSIGN, T_MOD_ASSIGN, G_OPERATOR | G_COMPOUND_ASSIGN);
            }
            putBackChar(stream, c);
            return makeToken(tp, '%', T_MOD, G_OPERATOR);

        case '.':
            c = getNextChar(stream);
            if (c == '.') {
                c = getNextChar(stream);
                if (c == '.') {
                    addStringToToken(tp, "..");
                    return makeToken(tp, c, T_ELIPSIS, 0);
                }
                putBackChar(stream, c);
                addCharToToken(tp, '.');
                return makeToken(tp, '.', T_DOT_DOT, 0);
#if FUTURE
            } else if (c == '<') {
                addCharToToken(tp, '.');
                return makeToken(tp, c, T_DOT_LESS, 0);
#endif
            } else if (isdigit(c)) {
                putBackChar(stream, c);
                return getNumberToken(input, tp, '.');
            }
            putBackChar(stream, c);
            //  EJS extension to consider this an operator
            return makeToken(tp, '.', T_DOT, G_OPERATOR);

        case ':':
            c = getNextChar(stream);
            if (c == ':') {
                addCharToToken(tp, ':');
                return makeToken(tp, c, T_COLON_COLON, 0);
            }
            putBackChar(stream, c);
            return makeToken(tp, ':', T_COLON, 0);

        case '!':
            c = getNextChar(stream);
            if (c == '=') {
                c = getNextChar(stream);
                if (c == '=') {
                    addStringToToken(tp, "!=");
                    return makeToken(tp, c, T_STRICT_NE, G_OPERATOR);
                }
                putBackChar(stream, c);
                addCharToToken(tp, '!');
                return makeToken(tp, '=', T_NE, G_OPERATOR);
            }
            putBackChar(stream, c);
            return makeToken(tp, '!', T_LOGICAL_NOT, G_OPERATOR);

        case '&':
            c = getNextChar(stream);
            if (c == '&') {
                addCharToToken(tp, '&');
                c = getNextChar(stream);
                if (c == '=') {
                    addCharToToken(tp, '&');
                    return makeSubToken(tp, '=', T_ASSIGN, T_LOGICAL_AND_ASSIGN, G_OPERATOR | G_COMPOUND_ASSIGN);
                }
                putBackChar(stream, c);
                return makeToken(tp, '&', T_LOGICAL_AND, G_OPERATOR);

            } else if (c == '=') {
                addCharToToken(tp, '&');
                return makeSubToken(tp, c, T_ASSIGN, T_BIT_AND_ASSIGN, G_OPERATOR | G_COMPOUND_ASSIGN);
            }
            putBackChar(stream, c);
            return makeToken(tp, '&', T_BIT_AND, G_OPERATOR);

        case '<':
            c = getNextChar(stream);
            if (c == '=') {
                addCharToToken(tp, '<');
                return makeToken(tp, c, T_LE, G_OPERATOR);
            } else if (c == '<') {
                c = getNextChar(stream);
                if (c == '=') {
                    addStringToToken(tp, "<<");
                    return makeSubToken(tp, c, T_ASSIGN, T_LSH_ASSIGN, G_OPERATOR | G_COMPOUND_ASSIGN);
                }
                putBackChar(stream, c);
                addCharToToken(tp, '<');
                return makeToken(tp, c, T_LSH, G_OPERATOR);

            } else if (c == '/') {
                addCharToToken(tp, '<');
                return makeToken(tp, c, T_LT_SLASH, 0);
            }
            putBackChar(stream, c);
            return makeToken(tp, '<', T_LT, G_OPERATOR);

        case '=':
            c = getNextChar(stream);
            if (c == '=') {
                c = getNextChar(stream);
                if (c == '=') {
                    addStringToToken(tp, "==");
                    return makeToken(tp, c, T_STRICT_EQ, G_OPERATOR);
                }
                putBackChar(stream, c);
                addCharToToken(tp, '=');
                return makeToken(tp, c, T_EQ, G_OPERATOR);
            }
            putBackChar(stream, c);
            return makeToken(tp, '=', T_ASSIGN, G_OPERATOR);

        case '>':
            c = getNextChar(stream);
            if (c == '=') {
                addCharToToken(tp, '<');
                return makeToken(tp, c, T_GE, G_OPERATOR);
            } else if (c == '>') {
                c = getNextChar(stream);
                if (c == '=') {
                    addStringToToken(tp, ">>");
                    return makeSubToken(tp, c, T_ASSIGN, T_RSH_ASSIGN, G_OPERATOR | G_COMPOUND_ASSIGN);
                } else if (c == '>') {
                    c = getNextChar(stream);
                    if (c == '=') {
                        addStringToToken(tp, ">>>");
                        return makeSubToken(tp, c, T_ASSIGN, T_RSH_ZERO_ASSIGN, G_OPERATOR | G_COMPOUND_ASSIGN);
                    }
                    putBackChar(stream, c);
                    addStringToToken(tp, ">>");
                    return makeToken(tp, '>', T_RSH_ZERO, G_OPERATOR);
                }
                putBackChar(stream, c);
                addCharToToken(tp, '>');
                return makeToken(tp, '>', T_RSH, G_OPERATOR);
            }
            putBackChar(stream, c);
            return makeToken(tp, '>', T_GT, G_OPERATOR);

        case '^':
            c = getNextChar(stream);
            if (c == '^') {
                addCharToToken(tp, '^');
                c = getNextChar(stream);
                if (c == '=') {
                    addCharToToken(tp, '^');
                    return makeSubToken(tp, '=', T_ASSIGN, T_LOGICAL_XOR_ASSIGN, G_OPERATOR | G_COMPOUND_ASSIGN);
                }
                putBackChar(stream, c);
                return makeToken(tp, '^', T_LOGICAL_XOR, G_OPERATOR);

            } else if (c == '=') {
                addCharToToken(tp, '^');
                return makeSubToken(tp, '=', T_ASSIGN, T_BIT_XOR_ASSIGN, G_OPERATOR | G_COMPOUND_ASSIGN);
            }
            putBackChar(stream, c);
            return makeToken(tp, '^', T_BIT_XOR, G_OPERATOR);

        case '|':
            c = getNextChar(stream);
            if (c == '|') {
                addCharToToken(tp, '|');
                c = getNextChar(stream);
                if (c == '=') {
                    addCharToToken(tp, '|');
                    return makeSubToken(tp, '=', T_ASSIGN, T_LOGICAL_OR_ASSIGN, G_OPERATOR | G_COMPOUND_ASSIGN);
                }
                putBackChar(stream, c);
                return makeToken(tp, '|', T_LOGICAL_OR, G_OPERATOR);

            } else if (c == '=') {
                addCharToToken(tp, '|');
                return makeSubToken(tp, '=', T_ASSIGN, T_BIT_OR_ASSIGN, G_OPERATOR | G_COMPOUND_ASSIGN);

            }
            putBackChar(stream, c);
            return makeToken(tp, '|', T_BIT_OR, G_OPERATOR);
        }
    }
}


int ecGetRegExpToken(EcInput *input)
{
    EcToken     *token, *tp;
    EcStream    *stream;
    int         c;

    stream = input->stream;
    tp = token = input->token;
    mprAssert(tp != 0);

    initializeToken(tp, stream);
    addCharToToken(tp, '/');

    while (1) {
        c = getNextChar(stream);
        switch (c) {
        case -1:
            return makeToken(tp, 0, T_ERR, 0);

        case 0:
            if (stream->flags & EC_STREAM_EOL) {
                return makeToken(tp, 0, T_NOP, 0);
            }
            return makeToken(tp, 0, T_EOF, 0);

        case '/':
            addCharToToken(tp, '/');
            while (1) {
                c = getNextChar(stream);
                if (c != 'g' && c != 'i' && c != 'm' && c != 'y' && c != 'x' && c != 'X' && c != 'U' && c != 's') {
                    putBackChar(stream, c);
                    break;
                }
                addCharToToken(tp, c);
            }
            return makeToken(tp, 0, T_REGEXP, 0);

        case '\\':
            c = getNextChar(stream);
            if (c == '\r' || c == '\n' || c == 0) {
                ecReportError(input->compiler, "warning", stream->name, stream->lineNumber, 0, stream->column,
                    "Illegal newline in regular expression");
                return makeToken(tp, 0, T_ERR, 0);
            }
            addCharToToken(tp, '\\');
            addCharToToken(tp, c);
            break;

        case '\r':
        case '\n':
            ecReportError(input->compiler, "warning", stream->name, stream->lineNumber, 0, stream->column,
                "Illegal newline in regular expression");
            return makeToken(tp, 0, T_ERR, 0);

        default:
            addCharToToken(tp, c);
        }
    }
}


/*
    Put back the current input token
 */
int ecPutToken(EcInput *input)
{
    ecPutSpecificToken(input, input->token);
    input->token = 0;

    return 0;
}


/*
    Put the given (specific) token back on the input queue. The current input
    token is unaffected.
 */
int ecPutSpecificToken(EcInput *input, EcToken *tp)
{
    mprAssert(tp);
    mprAssert(tp->tokenId > 0);

    /*
        Push token back on the input putBack queue
     */
    tp->next = input->putBack;
    input->putBack = tp;

    return 0;
}


/*
    Take the current token. Memory ownership retains with input unless the caller calls mprSteal.
 */
EcToken *ecTakeToken(EcInput *input)
{
    EcToken *token;

    token = input->token;
    input->token = 0;
    return token;
}


void ecFreeToken(EcInput *input, EcToken *token)
{
    token->next = input->freeTokens;
    input->freeTokens = token;
}


/*
    Hex:        0(x|X)[DIGITS]
    Octal:      0[DIGITS]
    Float:      [DIGITS].[DIGITS][(e|E)[+|-]DIGITS]
 */
static int getNumberToken(EcInput *input, EcToken *tp, int c)
{
    EcStream    *stream;

    stream = input->stream;
    if (c == '0') {
        c = getNextChar(stream);
        if (tolower(c) == 'x') {
            /* Hex */
            addCharToToken(tp, '0');
            do {
                addCharToToken(tp, c);
                c = getNextChar(stream);
            } while (isxdigit(c));
            putBackChar(stream, c);
            return finishToken(tp, T_NUMBER, -1, 0);

        } else if ('0' <= c && c <= '7') {
            /* Octal */
            addCharToToken(tp, '0');
            do {
                addCharToToken(tp, c);
                c = getNextChar(stream);
            } while ('0' <= c && c <= '7');
            putBackChar(stream, c);
            return finishToken(tp, T_NUMBER, -1, 0);

        } else {
            putBackChar(stream, c);
            c = '0';
        }
    }

    /*
        Float
     */
    while (isdigit(c)) {
        addCharToToken(tp, c);
        c = getNextChar(stream);
    }
    if (c == '.') {
        addCharToToken(tp, c);
        c = getNextChar(stream);
    }
    while (isdigit(c)) {
        addCharToToken(tp, c);
        c = getNextChar(stream);
    }
    if (tolower(c) == 'e') {
        addCharToToken(tp, c);
        c = getNextChar(stream);
        if (c == '+' || c == '-') {
            addCharToToken(tp, c);
            c = getNextChar(stream);
        }
        while (isdigit(c)) {
            addCharToToken(tp, c);
            c = getNextChar(stream);
        }
    }
    putBackChar(stream, c);
    return finishToken(tp, T_NUMBER, -1, 0);
}


static int getAlphaToken(EcInput *input, EcToken *tp, int c)
{
    ReservedWord    *rp;
    EcStream        *stream;

    /*
        We know that c is an alpha already
     */
    stream = input->stream;

    while (isalnum(c) || c == '_' || c == '$' || c == '\\') {
        if (c == '\\') {
            c = getNextChar(stream);
            if (c == '\n' || c == '\r') {
                break;
            } else if (c == 'u') {
                c = decodeNumber(input, 16, 4);
                //  TODO - for now, mask back to 8 bits.
                c = c & 0xff;
            }
        }
        addCharToToken(tp, c);
        c = getNextChar(stream);
    }
    if (c) {
        putBackChar(stream, c);
    }

    rp = (ReservedWord*) mprLookupHash(input->lexer->keywords, (char*) tp->text);
    if (rp) {
        return finishToken(tp, rp->tokenId, rp->subId, rp->groupMask);
    } else {
        return finishToken(tp, T_ID, -1, 0);
    }
}


static int getQuotedToken(EcInput *input, EcToken *tp, int c)
{
    EcStream    *stream;
    int         quoteType;

    stream = input->stream;
    quoteType = c;

    for (c = getNextChar(stream); c && c != quoteType; c = getNextChar(stream)) {
        if (c == 0) {
            return makeToken(tp, 0, T_ERR, 0);
        }
        if (c == '\\') {
            c = getNextChar(stream);
            switch (c) {
            //  TBD -- others
            case '\\':
                break;
            case '\'':
            case '\"':
                break;
            case 'b':
                c = '\b';
                break;
            case 'f':
                c = '\f';
                break;
            case 'n':
                c = '\n';
                break;
            case 'r':
                c = '\r';
                break;
            case 't':
                c = '\t';
                break;
            case 'u':
            case 'x':
                c = decodeNumber(input, 16, 4);
                break;
            case '0':
                c = decodeNumber(input, 8, 3);
                break;
            default:
                break;
            }
        }
        addCharToToken(tp, c);
    }
    return finishToken(tp, T_STRING, -1, 0);
}


static int decodeNumber(EcInput *input, int radix, int length)
{
    char        buf[16];
    int         i, c, lowerc;

    for (i = 0; i < length; i++) {
        c = getNextChar(input->stream);
        if (c == 0) {
            break;
        }
        if (radix <= 10) {
            if (!isdigit(c)) {
                break;
            }
        } else if (radix == 16) {
            lowerc = tolower(c);
            if (!isdigit(c) && !('a' <= c && c <= 'f')) {
                break;
            }
        }
        buf[i] = c;
    }
    if (i < length) {
        putBackChar(input->stream, c);
    }
    buf[i] = '\0';
    return (int) mprAtoi(buf, radix);
}


/*
    C, C++ and doc style comments. Return token or zero for no token.
 */
static int getComment(EcInput *input, EcToken *tp, int c)
{
    EcStream    *stream;
    int         form, startLine;

    startLine = tp->stream->lineNumber;

    stream = input->stream;
    form = c;

    for (form = c; c > 0;) {
        c = getNextChar(stream);
        if (c <= 0) {
            /*
                Unterminated Comment
             */
            addFormattedStringToToken(tp, "Unterminated comment starting on line %d", startLine);
            makeToken(tp, 0, form == '/' ? T_EOF: T_ERR, 0);
            return 1;
        }

        if (form == '/') {
            if (c == '\n') {
                break;
            }

        } else {
            if (c == '*') {
                c = getNextChar(stream);
                if (c == '/') {
                    break;
                }
                addCharToToken(tp, '*');
                putBackChar(stream, c);

            } else if (c == '/') {
                c = getNextChar(stream);
                if (c == '*') {
                    /*
                        Nested comment
                     */
                    if (input->compiler->warnLevel > 0) {
                        ecReportError(input->compiler, "warning", stream->name, stream->lineNumber, 0,
                                stream->column, "Possible nested comment");
                    }
                }
                addCharToToken(tp, '/');
            }
        }
        addCharToToken(tp, c);
    }
    return 0;
}


static int addCharToToken(EcToken *tp, int c)
{
    if (tp->currentLine == 0) {
        setTokenCurrentLine(tp);
    }
    if (tp->textLen >= (tp->textBufSize - 1)) {
        tp->text = (uchar*) mprRealloc(tp, tp->text, tp->textBufSize += EC_TOKEN_INCR);
        if (tp->text == 0) {
            return MPR_ERR_NO_MEMORY;
        }
    }
    tp->text[tp->textLen++] = c;
    mprAssert(tp->textLen < tp->textBufSize);
    tp->text[tp->textLen] = '\0';
    return 0;
}


static int addStringToToken(EcToken *tp, char *str)
{
    char    *cp;

    for (cp = str; *cp; cp++) {
        if (addCharToToken(tp, *cp) < 0) {
            return MPR_ERR_NO_MEMORY;
        }
    }
    return 0;
}


static int addFormattedStringToToken(EcToken *tp, char *fmt, ...)
{
    va_list     args;
    char        *buf;

    va_start(args, fmt);
    buf = mprVasprintf(tp, MPR_MAX_STRING, fmt, args);
    addStringToToken(tp, buf);
    mprFree(buf);
    va_end(args);

    return 0;
}


/*
    Called at the start of every token to initialize the token
 */
static void initializeToken(EcToken *tp, EcStream *stream)
{
    tp->textLen = 0;
    tp->stream = stream;

    if (tp->lineNumber != stream->lineNumber) {
        tp->currentLine = 0;
    }
}


/*
    Set the token's source debug information. 
 */
static void setTokenCurrentLine(EcToken *tp)
{
    tp->currentLine = tp->stream->currentLine;
    tp->lineNumber = tp->stream->lineNumber;
    /*
        The column is less one because we have already consumed one character.
     */
    tp->column = tp->stream->column - 1;
    tp->filename = tp->stream->name;
}


/*
    Called to complete any token
 */
static int finishToken(EcToken *tp, int tokenId, int subId, int groupMask)
{
    EcStream        *stream;
    char            *end;
    int             len;

    mprAssert(tp);
    stream = tp->stream;
    mprAssert(stream);

    tp->tokenId = tokenId;
    tp->subId = subId;
    tp->groupMask = groupMask;

    if (tp->currentLine == 0) {
        setTokenCurrentLine(tp);
    }
    if (tp->currentLine) {
        end = strchr(tp->currentLine, '\n');
        len = end ? (int) (end - tp->currentLine) : (int) strlen(tp->currentLine);

        tp->currentLine = (char*) mprMemdup(tp, tp->currentLine, len + 1);
        tp->currentLine[len] = '\0';
        mprAssert(tp->currentLine);

        mprLog(tp, 9, "Lex lineNumber %d \"%s\" %s", tp->lineNumber, tp->text, tp->currentLine);
    }
    return tokenId;
}


static int makeToken(EcToken *tp, int c, int tokenId, int groupMask)
{
    if (c && addCharToToken(tp, c) < 0) {
        return T_ERR;
    }
    return finishToken(tp, tokenId, -1, groupMask);
}


static int makeSubToken(EcToken *tp, int c, int tokenId, int subId, int groupMask)
{
    if (addCharToToken(tp, c) < 0) {
        return T_ERR;
    }
    return finishToken(tp, tokenId, subId, groupMask);
}


/*
    Get the next input char from the input stream.
 */
static int getNextChar(EcStream *stream)
{
    int         c;

    if (stream->nextChar >= stream->end && stream->gets) {
        if (stream->gets(stream) < 0) {
            return 0;
        }
    }
    if (stream->nextChar < stream->end) {
        c = (uchar) *stream->nextChar++;
        if (c == '\n') {
            stream->lineNumber++;
            stream->lastColumn = stream->column;
            stream->column = 0;
            stream->lastLine = stream->currentLine;
            stream->currentLine = stream->nextChar;
        } else {
            stream->column++;
        }
        return c;
    }
    return 0;
}


/*
    Put back a character onto the input stream.
 */
static void putBackChar(EcStream *stream, int c)
{
    if (stream->buf < stream->nextChar && c) {
        stream->nextChar--;
        mprAssert(c == (uchar) *stream->nextChar);
        if (c == '\n') {
            stream->currentLine = stream->lastLine;
            stream->column = stream->lastColumn + 1;
            stream->lineNumber--;
            mprAssert(stream->lineNumber >= 0);
        }
        stream->column--;
        mprAssert(stream->column >= 0);
    }
}


char *ecGetInputStreamName(EcLexer *lp)
{
    mprAssert(lp);
    mprAssert(lp->input);
    mprAssert(lp->input->stream);

    return lp->input->stream->name;
}


int ecOpenFileStream(EcLexer *lp, const char *path)
{
    EcFileStream    *fs;
    MprPath         info;
    int             c;

    fs = mprAllocObjZeroed(lp->input, EcFileStream);
    if (fs == 0) {
        return MPR_ERR_NO_MEMORY;
    }

    if ((fs->file = mprOpen(lp, path, O_RDONLY | O_BINARY, 0666)) == 0) {
        mprFree(fs);
        return MPR_ERR_CANT_OPEN;
    }

    if (mprGetPathInfo(fs, path, &info) < 0 || info.size < 0) {
        mprFree(fs);
        return MPR_ERR_CANT_ACCESS;
    }

    /* Sanity check */
    mprAssert(info.size < (100 * 1024 * 1024));
    mprAssert(info.size >= 0);

    fs->stream.buf = (char*) mprAlloc(fs, (int) info.size + 1);
    if (fs->stream.buf == 0) {
        mprFree(fs);
        return MPR_ERR_NO_MEMORY;
    }
    if (mprRead(fs->file, fs->stream.buf, (int) info.size) != (int) info.size) {
        mprFree(fs);
        return MPR_ERR_CANT_READ;
    }

    fs->stream.buf[info.size] = '\0';
    fs->stream.nextChar = fs->stream.buf;
    fs->stream.end = &fs->stream.buf[info.size];
    fs->stream.currentLine = fs->stream.buf;
    fs->stream.lineNumber = 1;
    fs->stream.compiler = lp->compiler;

    fs->stream.name = mprStrdup(lp, path);

    mprFree(lp->input->stream);
    lp->input->stream = (EcStream*) fs;

    lp->input->putBack = 0;
    lp->input->token = 0;
    lp->input->state = 0;
    lp->input->next = 0;

    /*
        Initialize the stream line and column data.
     */
    c = getNextChar(&fs->stream);
    putBackChar(&fs->stream, c);
    return 0;
}


int ecOpenMemoryStream(EcLexer *lp, const uchar *buf, int len)
{
    EcMemStream     *ms;
    int             c;

    ms = mprAllocObjZeroed(lp->input, EcMemStream);
    if (ms == 0) {
        return MPR_ERR_NO_MEMORY;
    }

    ms->stream.lineNumber = 0;

    ms->stream.buf = mprMemdup(ms, buf, len + 1);
    ms->stream.buf[len] = '\0';
    ms->stream.nextChar = ms->stream.buf;
    ms->stream.end = &ms->stream.buf[len];
    ms->stream.currentLine = ms->stream.buf;
    ms->stream.lineNumber = 1;
    ms->stream.compiler = lp->compiler;

    mprFree(lp->input->stream);
    lp->input->stream = (EcStream*) ms;

    lp->input->putBack = 0;
    lp->input->token = 0;
    lp->input->state = 0;
    lp->input->next = 0;

    /*
        Initialize the stream line and column data.
     */
    c = getNextChar(&ms->stream);
    putBackChar(&ms->stream, c);

    return 0;
}


int ecOpenConsoleStream(EcLexer *lp, EcStreamGet gets)
{
    EcConsoleStream     *cs;

    cs = mprAllocObjZeroed(lp->input, EcConsoleStream);
    if (cs == 0) {
        return MPR_ERR_NO_MEMORY;
    }

    cs->stream.lineNumber = 0;
    cs->stream.nextChar = 0;
    cs->stream.end = 0;
    cs->stream.currentLine = 0;
    cs->stream.gets = gets;
    cs->stream.compiler = lp->compiler;

    mprFree(lp->input->stream);
    lp->input->stream = (EcStream*) cs;

    lp->input->putBack = 0;
    lp->input->token = 0;
    lp->input->state = 0;
    lp->input->next = 0;

    return 0;
}


void ecCloseStream(EcLexer *lp)
{
    /*
        This will close file streams
     */
    mprFree(lp->input->stream);
    lp->input->stream = 0;
}


/*
    @copy   default
 
    Copyright (c) Embedthis Software LLC, 2003-2010. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2010. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    @end
 */
/************************************************************************/
/*
 *  End of file "../src/compiler/ecLex.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../src/compiler/ecModuleWrite.c"
 */
/************************************************************************/

/**
    ejsModuleWrite.c - Routines to encode and emit Ejscript byte code.

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */




static int  createBlockSection(EcCompiler *cp, EjsObj *block, int slotNum, EjsBlock *vp);
static int  createClassSection(EcCompiler *cp, EjsObj *block, int slotNum, EjsObj *vp);
static int  createDependencySection(EcCompiler *cp);
static int  createExceptionSection(EcCompiler *cp, EjsFunction *mp);
static int  createFunctionSection(EcCompiler *cp, EjsObj *block, int slotNum, EjsFunction *fun, int isSetter);
static int  createGlobalProperties(EcCompiler *cp);
static int  createGlobalType(EcCompiler *cp, EjsType *klass);
static int  createPropertySection(EcCompiler *cp, EjsObj *block, int slotNum, EjsObj *vp);
static int  createSection(EcCompiler *cp, EjsObj *block, int slotNum);
static int  reserveRoom(EcCompiler *cp, int room);
static int  sum(cchar *name, int value);
static int  swapShortField(EcCompiler *cp, int word);
static int  swapWordField(EcCompiler *cp, int word);

static int  createDocSection(EcCompiler *cp, EjsObj *block, int slotNum, EjsTrait *trait);

/*
    Write out the module file header
 */
int ecCreateModuleHeader(EcCompiler *cp)
{
    EjsModuleHdr    hdr;

    memset(&hdr, 0, sizeof(hdr));
    hdr.magic = swapShortField(cp, EJS_MODULE_MAGIC);
    hdr.fileVersion = swapWordField(cp, EJS_MODULE_VERSION);
    if (ecEncodeBlock(cp, (uchar*) &hdr, sizeof(hdr)) < 0) {
        return MPR_ERR_CANT_WRITE;
    }
    return 0;
}


/*
    Create a module section. This writes all classes, functions, variables and blocks contained by the module.
 */
int ecCreateModuleSection(EcCompiler *cp)
{
    Ejs         *ejs;
    EjsConst    *constants;
    EjsModule   *mp;
    EcState     *state;
    MprBuf      *buf;
    int         rc;

    state = cp->state;
    buf = state->code->buf;
    mp = state->currentModule;

    mprLog(cp, 5, "Create module section %s", mp->name);

    ejs = cp->ejs;
    constants = mp->constants;

    rc = 0;
    rc += ecEncodeByte(cp, EJS_SECT_MODULE);
    rc += ecEncodeString(cp, mp->name);
    rc += ecEncodeNumber(cp, mp->version);

    /*
        Remember this location for the module checksum. Reserve 4 bytes.
     */
    state->checksumOffset = mprGetBufEnd(buf) - buf->data;
    mprAdjustBufEnd(buf, 4);

    /*
        Write the constant pool and lock it against further updates.
     */
    mp->constants->locked = 1;
    rc += ecEncodeNumber(cp, constants->len);
    rc += ecEncodeBlock(cp, (uchar*) constants->pool, constants->len);

    if (createDependencySection(cp) < 0) {
        return EJS_ERR;
    }
    if (mp->hasInitializer) {
        if (createFunctionSection(cp, NULL, -1, mp->initializer, 0) < 0) {
            return EJS_ERR;
        }
    }
    if (createGlobalProperties(cp) < 0) {
        return EJS_ERR;
    }
    rc += ecEncodeByte(cp, EJS_SECT_MODULE_END);
    if (rc < 0) {
        return MPR_ERR_CANT_WRITE;
    }

    /*
        Update the checksum
     */
    mp->checksum += (sum(mp->name, 0) & EJS_ENCODE_MAX_WORD);
    ejsEncodeWord((uchar*) &buf->data[state->checksumOffset], mp->checksum);
//  print("CHECKSUM %s %d", mp->name, mp->checksum);
    return 0;
}


static int createDependencySection(EcCompiler *cp)
{
    Ejs         *ejs;
    EjsModule   *module, *mp;
    int         rc, i, count, version;

    mp = cp->state->currentModule;
    mprAssert(mp);

    ejs = cp->ejs;

    /*
        If merging, don't need references to dependent modules as they are aggregated onto the output
     */
    if (mp->dependencies && !cp->merge) {
        count = mprGetListCount(mp->dependencies);
        for (i = 0; i < count; i++) {
            module = (EjsModule*) mprGetItem(mp->dependencies, i);

            if (module->compiling && cp->outputFile) {
                continue;
            }
            if (strcmp(mp->name, module->name) == 0) {
                /* A module can't depend on itself */
                continue;
            }

            rc = 0;
            rc += ecEncodeByte(cp, EJS_SECT_DEPENDENCY);
            rc += ecEncodeString(cp, module->name);
            rc += ecEncodeNumber(cp, module->checksum);

            if (!cp->bind) {
                rc += ecEncodeNumber(cp, module->minVersion);
                rc += ecEncodeNumber(cp, module->maxVersion);
            } else {
                version = EJS_MAKE_COMPAT_VERSION(module->version);
                rc += ecEncodeNumber(cp, version);
                rc += ecEncodeNumber(cp, version);
            }
            if (rc < 0) {
                return MPR_ERR_CANT_WRITE;
            }
            mp->checksum += sum(module->name, 0);
            mprLog(cp, 5, "    dependency section for %s from module %s", module->name, mp->name);
        }
    }
    return 0;
}


/*
    Emit all global classes, functions, variables and blocks.
 */
static int createGlobalProperties(EcCompiler *cp)
{
    Ejs             *ejs;
    EjsName         *prop;
    EjsModule       *mp;
    EjsObj          *vp;
    int             next, slotNum;

    ejs = cp->ejs;
    mp = cp->state->currentModule;

    if (mp->globalProperties == 0) {
        return 0;
    }
    for (next = 0; (prop = (EjsName*) mprGetNextItem(mp->globalProperties, &next)) != 0; ) {
        slotNum = ejsLookupProperty(ejs, ejs->global, prop);
        if (slotNum < 0) {
            mprError(ejs, "Code generation error. Can't find global property %s.", prop->name);
            return EJS_ERR;
        }
        vp = ejsGetProperty(ejs, ejs->global, slotNum);
        if (vp->visited) {
            continue;
        }
        if (ejsIsType(vp)) {
            if (createGlobalType(cp, (EjsType*) vp) < 0) {
                return EJS_ERR;
            }
        } else {
            if (createSection(cp, ejs->global, slotNum) < 0) {
                return EJS_ERR;
            }
        }
    }
    for (next = 0; (prop = (EjsName*) mprGetNextItem(mp->globalProperties, &next)) != 0; ) {
        slotNum = ejsLookupProperty(ejs, ejs->global, prop);
        vp = ejsGetProperty(ejs, ejs->global, slotNum);
        vp->visited = 0;
    }
    return 0;
}


/*
    Recursively emit a class and its base classes
 */
static int createGlobalType(EcCompiler *cp, EjsType *type)
{
    Ejs             *ejs;
    EjsModule       *mp;
    EjsType         *iface;
    int             slotNum, next;

    ejs = cp->ejs;
    mp = cp->state->currentModule;

    if (type->block.obj.visited || type->module != mp) {
        return 0;
    }
    type->block.obj.visited = 1;

    if (type->baseType && !type->baseType->block.obj.visited) {
        createGlobalType(cp, type->baseType);
    }
    if (type->implements) {
        for (next = 0; (iface = mprGetNextItem(type->implements, &next)) != 0; ) {
            createGlobalType(cp, iface);
        }
    }
    slotNum = ejsLookupProperty(ejs, ejs->global, &type->qname);
    mprAssert(slotNum >= 0);

    if (createSection(cp, ejs->global, slotNum) < 0) {
        return EJS_ERR;
    }
    return 0;
}


static int createSection(EcCompiler *cp, EjsObj *block, int slotNum)
{
    Ejs         *ejs;
    EjsTrait    *trait;
    EjsName     qname;
    EjsFunction *fun;
    EjsObj      *vp;

    ejs = cp->ejs;
    vp = ejsGetProperty(ejs, (EjsObj*) block, slotNum);
    qname = ejsGetPropertyName(ejs, block, slotNum);
    trait = ejsGetPropertyTrait(ejs, block, slotNum);

    /*
        hoistBlockVar will delete hoisted properties but will not (yet) compact to reclaim the slot.
     */
    if (slotNum < 0 || trait == 0 || vp == 0 || qname.name[0] == '\0') {
        return 0;
    }
    mprAssert(qname.name);

    if (ejsIsType(vp)) {
        return createClassSection(cp, block, slotNum, vp);

    } else if (ejsIsFunction(vp)) {
        fun = (EjsFunction*) vp;
        mprAssert(fun->slotNum == slotNum);
        if (createFunctionSection(cp, block, slotNum, fun, 0) < 0) {
            return EJS_ERR;
        }
        if (trait->attributes & EJS_TRAIT_SETTER) {
            mprAssert(fun->setter);
            return createFunctionSection(cp, block, slotNum, fun->setter, 1);
        }
        return 0;

    } else if (ejsIsBlock(vp)) {
        return createBlockSection(cp, block, slotNum, (EjsBlock*) vp);
    }
    return createPropertySection(cp, block, slotNum, vp);
}


/*
    Create a type section in the module file.
 */
static int createClassSection(EcCompiler *cp, EjsObj *block, int slotNum, EjsObj *klass)
{
    Ejs             *ejs;
    EjsModule       *mp;
    EjsType         *type, *iface;
    EjsObj          *prototype;
    EjsTrait        *trait;
    EjsFunction     *fun;
    EjsName         qname, pname;
    int             next, i, rc, attributes, interfaceCount, instanceTraits, numTraits;

    ejs = cp->ejs;
    mp = cp->state->currentModule;

    trait = ejsGetPropertyTrait(ejs, ejs->global, slotNum);
    createDocSection(cp, ejs->global, slotNum, trait);
    qname = ejsGetPropertyName(ejs, ejs->global, slotNum);
    mprAssert(qname.name);

    mprLog(cp, 5, "    type section %s for module %s", qname.name, mp->name);

    type = (EjsType*) ejsGetProperty(ejs, ejs->global, slotNum);
    mprAssert(type);
    mprAssert(ejsIsType(type));

    rc = 0;
    rc += ecEncodeByte(cp, EJS_SECT_CLASS);
    rc += ecEncodeString(cp, qname.name);
    rc += ecEncodeString(cp, qname.space);

    attributes = (trait) ? trait->attributes : 0;
    attributes &= ~EJS_TYPE_FIXUP;

    if (type->hasStaticInitializer) {
        attributes |= EJS_TYPE_HAS_STATIC_INITIALIZER;
    }
    if (type->hasConstructor) {
        attributes |= EJS_TYPE_HAS_CONSTRUCTOR;
    }
    if (type->hasInitializer) {
        attributes |= EJS_TYPE_HAS_INITIALIZER;
    }
    if (type->callsSuper) {
        attributes |= EJS_TYPE_CALLS_SUPER;
    }
    if (type->implements) {
        for (next = 0; (iface = mprGetNextItem(type->implements, &next)) != 0; ) {
            if (!iface->isInterface) {
                attributes |= EJS_TYPE_FIXUP;
                break;
            }
        }
    }
    rc += ecEncodeNumber(cp, attributes);
    rc += ecEncodeNumber(cp, (cp->bind) ? slotNum: -1);

    mprAssert(type != type->baseType);
    rc += ecEncodeGlobal(cp, (EjsObj*) type->baseType, &type->baseType->qname);
    rc += ecEncodeNumber(cp, ejsGetNumTraits((EjsObj*) type));

    instanceTraits = ejsGetNumTraits((EjsObj*) type->prototype);
    rc += ecEncodeNumber(cp, instanceTraits);
    
    interfaceCount = (type->implements) ? mprGetListCount(type->implements) : 00;
    rc += ecEncodeNumber(cp, interfaceCount);

    if (type->implements) {
        for (next = 0; (iface = mprGetNextItem(type->implements, &next)) != 0; ) {
            rc += ecEncodeGlobal(cp, (EjsObj*) iface, &iface->qname);
        }
    }
    if (rc < 0) {
        return MPR_ERR_CANT_WRITE;
    }

    /*
        Loop over type traits
     */
    numTraits = ejsGetNumTraits((EjsObj*) type); 
    for (i = 0; i < numTraits; i++) {

        pname = ejsGetPropertyName(ejs, (EjsObj*) type, i);
        trait = ejsGetPropertyTrait(ejs, (EjsObj*) type, i);
        if (trait == 0) {
            continue;
        }
        if (i < type->numInherited) {
            /*
                Skip inherited and implemented functions that are not overridden. We must emit overridden functions so
                the loader will create a unique function defintion for the overridden method.
             */
            fun = (EjsFunction*) ejsGetProperty(ejs, (EjsObj*) type, i);
            if (fun == 0 || !fun->block.obj.isFunction || !fun->override) {
                continue;
            }
            if (trait->attributes & EJS_FUN_INHERITED) {
                continue;
            }
        }
        if (createSection(cp, (EjsObj*) type, i) < 0) {
            return rc;
        }
    }

    /*
        Loop over non-inherited instance properties. This skips implemented and inherited properties. They will be 
        copied by the loader when the module is loaded.
     */
    prototype = type->prototype;
    if (prototype) {
        numTraits = ejsGetNumTraits(prototype);
        for (slotNum = type->numPrototypeInherited; slotNum < numTraits; slotNum++) {
            pname = ejsGetPropertyName(ejs, prototype, slotNum);
            if (createSection(cp, prototype, slotNum) < 0) {
                return rc;
            }
        }
    }
    mp->checksum += sum(type->qname.name, slotNum + ejsGetNumTraits((EjsObj*) type) + instanceTraits + interfaceCount);

    if (ecEncodeByte(cp, EJS_SECT_CLASS_END) < 0) {
        return EJS_ERR;
    }
    return 0;
}


/*
    NOTE: static methods and methods are both stored in the typeTraits.
    The difference is in how the methods are called by the VM op codes.
 */
static int createFunctionSection(EcCompiler *cp, EjsObj *block, int slotNum, EjsFunction *fun, int isSetter)
{
    Ejs             *ejs;
    EjsModule       *mp;
    EjsTrait        *trait;
    EjsName         qname;
    EjsCode         *code;
    EjsType         *resultType;
    EjsObj          *activation;
    int             rc, i, attributes, numSlots;

    mprAssert(fun);

    rc = 0;
    mp = cp->state->currentModule;
    ejs = cp->ejs;
    activation = fun->activation;
    numSlots = (activation) ? activation->numSlots: 0;

    code = &fun->body.code;
    mprAssert(code);

    if (block && slotNum >= 0) {
        trait = ejsGetPropertyTrait(ejs, block, slotNum);
        createDocSection(cp, block, slotNum, trait);
        qname = ejsGetPropertyName(ejs, block, slotNum);
        attributes = trait->attributes;
        if (fun->isInitializer) {
            attributes |= EJS_FUN_INITIALIZER;
        }
        if (trait->attributes & (EJS_TRAIT_GETTER | EJS_TRAIT_SETTER)) {
            if (isSetter) {
                attributes &= ~EJS_TRAIT_GETTER;
            } else {
                attributes &= ~EJS_TRAIT_SETTER;
            }
            mprAssert(attributes);
        }
    } else {
        attributes = EJS_FUN_INITIALIZER;
        qname.name = EJS_INITIALIZER_NAME;
        qname.space = EJS_EJS_NAMESPACE;
    }
    rc += ecEncodeByte(cp, EJS_SECT_FUNCTION);
    rc += ecEncodeString(cp, qname.name);
    rc += ecEncodeString(cp, qname.space);

    if (fun->constructor) {
        attributes |= EJS_FUN_CONSTRUCTOR;
    }
    if (fun->rest) {
        attributes |= EJS_FUN_REST_ARGS;
    }
    if (fun->fullScope) {
        attributes |= EJS_FUN_FULL_SCOPE;
    }
    if (fun->hasReturn) {
        attributes |= EJS_FUN_HAS_RETURN;
    }
    rc += ecEncodeNumber(cp, attributes);
    rc += ecEncodeByte(cp, fun->strict);

    resultType = fun->resultType;
    rc += ecEncodeGlobal(cp, (EjsObj*) resultType, (resultType) ? &resultType->qname : 0);

    rc += ecEncodeNumber(cp, (cp->bind || (block != ejs->global)) ? slotNum: -1);
    rc += ecEncodeNumber(cp, numSlots);
    rc += ecEncodeNumber(cp, fun->numArgs);
    rc += ecEncodeNumber(cp, fun->numDefault);
    rc += ecEncodeNumber(cp, code->numHandlers);

    /*
        Output the code
     */
    rc += ecEncodeNumber(cp, code->codeLen);
    if (code->codeLen > 0) {
        rc += ecEncodeBlock(cp, code->byteCode, code->codeLen);
    }
    if (code->numHandlers > 0) {
        rc += createExceptionSection(cp, fun);
    }

    /*
        Recursively write args, locals and any nested functions and blocks.
     */
    attributes = 0;
    for (i = 0; i < numSlots; i++) {
        createSection(cp, activation, i);
    }
    if (ecEncodeByte(cp, EJS_SECT_FUNCTION_END) < 0) {
        return EJS_ERR;
    }
    if (strstr(qname.name, "--fun_")) {
        /* Don't sum the name for dynamic functions */
        mp->checksum += sum(NULL, slotNum + fun->numArgs + numSlots - fun->numArgs + code->numHandlers);
    } else {
        mp->checksum += sum(qname.name, slotNum + fun->numArgs + numSlots - fun->numArgs + code->numHandlers);
    }
    return rc;
}


/*
    NOTE: static methods and methods are both stored in the typeTraits.
    The difference is in how the methods are called by the VM op codes.
 */
static int createExceptionSection(EcCompiler *cp, EjsFunction *fun)
{
    Ejs         *ejs;
    EjsEx       *ex;
    EjsModule   *mp;
    int         rc, i;

    mprAssert(fun);

    rc = 0;
    mp = cp->state->currentModule;
    ejs = cp->ejs;

    rc += ecEncodeByte(cp, EJS_SECT_EXCEPTION);

    for (i = 0; i < fun->body.code.numHandlers; i++) {
        ex = fun->body.code.handlers[i];
        rc += ecEncodeByte(cp, ex->flags);
        rc += ecEncodeNumber(cp, ex->tryStart);
        rc += ecEncodeNumber(cp, ex->tryEnd);
        rc += ecEncodeNumber(cp, ex->handlerStart);
        rc += ecEncodeNumber(cp, ex->handlerEnd);
        rc += ecEncodeNumber(cp, ex->numBlocks);
        rc += ecEncodeNumber(cp, ex->numStack);
        rc += ecEncodeGlobal(cp, (EjsObj*) ex->catchType, ex->catchType ? &ex->catchType->qname : 0);
        // mp->checksum += sum(NULL, ex->tryStart + ex->tryEnd);
    }
    return rc;
}


static int createBlockSection(EcCompiler *cp, EjsObj *parent, int slotNum, EjsBlock *block)
{
    Ejs             *ejs;
    EjsModule       *mp;
    EjsName         qname;
    int             i, rc;

    ejs = cp->ejs;
    mp = cp->state->currentModule;

    if (ecEncodeByte(cp, EJS_SECT_BLOCK) < 0) {
        return MPR_ERR_CANT_WRITE;
    }
    qname = ejsGetPropertyName(ejs, parent, slotNum);
    if (ecEncodeString(cp, qname.name) < 0) {
        return MPR_ERR_CANT_WRITE;
    }
    rc = 0;
    rc += ecEncodeNumber(cp, (cp->bind || (block != ejs->globalBlock)) ? slotNum : -1);
    rc += ecEncodeNumber(cp, block->obj.numSlots);
    if (rc < 0) {
        return MPR_ERR_CANT_WRITE;
    }

    /*
        Now emit all the properties
     */
    for (i = 0; i < block->obj.numSlots; i++) {
        createSection(cp, (EjsObj*) block, i);
    }
    if (ecEncodeByte(cp, EJS_SECT_BLOCK_END) < 0) {
        return EJS_ERR;
    }
    // mp->checksum += sum(qname.name, block->obj.numSlots + slotNum);
    return 0;
}


static int createPropertySection(EcCompiler *cp, EjsObj *block, int slotNum, EjsObj *vp)
{
    Ejs         *ejs;
    EjsTrait    *trait;
    EjsName     qname;
    EjsModule   *mp;
    int         rc, attributes;

    ejs = cp->ejs;
    mp = cp->state->currentModule;

    trait = ejsGetPropertyTrait(ejs, block, slotNum);
    qname = ejsGetPropertyName(ejs, block, slotNum);
    
    mprAssert(qname.name[0] != '\0');
    attributes = trait->attributes;

    createDocSection(cp, block, slotNum, trait);

    mprLog(cp, 5, "    global property section %s", qname.name);

    if (trait->type) {
        if (trait->type == ejs->namespaceType || (!ejs->initialized && (strcmp(trait->type->qname.name, "Namespace") == 0))){
            attributes |= EJS_PROP_HAS_VALUE;
        }
    }
    rc = 0;
    rc += ecEncodeByte(cp, EJS_SECT_PROPERTY);
    rc += ecEncodeName(cp, &qname);

    rc += ecEncodeNumber(cp, attributes);
    rc += ecEncodeNumber(cp, (cp->bind || (block != ejs->global)) ? slotNum : -1);
    rc += ecEncodeGlobal(cp, (EjsObj*) trait->type, trait->type ? &trait->type->qname : 0);

    if (attributes & EJS_PROP_HAS_VALUE) {
        if (vp && ejsIsNamespace(vp)) {
            rc += ecEncodeString(cp, ((EjsNamespace*) vp)->name);
        } else {
            rc += ecEncodeString(cp, 0);
        }
    }
    mp->checksum += sum(qname.name, slotNum);
    return rc;
}


static int createDocSection(EcCompiler *cp, EjsObj *block, int slotNum, EjsTrait *trait)
{
    Ejs         *ejs;
    EjsName     qname;
    EjsDoc      *doc;
    char        key[32];

    ejs = cp->ejs;
    mprAssert(slotNum >= 0);
    
    if (trait == 0 || !(ejs->flags & EJS_FLAG_DOC)) {
        return 0;
    }
    if (ejs->doc == 0) {
        ejs->doc = mprCreateHash(ejs, EJS_DOC_HASH_SIZE);
    }
#if UNUSED
    if (slotNum < 0) {
        mprAssert(ejsIsBlock(block));
        slotNum = trait - block->traits->entries;
    }
#endif
    mprAssert(slotNum >= 0);
    mprSprintf(key, sizeof(key), "%Lx %d", PTOL(block), slotNum);
    doc = (EjsDoc*) mprLookupHash(ejs->doc, key);
    if (doc == 0) {
        return 0;
    }
    qname = ejsGetPropertyName(ejs, block, slotNum);
    mprAssert(qname.name);

    mprLog(cp, 5, "Create doc section for %s::%s", qname.space, qname.name);

    if (ecEncodeByte(cp, EJS_SECT_DOC) < 0) {
        return MPR_ERR_CANT_WRITE;
    }
    if (ecEncodeString(cp, doc->docString) < 0) {
        return MPR_ERR_CANT_WRITE;
    }
    return 0;
}


/*
    Add a constant to the constant pool. Grow if required and return the
    constant string offset into the pool.
 */
int ecAddConstant(EcCompiler *cp, cchar *str)
{
    int    offset;

    mprAssert(cp);

    if (str) {
        offset = ecAddModuleConstant(cp, cp->state->currentModule, str);
        if (offset < 0) {
            cp->fatalError = 1;
            mprAssert(offset > 0);
            return EJS_ERR;
        }

    } else {
        offset = 0;
    }
    return offset;
}


int ecAddNameConstant(EcCompiler *cp, EjsName *qname)
{
    if (ecAddConstant(cp, qname->name) < 0 || ecAddConstant(cp, qname->space) < 0) {
        return EJS_ERR;
    }
    return 0;
}


void ecAddFunctionConstants(EcCompiler *cp, EjsFunction *fun)
{
    if (fun->resultType) {
        ecAddNameConstant(cp, &fun->resultType->qname);
    }
    if (cp->ejs->flags & EJS_FLAG_DOC) {
        ecAddDocConstant(cp, 0, fun->owner, fun->slotNum);
    }
    ecAddBlockConstants(cp, (EjsBlock*) fun);
}


void ecAddBlockConstants(EcCompiler *cp, EjsBlock *block)
{
    Ejs         *ejs;
    EjsName     qname;
    EjsTrait    *trait;
    EjsObj      *vp;
    int         i, numTraits;

    ejs = cp->ejs;

    numTraits = ejsGetNumTraits((EjsObj*) block);
    for (i = 0; i < numTraits; i++) {
        qname = ejsGetPropertyName(ejs, (EjsObj*) block, i);
        ecAddNameConstant(cp, &qname);
        trait = ejsGetPropertyTrait(ejs, (EjsObj*) block, i);
        if (trait && trait->type) {
            ecAddNameConstant(cp, &trait->type->qname);
        }
        vp = ejsGetProperty(ejs, (EjsObj*) block, i);
        if (vp != (EjsObj*) block) {
            if (ejsIsFunction(vp)) {
                ecAddFunctionConstants(cp, (EjsFunction*) vp);
            } else if (ejsIsBlock(vp)) {
                ecAddBlockConstants(cp, (EjsBlock*) vp);
            }
        }
    }
}


/*
    Allow 2 methods to get the doc string: by trait and by block:slotNum
 */
int ecAddDocConstant(EcCompiler *cp, EjsTrait *trait, EjsObj *block, int slotNum)
{
    Ejs         *ejs;
    EjsDoc      *doc;
    char        key[32];

    ejs = cp->ejs;

    mprAssert(slotNum >= 0);

    if (trait == 0 && slotNum >= 0) {
        trait = ejsGetPropertyTrait(cp->ejs, block, slotNum);
    }
    if (trait) {
        if (ejs->doc == 0) {
            ejs->doc = mprCreateHash(ejs, EJS_DOC_HASH_SIZE);
        }
#if UNUSED
        if (slotNum < 0) {
            mprAssert(ejsIsBlock(block));
            slotNum = trait - block->traits->entries;
        }
#endif
        mprAssert(slotNum >= 0);
        mprSprintf(key, sizeof(key), "%Lx %d", PTOL(block), slotNum);
        doc = (EjsDoc*) mprLookupHash(ejs->doc, key);
        if (doc && doc->docString) {
            if (ecAddConstant(cp, doc->docString) < 0) {
                return EJS_ERR;
            }
        }
    }
    return 0;
}


/*
    Add a constant and encode the offset.
 */
int ecAddModuleConstant(EcCompiler *cp, EjsModule *mp, cchar *str)
{
    Ejs         *ejs;
    EjsConst    *constants;
    MprHash     *sp;
    int         len, oldLen, size;

    mprAssert(mp);

    if (str == 0) {
        /* Just ignore null names */
        return 0;
    }
    ejs = cp->ejs;
    mprAssert(ejs);
    constants = mp->constants;

    /*
        Maintain a symbol table for quick location
     */
    sp = mprLookupHashEntry(constants->table, str);
    if (sp != 0) {
        return PTOI(sp->data);
    }
    if (constants->locked) {
        mprError(ejs, "Constant pool for module %s is locked. Can't add \"%s\".",  mp->name, str);
#if UNUSED
        cp->fatalError = 1;
        return MPR_ERR_CANT_CREATE;
#endif
    }

    /*
        First string always starts at 1.
     */
    if (constants->len == 0) {
        constants->len = 1;
        constants->size = EC_BUFSIZE;
        constants->pool = (char*) mprAllocZeroed(constants, constants->size);
        if (constants->pool == 0) {
            cp->fatalError = 1;
            return MPR_ERR_CANT_CREATE;
        }
    }
    oldLen = constants->len;

    /*
        Add one for the null
     */
    len = (int) strlen(str) + 1;

    if ((oldLen + len) >= constants->size) {
        size = constants->size + len;
        size = (size + EC_BUFSIZE) / EC_BUFSIZE * EC_BUFSIZE;
        constants->pool = (char*) mprRealloc(constants, constants->pool, size);
        if (constants->pool == 0) {
            cp->fatalError = 1;
            return MPR_ERR_CANT_CREATE;
        }
        memset(&constants->pool[constants->size], 0, size - constants->size);
        constants->size = size;
    }
    mprStrcpy(&constants->pool[oldLen], len, str);
    constants->len += len;
    mprAddHash(constants->table, str, ITOP(oldLen));
    return oldLen;
}


/*
    Emit an encoded string ored with flags. The name index is shifted by 2.
 */
static int encodeTypeName(EcCompiler *cp, cchar *name, int flags)
{
    int        offset;

    mprAssert(name && *name);

    offset = ecAddModuleConstant(cp, cp->state->currentModule, name);
    if (offset < 0) {
        cp->fatalError = 1;
        mprAssert(offset > 0);
        return EJS_ERR;
    }
    return ecEncodeNumber(cp, offset << 2 | flags);
}


/*
    Encode a global variable (usually a type). The encoding is untyped: 0, bound type: slot number, unbound or 
    unresolved type: name.
 */
int ecEncodeGlobal(EcCompiler *cp, EjsObj *obj, EjsName *qname)
{
    Ejs         *ejs;
    int         slotNum;

    ejs = cp->ejs;
    slotNum = -1;

    if (obj == 0) {
        ecEncodeNumber(cp, EJS_ENCODE_GLOBAL_NOREF);
        return 0;
    }

    /*
        If binding globals, we can encode the slot number of the type.
     */
    if (obj->builtin || cp->bind) {
        slotNum = ejsLookupProperty(ejs, ejs->global, qname);
        if (slotNum >= 0) {
            ecEncodeNumber(cp, (slotNum << 2) | EJS_ENCODE_GLOBAL_SLOT);
            return 0;
        }
    }

    /*
        So here we encode the type name and namespace name.
     */
    encodeTypeName(cp, qname->name, EJS_ENCODE_GLOBAL_NAME);
    ecEncodeString(cp, qname->space);
    return 0;
}


/*
    Reserve a small amount of room sufficient for the next encoding
 */
static int reserveRoom(EcCompiler *cp, int room)
{
    EcCodeGen       *code;

    code = cp->state->code;
    mprAssert(code);

    if (mprGetBufSpace(code->buf) < room) {
        if (mprGrowBuf(code->buf, -1) < 0) {
            cp->fatalError = 1;
            cp->memError = 1;
            mprAssert(0);
            return MPR_ERR_NO_MEMORY;
        }
    }
    return 0;
}


/*
    Encode an Ejscript instruction operation code
 */
int ecEncodeOpcode(EcCompiler *cp, int code)
{
    mprAssert(code < 240);
    mprAssert(cp);

    cp->lastOpcode = code;
    return ecEncodeByte(cp, code);
}


/*
    Encode a <name><namespace> pair
 */
int ecEncodeName(EcCompiler *cp, EjsName *qname)
{
    int     rc;

    mprAssert(qname->name);

    rc = 0;
    rc += ecEncodeString(cp, qname->name);
    rc += ecEncodeString(cp, qname->space);
    return rc;

}


int ecEncodeString(EcCompiler *cp, cchar *str)
{
    int    offset;

    mprAssert(cp);

    if (str) {
        offset = ecAddModuleConstant(cp, cp->state->currentModule, str);
        if (offset < 0) {
            cp->error = 1;
            cp->fatalError = 1;
            return EJS_ERR;
        }
    } else {
        offset = 0;
    }
    return ecEncodeNumber(cp, offset);
}


int ecEncodeByte(EcCompiler *cp, int value)
{
    EcCodeGen   *code;
    uchar       *pc;

    mprAssert(cp);
    code = cp->state->code;

    if (reserveRoom(cp, sizeof(uchar)) < 0) {
        mprAssert(0);
        return EJS_ERR;
    }
    pc = (uchar*) mprGetBufEnd(code->buf);
    *pc++ = value;
    mprAdjustBufEnd(code->buf, sizeof(uchar));
    return 0;
}


int ecEncodeNumber(EcCompiler *cp, int64 number)
{
    MprBuf      *buf;
    int         len;

    mprAssert(cp);
    buf = cp->state->code->buf;
    if (reserveRoom(cp, sizeof(int64) + 2) < 0) {
        mprAssert(0);
        return EJS_ERR;
    }
    len = ejsEncodeNum((uchar*) mprGetBufEnd(buf), number);
    mprAdjustBufEnd(buf, len);
    return 0;
}


int ecEncodeDouble(EcCompiler *cp, double value)
{
    MprBuf      *buf;
    int         len;

    mprAssert(cp);
    buf = cp->state->code->buf;
    if (reserveRoom(cp, sizeof(double) + 4) < 0) {
        mprAssert(0);
        return EJS_ERR;
    }
    len = ejsEncodeDouble((uchar*) mprGetBufEnd(buf), value);
    mprAdjustBufEnd(buf, len);
    return 0;
}


/*
    Encode a 32-bit number. Always emit exactly 4 bytes.
 */
int ecEncodeWord(EcCompiler *cp, int number)
{
    MprBuf      *buf;
    int         len;

    mprAssert(cp);
    buf = cp->state->code->buf;

    if (reserveRoom(cp, sizeof(int) / sizeof(char)) < 0) {
        mprAssert(0);
        return EJS_ERR;
    }
    len = ejsEncodeWord((uchar*) mprGetBufEnd(buf), number);
    mprAssert(len == 4);
    mprAdjustBufEnd(buf, len);
    return 0;
}


int ecEncodeByteAtPos(EcCompiler *cp, uchar *pos, int value)
{
    return ejsEncodeByteAtPos(pos, value);
}


int ecEncodeWordAtPos(EcCompiler *cp, uchar *pos, int value)
{
    if (abs(value) > EJS_ENCODE_MAX_WORD) {
        mprError(cp, "Code generation error. Word %d exceeds maximum %d", value, EJS_ENCODE_MAX_WORD);
        return -1;
    }
    return ejsEncodeWordAtPos(pos, value);
}


int ecEncodeBlock(EcCompiler *cp, uchar *buf, int len)
{
    EcCodeGen   *code;

    code = cp->state->code;

    if (reserveRoom(cp, len) < 0) {
        mprAssert(0);
        return EJS_ERR;
    }
    if (mprPutBlockToBuf(code->buf, (char*) buf, len) != len) {
        cp->fatalError = 1;
        cp->memError = 1;
        mprAssert(0);
        return EJS_ERR;
    }
    return 0;
}


uint ecGetCodeOffset(EcCompiler *cp)
{
    EcCodeGen   *code;

    code = cp->state->code;
    return (uint) ((uchar*) mprGetBufEnd(code->buf) - (uchar*) mprGetBufStart(code->buf));
}


int ecGetCodeLen(EcCompiler *cp, uchar *mark)
{
    EcCodeGen   *code;

    code = cp->state->code;
    return (int) (((uchar*) mprGetBufEnd(code->buf)) - mark);
}


/*
    Copy the code at "pos" of length "size" the distance specified by "dist". Dist may be postitive or negative.
 */
void ecCopyCode(EcCompiler *cp, uchar *pos, int size, int dist)
{
    mprMemcpy((char*) &pos[dist], size, (char*) pos, size);
}


void ecAdjustCodeLength(EcCompiler *cp, int adj)
{
    EcCodeGen   *code;

    code = cp->state->code;
    mprAdjustBufEnd(code->buf, adj);
}


static int swapShortField(EcCompiler *cp, int word)
{
    if (mprGetEndian(cp) == MPR_LITTLE_ENDIAN) {
        return word;
    }
    word = ((word & 0xFFFF) << 16) | ((word & 0xFFFF0000) >> 16);
    return ((word & 0xFF) << 8) | ((word & 0xFF00) >> 8);
}


static int swapWordField(EcCompiler *cp, int word)
{
    if (mprGetEndian(cp) == MPR_LITTLE_ENDIAN) {
        return word;
    }
    return ((word & 0xFF000000) >> 24) | ((word & 0xFF0000) >> 8) | ((word & 0xFF00) << 8) | ((word & 0xFF) << 24);
}


/*
    Simple checksum of name and slots. Not meant to be rigorous.
 */
static int sum(cchar *name, int value)
{
    cchar    *cp;
    int     checksum;

    checksum = value;
    if (name) {
        for (cp = name; *cp; cp++) {
            checksum += *cp;
        }
    }
    return checksum;
}


/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2010. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2010. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    @end
 */
/************************************************************************/
/*
 *  End of file "../src/compiler/ecModuleWrite.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../src/compiler/ecParser.c"
 */
/************************************************************************/

/**
    ecParser. Parse ejscript source files.

    Parse source and create an internal abstract syntax tree of nodes representing the program.

    The Abstract Syntax Tree (AST) is comprised of a linked set of EcNodes. EjsNodes have a left and right pointer.
    Node with a list of children are represented by right hand links.

    Copyright (c) All Rights Reserved. See details at the end of the file.
 */




#define peekToken(cp)   peekAheadToken(cp, 1)

/*
    State level macros. Enter/Leave manage state and inheritance of state.
 */
#undef ENTER
#define ENTER(a)        if (ecEnterState(a) < 0) { return 0; } else

#undef LEAVE
#define LEAVE(cp, np)   ecLeaveStateWithResult(cp, np)


static void     addTokenToBuf(EcCompiler *cp, EcNode *np);
static void     appendDocString(EcCompiler *cp, EcNode *np, EcNode *parameter, EcNode *value);
static EcNode   *appendNode(EcNode *top, EcNode *np);
static void     applyAttributes(EcCompiler *cp, EcNode *np, EcNode *attributes, cchar *namespaceName);
static void     copyDocString(EcCompiler *cp, EcNode *np, EcNode *from);
static int      compileInner(EcCompiler *cp, int argc, char **argv, int flags);
static int      compileInput(EcCompiler *cp, EcNode **nodes, cchar *path);
static EcNode   *createAssignNode(EcCompiler *cp, EcNode *lhs, EcNode *rhs, EcNode *parent);
static EcNode   *createBinaryNode(EcCompiler *cp, EcNode *lhs, EcNode *rhs, EcNode *parent);
static EcNode   *createNameNode(EcCompiler *cp, cchar *name, cchar *space);
static EcNode   *createNamespaceNode(EcCompiler *cp, cchar *name, bool isDefault, bool isLiteral);
static EcNode   *createNode(EcCompiler *cp, int kind);
static void     dummy(int junk);
static EcNode   *expected(EcCompiler *cp, const char *str);
static int      getToken(EcCompiler *cp);
static EcNode   *insertNode(EcNode *top, EcNode *np, int pos);
static EcNode   *linkNode(EcNode *np, EcNode *node);
static const char *getExt(const char *path);
static EcNode   *parseAnnotatableDirective(EcCompiler *cp, EcNode *attributes);
static EcNode   *parseArgumentList(EcCompiler *cp);
static EcNode   *parseArguments(EcCompiler *cp);
static EcNode   *parseArrayType(EcCompiler *cp);
static EcNode   *parseAssignmentExpression(EcCompiler *cp);
static EcNode   *parseAttribute(EcCompiler *cp);
static EcNode   *parseAttributeName(EcCompiler *cp);
static EcNode   *parseBlock(EcCompiler *cp);
static EcNode   *parseBlockStatement(EcCompiler *cp);
static EcNode   *parseBrackets(EcCompiler *cp);
static EcNode   *parseBreakStatement(EcCompiler *cp);
static EcNode   *parseCaseElements(EcCompiler *cp);
static EcNode   *parseCaseLabel(EcCompiler *cp);
static EcNode   *parseCatchClause(EcCompiler *cp);
static EcNode   *parseCatchClauses(EcCompiler *cp);
static EcNode   *parseClassBody(EcCompiler *cp);
static EcNode   *parseClassDefinition(EcCompiler *cp, EcNode *attributes);
static EcNode   *parseClassInheritance(EcCompiler *cp);
static EcNode   *parseClassName(EcCompiler *cp);
static EcNode   *parseConstructorSignature(EcCompiler *cp, EcNode *np);
static EcNode   *parseConstructorInitializer(EcCompiler *cp);
static EcNode   *parseContinueStatement(EcCompiler *cp);
static EcNode   *parseDirective(EcCompiler *cp);
static EcNode   *parseDirectives(EcCompiler *cp);
static EcNode   *parseDoStatement(EcCompiler *cp);
static EcNode   *parseDirectivesPrefix(EcCompiler *cp);
static EcNode   *parseElementList(EcCompiler *cp, EcNode *newNode);
static EcNode   *parseElements(EcCompiler *cp, EcNode *newNode);
static EcNode   *parseElementTypeList(EcCompiler *cp);
static EcNode   *parseFieldList(EcCompiler *cp, EcNode *np);
static EcNode   *parseEmptyStatement(EcCompiler *cp);
static EcNode   *parseError(EcCompiler *cp, char *fmt, ...);
static EcNode   *parseExpressionStatement(EcCompiler *cp);
static EcNode   *parseFieldName(EcCompiler *cp);
static int      parseFile(EcCompiler *cp, char *path, EcNode **nodes);
static EcNode   *parseForStatement(EcCompiler *cp);
static EcNode   *parseFunctionDeclaration(EcCompiler *cp, EcNode *attributes);
static EcNode   *parseFunctionDefinition(EcCompiler *cp, EcNode *attributes);
static EcNode   *parseFunctionBody(EcCompiler *cp, EcNode *fun);
static EcNode   *parseFunctionExpression(EcCompiler *cp);
static EcNode   *parseFunctionExpressionBody(EcCompiler *cp);
static EcNode   *parseFunctionName(EcCompiler *cp);
static EcNode   *parseFunctionSignature(EcCompiler *cp, EcNode *np);
static EcNode   *parseHashStatement(EcCompiler *cp);
static EcNode   *parseIdentifier(EcCompiler *cp);
static EcNode   *parseIfStatement(EcCompiler *cp);
static EcNode   *parseInterfaceBody(EcCompiler *cp);
static EcNode   *parseInterfaceInheritance(EcCompiler *cp);
static EcNode   *parseInitializerList(EcCompiler *cp, EcNode *np);
static EcNode   *parseInitializer(EcCompiler *cp);
static EcNode   *parseParameter(EcCompiler *cp, bool rest);
static EcNode   *parseParameterInit(EcCompiler *cp, EcNode *args);
static EcNode   *parseInterfaceDefinition(EcCompiler *cp, EcNode *attributes);
static EcNode   *parseLabeledStatement(EcCompiler *cp);
static EcNode   *parseLeftHandSideExpression(EcCompiler *cp);
static EcNode   *parseLetBindingList(EcCompiler *cp);
static EcNode   *parseLetExpression(EcCompiler *cp);
static EcNode   *parseLetStatement(EcCompiler *cp);
static EcNode   *parseLiteralElement(EcCompiler *cp);
static EcNode   *parseLiteralField(EcCompiler *cp, EcNode *on);
static EcNode   *parseListExpression(EcCompiler *cp);
static EcNode   *parseNamespaceAttribute(EcCompiler *cp);
static EcNode   *parseNamespaceDefinition(EcCompiler *cp, EcNode *attributes);
static EcNode   *parseNamespaceInitialisation(EcCompiler *cp, EcNode *nameNode);
static EcNode   *parseNonemptyParameters(EcCompiler *cp, EcNode *list);
static EcNode   *parseNullableTypeExpression(EcCompiler *cp);
static EcNode   *parseOptionalExpression(EcCompiler *cp);
static EcNode   *parseOverloadedOperator(EcCompiler *cp);
static EcNode   *parseParenListExpression(EcCompiler *cp);
static EcNode   *parseParameterisedTypeName(EcCompiler *cp);
static EcNode   *parseParameterKind(EcCompiler *cp);
static EcNode   *parseParameters(EcCompiler *cp, EcNode *args);
static EcNode   *parsePath(EcCompiler *cp, EcNode *lhs);
static EcNode   *parsePattern(EcCompiler *cp);
static EcNode   *parsePragmaItems(EcCompiler *cp, EcNode *np);
static EcNode   *parsePragmaItem(EcCompiler *cp);
static EcNode   *parsePragmas(EcCompiler *cp, EcNode *np);
static EcNode   *parsePrimaryExpression(EcCompiler *cp);
static EcNode   *parsePrimaryName(EcCompiler *cp);
static EcNode   *parseProgram(EcCompiler *cp, cchar *path);
static EcNode   *parsePropertyName(EcCompiler *cp);
static EcNode   *parsePropertyOperator(EcCompiler *cp);
static EcNode   *parseQualifiedNameIdentifier(EcCompiler *cp);
static EcNode   *parseRegularExpression(EcCompiler *cp);
static EcNode   *parseRequireItem(EcCompiler *cp);
static EcNode   *parseRequireItems(EcCompiler *cp, EcNode *np);
static EcNode   *parseReservedNamespace(EcCompiler *cp);
static EcNode   *parseRestParameter(EcCompiler *cp);
static EcNode   *parseResultType(EcCompiler *cp);
static EcNode   *parseReturnStatement(EcCompiler *cp);
static EcNode   *parseSimplePattern(EcCompiler *cp);
static EcNode   *parseSimpleQualifiedName(EcCompiler *cp);
static EcNode   *parseStatement(EcCompiler *cp);
static EcNode   *parseSubstatement(EcCompiler *cp);
static EcNode   *parseSuperInitializer(EcCompiler *cp);
static EcNode   *parseSwitchStatement(EcCompiler *cp);
static EcNode   *parseThrowStatement(EcCompiler *cp);
static EcNode   *parseTryStatement(EcCompiler *cp);
static EcNode   *parseTypeDefinition(EcCompiler *cp, EcNode *attributes);
static EcNode   *parseTypeExpression(EcCompiler *cp);
static EcNode   *parseTypeIdentifierList(EcCompiler *cp);
static EcNode   *parseTypeInitialisation(EcCompiler *cp);
static EcNode   *parseModuleBody(EcCompiler *cp);
static EcNode   *parseModuleName(EcCompiler *cp);
static EcNode   *parseModuleDefinition(EcCompiler *cp);
static EcNode   *parseUsePragma(EcCompiler *cp, EcNode *np);
static EcNode   *parseVariableBinding(EcCompiler *cp, EcNode *varList, EcNode *attributes);
static EcNode   *parseVariableBindingList(EcCompiler *cp, EcNode *list, EcNode *attributes);
static EcNode   *parseVariableDefinition(EcCompiler *cp, EcNode *attributes);
static EcNode   *parseVariableDefinitionKind(EcCompiler *cp, EcNode *attributes);
static EcNode   *parseVariableInitialisation(EcCompiler *cp);
static int       parseVersion(EcCompiler *cp, int parseMax);
static EcNode   *parseWhileStatement(EcCompiler *cp);
static EcNode   *parseWithStatement(EcCompiler *cp);
struct EcNode   *parseXMLAttribute(EcCompiler *cp, EcNode *np);
struct EcNode   *parseXMLAttributes(EcCompiler *cp, EcNode *np);
struct EcNode   *parseXMLElement(EcCompiler *cp, EcNode *np);
struct EcNode   *parseXMLElementContent(EcCompiler *cp, EcNode *np);
struct EcNode   *parseXMLTagContent(EcCompiler *cp, EcNode *np);
struct EcNode   *parseXMLTagName(EcCompiler *cp, EcNode *np);
static EcNode   *parseYieldExpression(EcCompiler *cp);
static int      peekAheadToken(EcCompiler *cp, int ahead);
static EcToken  *peekAheadTokenStruct(EcCompiler *cp, int ahead);
static void     putSpecificToken(EcCompiler *cp, EcToken *token);
static void     putToken(EcCompiler *cp);
static EcNode   *removeNode(EcNode *np, EcNode *child);
static void     setNodeDoc(EcCompiler *cp, EcNode *np);
static void     setId(EcNode *np, char *name);
static EcNode   *unexpected(EcCompiler *cp);
static void     updateTokenInfo(EcCompiler *cp);

#if BLD_DEBUG
/*
    Just for debugging. Generated via tokens.ksh
 */
char *tokenNames[] = {
    "",
    "as",
    "assign",
    "at",
    "attribute",
    "bit_and",
    "bit_and_assign",
    "bit_or",
    "bit_or_assign",
    "bit_xor",
    "bit_xor_assign",
    "break",
    "call",
    "case",
    "cast",
    "catch",
    "class",
    "close_tag",
    "colon",
    "colon_colon",
    "comma",
    "const",
    "context_reserved_id",
    "continue",
    "debugger",
    "decimal",
    "decrement",
    "default",
    "delete",
    "div",
    "div_assign",
    "do",
    "dot",
    "dot_dot",
    "dot_less",
    "double",
    "dynamic",
    "each",
    "elipsis",
    "else",
    "enumerable",
    "eof",
    "eq",
    "extends",
    "false",
    "final",
    "finally",
    "float",
    "for",
    "function",
    "ge",
    "get",
    "goto",
    "gt",
    "id",
    "if",
    "implements",
    "import",                   //  UNUSED
    "in",
    "include",
    "increment",
    "instanceof",
    "int",
    "int64",
    "interface",
    "internal",
    "intrinsic",
    "is",
    "lbrace",
    "lbracket",
    "le",
    "let",
    "logical_and",
    "logical_and_assign",
    "logical_not",
    "logical_or",
    "logical_or_assign",
    "logical_xor",
    "logical_xor_assign",
    "lparen",
    "lsh",
    "lsh_assign",
    "lt",
    "minus",
    "minus_assign",
    "minus_minus",
    "mod",
    "module",
    "mod_assign",
    "mul",
    "mul_assign",
    "namespace",
    "native",
    "ne",
    "new",
    "null",
    "number",
    "open_tag",
    "override",
    "package",              //  UNUSED
    "plus",
    "plus_assign",
    "plus_plus",
    "private",
    "protected",
    "prototype",
    "public",
    "query",
    "rbrace",
    "rbracket",
    "readonly",
    "return",
    "rounding",             //  UNUSED
    "rparen",
    "rsh",
    "rsh_assign",
    "rsh_zero",
    "rsh_zero_assign",
    "semicolon",
    "set",
    "nspace",
    "standard",
    "static",
    "strict",
    "strict_eq",
    "strict_ne",
    "string",
    "super",
    "switch",
    "sync",
    "this",
    "throw",
    "tilde",
    "to",
    "true",
    "try",
    "type",
    "typeof",
    "uint",
    "use",
    "var",
    "void",
    "while",
    "with",
    "xml",                  //  UNUSED
    "yield",
    "early",
    "enum",
    "has",
    "precision",            //  UNUSED
    "undefined",
    "boolean",
    "long",
    "volatile",
    "ulong",
    "hash",
    "abstract",
    "callee",
    "generator",
    "number",
    "UNUSED-unit",          // UNUSED
    "xml_comment_start",
    "xml_comment_end",
    "cdata_start",
    "cdata_end",
    "xml_pi_start",
    "xml_pi_end",
    "lt_slash",
    "slash_gt",
    "like",
    "regexp",
    "require",
    "shared",
    "nop",
    "err",
    0,
};


/*
    Just for debugging. Generated via tokens.ksh
 */
char *nodes[] = {
    "",
    "n_value",
    "n_literal",
    "N_qname",
    "n_import",                     //  UNUSED
    "n_binary_type_op",
    "n_binary_op",
    "n_assign_op",
    "n_number_type",
    "n_unary_op",
    "n_if",
    "n_var_definition",
    "n_pragma",
    "N_namespace_definition",
    "n_function",
    "n_parameter",
    "n_class",
    "n_package",                    //  UNUSED
    "n_directives",
    "n_type",                       //  UNUSED
    "n_program",
    "n_packages",                   //  UNUSED
    "n_expressions",
    "n_pragmas",
    "n_type_identifiers",
    "n_block",
    "n_dot",
    "n_return",
    "n_call",
    "n_args",
    "n_this",
    "n_new",
    "n_for",
    "n_for_in",
    "n_postfix_op",
    "n_super",
    "n_try",
    "n_catch",
    "n_catch_clauses",
    "n_throw",
    "n_end_function",
    "n_nop",
    "n_ref",
    "n_switch",
    "n_case_label",
    "n_case_elements",
    "n_break",
    "n_continue",
    "n_goto",
    "n_use_namespace",
    "n_attributes",
    "n_do",
    "n_module",
    "n_use_module",
    "n_void",
    "n_hash",
    "n_object_literal",
    "n_field",
    "n_array_literal",
    "n_catch_arg",
    "n_with",
    0,
};

#endif  /* BLD_DEBUG */

/*
    Create a compiler instance
 */

EcCompiler *ecCreateCompiler(Ejs *ejs, int flags)
{
    EcCompiler      *cp;

    cp = mprAllocObjWithDestructorZeroed(ejs, EcCompiler, NULL);
    if (cp == 0) {
        return 0;
    }

    cp->ejs = ejs;
    cp->strict = 0;
    cp->tabWidth = EC_TAB_WIDTH;
    cp->warnLevel = 1;
    cp->shbang = 1;
    cp->optimizeLevel = 9;
    cp->warnLevel = 1;

    if (flags & EC_FLAGS_BIND) {
        cp->bind = 1;
    }
    if (flags & EC_FLAGS_DEBUG) {
        cp->debug = 1;
    }
    if (flags & EC_FLAGS_MERGE) {
        cp->merge = 1;
    }
    if (flags & EC_FLAGS_NO_OUT) {
        cp->noout = 1;
    }
#if UNUSED
    if (flags & EC_FLAGS_NO_INIT) {
        cp->noinit = 1;
    }
#endif
    if (ecResetModuleList(cp) < 0) {
        mprFree(cp);
        return 0;
    }
    cp->lexer = ecCreateLexer(cp);
    if (cp->lexer == 0) {
        mprFree(cp);
        return 0;
    }
    ecResetParser(cp);
    return cp;
}


//  MOB -- flags not used
int ecCompile(EcCompiler *cp, int argc, char **argv, int flags)
{
    Ejs     *ejs;
    int     rc, old, saveCompiling;

    ejs = cp->ejs;
    saveCompiling = ejs->compiling;
    ejs->compiling = 1;
    old = ejsEnableGC(ejs, 0);
    rc = compileInner(cp, argc, argv, flags);
    ejsEnableGC(ejs, old);
    ejs->compiling = saveCompiling;
    return rc;
}


//  MOB -- flags not used
static int compileInner(EcCompiler *cp, int argc, char **argv, int flags)
{
    Ejs         *ejs;
    EjsModule   *mp;
    EcNode      **nodes;
    EjsBlock    *block;
    cchar       *ext;
    int         i, j, next, nextModule, lflags;

    ejs = cp->ejs;
    nodes = (EcNode**) mprAllocZeroed(cp, sizeof(EcNode*) * argc);
    if (nodes == 0) {
        return EJS_ERR;
    }

    /*
        Warn about source files mentioned multiple times.
     */
    for (i = 0; i < argc; i++) {
        for (j = 0; j < argc; j++) {
            if (i == j) {
                continue;
            }
            if (mprSamePath(cp, argv[i], argv[j])) {
                parseError(cp, "Loading source %s multiple times. Ignoring extra copies.", argv[i]);
                return EJS_ERR;
            }
        }
        if (cp->outputFile && mprSamePath(cp, cp->outputFile, argv[i])) {
            parseError(cp, "Output file is the same as input file: %s", argv[i]);
            return EJS_ERR;
        }
    }

    /*
        Compile source files and load any module files
     */
    for (i = 0; i < argc && !cp->fatalError; i++) {
        ext = getExt(argv[i]);

        if (mprStrcmpAnyCase(ext, EJS_MODULE_EXT) == 0 || mprStrcmpAnyCase(ext, BLD_SHOBJ) == 0) {
            nextModule = mprGetListCount(ejs->modules);
            lflags = cp->strict ? EJS_LOADER_STRICT : 0;
            if ((ejsLoadModule(cp->ejs, argv[i], -1, -1, lflags)) < 0) {
                parseError(cp, "Can't load module file %s\n%s", argv[i], ejsGetErrorMsg(cp->ejs, 0));
                return EJS_ERR;
            }
            if (cp->merge) {
                /*
                    If merging, we must emit the loaded module into the output. So add to the compiled modules list.
                 */
                for (next = nextModule; (mp = mprGetNextItem(ejs->modules, &next)) != 0; ) {
                    if (mprLookupItem(cp->modules, mp) < 0 && mprAddItem(cp->modules, mp) < 0) {
                        parseError(cp, "Can't add module %s", mp->name);
                    }
                }
            }
            nodes[i] = 0;

        } else  {
            parseFile(cp, argv[i], &nodes[i]);
        }
    }

    /*
        Allocate the eval frame stack. This is used for property lookups. We have one dummy block at the top always.
     */
    block = ejsCreateBlock(ejs, 0);
    ejsSetDebugName(block, "Compiler");

    ejsPushBlock(ejs, block);
    
    /*
        Process the internal representation and generate code
     */
    if (!cp->parseOnly && cp->errorCount == 0) {

        ecResetParser(cp);
        if (ecAstProcess(cp, argc, nodes) < 0) {
            ejsPopBlock(ejs);
            mprFree(nodes);
            return EJS_ERR;
        }

        /*
            TODO createNode will set cp->token which causes "^" in error messages which are only
            appropriate during the parse phase. When listings are removed and done by the disassembler,
            we can call ecDestroyLexer() earlier and remove calls to ResetParser.
         */
        if (cp->errorCount == 0) {
            ecResetParser(cp);
            if (ecCodeGen(cp, argc, nodes) < 0) {
                ejsPopBlock(ejs);
                mprFree(nodes);
                return EJS_ERR;
            }
        }
    }
    ejsPopBlock(ejs);
    mprFree(nodes);
    if (cp->errorCount > 0) {
        return EJS_ERR;
    }
    /*
        Add compiled modules to the interpreter
     */
    for (next = 0; ((mp = (EjsModule*) mprGetNextItem(cp->modules, &next)) != 0); ) {
        ejsAddModule(cp->ejs, mp);
    }
    return 0;
}


/*
    Compile the input stream and parse all directives into the given nodes reference.
    path is optional.
 */
static int compileInput(EcCompiler *cp, EcNode **nodes, cchar *path)
{
    EcNode      *np;

    mprAssert(cp);
    mprAssert(nodes);

    *nodes = 0;

    if (ecEnterState(cp) < 0) {
        return EJS_ERR;
    }

    /*
        Alias for convenient access. TODO - who maintains these. Should have an API for this.
     */
    cp->input = cp->lexer->input;
    cp->token = cp->lexer->input->token;

    cp->fileState = cp->state;
    cp->fileState->strict = cp->strict;
    cp->blockState = cp->state;

    if (cp->shbang) {
        if (getToken(cp) == T_HASH && peekToken(cp) == T_LOGICAL_NOT) {
            while (cp->token->lineNumber <= 1 && cp->token->tokenId != T_EOF && cp->token->tokenId != T_NOP) {
                getToken(cp);
            }
        }
        putToken(cp);
    }

    np = parseProgram(cp, path);
    mprAssert(np || cp->error);
    np = ecLeaveStateWithResult(cp, np);
    *nodes = np;
    cp->fileState = 0;

    if (np == 0 || cp->errorCount > 0) {
        return EJS_ERR;
    }
    return 0;
}


/*
    Compile a source file and parse all directives into the given nodes reference.
    This may be called with the input stream already setup to parse a script.
 */
static int parseFile(EcCompiler *cp, char *path, EcNode **nodes)
{
    int         rc, opened;

    mprAssert(path);
    mprAssert(nodes);

    opened = 0;
    path = mprGetNormalizedPath(cp, path);

    if (cp->lexer->input->stream == 0) {
        if (ecOpenFileStream(cp->lexer, path) < 0) {
            parseError(cp, "Can't open %s", path);
            mprFree(path);
            return EJS_ERR;
        }
        opened = 1;
    }
    rc = compileInput(cp, nodes, path);
    if (opened) {
        ecCloseStream(cp->lexer);
    }
    mprFree(path);
    return rc;
}


/*
    Lookup a module of the right version
    If max is <= 0, then accept any version from min upwards.
    This allows the caller to provide -1, -1 to match all versions.
    If both are equal, then only that version is acceptable.
 */
EjsModule *ecLookupModule(EcCompiler *cp, cchar *name, int minVersion, int maxVersion)
{
    EjsModule   *mp, *best;
    int         next;

    if (maxVersion <= 0) {
        maxVersion = MAXINT;
    }
    best = 0;
    for (next = 0; (mp = (EjsModule*) mprGetNextItem(cp->modules, &next)) != 0; ) {
        if (minVersion <= mp->version && mp->version <= maxVersion) {
            if (strcmp(mp->name, name) == 0) {
                if (best == 0 || best->version < mp->version) {
                    best = mp;
                }
            }
        }
    }
    return best;
}


int ecAddModule(EcCompiler *cp, EjsModule *mp)
{
    mprAssert(cp->modules);
    return mprAddItem(cp->modules, mp);
}


int ecRemoveModule(EcCompiler *cp, EjsModule *mp)
{
    mprAssert(cp->modules);
    return mprRemoveItem(cp->modules, mp);
}


int ecResetModuleList(EcCompiler *cp)
{
    mprFree(cp->modules);
    cp->modules = mprCreateList(cp);
    if (cp->modules == 0) {
        return EJS_ERR;
    }
    return 0;
}


void ecResetParser(EcCompiler *cp)
{
    cp->token = 0;
}


/*
    XMLComment (ECMA-357)

    Input Sequences
        <!-- XMLCommentCharacters -->

    AST
 */
static EcNode *parseXMLComment(EcCompiler *cp)
{
    EcNode  *np;

    ENTER(cp);

    np = 0;
    if (getToken(cp) == T_XML_COMMENT_START) { }
    if (getToken(cp) != T_XML_COMMENT_END) {
        return expected(cp, "-->");
    }
    return LEAVE(cp, np);
}


/*
    XMLCdata (ECMA-357)

    Input Sequences
        <![CDATA[ XMLCDataCharacters ]]>

    AST
 */
static EcNode *parseXMLCdata(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    np = 0;
    if (getToken(cp) == T_CDATA_START) { }
    if (getToken(cp) != T_CDATA_END) {
        return expected(cp, "]]>");
    }
    return LEAVE(cp, np);
}


/*
    XMLPI (ECMA-357)

    Input Sequences
        <? .... ?>

    AST
 */
static EcNode *parseXMLPI(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    np = 0;
    if (getToken(cp) == T_XML_PI_START) { }
    if (getToken(cp) != T_XML_PI_END) {
        return expected(cp, "?>");
    }
    return LEAVE(cp, np);
}


/*
    XMLMarkup (ECMA-357)
        XMLComment
        XMLCDATA
        XMLPI

    Input Sequences
        <!--
        [CDATA
        <?

    AST
 */
static EcNode *parseXMLMarkup(EcCompiler *cp, EcNode *np)
{
    switch (peekToken(cp)) {
    case T_XML_COMMENT_START:
        return parseXMLComment(cp);

    case T_CDATA_START:
        return parseXMLCdata(cp);

    case T_XML_PI_START:
        return parseXMLPI(cp);

    default:
        getToken(cp);
        return LEAVE(cp, unexpected(cp));
    }
}


/*
    XMLText (ECMA-357)

    Input Sequences
        SourceCharacters but no { or <

    AST
 */
static EcNode *parseXMLText(EcCompiler *cp, EcNode *np)
{
    uchar   *p;
    int     count;

    //  TODO This is discarding text white space. Need a low level getXmlToken routine
    //  or need lexer to preserved inter-token white space somewhere.
  
    peekToken(cp);
    for (count = 0; np; count++) {
        for (p = cp->peekToken->text; p && *p; p++) {
            if (*p == '{' || *p == '<') {
                if (cp->peekToken->text < p) {
                    mprPutBlockToBuf(np->literal.data, (cchar*) cp->token->text, p - cp->token->text);
                    mprAddNullToBuf(np->literal.data);
                    if (getToken(cp) == T_EOF || cp->token->tokenId == T_ERR || cp->token->tokenId == T_NOP) {
                        return 0;
                    }
                }
                return np;
            }
        }
        if (getToken(cp) == T_EOF || cp->token->tokenId == T_ERR || cp->token->tokenId == T_NOP) {
            return 0;
        }
        if (isalnum(cp->token->text[0]) && count > 0) {
            mprPutCharToBuf(np->literal.data, ' ');
        }
        addTokenToBuf(cp, np);
        peekToken(cp);
    }
    return np;
}


/*
    XMLName (ECMA-357)
        XMLNameStart
        XMLName XMLNamePart

    Input Sequences
        UnicodeLetter
        _       underscore
        :       colon

    AST
 */
static EcNode *parseXMLName(EcCompiler *cp, EcNode *np)
{
    int         c;

    ENTER(cp);

    getToken(cp);
    if (cp->token == 0 || cp->token->text == 0) {
        return LEAVE(cp, unexpected(cp));
    }
    c = cp->token->text[0];
    if (isalpha(c) || c == '_' || c == ':') {
        addTokenToBuf(cp, np);
    } else {
        np = parseError(cp, "Not an XML Name \"%s\"", cp->token->text);
    }
    return LEAVE(cp, np);
}


/*
    XMLAttributeValue (ECMA-357)
        XMLDoubleStringCharacters
        XMLSingleStringCharacters

    Input Sequences
        "
        '
    AST
        Add data to literal.data buffer
 */
static EcNode *parseXMLAttributeValue(EcCompiler *cp, EcNode *np)
{
    //  TODO - should be preserving whether the input was ' or ""
    if (getToken(cp) != T_STRING) {
        return expected(cp, "quoted string");
    }
    mprPutCharToBuf(np->literal.data, '\"');
    addTokenToBuf(cp, np);
    mprPutCharToBuf(np->literal.data, '\"');
    return np;
}


/*
    Identifier (1)
        ID |
        ContextuallyReservedIdentifier

    Input Sequences
        ID
        ContextuallyReservedIdentifier

    AST
        N_QNAME
            name
                id
 */

static EcNode *parseIdentifier(EcCompiler *cp)
{
    EcNode      *np;
    int         tid;

    ENTER(cp);

    tid = getToken(cp);
    if (cp->token->groupMask & G_CONREV) {
        tid = T_ID;
    }

    switch (tid) {
    case T_ID:
    case T_MUL:
        np = createNode(cp, N_QNAME);
        setId(np, (char*) cp->token->text);
        break;

    default:
        np = parseError(cp, "Not an identifier \"%s\"", cp->token->text);
    }
    return LEAVE(cp, np);
}


/*
    Qualifier (3)
        *
        Identifier
        ReservedNamespace
        "StringLiteral"

    Input Sequences:
        *
        ID

    AST
        N_ATTRIBUTES
            namespace
 */

static EcNode *parseQualifier(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    switch (peekToken(cp)) {
    case T_ID:
        np = parseIdentifier(cp);
        break;

    case T_STRING:
        getToken(cp);
        np = createNode(cp, N_QNAME);
        np->qname.space = mprStrdup(np, (char*) cp->token->text);
        np->literalNamespace = 1;
        break;

    case T_MUL:
        getToken(cp);
        np = createNode(cp, N_ATTRIBUTES);
        np->qname.space = mprStrdup(np, (char*) cp->token->text);
        break;

    case T_RESERVED_NAMESPACE:
        np = parseReservedNamespace(cp);
        break;

    default:
        getToken(cp);
        np = unexpected(cp);
    }
    return LEAVE(cp, np);
}


/*
    ReservedNamespace (6)
        internal
        intrinsic
        private
        protected
        public

    Input
        internal
        intrinsic
        private
        protected
        public

    AST
        N_ATTRIBUTES
            namespace
            attributes
 */
static EcNode *parseReservedNamespace(EcCompiler *cp)
{
    EcNode      *np;
    int         attributes;

    ENTER(cp);

    if (getToken(cp) != T_RESERVED_NAMESPACE) {
        return LEAVE(cp, expected(cp, "reserved namespace"));
    }

    np = createNode(cp, N_ATTRIBUTES);

    attributes = 0;

    switch (cp->token->subId) {
    case T_INTRINSIC:
        break;

    case T_INTERNAL:
    case T_PRIVATE:
    case T_PROTECTED:
    case T_PUBLIC:
        np->specialNamespace = 1;
        break;

    default:
        return LEAVE(cp, parseError(cp, "Unknown reserved namespace %s", cp->token->text));
    }
    np->attributes = attributes;
    np->qname.space = mprStrdup(np, (char*) cp->token->text);
    return LEAVE(cp, np);
}


/*
    QualifiedNameIdentifier (11)
        Identifier
        ReservedIdentifier
        StringLiteral
        NumberLiteral
        Brackets
        OverloadedOperator

    Notes:
        Can be used to the right of a namespace qualifier. Eg. public::QualfiedNameIdentifier

    Input
        Identifier
        ReservedIdentifier
        Number
        "String"
        [
        Overloaded Operator

    AST
        N_QNAME
            name:
                namespace
                id
            left: N_EXPRESSIONS
 */
static EcNode *parseQualifiedNameIdentifier(EcCompiler *cp)
{
    EcNode      *np;
    EjsObj      *vp;
    int         tid, reservedWord;

    ENTER(cp);

    tid = peekToken(cp);
    reservedWord = (cp->peekToken->groupMask & G_RESERVED);

    if (reservedWord) {
        np = createNode(cp, N_QNAME);
        setId(np, (char*) cp->token->text);

    } else switch (tid) {
        case T_ID:
        case T_TYPE:
            np = parseIdentifier(cp);
            break;

        case T_NUMBER:
            getToken(cp);
            np = createNode(cp, N_QNAME);
            setId(np, (char*) cp->token->text);
            vp = ejsParse(cp->ejs, (char*) cp->token->text, -1);
            np->literal.var = vp;
            break;

        case T_STRING:
            getToken(cp);
            np = createNode(cp, N_QNAME);
            setId(np, (char*) cp->token->text);
            vp = (EjsObj*) ejsCreateString(cp->ejs, (char*) cp->token->text);
            np->literal.var = vp;
            break;

        case T_LBRACKET:
            np = parseBrackets(cp);
            break;

        default:
            if (cp->token->groupMask == G_OPERATOR) {
                np = parseOverloadedOperator(cp);
            } else {
                getToken(cp);
                np = unexpected(cp);
            }
            break;
    }
    return LEAVE(cp, np);
}


/*
    SimpleQualifiedName (17)
        Identifier
        Qualifier :: QualifiedNameIdentifier

    Notes:
        Optionally namespace qualified name

    Input
        Identifier
        *

    AST
        N_QNAME
            name
                id
            qualifier: N_ATTRIBUTES
 */
static EcNode *parseSimpleQualifiedName(EcCompiler *cp)
{
    EcNode      *np, *name, *qualifier;

    ENTER(cp);

    if (peekToken(cp) == T_MUL || cp->peekToken->tokenId == T_STRING) {

        if (peekAheadToken(cp, 2) == T_COLON_COLON) {
            qualifier = parseQualifier(cp);
            getToken(cp);
            np = parseQualifiedNameIdentifier(cp);
            if (np->kind == N_EXPRESSIONS) {
                name = np;
                np = createNode(cp, N_QNAME);
                np->name.nameExpr = linkNode(np, name);
                np->qname.space = mprStrdup(np, (char*) qualifier->qname.space);
            } else {
                np->qname.space = mprStrdup(np, (char*) qualifier->qname.space);
                np->literalNamespace = 1;
            }
        } else {
            np = parseIdentifier(cp);
        }

    } else {
        np = parseIdentifier(cp);
        if (peekToken(cp) == T_COLON_COLON) {
            getToken(cp);
            qualifier = np;
            np = parseQualifiedNameIdentifier(cp);
            if (np) {
                if (np->kind == N_EXPRESSIONS) {
                    name = np;
                    np = createNode(cp, N_QNAME);
                    np->name.nameExpr = linkNode(np, name);
                }
                np->name.qualifierExpr = linkNode(np, qualifier);
            }
        }
    }
    return LEAVE(cp, np);
}


/*
    ExpressionQualifiedName (15)
        ParenListExpression :: QualifiedNameIdentifier

    Input
        ( ListExpression ) :: *
        ( ListExpression ) :: Identifier
        ( ListExpression ) :: ReservedIdentifier
        ( ListExpression ) :: Number
        ( ListExpression ) :: String
        ( ListExpression ) :: [ ... ]
        ( ListExpression ) :: OverloadedOperator

    AST
        N_QNAME
            left: N_EXPRESSIONS
            qualifier: N_ATTRIBUTES
 */
static EcNode *parseExpressionQualifiedName(EcCompiler *cp)
{
    EcNode      *np, *qualifier;

    ENTER(cp);

    if (getToken(cp) != T_LPAREN) {
        return LEAVE(cp, unexpected(cp));
    }
    qualifier = parseListExpression(cp);

    if (getToken(cp) == T_COLON_COLON) {
        np = parseQualifiedNameIdentifier(cp);
        np->name.qualifierExpr = linkNode(np, qualifier);

    } else {
        np = expected(cp, "\"::\"");
    }
    return LEAVE(cp, np);
}


/*
    PropertyName (20)
        SimpleQualifiedName         |
        ExpressionQualifiedName

    Input
        Identifier
        *
        internal, intrinsic, private, protected, public
        (

    AST
        N_QNAME
            name
                namespace
                id
            left: N_EXPRESSIONS
            right: N_EXPRESSIONS
 */
static EcNode *parsePropertyName(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    if (peekToken(cp) == T_LPAREN) {
        np = parseExpressionQualifiedName(cp);
    } else {
        np = parseSimpleQualifiedName(cp);
    }
    return LEAVE(cp, np);
}


/*
    AttributeName (22)
        @ Brackets
        @ PropertyName

    Input
        @ [ ... ]
        @ PropertyName
            @ *
            @ ID
            @ Qualifier :: *
            @ Qualifier :: ID
            @ Qualifier :: ReservedIdentifier
            @ Qualifier :: Brackets
            @ ( ListExpression ) :: *
            @ ( ListExpression ) :: ID
            @ ( ListExpression ) :: ReservedIdentifier
            @ ( ListExpression ) :: [ ... ]

    AST
        N_QNAME
            name
                id
                namespace
                isAttribute
            left: N_EXPRESSIONS
 */
static EcNode *parseAttributeName(EcCompiler *cp)
{
    EcNode      *np;
    char        *attribute;

    ENTER(cp);

    if (getToken(cp) != T_AT) {
        return LEAVE(cp, expected(cp, "@ prefix"));
    }
    if (peekToken(cp) == T_LBRACKET) {
        np = createNode(cp, N_QNAME);
        np = appendNode(np, parseBrackets(cp));
    } else {
        np = parsePropertyName(cp);
    }
    if (np && np->kind == N_QNAME) {
        //  TODO - OPT. Better to allow lexer to keep @ in the id name and return T_AT with the entire attribute name.
        np->name.isAttribute = 1;
        attribute = mprStrcat(np, -1, "@", np->qname.name, NULL);
        mprFree((char*) np->qname.name);
        np->qname.name = attribute;
    }
    return LEAVE(cp, np);
}


/*
    QualifiedName (24)
        AttributeName
        PropertyName

    Input
        @ ...
        Identifier
        *
        internal, intrinsic, private, protected, public
        (

    AST
        N_QNAME
            name
                id
                namespace
                isAttribute
            left: listExpression
            right: bracketExpression
 */
static EcNode *parseQualifiedName(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    if (peekToken(cp) == T_AT) {
        np = parseAttributeName(cp);
    } else {
        np = parsePropertyName(cp);
    }
    return LEAVE(cp, np);
}


/*
    PrimaryName (26)
        Path . PropertyName
        PropertyName

    Input
        *
        internal, intrinsic, private, protected, public
        Identifier
        (

    AST
        N_QNAME
        N_DOT
 */
static EcNode *parsePrimaryName(EcCompiler *cp)
{
    EcNode      *np, *path;
    int         tid, id;

    ENTER(cp);

    np = 0;
    tid = peekToken(cp);
    if (cp->peekToken->groupMask & G_CONREV) {
        tid = T_ID;
    }

    if (tid == T_ID && peekAheadToken(cp, 2) == T_DOT) {
        EcToken     *tok;
        tok = peekAheadTokenStruct(cp, 3);
        id = tok->tokenId;
        if (tok->groupMask & G_CONREV) {
            id = T_ID;
        }
        if (id == T_ID || id == T_MUL || id == T_RESERVED_NAMESPACE || id == T_LPAREN) {
            path = parsePath(cp, 0);
            np = createNode(cp, N_DOT);
            np = appendNode(np, path);
            getToken(cp);
        }
    }

    if (np) {
        np = appendNode(np, parsePropertyName(cp));
    } else {
        np = parsePropertyName(cp);
    }

    return LEAVE(cp, np);
}


/*
    Path (28)
        Identifier |
        Path . Identifier

    Input
        ID
        ID. ... .ID

    AST
        N_QNAME
        N_DOT

    "dontConsumeLast" will be set if parsePath should not consume the last Identifier.
 */
static EcNode *parsePath(EcCompiler *cp, EcNode *lhs)
{
    EcNode      *np;
    EcToken     *tok;
    int         tid;

    ENTER(cp);

    if (lhs) {
        np = appendNode(createNode(cp, N_DOT), lhs);
        np = appendNode(np,  parseIdentifier(cp));
    } else {
        np = parseIdentifier(cp);
    }

    /*
        parsePath is called only from parsePrimaryName which requires that a ".PropertyName" be preserved.
        TODO - OPT. Perhaps hoist back into parsePrimaryName.
     */
    if (peekToken(cp) == T_DOT && peekAheadToken(cp, 2) == T_ID) {
        if (peekAheadToken(cp, 3) == T_DOT) {
            tok = peekAheadTokenStruct(cp, 4);
            tid = tok->tokenId;
            if (tok->groupMask & G_CONREV) {
                tid = T_ID;
            }
            if (tid == T_ID || tid == T_MUL || tid == T_RESERVED_NAMESPACE || tid == T_LPAREN) {
                getToken(cp);
                np = parsePath(cp, np);
            }
        }
    }

    return LEAVE(cp, np);
}


#if UNUSED
/*
    ParenExpression (30)
        ( AssignmentExpression )
        ( )                                 # EJS FIX

    Input
        (

    AST
        N_EXPR
        N_NOP
 */
static EcNode *parseParenExpression(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    if (getToken(cp) != T_LPAREN) {
        return LEAVE(cp, unexpected(cp));
    }
    if (peekToken(cp) != T_RPAREN) {
        np = parseAssignmentExpression(cp);
    } else {
        np = createNode(cp, N_NOP);
    }
    if (getToken(cp) != T_RPAREN) {
        np = expected(cp, ")");
    }
    return LEAVE(cp, np);
}
#endif


/*
    ParenListExpression (31)
        ( ListExpression )

    Input
        (

    AST
        N_EXPRESSIONS
 */
static EcNode *parseParenListExpression(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    if (getToken(cp) != T_LPAREN) {
        return LEAVE(cp, expected(cp, "("));
    }
    np = parseListExpression(cp);
    if (getToken(cp) != T_RPAREN) {
        np = expected(cp, ")");
    }
    return LEAVE(cp, np);
}


/*
    FunctionExpression (32)
        function Identifier FunctionSignature FunctionBody
        function FunctionSignature FunctionBody

    Input
        function id ( args ) { body }
        function ( args ) { body }

    AST
        N_FUNCTION
 */
static EcNode *parseFunctionExpression(EcCompiler *cp)
{
    EcState     *state;
    EcNode      *np, *funRef;

    ENTER(cp);
    state = cp->state;

    if (getToken(cp) != T_FUNCTION) {
        return LEAVE(cp, unexpected(cp));
    }
    np = createNode(cp, N_FUNCTION);

    if (peekToken(cp) == T_ID) {
        getToken(cp);
        np->qname.name = mprStrdup(np, (char*) cp->token->text);
    }
    if (np->qname.name == 0) {
        np->qname.name = mprAsprintf(np, -1, "--fun_%d-%d--", np->seqno, (int) mprGetTime(np));
    }
    np->qname.space = mprStrdup(np, state->inFunction ? EJS_PRIVATE_NAMESPACE: cp->fileState->namespace);

    np = parseFunctionSignature(cp, np);
    if (np == 0) {
        return LEAVE(cp, np);
    }
    if (STRICT_MODE(cp)) {
        if (np->function.resultType == 0) {
            return LEAVE(cp, parseError(cp,
                "Function has not defined a return type. Fuctions must be typed when declared in strict mode"));
        }
    }
    cp->state->currentFunctionNode = np;
    np->function.body = linkNode(np, parseFunctionExpressionBody(cp));
    mprStealBlock(np, np->function.body);

    if (np->function.body == 0) {
        return LEAVE(cp, 0);
    }
    /*
        The function must get linked into the top var block. It must not get processed inline at this point in the AST tree.
     */
    mprAssert(cp->state->topVarBlockNode);
    appendNode(cp->state->topVarBlockNode, np);

    /*
        Create a name node to reference the function. This is the value of this function expression.
        The funRef->name will be filled in by the AST processing for the function node.
     */
    funRef = createNode(cp, N_QNAME);
    funRef->qname = ejsCopyName(funRef, &np->qname);
    return LEAVE(cp, funRef);
}


/*
    FunctionExpressionBody (34)
        Block
        AssignmentExpression

    Input
        {
    AST
 */
static EcNode *parseFunctionExpressionBody(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    if (peekToken(cp) == T_LBRACE) {
        np = parseBlock(cp);
        if (np) {
            np = np->left;
        }

    } else {
        np = parseAssignmentExpression(cp);
    }
    if (np) {
        mprAssert(np->kind == N_DIRECTIVES);
    }

    np = appendNode(np, createNode(cp, N_END_FUNCTION));

    return LEAVE(cp, np);
}


/*
    ObjectLiteral (36)
        { FieldList }
        { FieldList } : NullableTypeExpression

    Input
        { LiteralField , ... }

    AST
        N_EXPRESSIONS
 */
static EcNode *parseObjectLiteral(EcCompiler *cp)
{
    EcNode  *typeNode, *np;

    ENTER(cp);

    np = createNode(cp, N_OBJECT_LITERAL);
    if (getToken(cp) != T_LBRACE) {
        return LEAVE(cp, unexpected(cp));
    }
    np = parseFieldList(cp, np);
    if (np == 0) {
        return LEAVE(cp, 0);
    }
    if (peekToken(cp) == T_COLON) {
        getToken(cp);
        typeNode = parseNullableTypeExpression(cp);
    } else {
        /*
            Defaults to Object type
         */
        typeNode = createNode(cp, N_QNAME);
        setId(typeNode, (char*) cp->ejs->objectType->qname.name);
    }
    np->objectLiteral.typeNode = linkNode(np, typeNode);

    if (getToken(cp) != T_RBRACE) {
        return LEAVE(cp, unexpected(cp));
    }
    return LEAVE(cp, np);
}


/*
    FieldList (41)
        EMPTY
        LiteralField
        LiteralField , LiteralField

    Input
        LiteralField , ...

    AST
 */
static EcNode *parseFieldList(EcCompiler *cp, EcNode *np)
{
    EcNode      *elt;

    ENTER(cp);

    while (peekToken(cp) != T_RBRACE) {
        elt = parseLiteralField(cp, np);
        if (elt) {
            np = appendNode(np, elt);
        }
        if (peekToken(cp) != T_COMMA) {
            break;
        }
        getToken(cp);
    }
    return LEAVE(cp, np);
}


/*
    LiteralField (42)
        FieldKind FieldName : AssignmentExpression
        get Identifier FunctionSignature FunctionBody
        set Identifier FunctionSignature FunctionBody

    Input

    AST
 */
static EcNode *parseLiteralField(EcCompiler *cp, EcNode *on)
{
    EcNode  *fp, *np, *id, *funRef, *fieldName;
    int     getterSetter;

    ENTER(cp);
    np = 0;
    getterSetter = 0;
    
    getToken(cp);
    if ((cp->token->tokenId == T_GET || cp->token->tokenId == T_SET) && peekToken(cp) != T_COLON) {
        /*
            get NAME() {}
         */
        fp = createNode(cp, N_FUNCTION);
        if (cp->token->tokenId == T_GET) {
            fp->function.getter = 1;
            fp->attributes |= EJS_TRAIT_GETTER;
        } else {
            fp->function.setter = 1;
            fp->attributes |= EJS_TRAIT_SETTER;
        }
        id = parseIdentifier(cp);
        if (id == 0) {
            return LEAVE(cp, 0);
        }
        cp->state->currentFunctionNode = fp;
        fp = parseFunctionSignature(cp, fp);
        fp->function.body = linkNode(fp, parseFunctionBody(cp, fp));
        if (fp->function.body == 0) {
            return LEAVE(cp, 0);
        }
        /*
            The function must get linked into the current var block. It must not get processed inline at
            this point in the AST tree because it must not use the block scope. Create a name based on the
            object literal seqno. This permits setters and getters to share the same name and thus when
            ejsDefineProperty is called -- they will get cross-linked.
         */
        fp->qname.name = mprAsprintf(np, -1, "--fun_%d-%d--", fp->seqno, (int) mprGetTime(fp));
        fp->qname.space = mprStrdup(fp, cp->fileState->namespace);
        mprAssert(cp->state->topVarBlockNode);
        appendNode(cp->state->topVarBlockNode, fp);

        np = createNode(cp, N_FIELD);
        np->field.fieldKind = FIELD_KIND_FUNCTION;
        np->attributes = fp->attributes;
        /*
            Must clear the getter|setter attributes so it can be loaded without invoking the accessor.
            The NEW_OBJECT opcode will call ejsDefineProperty which will restore the attributes.
         */
        fp->attributes &= ~(EJS_TRAIT_GETTER | EJS_TRAIT_SETTER);

        fieldName = createNode(cp, N_QNAME);
        fieldName->qname.name = mprStrdup(fp, id->qname.name);
        np->field.fieldName = linkNode(np, fieldName);

        funRef = createNode(cp, N_QNAME);
        funRef->qname.name = fp->qname.name;
        np->field.expr = linkNode(np, funRef);

    } else {
        if (cp->token->tokenId == T_CONST) {
            np = createNode(cp, N_FIELD);
            np->field.varKind = KIND_CONST;
            np->attributes |= EJS_TRAIT_READONLY;
        } else {
            putToken(cp);
            np = createNode(cp, N_FIELD);
        }
        np->field.fieldKind = FIELD_KIND_VALUE;
        np->field.fieldName = linkNode(np, parseFieldName(cp));
        if (getToken(cp) != T_COLON) {
            return LEAVE(cp, expected(cp, ":"));
        }
        np->field.expr = linkNode(np, parseAssignmentExpression(cp));
    }
    return LEAVE(cp, np);
}


#if ROLLED_UP
/*
    FieldKind (45)
        EMPTY
        const

    Input

    AST
 */
static EcNode *parseFieldKind(EcCompiler *cp, EcNode *np)
{
    EcNode  *np;

    ENTER(cp);

    if (peekToken(cp) == T_CONST) {
        getToken(cp);
        np->def.varKind = KIND_CONST;
    }
    return LEAVE(cp, np);
}
#endif


/*
    FieldName (47)
        PropertyName
        StringLiteral
        NumberLiteral
        ReservedIdentifier

    Input

    AST
 */
static EcNode *parseFieldName(EcCompiler *cp)
{
    EcNode  *np;

    ENTER(cp);

    switch (peekToken(cp)) {
    case T_ID:
    case T_NUMBER:
    case T_STRING:
        np = parsePrimaryExpression(cp);
        break;

    default:
        np = parsePropertyName(cp);
        break;
    }
    return LEAVE(cp, np);
}


/*
    ArrayLiteral (51)
        [ Elements ]

    ArrayLiteral (52)
        [ Elements ] : NullableTypeExpression

    Input sequence
        [

    AST
        N_EXPRESSIONS
            N_NEW
                N_QNAME
            N_EXPRESSIONS
                N_ASSIGN_OP
                    N_DOT
                        N_PARENT
                        N_LITERAL
                    ANY
 */
static EcNode *parseArrayLiteral(EcCompiler *cp)
{
    EjsType     *type;
    EcNode      *np, *typeNode, *elementsNode, *newNode, *lit;

    ENTER(cp);

    typeNode = 0;
    newNode = createNode(cp, N_NEW);

    if (getToken(cp) != T_LBRACKET) {
        np = parseError(cp, "Expecting \"[\"");

    } else {
        np = parseElements(cp, newNode);
        if (getToken(cp) != T_RBRACKET) {
            np = parseError(cp, "Expecting \"[\"");

        } else {
            if (peekToken(cp) == T_COLON) {
                typeNode = parseArrayType(cp);
                if (typeNode == 0) {
                    return LEAVE(cp, 0);
                }
            }
        }

        if (np) {
            elementsNode = np;

            if (typeNode == 0) {
                /*
                    Defaults to Array type
                 */
                type = (EjsType*) cp->ejs->arrayType;
                mprAssert(type);
                typeNode = createNode(cp, N_QNAME);
                mprAssert(typeNode);
                setId(typeNode, (char*) type->qname.name);
            }

            newNode = appendNode(newNode, typeNode);
            np = createNode(cp, N_EXPRESSIONS);
            np = appendNode(np, newNode);
            np = appendNode(np, elementsNode);
        }
    }
    lit = createNode(cp, N_ARRAY_LITERAL);
    np = appendNode(lit, np);
    return LEAVE(cp, np);
}


/*
    Elements (54)
        ElementList
        ElementComprehension

    Input sequence

    AST
        N_EXPRESSIONS
            N_ASSIGN_OP
                N_DOT
                    N_REF
                    N_LITERAL
                ANY
 */
static EcNode *parseElements(EcCompiler *cp, EcNode *newNode)
{
    EcNode      *np;

    ENTER(cp);

    np = parseElementList(cp, newNode);
#if FUTURE
    if (peekToken(cp) == T_FOR) {
        np = parseElementComprehension(cp, np);
    }
#endif
    return LEAVE(cp, np);
}


/*
    ElementList (56)
        EMPTY
        LiteralElement
        , ElementList
        LiteralElement , ElementList

    Input sequence

    AST
        N_EXPRESSIONS
            N_ASSIGN_OP
                N_DOT
                    N_REF
                    N_LITERAL
                ANY
 */
static EcNode *parseElementList(EcCompiler *cp, EcNode *newNode)
{
    EcNode      *np, *valueNode, *left;
    int         index;

    ENTER(cp);

    np = createNode(cp, N_EXPRESSIONS);
    index = 0;

    do {
        /*
            Leading comma, or dual commas means a gap in the indicies
         */
        if (peekToken(cp) == T_COMMA) {
            getToken(cp);
            index++;
            continue;

        } else if (cp->peekToken->tokenId == T_RBRACKET) {
            break;
        }

        valueNode = parseLiteralElement(cp);
        if (valueNode) {
            /*
                Update the array index
             */
            mprAssert(valueNode->kind == N_ASSIGN_OP);

            left = valueNode->left;
            mprAssert(left->kind == N_DOT);

            /*
                Set the array index
             */
            mprAssert(left->right->kind == N_LITERAL);
            left->right->literal.var = (EjsObj*) ejsCreateNumber(cp->ejs, index);

            /*
                Update the reference (array) node reference. This refers to the actual array object.
             */
            mprAssert(left->left->kind == N_REF);
            left->left->ref.node = newNode;
            np = appendNode(np, valueNode);

        } else {
            np = 0;
        }

    } while (np);

    return LEAVE(cp, np);
}


/*
    LiteralElement (60)
        AssignmentExpression -noList, allowin-

    Input sequence

    AST
        N_ASSIGN_OP
            N_DOT
                N_REF
                N_LITERAL (empty - caller must set node->var)
            ANY
 */
static EcNode *parseLiteralElement(EcCompiler *cp)
{
    EcNode      *np, *parent;

    ENTER(cp);

    np = createNode(cp, N_DOT);

    np = appendNode(np, createNode(cp, N_REF));
    np = appendNode(np, createNode(cp, N_LITERAL));

    parent = createNode(cp, N_ASSIGN_OP);
    np = createAssignNode(cp, np, parseAssignmentExpression(cp), parent);
    if (np == 0) {
        return LEAVE(cp, np);
    }

    /*
        To allow multiple literal elements, we must not consume the object on the stack.
     */
    mprAssert(np->kind == N_ASSIGN_OP);

    //  TOD - bad name. Only used by literals
    np->needDupObj = 1;
    return LEAVE(cp, np);
}


#if UNUSED
/*
    ElementComprehension (61)
        LiteralElement ForExpression OptionalIfExpression

    parseElements will parse the LiteralElement, so refactored to be:

    ElementComprehension
        ForExpression IfExpression

    Input sequence
        for

    AST
 */
static EcNode *parseElementComprehension(EcCompiler *cp, EcNode *literalElement)
{
    EcNode      *np;

    ENTER(cp);

#if FUTURE
    np = parseForExpression(cp);
    np = parseIfExpression(cp);
#endif
    return LEAVE(cp, np);
}


/*
    ForInExpressionList (62)
        ForExpression
        ForExpressionList ForExpression

    Input sequence

    AST
 */
static EcNode *parseForInExpressionList(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}


/*
    ForInExpression (64)
        for ( ForInBinding in ListExpression -allowin- )
        for each ( ForInBinding in ListExpression -allowin- )
        ForExpressionList ForExpression

    Input sequence

    AST
 */
static EcNode *parseForInExpression(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}
#endif


/*
    OptionalIfCondition (66)
        EMPTY
        if ParenListExpression

    Input
        this

    AST
 */


/*
    XMLInitializer (68)
        XMLMarkup
        XMLElement
        < > XMLElementContent </ >

    Input
        <!--
        [CDATA
        <?
        <

    AST
        Add data to literal.data buffer
 */
struct EcNode *parseXMLInitializer(EcCompiler *cp)
{
    Ejs         *ejs;
    EcNode      *np;

    ENTER(cp);
    ejs = cp->ejs;

    np = createNode(cp, N_LITERAL);
    np->literal.data = mprCreateBuf(np, 0, 0);

    if (ejs->xmlType == 0) {
        return LEAVE(cp, parseError(cp, "No XML support configured"));
    }
    np->literal.var = (EjsObj*) ejsCreate(ejs, ejs->xmlType, 0);

    switch (peekToken(cp)) {
    case T_XML_COMMENT_START:
    case T_CDATA_START:
    case T_XML_PI_START:
        return parseXMLMarkup(cp, np);

    case T_LT:
        if (peekAheadToken(cp, 2) == T_GT) {
            getToken(cp);
            getToken(cp);
            mprPutStringToBuf(np->literal.data, "<>");
            np = parseXMLElementContent(cp, np);
            if (getToken(cp) != T_LT_SLASH) {
                return LEAVE(cp, expected(cp, "</"));
            }
            if (getToken(cp) != T_GT) {
                return LEAVE(cp, expected(cp, ">"));
            }
            mprPutStringToBuf(np->literal.data, "</>");

        } else {
            return parseXMLElement(cp, np);
        }
        break;

    default:
        getToken(cp);
        return LEAVE(cp, unexpected(cp));
    }
    np = 0;
    return LEAVE(cp, np);
}


/*
    XMLElementContent (71)
        { ListExpression } XMLElementContent
        XMLMarkup XMLElementContent
        XMLText XMLElementContent
        XMLElement XMLElementContent
        EMPTY
    Input
        {
        <!--
        [CDATA
        <?
        <
        Text
    AST
 */
struct EcNode *parseXMLElementContent(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);

    if (np == 0) {
        return LEAVE(cp, np);
    }
    
    switch (peekToken(cp)) {
    case T_LBRACE:
        getToken(cp);
        np = parseListExpression(cp);
        if (getToken(cp) != T_RBRACE) {
            return LEAVE(cp, expected(cp, "}"));
        }
        np = parseXMLElementContent(cp, np);
        break;

    case T_XML_COMMENT_START:
    case T_CDATA_START:
    case T_XML_PI_START:
        np = parseXMLMarkup(cp, np);
        break;

    case T_LT:
        np = parseXMLElement(cp, np);
        np = parseXMLElementContent(cp, np);
        break;

    case T_LT_SLASH:
        break;

    case T_EOF:
    case T_ERR:
    case T_NOP:
        return LEAVE(cp, 0);

    default:
        np = parseXMLText(cp, np);
        np = parseXMLElementContent(cp, np);
    }
    return LEAVE(cp, np);
}


/*
    XMLElement (76)
        < XMLTagContent XMLWhitespace />
        < XMLTagContent XMLWhitespace > XMLElementContent </ XMLTagName XMLWhitespace >

    Input
        <

    AST
        Add data to literal.data buffer
 */
struct EcNode *parseXMLElement(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);

    if (getToken(cp) != T_LT) {
        return LEAVE(cp, expected(cp, "<"));
    }
    addTokenToBuf(cp, np);

    np = parseXMLTagContent(cp, np);
    if (np == 0) {
        return LEAVE(cp, np);
    }

    if (getToken(cp) == T_SLASH_GT) {
        addTokenToBuf(cp, np);
        return LEAVE(cp, np);

    } else if (cp->token->tokenId != T_GT) {
        return LEAVE(cp, unexpected(cp));
    }

    addTokenToBuf(cp, np);

    np = parseXMLElementContent(cp, np);
    if (getToken(cp) != T_LT_SLASH) {
        return LEAVE(cp, expected(cp, "</"));
    }
    addTokenToBuf(cp, np);

    np = parseXMLTagName(cp, np);
    if (getToken(cp) != T_GT) {
        return LEAVE(cp, expected(cp, ">"));
    }
    addTokenToBuf(cp, np);
    return LEAVE(cp, np);
}


/*
    XMLTagContent (79)
        XMLTagName XMLAttributes

    Input
        {
        UnicodeLetter
        _       underscore
        :       colon

    AST
        Add data to literal.data buffer
 */
struct EcNode *parseXMLTagContent(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);

    np = parseXMLTagName(cp, np);
    if (np) {
        np = parseXMLAttributes(cp, np);
    }
    return LEAVE(cp, np);
}


/*
    XMLTagName (80)
        { ListExpression }
        XMLName

    Input
        {
        UnicodeLetter
        _       underscore
        :       colon

    AST
        Add data to literal.data buffer
 */
struct EcNode *parseXMLTagName(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);

    if (np == 0) {
        return LEAVE(cp, np);
    }
    if (peekToken(cp) == T_LBRACE) {
        getToken(cp);
        np = parseListExpression(cp);
        if (getToken(cp) != T_RBRACE) {
            return LEAVE(cp, expected(cp, "}"));
        }
    } else {
        np = parseXMLName(cp, np);
    }
    return LEAVE(cp, np);
}


/*
    XMLAttributes (82)
        XMLWhitespace { ListExpression }
        XMLAttribute XMLAttributes
        EMPTY
    Input

    AST
        Add data to literal.data buffer
 */
struct EcNode *parseXMLAttributes(EcCompiler *cp, EcNode *np)
{
    int         tid;

    ENTER(cp);

    tid = peekToken(cp);
    if (tid == T_LBRACE) {
        parseListExpression(cp);
        if (peekToken(cp) == T_RBRACE) {
            return LEAVE(cp, expected(cp, "}"));
        }

    } else while (tid == T_COLON || tid == T_ID) {
        np = parseXMLAttribute(cp, np);
        tid = peekToken(cp);
    }
    return LEAVE(cp, np);
}


/*
    XMLAttributes (85)
        XMLWhitespace XMLName XMLWhitespace = XMLWhitepace { ListExpression (allowIn) }
        XMLWhitespace XMLName XMLWhitespace = XMLAttributeValue

    Input
        UnicodeLetter
        _       underscore
        :       colon

    AST
        Add data to literal.data buffer
 */
struct EcNode *parseXMLAttribute(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);

    mprPutCharToBuf(np->literal.data, ' ');
    np = parseXMLName(cp, np);

    if (getToken(cp) != T_ASSIGN) {
        return LEAVE(cp, expected(cp, "="));
    }
    mprPutCharToBuf(np->literal.data, '=');

    if (peekToken(cp) == T_LBRACE) {
        np = parseListExpression(cp);
        if (getToken(cp) != T_RBRACE) {
            return LEAVE(cp, expected(cp, "}"));
        }
    } else {
        np = parseXMLAttributeValue(cp, np);
    }
    return LEAVE(cp, np);
}


/*
    ThisExpression (87)
        this
        this callee
        this generator
        this function
    Input
        this

    AST
 */
static EcNode *parseThisExpression(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    if (getToken(cp) != T_THIS) {
        return LEAVE(cp, unexpected(cp));
    }

    np = createNode(cp, N_THIS);

    switch (peekToken(cp)) {
    case T_TYPE:
        getToken(cp);
        np->thisNode.thisKind = N_THIS_TYPE;
        break;

    case T_FUNCTION:
        getToken(cp);
        np->thisNode.thisKind = N_THIS_FUNCTION;
        break;

    case T_CALLEE:
        getToken(cp);
        np->thisNode.thisKind = N_THIS_CALLEE;
        break;

    case T_GENERATOR:
        getToken(cp);
        np->thisNode.thisKind = N_THIS_GENERATOR;
        break;
    }
    return LEAVE(cp, np);
}


/*
    PrimaryExpression (90)
        null
        true
        false
        NumberLiteral
        StringLiteral
        RegularExpression
        ThisExpression
        XMLInitializer
        ParenListExpression
        ArrayLiteral
        ObjectLiteral
        FunctionExpression
        AttributeName
        PrimaryName

    Input sequence
        null
        true
        false
        this
        function
        Identifier
        ContextuallyReservedIdentifier
        {
        [
        (
        @
        NumberLiteral
        StringLiteral
        RegularExpression
        XMLInitializer: <!--, [CDATA, <?, <

    AST
        N_FUNCTION
        N_NEW           (array / object literals)
        N_LITERAL
        N_QNAME
        N_THIS
 */
static EcNode *parsePrimaryExpression(EcCompiler *cp)
{
    EcNode      *np;
    EjsObj      *vp;
    Ejs         *ejs;
    int         tid;

    ENTER(cp);

    ejs = cp->ejs;
    tid = peekToken(cp);
    if (cp->peekToken->groupMask & G_CONREV) {
        tid = T_ID;
    }

    np = 0;
    switch (tid) {
    case T_STRING:
        if (peekAheadToken(cp, 2) == T_COLON_COLON) {
            np = parsePrimaryName(cp);
        } else {
            getToken(cp);
            vp = (EjsObj*) ejsCreateString(cp->ejs, (char*) cp->token->text);
            np = createNode(cp, N_LITERAL);
            np->literal.var = vp;
        }
        break;

    case T_ID:
        np = parsePrimaryName(cp);
        break;

    case T_AT:
        np = appendNode(np, parseAttributeName(cp));
        break;

    case T_NUMBER:
        getToken(cp);
        vp = ejsParse(cp->ejs, (char*) cp->token->text, -1);
        np = createNode(cp, N_LITERAL);
        np->literal.var = vp;
        break;

    case T_NULL:
        getToken(cp);
        if (!ejs->initialized) {
            np = createNode(cp, N_QNAME);
            setId(np, (char*) cp->token->text);
        } else {
            np = createNode(cp, N_LITERAL);
            np->literal.var = cp->ejs->nullValue;
        }
        break;

    case T_UNDEFINED:
        getToken(cp);
        if (!ejs->initialized) {
            np = createNode(cp, N_QNAME);
            setId(np, (char*) cp->token->text);
        } else {
            np = createNode(cp, N_LITERAL);
            np->literal.var = cp->ejs->undefinedValue;
        }
        break;

    case T_TRUE:
        getToken(cp);
        if (!ejs->initialized) {
            np = createNode(cp, N_QNAME);
            setId(np, (char*) cp->token->text);
        } else {
            np = createNode(cp, N_LITERAL);
            vp = (EjsObj*) ejsCreateBoolean(cp->ejs, 1);
            np->literal.var = vp;
        }
        break;

    case T_FALSE:
        getToken(cp);
        if (!ejs->initialized) {
            np = createNode(cp, N_QNAME);
            setId(np, (char*) cp->token->text);
        } else {
            np = createNode(cp, N_LITERAL);
            vp = (EjsObj*) ejsCreateBoolean(cp->ejs, 0);
            np->literal.var = vp;
        }
        break;

    case T_THIS:
        np = parseThisExpression(cp);
        break;

    case T_LPAREN:
        np = parseParenListExpression(cp);
        break;

    case T_LBRACKET:
        np = parseArrayLiteral(cp);
        break;

    case T_LBRACE:
        np = parseObjectLiteral(cp);
        break;

    case T_FUNCTION:
        np = parseFunctionExpression(cp);
        break;

    case T_VOID:
    case T_NAMESPACE:
    case T_TYPEOF:
        getToken(cp);
        if (!ejs->initialized) {
            np = createNode(cp, N_QNAME);
            setId(np, (char*) cp->token->text);
        } else {
            np = unexpected(cp);
        }
        break;

    case T_LT:
    case T_XML_COMMENT_START:
    case T_CDATA_START:
    case T_XML_PI_START:
        np = parseXMLInitializer(cp);
        break;

    case T_DIV:
        np = parseRegularExpression(cp);
        break;

    case T_ERR:
    default:
        getToken(cp);
        np = unexpected(cp);
        break;
    }
    return LEAVE(cp, np);
}


static EcNode *parseRegularExpression(EcCompiler *cp)
{
    EcNode      *np;
    EjsObj      *vp;
    int         id;

    ENTER(cp);

    /*
        Flush peek ahead buffer
     */
    while (cp->input->putBack) {
        getToken(cp);
    }

    id = ecGetRegExpToken(cp->input);
    updateTokenInfo(cp);
    cp->peekToken = 0;
#if BLD_DEBUG
    cp->peekTokenName = 0;
#endif

    if (id != T_REGEXP) {
        return LEAVE(cp, parseError(cp, "Can't parse regular expression"));
    }
    vp = (EjsObj*) ejsCreateRegExp(cp->ejs, (char*) cp->token->text);
    if (vp == 0) {
        return LEAVE(cp, parseError(cp, "Can't compile regular expression"));
    }
    np = createNode(cp, N_LITERAL);
    np->literal.var = vp;
    return LEAVE(cp, np);
}


/*
    SuperExpression (104)
        super
        super ParenExpression

    Input
        super

    AST
        N_SUPER

    NOTES:
        Using Arguments instead of ParenExpression so we can have multiple args.
 */
static EcNode *parseSuperExpression(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    if (getToken(cp) != T_SUPER) {
        np = unexpected(cp);

    } else {
        if (peekToken(cp) == T_LPAREN) {
            np = createNode(cp, N_SUPER);
            np = appendNode(np, parseArguments(cp));
        } else {
            np = createNode(cp, N_SUPER);
        }
    }
    return LEAVE(cp, np);
}


/*
    Arguments (106)
        ( )
        ( ArgumentList )

    Input
        (

    AST
        N_ARGS
 */
static EcNode *parseArguments(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    if (getToken(cp) != T_LPAREN) {
        np = parseError(cp, "Expecting \"(\"");

    } else if (peekToken(cp) == T_RPAREN) {
        getToken(cp);
        np = createNode(cp, N_ARGS);

    } else {
        np = parseArgumentList(cp);
        if (np && getToken(cp) != T_RPAREN) {
            np = parseError(cp, "Expecting \")\"");
        }
    }
    return LEAVE(cp, np);
}


/*
    ArgumentList (118)
        AssignmentExpression
        ArgumentList , AssignmentExpression

    Input

    AST N_ARGS
        children: arguments
 */
static EcNode *parseArgumentList(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    np = createNode(cp, N_ARGS);
    np = appendNode(np, parseAssignmentExpression(cp));

    while (np && peekToken(cp) == T_COMMA) {
        getToken(cp);
        np = appendNode(np, parseAssignmentExpression(cp));
    }
    return LEAVE(cp, np);
}


/*
    PropertyOperator (110)
        . ReservedIdentifier
        . PropertyName
        . AttributeName
        .. QualifiedName
        . ParenListExpression
        . ParenListExpression :: QualifiedNameIdentifier
        Brackets
        TypeApplication

    Input
        .
        ..
        [

    AST
        N_DOT
 */
static EcNode *parsePropertyOperator(EcCompiler *cp)
{
    EcNode      *np, *name;
    char        *id;

    ENTER(cp);

    switch (peekToken(cp)) {
    case T_DOT:
        np = createNode(cp, N_DOT);
        getToken(cp);
        switch (peekToken(cp)) {
        case T_LPAREN:
            np = appendNode(np, parseParenListExpression(cp));
            break;

        /* TODO - should handle all contextually reserved identifiers here */
        case T_TYPE:
        case T_ID:
        case T_STRING:
        case T_REQUIRE:
        case T_RESERVED_NAMESPACE:
            if (cp->token->groupMask & G_RESERVED) {
                np = appendNode(np, parseIdentifier(cp));
            } else {
                np = appendNode(np, parsePropertyName(cp));
            }
            break;

        case T_AT:
            np = appendNode(np, parseAttributeName(cp));
            break;

        case T_SUPER:
            getToken(cp);
            np = appendNode(np, createNode(cp, N_SUPER));
            break;

        default:
            getToken(cp);
            np = unexpected(cp);
            break;
        }
        break;

    case T_LBRACKET:
        np = createNode(cp, N_DOT);
        np = appendNode(np, parseBrackets(cp));
        break;

    case T_DOT_DOT:
        getToken(cp);
        np = createNode(cp, N_DOT);
        name = parseQualifiedName(cp);
        if (name && name->kind == N_QNAME) {
            id = mprStrcat(name, -1, ".", name->qname.name, NULL);
            mprFree((char*) name->qname.name);
            name->qname.name = id;
        }
        np = appendNode(np, name);
        break;

    default:
        getToken(cp);
        np = parseError(cp, "Expecting property operator . .. or [");
        break;
    }
    return LEAVE(cp, np);
}


/*
    Brackets (125)
        [ ListExpression ]
        [ SliceExpression ]

    Input
        [

    AST
        N_EXPRESSIONS
 */
static EcNode *parseBrackets(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    //  TODO - not yet implementing SliceExpression
    if (getToken(cp) != T_LBRACKET) {
        np = parseError(cp, "Expecting \"[\"");
    }

    if (peekToken(cp) == T_COLON) {
        /*
            Slice expression
         */
        /* First optional expression in a slice expression is empty */
        np = parseOptionalExpression(cp);
        if (getToken(cp) != T_COLON) {
            np = parseError(cp, "Expecting \":\"");
        }
        np = appendNode(np, parseOptionalExpression(cp));

    } else {

        np = parseListExpression(cp);

        if (peekToken(cp) == T_COLON) {
            /*
                Slice expression
             */
            np = appendNode(np, parseOptionalExpression(cp));
            if (peekToken(cp) != T_COLON) {
                getToken(cp);
                np = parseError(cp, "Expecting \":\"");
            }
            np = appendNode(np, parseOptionalExpression(cp));
        }
    }

    if (getToken(cp) != T_RBRACKET) {
        np = parseError(cp, "Expecting \"[\"");
    }
    return LEAVE(cp, np);
}


/*
    TypeApplication (120)
        .< TypeExpressionList >

    Input
        .<

    AST
 */
#if FUTURE
/*
    SliceExpression (121)
        OptionalExpression : OptionalExpression
        OptionalExpression : OptionalExpression : OptionalExpression

    Input

    AST
 */
static EcNode *parseSliceExpression(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}
#endif


/*
    OptionalExpression (123)
        ListExpression -allowin-
        EMPTY

    Input

    AST
 */
static EcNode *parseOptionalExpression(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = parseListExpression(cp);
    return LEAVE(cp, np);
}


/*
    MemberExpression (125) -a,b-
        PrimaryExpression -a,b-
        new MemberExpression Arguments
        SuperExpression PropertyOperator
        MemberExpression PropertyOperator

    Input
        null
        true
        false
        this
        function
        Identifier
        {
        [
        (
        @
        NumberLiteral
        StringLiteral
        RegularExpression
        XMLInitializer: <!--, [CDATA, <?, <
        super
        new

    AST
        N_FUNCTION
        N_DOT
            left: N_QNAME | N_DOT | N_EXPRESSIONS | N_FUNCTION
            right: N_QNAME | N_EXPRESSIONS | N_FUNCTION
        N_LITERAL
        N_NEW           (array / object literals)
        N_QNAME
        N_SUPER
        N_THIS
 */
static EcNode *parseMemberExpression(EcCompiler *cp)
{
    EcNode      *np, *newNode;

    ENTER(cp);

    switch (peekToken(cp)) {
    case T_SUPER:
        np = parseSuperExpression(cp);
        if (peekToken(cp) == T_DOT || cp->peekToken->tokenId == T_DOT_DOT ||
                cp->peekToken->tokenId == T_LBRACKET) {
            np = insertNode(parsePropertyOperator(cp), np, 0);
        }
        break;

    case T_NEW:
        getToken(cp);
        newNode = createNode(cp, N_NEW);
        newNode = appendNode(newNode, parseMemberExpression(cp));
        np = createNode(cp, N_NEW);
        np = appendNode(np, newNode);
        np = appendNode(np, parseArguments(cp));
        break;

    default:
        np = parsePrimaryExpression(cp);
        break;
    }

    while (np && (peekToken(cp) == T_DOT || cp->peekToken->tokenId == T_DOT_DOT ||
            cp->peekToken->tokenId == T_LBRACKET)) {
#if OLD && UNUSED
        if (np->lineNumber == cp->peekToken->lineNumber) {
            np = insertNode(parsePropertyOperator(cp), np, 0);
        } else {
            break;
        }
#else
        np = insertNode(parsePropertyOperator(cp), np, 0);
#endif
    }
    return LEAVE(cp, np);
}


/*
    CallExpression (129) -a,b-
        MemberExpression Arguments
        CallExpression Arguments
        CallExpression PropertyOperator

    Input

    AST
        N_CALL

    "me" is to to an already parsed member expression
 */
static EcNode *parseCallExpression(EcCompiler *cp, EcNode *me)
{
    EcNode      *np;

    ENTER(cp);

    np = 0;

    while (1) {
        peekToken(cp);
        if (me && me->lineNumber != cp->peekToken->lineNumber) {
            return LEAVE(cp, np);
        }
        switch (peekToken(cp)) {
        case T_LPAREN:
            np = createNode(cp, N_CALL);
            np = appendNode(np, me);
            np = appendNode(np, parseArguments(cp));
            if (np && cp->token) {
                np->lineNumber = cp->token->lineNumber;
            }
            break;

        case T_DOT:
        case T_DOT_DOT:
        case T_LBRACKET:
            if (me == 0) {
                getToken(cp);
                return LEAVE(cp, unexpected(cp));
            }
            np = insertNode(parsePropertyOperator(cp), me, 0);
            if (np && cp->token) {
                np->lineNumber = cp->token->lineNumber;
            }
            break;

        default:
            if (np == 0) {
                getToken(cp);
                return LEAVE(cp, unexpected(cp));
            }
            return LEAVE(cp, np);
        }
        if (np == 0) {
            return LEAVE(cp, np);
        }
        me = np;
    }
    return LEAVE(cp, np);
}


/*
    NewExpression (132)
        MemberExpression
        new NewExpression

    Input
        null
        true
        false
        this
        function
        Identifier
        {
        [
        (
        @
        NumberLiteral
        StringLiteral
        RegularExpression
        XMLInitializer: <!--, [CDATA, <?, <
        super
        new

    AST
        N_FUNCTION
        N_DOT
            left: N_QNAME | N_DOT | N_EXPRESSIONS | N_FUNCTION
            right: N_QNAME | N_EXPRESSIONS | N_FUNCTION
        N_LITERAL
        N_NEW           (array / object literals)
        N_QNAME
        N_SUPER
        N_THIS
 */
static EcNode *parseNewExpression(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    if (peekToken(cp) == T_NEW) {
        getToken(cp);
        np = createNode(cp, N_NEW);
        np = appendNode(np, parseNewExpression(cp));

    } else {
        np = parseMemberExpression(cp);
    }
    return LEAVE(cp, np);
}


/*
    LeftHandSideExpression (134) -a,b-
        NewExpression
        CallExpression

    Where NewExpression is:
        MemberExpression
        new NewExpression

    Where CallExpression is:
        MemberExpression Arguments
        CallExpression Arguments
        CallExpression PropertyOperator

    Where MemberExpression is:
        PrimaryExpression -a,b-
        new MemberExpression Arguments
        SuperExpression PropertyOperator
        MemberExpression PropertyOperator

    So look ahead problem on MemberExpression. We don't know if it is a newExpression or a CallExpression. This requires
    large lookahead. So, refactored to be:

    LeftHandSideExpression (136) -a,b-
        new MemberExpression LeftHandSidePrime
        MemberExpression LeftHandSidePrime

    and where LeftHandSidePrime is:
        Arguments LeftHandSidePrime
        PropertyOperator LeftHandSidePrime
        EMPTY

    Input
        null
        true
        false
        this
        function
        Identifier
        {
        [
        (
        @
        NumberLiteral
        StringLiteral
        RegularExpression
        XMLInitializer: <!--, [CDATA, <?, <
        super
        new

    Also:
        new MemberExpression
        MemberExpression
        MemberExpression (
        MemberExpression .
        MemberExpression ..
        MemberExpression [

    AST
        N_CALL
        N_FUNCTION
        N_DOT
            left: N_QNAME | N_DOT | N_EXPRESSIONS | N_FUNCTION
            right: N_QNAME | N_EXPRESSIONS | N_FUNCTION
        N_LITERAL
        N_NEW           (array / object literals)
        N_QNAME
        N_SUPER
        N_THIS
 */
static EcNode *parseLeftHandSideExpression(EcCompiler *cp)
{
    EcNode      *np, *callNode;

    ENTER(cp);

    if (peekToken(cp) == T_NEW) {
        np = parseNewExpression(cp);

    } else {
        np = parseMemberExpression(cp);
    }

    if (np) {
        /*
            Refactored CallExpression processing
         */
        switch (peekToken(cp)) {
        case T_LPAREN:
        case T_DOT:
        case T_DOT_DOT:
        case T_LBRACKET:
            /* CHANGE: was np->lineNumber */
            if (cp->token->lineNumber == cp->peekToken->lineNumber) {
                /*
                    May have multiline function expression: x = (function ..... multiple lines)() 
                 */
                np->lineNumber = cp->token->lineNumber;
                np = parseCallExpression(cp, np);
            }
            break;

        default:
            if (np->kind == N_NEW) {
                /*
                    Create a dummy call to the constructor
                 */
                callNode = createNode(cp, N_CALL);
                np = appendNode(callNode, np);
                np = appendNode(np, createNode(cp, N_ARGS));
            }
            break;
        }
    }
    return LEAVE(cp, np);
}


#if UNUSED
/*
    LeftHandSidePrime (psudo) -a,b-
        Arguments LeftHandSidePrime
        PropertyOperator LeftHandSidePrime
        EMPTY

    Input
        (
        .
        ..
        null
        true
        false
        this
        function
        Identifier
        {
        [
        (
        @
        NumberLiteral
        StringLiteral
        RegularExpression
        XMLInitializer: <!--, [CDATA, <?, <
        super
        new

    AST
        N_CALL
        N_FUNCTION
        N_DOT
            left: N_QNAME | N_DOT | N_EXPRESSIONS | N_FUNCTION
            right: N_QNAME | N_EXPRESSIONS | N_FUNCTION
        N_LITERAL
        N_NEW           (array / object literals)
        N_QNAME
        N_SUPER
        N_THIS
 */
static EcNode *parseLeftHandSidePrime(EcCompiler *cp, EcNode *np)
{
    EcNode      *callNode;

    ENTER(cp);

    do {
        switch (peekToken(cp)) {
        case T_LPAREN:
#if UNUSED
            callNode = createNode(cp, N_CALL);
            np = appendNode(callNode, np);
            np = appendNode(np, parseArguments(cp));
#endif
            break;

        case T_DOT:
        case T_DOT_DOT:
        case T_LBRACKET:
            np = appendNode(np, parsePropertyOperator(cp));
            break;

        default:
            return LEAVE(cp, np);
        }

    } while (np);

    return LEAVE(cp, np);
}
#endif


/*
    UnaryTypeExpression (136)
        LeftHandSideExpression
        type NullableTypeExpression

    Input
        type

    AST
 */
static EcNode *parseUnaryTypeExpression(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    if (peekToken(cp) == T_TYPE) {
        getToken(cp);
        np = parseNullableTypeExpression(cp);
    } else {
        np = parseLeftHandSideExpression(cp);
    }
    return LEAVE(cp, np);
}


/*
    PostfixExpression (138)
        UnaryTypeExpression
        LeftHandSideExpression [no line break] ++
        LeftHandSideExpression [no line break] --

    Input

    AST
 */
static EcNode *parsePostfixExpression(EcCompiler *cp)
{
    EcNode      *parent, *np;

    ENTER(cp);

    if (peekToken(cp) == T_TYPE) {
        np = parseUnaryTypeExpression(cp);
    } else {
        np = parseLeftHandSideExpression(cp);
        if (np) {
            if (peekToken(cp) == T_PLUS_PLUS || cp->peekToken->tokenId == T_MINUS_MINUS) {
                getToken(cp);
                parent = createNode(cp, N_POSTFIX_OP);
                np = appendNode(parent, np);
            }
        }
    }
    return LEAVE(cp, np);
}


/*
    UnaryExpression (141)
        PostfixExpression
        delete PostfixExpression
        void UnaryExpression
        typeof UnaryExpression
        ++ PostfixExpression
        -- PostfixExpression
        + UnaryExpression
        - UnaryExpression
        ~ UnaryExpression           (bitwise not)
        ! UnaryExpression

    Input

    AST
 */
static EcNode *parseUnaryExpression(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    switch (peekToken(cp)) {
    case T_DELETE:
    case T_LOGICAL_NOT:
    case T_PLUS:
    case T_PLUS_PLUS:
    case T_MINUS:
    case T_MINUS_MINUS:
    case T_TILDE:
    case T_TYPEOF:
    case T_VOID:
        getToken(cp);
        np = createNode(cp, N_UNARY_OP);
        np = appendNode(np, parsePostfixExpression(cp));
        break;

    default:
        np = parsePostfixExpression(cp);
    }
    return LEAVE(cp, np);
}


/*
    MultiplicativeExpression (152) -a,b-
        UnaryExpression
        MultiplicativeExpression * UnaryExpression
        MultiplicativeExpression / UnaryExpression
        MultiplicativeExpression % UnaryExpression

    Input

    AST
 */
static EcNode *parseMultiplicativeExpression(EcCompiler *cp)
{
    EcNode      *np, *parent;

    ENTER(cp);
    np = parseUnaryExpression(cp);
    while (np) {
        switch (peekToken(cp)) {
        case T_MUL:
        case T_DIV:
        case T_MOD:
            getToken(cp);
            parent = createNode(cp, N_BINARY_OP);
            np = createBinaryNode(cp, np, parseUnaryExpression(cp), parent);
            break;

        default:
            return LEAVE(cp, np);
        }
    }
    mprAssert(cp > 0);
    return LEAVE(cp, np);
}


/*
    AdditiveExpression (156)
        MultiplicativeExpression
        AdditiveExpression + MultiplicativeExpression
        AdditiveExpression - MultiplicativeExpression

    Input

    AST
 */
static EcNode *parseAdditiveExpression(EcCompiler *cp)
{
    EcNode      *np, *parent;
    
    ENTER(cp);

    np = parseMultiplicativeExpression(cp);

    while (np) {
        switch (peekToken(cp)) {
        case T_PLUS:
        case T_MINUS:
            getToken(cp);
            parent = createNode(cp, N_BINARY_OP);
            np = createBinaryNode(cp, np, parseMultiplicativeExpression(cp), parent);
            break;

        default:
            return LEAVE(cp, np);
        }
    }
    return LEAVE(cp, np);
}


/*
    ShiftExpression (159) -a,b-
        AdditiveExpression
        ShiftExpression << AdditiveExpression
        ShiftExpression >> AdditiveExpression
        ShiftExpression >>> AdditiveExpression

    Input

    AST
 */
static EcNode *parseShiftExpression(EcCompiler *cp)
{
    EcNode      *np, *parent;

    ENTER(cp);

    np = parseAdditiveExpression(cp);

    while (np) {
        switch (peekToken(cp)) {
        case T_LSH:
        case T_RSH:
        case T_RSH_ZERO:
            getToken(cp);
            parent = createNode(cp, N_BINARY_OP);
            np = createBinaryNode(cp, np, parseAdditiveExpression(cp), parent);
            break;

        default:
            return LEAVE(cp, np);
        }
    }
    return LEAVE(cp, np);
}


/*
    RelationalExpression (163) -allowin-
        ShiftExpression
        RelationalExpression < ShiftExpression
        RelationalExpression > ShiftExpression
        RelationalExpression <= ShiftExpression
        RelationalExpression >= ShiftExpression
        RelationalExpression [in] ShiftExpression
        RelationalExpression instanceOf ShiftExpression
        RelationalExpression cast ShiftExpression
        RelationalExpression to ShiftExpression
        RelationalExpression is ShiftExpression
        RelationalExpression like ShiftExpression

    Input

    AST
 */
static EcNode *parseRelationalExpression(EcCompiler *cp)
{
    EcNode      *np, *parent;

    ENTER(cp);

    np = parseShiftExpression(cp);

    while (np) {
        switch (peekToken(cp)) {
        case T_IN:
            if (cp->state->noin) {
                return LEAVE(cp, np);
            }
            /* Fall through */

        case T_LT:
        case T_LE:
        case T_GT:
        case T_GE:
        case T_INSTANCEOF:
        case T_IS:
        case T_LIKE:
        case T_CAST:
            getToken(cp);
            parent = createNode(cp, N_BINARY_OP);
            np = createBinaryNode(cp, np, parseShiftExpression(cp), parent);
            break;

        default:
            return LEAVE(cp, np);
        }
    }
    return LEAVE(cp, np);
}


/*
    EqualityExpression (182)
        RelationalExpression
        EqualityExpression == RelationalExpression
        EqualityExpression != RelationalExpression
        EqualityExpression === RelationalExpression
        EqualityExpression !== RelationalExpression

    Input

    AST
 */
static EcNode *parseEqualityExpression(EcCompiler *cp)
{
    EcNode      *np, *parent;

    ENTER(cp);

    np = parseRelationalExpression(cp);

    while (np) {
        switch (peekToken(cp)) {
        case T_EQ:
        case T_NE:
        case T_STRICT_EQ:
        case T_STRICT_NE:
            getToken(cp);
            parent = createNode(cp, N_BINARY_OP);
            np = createBinaryNode(cp, np, parseRelationalExpression(cp), parent);
            break;

        default:
            return LEAVE(cp, np);
        }
    }
    return LEAVE(cp, np);
}


/*
    BitwiseAndExpression (187)
        EqualityExpression
        BitwiseAndExpression & EqualityExpression

    Input

    AST
 */
static EcNode *parseBitwiseAndExpression(EcCompiler *cp)
{
    EcNode      *np, *parent;

    ENTER(cp);

    np = parseEqualityExpression(cp);

    while (np) {
        switch (peekToken(cp)) {
        case T_BIT_AND:
            getToken(cp);
            parent = createNode(cp, N_BINARY_OP);
            np = createBinaryNode(cp, np, parseEqualityExpression(cp), parent);
            break;

        default:
            return LEAVE(cp, np);
        }
    }
    return LEAVE(cp, np);
}


/*
    BitwiseXorExpression (189)
        BitwiseAndExpression
        BitwiseXorExpression ^ BitwiseAndExpression

    Input

    AST
 */
static EcNode *parseBitwiseXorExpression(EcCompiler *cp)
{
    EcNode      *np, *parent;

    ENTER(cp);

    np = parseBitwiseAndExpression(cp);

    while (np) {
        switch (peekToken(cp)) {
        case T_BIT_XOR:
            getToken(cp);
            parent = createNode(cp, N_BINARY_OP);
            np = createBinaryNode(cp, np, parseBitwiseAndExpression(cp), parent);
            break;

        default:
            return LEAVE(cp, np);
        }
    }
    return LEAVE(cp, np);
}


/*
    BitwiseOrExpression (191)
        BitwiseXorExpression
        BitwiseOrExpression | BitwiseXorExpression

    Input

    AST
 */
static EcNode *parseBitwiseOrExpression(EcCompiler *cp)
{
    EcNode      *np, *parent;

    ENTER(cp);

    np = parseBitwiseXorExpression(cp);

    while (np) {
        switch (peekToken(cp)) {
        case T_BIT_OR:
            getToken(cp);
            parent = createNode(cp, N_BINARY_OP);
            np = createBinaryNode(cp, np, parseBitwiseXorExpression(cp), parent);
            break;

        default:
            return LEAVE(cp, np);
        }
    }
    return LEAVE(cp, np);
}


/*
    LogicalAndExpression (193)
        BitwiseOrExpression
        LogicalAndExpression && BitwiseOrExpression

    Input

    AST
 */
static EcNode *parseLogicalAndExpression(EcCompiler *cp)
{
    EcNode      *np, *parent;

    ENTER(cp);

    np = parseBitwiseOrExpression(cp);

    while (np) {
        switch (peekToken(cp)) {
        case T_LOGICAL_AND:
            getToken(cp);
            parent = createNode(cp, N_BINARY_OP);
            np = createBinaryNode(cp, np, parseBitwiseOrExpression(cp), parent);
            break;

        default:
            return LEAVE(cp, np);
        }
    }
    return LEAVE(cp, np);
}


/*
    LogicalOrExpression (195)
        LogicalAndExpression
        LogicalOrExpression || LogicalOrExpression

    Input

    AST
 */
static EcNode *parseLogicalOrExpression(EcCompiler *cp)
{
    EcNode      *np, *parent;

    ENTER(cp);

    np = parseLogicalAndExpression(cp);

    while (np) {
        switch (peekToken(cp)) {
        case T_LOGICAL_OR:
            getToken(cp);
            parent = createNode(cp, N_BINARY_OP);
            np = createBinaryNode(cp, np, parseLogicalOrExpression(cp), parent);
            break;

        default:
            return LEAVE(cp, np);
        }
    }
    return LEAVE(cp, np);
}


/*
    ConditionalExpression (197) -allowList,b-
        LetExpression -b-
        YieldExpression -b-
        LogicalOrExpression -a,b-
        LogicalOrExpression -allowList,b-
            ? AssignmentExpression : AssignmentExpression

    ConditionalExpression (197) -noList,b-
        SimpleYieldExpression
        LogicalOrExpression -a,b-
        LogicalOrExpression -allowList,b-
            ? AssignmentExpression : AssignmentExpression

    Input
        let
        yield
        (
        .
        ..
        null
        true
        false
        this
        function
        Identifier
        delete
        {
        [
        (
        @
        NumberLiteral
        StringLiteral
        RegularExpression
        XMLInitializer: <!--, [CDATA, <?, <
        super
        new

    AST
        N_CALL
        N_EXPRESSIONS
        N_FUNCTION
        N_DOT
            left: N_QNAME | N_DOT | N_EXPRESSIONS | N_FUNCTION
            right: N_QNAME | N_EXPRESSIONS | N_FUNCTION
        N_LITERAL
        N_NEW           (array / object literals)
        N_QNAME
        N_SUPER
        N_THIS
 */
static EcNode *parseConditionalExpression(EcCompiler *cp)
{
    EcNode      *np, *cond;

    ENTER(cp);

    switch (peekToken(cp)) {
    case T_LET:
        np = parseLetExpression(cp);
        break;

    case T_YIELD:
        np = parseYieldExpression(cp);
        break;

    default:
        np = parseLogicalOrExpression(cp);
        if (np) {
            if (peekToken(cp) == T_QUERY) {
                getToken(cp);
                cond = np;
                np = createNode(cp, N_IF);
                np->tenary.cond = linkNode(np, cond);
                np->tenary.thenBlock = linkNode(np, parseAssignmentExpression(cp));
                if (getToken(cp) != T_COLON) {
                    np = parseError(cp, "Expecting \":\"");
                } else {
                    np->tenary.elseBlock = linkNode(np, parseAssignmentExpression(cp));
                }
            }
        }
    }
    return LEAVE(cp, np);
}


/*
    NonAssignmentExpression -allowList,b- (199)
        LetExpression
        YieldExpression
        LogicalOrExpression -a,b-
        LogicalOrExpression -allowList,b-
            ? AssignmentExpression : AssignmentExpression

    NonAssignmentExpression -noList,b-
        SimpleYieldExpression
        LogicalOrExpression -a,b-
        LogicalOrExpression -allowList,b-
            ? AssignmentExpression : AssignmentExpression

    Input

    AST
 */
static EcNode *parseNonAssignmentExpression(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    switch (peekToken(cp)) {
    case T_LET:
        np = parseLetExpression(cp);
        break;

    case T_YIELD:
        np = parseYieldExpression(cp);
        break;

    default:
        np = parseLogicalOrExpression(cp);
        if (np) {
            if (peekToken(cp) == T_QUERY) {
                getToken(cp);
                np = parseAssignmentExpression(cp);
                if (getToken(cp) != T_COLON) {
                    // putToken(cp);
                    np = parseError(cp, "Expecting \":\"");
                } else {
                    np = parseAssignmentExpression(cp);
                }
            }
        }
    }
    return LEAVE(cp, np);
}


/*
    LetExpression (204)
        let ( LetBindingList ) ListExpression

    Input
        let

    AST
 */
static EcNode *parseLetExpression(EcCompiler *cp)
{
    EcNode  *np;

    if (getToken(cp) != T_LET) {
        return LEAVE(cp, expected(cp, "let"));
    }
    if (getToken(cp) != T_LPAREN) {
        return LEAVE(cp, expected(cp, "("));
    }
    np = parseLetBindingList(cp);
    if (getToken(cp) != T_RPAREN) {
        return LEAVE(cp, expected(cp, ")"));
    }
    return 0;
}


/*
    LetBindingList (205)
        EMPTY
        NonemptyLetBindingList -allowList-

    Input

    AST
 */
static EcNode *parseLetBindingList(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}


#if UNUSED
/*
    NonemptyLetBindingList (207) -a-
        VariableBinding -a,allowin-
        VariableBinding -noList,allowin- , NonemptyLetBindingList -a-

    Input

    AST
 */
static EcNode *parseNonemptyLetBindingList(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}
#endif


/*
    YieldExpression (209)
        yield
        yield [no line break] ListExpression

    Input

    AST
 */
static EcNode *parseYieldExpression(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}


/*
    Rewrite compound assignment. Eg. given x += 3  rewrite as
        x = x + 3;
 */
static EcNode *rewriteCompoundAssignment(EcCompiler *cp, int subId, EcNode *lhs, EcNode *rhs)
{
    EcNode      *np, *parent;

    ENTER(cp);

    /*
        Map the operator token to its non-assignment counterpart
     */
    np = createNode(cp, N_BINARY_OP);
    np->tokenId = subId - 1;

    np = appendNode(np, lhs);
    np = appendNode(np, rhs);
    parent = createNode(cp, N_ASSIGN_OP);
    np = createAssignNode(cp, lhs, np, parent);

    return LEAVE(cp, np);
}


/*
    AssignmentExpression (211)
        ConditionalExpression
        Pattern -a,b-allowin- = AssignmentExpression -a,b-
        SimplePattern -a,b-allowExpr- CompoundAssignmentOperator
                AssignmentExpression -a,b-

    Where
        SimplePattern is:
            LeftHandSideExpression -a,b-
            Identifier
        ConditionalExpression is:
            LetExpression -b-
            YieldExpression -b-
            LogicalOrExpression -a,b-

    Input
        (
        .
        ..
        null
        true
        false
        this
        function
        Identifier
        {
        [
        (
        @
        NumberLiteral
        StringLiteral
        RegularExpression
        XMLInitializer: <!--, [CDATA, <?, <
        super
        new
        let
        yield

    AST
        N_CALL
        N_EXPRESSIONS
        N_FUNCTION
        N_DOT
            left: N_QNAME | N_DOT | N_EXPRESSIONS | N_FUNCTION
            right: N_QNAME | N_EXPRESSIONS | N_FUNCTION
        N_LITERAL
        N_NEW           (array / object literals)
        N_QNAME
        N_SUPER
        N_THIS
        N_DELETE
 */
static EcNode *parseAssignmentExpression(EcCompiler *cp)
{
    EcNode      *np, *parent;
    int         subId;

    ENTER(cp);

    /*
        A LeftHandSideExpression is allowed in both ConditionalExpression and in a SimplePattern. So allow the longest
        matching production to have first  crack at the input.
     */
    np = parseConditionalExpression(cp);
    if (np) {
        if (peekToken(cp) == T_ASSIGN) {
            getToken(cp);
            subId = cp->token->subId;
            if (cp->token->groupMask & G_COMPOUND_ASSIGN) {
                np = rewriteCompoundAssignment(cp, subId, np, parseAssignmentExpression(cp));

            } else {
                parent = createNode(cp, N_ASSIGN_OP);
                np = createAssignNode(cp, np, parseAssignmentExpression(cp), parent);
            }
        }
    }
    return LEAVE(cp, np);
}


#if UNUSED
/*
    TODO - refactored
    CompoundAssignmentOperator (227)
        *=
        /=
        %=
        +=
        -=
        <<=
        >>=
        >>>=
        &=
        ^=
        |=
        &&=
        ||=

    Input (see above)

    AST
 */
static EcNode *parseCompoundAssignmentOperator(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}
#endif


/*
    ListExpression (227)
        AssignmentExpression -allowList,b-
        ListExpression -b- , AssignmentExpression -allowList,b-

    Input
        x = ...

    AST
        N_EXPRESSIONS
 */
static EcNode *parseListExpression(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    np = createNode(cp, N_EXPRESSIONS);
    mprAssert(np);
    do {
        np = appendNode(np, parseAssignmentExpression(cp));
    } while (np && getToken(cp) == T_COMMA);

    if (np) {
        putToken(cp);
    }
    return LEAVE(cp, np);
}


/*
    Pattern -a,b,g- (231)
        SimplePattern -a,b-g-
        ObjectPattern
        ArrayPattern

    Input
        Identifier
        {
        [

    AST
 */
static EcNode *parsePattern(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    switch (peekToken(cp)) {
#if TODO
    case T_LBRACKET:
        np = parseArrayPattern(cp);
        break;

    case T_LBRACE:
        np = parseObjectPattern(cp);
        break;
#endif

    default:
        np = parseSimplePattern(cp);
        break;
    }

    return LEAVE(cp, np);
}


/*
    SimplePattern -a,b,noExpr- (232)
        Identifier

    SimplePattern -a,b,noExpr- (233)
        LeftHandSideExpression -a,b-

    Input

    AST
        N_QNAME
        N_LIST_EXPRESSION
 */
static EcNode *parseSimplePattern(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    np = parseLeftHandSideExpression(cp);
    if (np == 0 && peekToken(cp) == T_ID) {
        np = parseIdentifier(cp);
    }

    return LEAVE(cp, np);
}


#if UNUSED
/*
    ObjectPattern -g- (234)
        { DestructuringFieldList }

    Input

    AST
 */
static EcNode *parseObjectPattern(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}


/*
    DestructuringFieldList -g- (248)
        EMPTY
        DestructuringField
        DestructuringField , DestructuringField

    Input

    AST
 */
static EcNode *parseDestructuringFieldList(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}


/*
    DestructuringField -g- (251)
        FieldName : Pattern -noList,allowin,g-

    Input

    AST
 */
static EcNode *parseDestructuringField(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}


/*
    ArrayPattern (240)
        [ DestructuringElementList ]

    Input

    AST
 */
static EcNode *parseArrayPattern(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}


/*
    DestructuringElementList -g- (253)
        EMPTY
        DestructuringElement
        , DestructuringElementList
        DestructuringElement , DestructuringElementList

    Input

    AST
 */
static EcNode *parseDestructuringElement(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}
#endif


/*
    TypedIdentifier (258)
        SimplePattern -noList,noin,noExpr-
        SimplePattern -a,b,noExpr- : TypeExpression

    Input

    AST
 */
static EcNode *parseTypedIdentifier(EcCompiler *cp)
{
    EcNode      *np, *typeNode;

    ENTER(cp);

    np = parseSimplePattern(cp);

    if (peekToken(cp) == T_COLON) {
        getToken(cp);
        typeNode = parseNullableTypeExpression(cp);
        if (typeNode) {
            np->typeNode = linkNode(np, typeNode);
            /* Accumulate EJS_TRAIT_MATCH | EJS_TRAIT_NULLABLE */
            np->attributes |= typeNode->attributes;
        } else {
            np = parseError(cp, "Expecting type");
        }
    }
    return LEAVE(cp, np);
}


/*
    TypedPattern (248)
        SimplePattern -a,b,noExpr-
        SimplePattern -a,b,noExpr- : NullableTypeExpression
        ObjectPattern -noExpr-
        ObjectPattern -noExpr- : TypeExpression
        ArrayPattern -noExpr-
        ArrayPattern -noExpr- : TypeExpression

    Input

    AST
 */
static EcNode *parseTypedPattern(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    switch (peekToken(cp)) {
#if UNUSED
    case T_LBRACKET:
        np = parseArrayPattern(cp);
        if (peekToken(cp) == T_COLON) {
            getToken(cp);
            np->typeNode = linkNode(np, parseTypeExpression(cp));
        }
        break;

    case T_LBRACE:
        np = parseObjectPattern(cp);
        if (peekToken(cp) == T_COLON) {
            getToken(cp);
            np->typeNode = linkNode(np, parseTypeExpression(cp));
        }
        break;
#endif

    default:
        np = parseSimplePattern(cp);
        if (peekToken(cp) == T_COLON) {
            getToken(cp);
            np->typeNode = linkNode(np, parseNullableTypeExpression(cp));
        }
        break;
    }
    mprAssert(np == 0 || np->kind == N_QNAME);

#if UNUSED
    if (np) {
        np->name.isType = 1;
    }
#endif
    return LEAVE(cp, np);
}


/*
    NullableTypeExpression (266)
        null
        undefined
        TypeExpression
        TypeExpression ?            # Nullable
        MOB REMOVE TypeExpression ! # Non-Nullable

    Input

    AST
 */
static EcNode *parseNullableTypeExpression(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    switch (peekToken(cp)) {
    case T_NULL:
    case T_UNDEFINED:
        np = createNode(cp, N_QNAME);
        setId(np, (char*) cp->token->text);
        np->name.isType = 1;
        break;

    default:
        np = parseTypeExpression(cp);
        if (peekToken(cp) == T_QUERY) {
            getToken(cp);
        } else if (cp->peekToken->tokenId == T_LOGICAL_NOT) {
            getToken(cp);
            np->attributes |= EJS_TRAIT_THROW_NULLS;
        } else if (cp->peekToken->tokenId == T_TILDE) {
            getToken(cp);
            np->attributes |= EJS_TRAIT_CAST_NULLS;
        }
        break;
    }
    return LEAVE(cp, np);
}


/*
    TypeExpression (271)
        FunctionType
        UnionType
        RecordType
        ArrayType
        PrimaryName

    Input
        function
        (
        {
        [
        Identifier

    AST
        N_QNAME
        N_DOT
 */
static EcNode *parseTypeExpression(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    switch (peekToken(cp)) {
#if UNUSED
    case T_FUNCTION:
        np = appendNode(np, parseFunctionType(cp));
        break;

    case T_LPAREN:
        np = appendNode(np, parseUnionType(cp));
        break;

    case T_LBRACE:
        np = appendNode(np, parseRecordType(cp));
        break;

    case T_LBRACKET:
        appendNode(np, parseFunctionType(cp));
        break;
#endif

    case T_STRING:
    case T_ID:
    case T_MUL:
        np = parsePrimaryName(cp);
        if (np) {
            np->name.isType = 1;
        }
        break;

    default:
        getToken(cp);
        np = unexpected(cp);
    }
    return LEAVE(cp, np);
}


#if UNUSED
/*
    FunctionType (276)
        function FunctionSignatureType

    Input sequnces
        function ...

    AST
 */
static EcNode *parseFunctionType(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}


/*
    FunctionSignatureType (277)
        TypeParameters ( ParametersType ) ResultType
        TypeParameters ( this : PrimaryName ) ResultType
        TypeParameters ( this : PrimaryName , NonemptyParameters )
                ResultType

    Input sequnces
        function ...

    AST
 */
static EcNode *parseFunctionSignatureType(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}


/*
    ParametersType (280)
        EMPTY
        NonemptyParametersType

    Input

    AST
 */
static EcNode *parseParametersType(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}


/*
    NonemptyParametersType (282)
        ParameterInitType
        ParameterInitType , NonemptyParametersType
        RestParameterType

    Input

    AST
 */
static EcNode *parseNonemptyParametersType(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}


/*
    ParameterInitType (285)
        ParameterType
        ParameterType =

    Input

    AST
 */
static EcNode *parseParameterInitType(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}


/*
    RestParameterType (288)
        ...
        ... ParameterType

    Input
        ...

    AST
 */
static EcNode *parseRestParameterType(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}


/*
    UnionType (290)
        ( TypeExpressionList )

    Input
        (

    AST
 */
static EcNode *parseUnionType(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}


/*
    RecordType (291)
        { FieldTypeList }

    Input
        {

    AST
 */
static EcNode *parseRecordType(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}


/*
    FieldTypeList (292)
        EMPTY
        NonemptyFieldTypeList

    Input

    AST
 */
static EcNode *parseFieldTypeList(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}


/*
    NonemptyFieldTypeList (294)
        FieldType
        FieldType , NonemptyFieldTypeList

    Input

    AST
 */
static EcNode *parseNonemptyFieldTypeList(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}


/*
    FieldType (296)
        FieldName : NullableTypeExpression

    Input

    AST
 */
static EcNode *parseFieldType(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}
#endif


/*
    ArrayType (297)
        [ ElementTypeList ]

    Input

    AST
 */
static EcNode *parseArrayType(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    if (getToken(cp) != T_LBRACKET) {
        np = expected(cp, "[");
    } else {
        np = parseElementTypeList(cp);
        if (np) {
            if (getToken(cp) != T_LBRACKET) {
                np = expected(cp, "[");
            }
        }
    }

    return LEAVE(cp, np);
}


/*
    ElementTypeList (298)
        EMPTY
        NullableTypeExpression
        , ElementTypeList
        NullableTypeExpression , ElementTypeList

    Input

    AST
 */
static EcNode *parseElementTypeList(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}


#if FUTURE
/*
    TypeExpressionList (302)
        NullableTypeExpression
        TypeExpressionList , NullableTypeExpression

    Input

    AST
 */
static EcNode *parseTypeExpressionList(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}
#endif


/*
    Statement (289) -t,o-
        Block -t-
        BreakStatement Semicolon -o-
        ContinueStatement Semicolon -o-
        DefaultXMLNamespaceStatement Semicolon -o-
        DoStatement Semicolon -o-
        ExpresssionStatement Semicolon -o-
        ForStatement -o-
        IfStatement -o-
        LabeledStatement -o-
        LetStatement -o-
        ReturnStatement Semicolon -o-
        SwitchStatement
        SwitchTypeStatement
        ThrowStatement Semicolon -o-
        TryStatement
        WhileStatement -o-
        WithStatement -o-

    Input
        EMPTY
        {
        (
        .
        ..
        [
        (
        @
        break
        continue
        ?? DefaultXML
        do
        for
        if
        let
        return
        switch
        throw
        try
        while
        with
        null
        true
        false
        this
        function
        Identifier
        NumberLiteral
        StringLiteral
        RegularExpression
        XMLInitializer: <!--, [CDATA, <?, <
        super
        new

    AST
        N_BLOCK
        N_CONTINUE
        N_BREAK
        N_FOR
        N_FOR_IN
        N_HASH
        N_IF
        N_SWITCH
        N_THROW
        N_TRY
        N_WHILE

 */
static EcNode *parseStatement(EcCompiler *cp)
{
    EcNode      *np;
    int         expectSemi, tid;

    ENTER(cp);

    expectSemi = 0;
    np = 0;

    switch ((tid = peekToken(cp))) {
    case T_AT:
    case T_DELETE:
    case T_DIV:
    case T_DOT:
    case T_DOT_DOT:
    case T_FALSE:
    case T_FUNCTION:
    case T_LBRACKET:
    case T_LPAREN:
    case T_MINUS_MINUS:
    case T_NEW:
    case T_NUMBER:
    case T_NULL:
    case T_PLUS_PLUS:
    case T_STRING:
    case T_SUPER:
    case T_THIS:
    case T_TRUE:
    case T_TYPEOF:
    case T_RESERVED_NAMESPACE:
    case T_REQUIRE:                             /* require used as an identifier */
        np = parseExpressionStatement(cp);
        expectSemi++;
        break;

    case T_BREAK:
        np = parseBreakStatement(cp);
        expectSemi++;
        break;

    case T_CONTINUE:
        np = parseContinueStatement(cp);
        expectSemi++;
        break;

    case T_DO:
        np = parseDoStatement(cp);
        expectSemi++;
        break;

    case T_FOR:
        np = parseForStatement(cp);
        break;

    case T_HASH:
        np = parseHashStatement(cp);
        break;

    case T_ID:
        if (tid == T_ID && peekAheadToken(cp, 2) == T_COLON) {
            np = parseLabeledStatement(cp);
        } else {
            np = parseExpressionStatement(cp);
            expectSemi++;
        }
        break;

    case T_IF:
        np = parseIfStatement(cp);
        break;

    case T_LBRACE:
        np = parseBlockStatement(cp);
        break;

    case T_LET:
        np = parseLetStatement(cp);
        break;

    case T_RETURN:
        np = parseReturnStatement(cp);
        expectSemi++;
        break;

    case T_SWITCH:
        np = parseSwitchStatement(cp);
        break;

    case T_THROW:
        np = parseThrowStatement(cp);
        expectSemi++;
        break;

    case T_TRY:
        np = parseTryStatement(cp);
        break;

    case T_WHILE:
        np = parseWhileStatement(cp);
        break;

    case T_WITH:
        np = parseWithStatement(cp);
        break;

    default:
        getToken(cp);
        np = unexpected(cp);
    }

    if (np && expectSemi) {
        if (getToken(cp) != T_SEMICOLON) {
            if (np->lineNumber < cp->token->lineNumber || cp->token->tokenId == T_EOF || cp->token->tokenId == T_NOP ||
                cp->token->tokenId == T_RBRACE) {
                putToken(cp);
            } else {
                np = unexpected(cp);
            }
        }
    }
    return LEAVE(cp, np);
}


/*
    Substatement -o- (320)
        EmptyStatement
        Statement -o-

    Statement:
        Block -t-
        BreakStatement Semicolon -o-
        ContinueStatement Semicolon -o-
        DefaultXMLNamespaceStatement Semicolon -o-
        DoStatement Semicolon -o-
        ExpresssionStatement Semicolon -o-
        ForStatement -o-
        IfStatement -o-
        LabeledStatement -o-
        LetStatement -o-
        ReturnStatement Semicolon -o-
        SwitchStatement
        SwitchTypeStatement
        ThrowStatement Semicolon -o-
        TryStatement
        WhileStatement -o-
        WithStatement -o-

    Input
        EMPTY
        {
        (
        .
        ..
        [
        (
        @
        break
        continue
        ?? DefaultXML
        do
        for
        if
        let
        return
        switch
        throw
        try
        while
        with
        null
        true
        false
        this
        function
        Identifier
        NumberLiteral
        StringLiteral
        RegularExpression
        XMLInitializer: <!--, [CDATA, <?, <
        super
        new

    AST
        N_NOP
        N_BLOCK
        N_CONTINUE
        N_BREAK
        N_FOR
        N_FOR_IN
        N_IF
        N_SWITCH
        N_THROW
        N_TRY
        N_WHILE
 */

static EcNode *parseSubstatement(EcCompiler *cp)
{
    EcNode      *np;
    int         tid;

    ENTER(cp);

    np = 0;

    /*
        TODO: Missing: DefaultXML
     */
    switch ((tid = peekToken(cp))) {
    case T_AT:
    case T_BREAK:
    case T_CONTINUE:
    case T_DO:
    case T_DOT:
    case T_DOT_DOT:
    case T_FALSE:
    case T_FOR:
    case T_FUNCTION:
    case T_IF:
    case T_LBRACE:
    case T_LBRACKET:
    case T_LET:
    case T_LPAREN:
    case T_NEW:
    case T_NUMBER:
    case T_NULL:
    case T_RETURN:
    case T_STRING:
    case T_SUPER:
    case T_SWITCH:
    case T_THIS:
    case T_THROW:
    case T_TRUE:
    case T_TRY:
    case T_WHILE:
    case T_WITH:
        np = parseStatement(cp);
        break;

    case T_ID:
        if (peekAheadToken(cp, 2) == T_COLON) {
            /* Labeled expression */
            np = parseStatement(cp);
        } else {
            np = parseStatement(cp);
        }
        break;


    default:
        np = createNode(cp, N_NOP);
    }

    return LEAVE(cp, np);
}


#if UNUSED
/*
    Semicolon -abbrev- (322)
        ;
        VirtualSemicolon
        EMPTY

    Semicolon -noshortif- (325)
        ;
        VirtualSemicolon
        EMPTY

    Input

    AST
 */
static EcNode *parseSemicolon(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}
#endif


/*
    EmptyStatement (33)
        ;

    Input
        EMPTY

    AST
        N_NOP
 */
static EcNode *parseEmptyStatement(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = createNode(cp, N_NOP);;
    return LEAVE(cp, np);
}


/*
    ExpressionStatement (331)
        [lookahead !function,{}] ListExpression -allowin-

    Input
        (
        .
        ..
        null
        true
        false
        this
        function
        delete
        Identifier
        [
        (
        @
        NumberLiteral
        StringLiteral
        RegularExpression
        XMLInitializer: <!--, [CDATA, <?, <
        super
        new

    AST
        N_CALL
        N_DELETE
        N_DOT
            left: N_QNAME | N_DOT | N_EXPRESSIONS | N_FUNCTION
            right: N_QNAME | N_EXPRESSIONS | N_FUNCTION
        N_EXPRESSIONS
        N_LITERAL
        N_NEW           (array / object literals)
        N_QNAME
        N_SUPER
        N_THIS
 */
static EcNode *parseExpressionStatement(EcCompiler *cp)
{
    EcNode      *np;
    int         tid;

    ENTER(cp);
    tid = peekToken(cp);
    if (tid == T_FUNCTION || tid == T_LBRACE) {
        np = createNode(cp, 0);
    } else {
        np = parseListExpression(cp);
    }
    return LEAVE(cp, np);
}


/*
    BlockStatement (318)
        Block

    Input
        {

    AST
        N_BLOCK
 */
static EcNode *parseBlockStatement(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = parseBlock(cp);
    return LEAVE(cp, np);
}


/*
    LabeledStatement -o- (319)
        Identifier : Substatement

    Input

    AST
 */
static EcNode *parseLabeledStatement(EcCompiler *cp)
{
    getToken(cp);
    return parseError(cp, "Labeled statements are not yet implemented");
}


/*
    IfStatement -abbrev- (320)
        if ParenListExpression Substatement
        if ParenListExpression Substatement else Substatement

    IfStatement -full- (322)
        if ParenListExpression Substatement
        if ParenListExpression Substatement else Substatement

    IfStatement -noShortif- (324)
        if ParenListExpression Substatement else Substatement

    Input
        if ...

    AST
 */
static EcNode *parseIfStatement(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    if (getToken(cp) != T_IF) {
        return LEAVE(cp, parseError(cp, "Expecting \"if\""));
    }
    if (peekToken(cp) != T_LPAREN) {
        getToken(cp);
        return LEAVE(cp, parseError(cp, "Expecting \"(\""));
    }

    np = createNode(cp, N_IF);
    np->tenary.cond = linkNode(np, parseParenListExpression(cp));
    np->tenary.thenBlock = linkNode(np, parseSubstatement(cp));

    if (peekToken(cp) == T_ELSE) {
        getToken(cp);
        np->tenary.elseBlock = linkNode(np, parseSubstatement(cp));
    }
    return LEAVE(cp, np);
}


/*
    SwitchStatement (328)
        switch ParenListExpression { CaseElements }
        switch type ( ListExpression -allowList,allowin- : TypeExpression )
                { TypeCaseElements }

    Input
        switch ...

    AST
        N_SWITCH
            N_EXPRESSIONS           ( ListExpression )
            N_CASE_ELEMENTS
 */
static EcNode *parseSwitchStatement(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    np = createNode(cp, N_SWITCH);

    if (getToken(cp) != T_SWITCH) {
        np = unexpected(cp);

    } else {
        if (peekToken(cp) != T_TYPE) {
            np = appendNode(np, parseParenListExpression(cp));
            if (getToken(cp) != T_LBRACE) {
                np = parseError(cp, "Expecting \"{\"");
            } else {
                np = appendNode(np, parseCaseElements(cp));
                if (getToken(cp) != T_RBRACE) {
                    np = parseError(cp, "Expecting \"{\"");
                }
            }

        } else {
#if FUTURE
            //  switch type
            getToken(cp);
            if (getToken(cp) != T_LPAREN) {
                np = parseError(cp, "Expecting \"(\"");
            } else {
                x = parseListExpression(cp);
                if (getToken(cp) != T_COLON) {
                    np = parseError(cp, "Expecting \":\"");
                } else {
                    x = parseTypeExpression(cp);
                    if (getToken(cp) != T_RPAREN) {
                        np = parseError(cp, "Expecting \")\"");
                    } else  if (getToken(cp) != T_LBRACE) {
                        np = parseError(cp, "Expecting \"{\"");
                    } else {
                        x = parseTypeCaseElements(cp);
                        if (getToken(cp) != T_RBRACE) {
                            np = parseError(cp, "Expecting \"}\"");
                        }
                    }
                }
                parseListExpression(cp);
            }
#endif
        }
    }
    return LEAVE(cp, np);
}


/*
    CaseElements (342)
        EMPTY
        CaseLabel
        CaseLabel CaseElementsPrefix CaseLabel
        CaseLabel CaseElementsPrefix Directive -abbrev-

    Refactored as:
        EMPTY
        CaseLable Directives
        CaseElements

    Input
        case
        default

    AST
        N_CASE_ELEMENTS
            N_CASE_LABEL: kind, expression
 */
static EcNode *parseCaseElements(EcCompiler *cp)
{
    EcNode      *np, *caseLabel, *directives;

    ENTER(cp);

    np = createNode(cp, N_CASE_ELEMENTS);

    while (np && (peekToken(cp) == T_CASE || cp->peekToken->tokenId == T_DEFAULT)) {
        caseLabel = parseCaseLabel(cp);
        directives = createNode(cp, N_DIRECTIVES);
        caseLabel = appendNode(caseLabel, directives);

        while (caseLabel && directives && peekToken(cp) != T_CASE && cp->peekToken->tokenId != T_DEFAULT) {
            if (cp->peekToken->tokenId == T_RBRACE) {
                break;
            }
            directives = appendNode(directives, parseDirective(cp));
        }
        np = appendNode(np, caseLabel);
    }
    return LEAVE(cp, np);
}


#if UNUSED && NOT_REQUIRED
/*
    CaseElementsPrefix (346)
        EMPTY
        CaseElementsPrefix CaseLabel
        CaseElementsPrefix Directive -full-

    Input

    AST
 */
static EcNode *parseCaseElementsPrefix(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}
#endif


/*
    CaseLabel (349)
        case ListExpression -allowin- :
        default :

    Input
        case .. :
        default :

    AST
        N_CASE_LABEL  kind, expression
 */
static EcNode *parseCaseLabel(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;

    if (peekToken(cp) == T_CASE) {
        getToken(cp);
        np = createNode(cp, N_CASE_LABEL);
        np->caseLabel.kind = EC_SWITCH_KIND_CASE;
        if ((np->caseLabel.expression = linkNode(np, parseListExpression(cp))) == 0) {
            return LEAVE(cp, np);
        }
    } else if (cp->peekToken->tokenId == T_DEFAULT) {
        getToken(cp);
        np = createNode(cp, N_CASE_LABEL);
        np->caseLabel.kind = EC_SWITCH_KIND_DEFAULT;
    }
    if (getToken(cp) != T_COLON) {
        np = expected(cp, ":");
    }
    return LEAVE(cp, np);
}


#if UNUSED
/*
    TypeCaseElements (351)
        TypeCaseElement
        TypeCaseElement TypeCaseElement

    Input

    AST
 */
static EcNode *parseTypeCaseElements(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}


/*
    TypeCaseElement (353)
        case ( TypedPattern -noList,noIn- ) Block -local-
        default Block -local-

    Input

    AST
 */
static EcNode *parseTypeCaseElement(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}
#endif


/*
    DoStatement (355)
        do Substatement -abbrev- while ParenListExpresison

    Input
        do

    AST
        N_FOR
 */
static EcNode *parseDoStatement(EcCompiler *cp)
{
    EcNode      *np;


    ENTER(cp);

    np = createNode(cp, N_DO);

    if (getToken(cp) != T_DO) {
        return LEAVE(cp, unexpected(cp));
    }
    np->forLoop.body = linkNode(np, parseSubstatement(cp));

    if (getToken(cp) != T_WHILE) {
        np = expected(cp, "while");
    } else {
        np->forLoop.cond = linkNode(np, parseParenListExpression(cp));
    }
    return LEAVE(cp, np);
}


/*
    WhileStatement (356)
        while ParenListExpresison Substatement -o-

    Input
        while

    AST
        N_FOR
 */
static EcNode *parseWhileStatement(EcCompiler *cp)
{
    EcNode      *np, *initializer;

    ENTER(cp);

    initializer = 0;

    if (getToken(cp) != T_WHILE) {
        return LEAVE(cp, parseError(cp, "Expecting \"while\""));
    }
    /*
        Convert into a "for" AST
     */
    np = createNode(cp, N_FOR);
    np->forLoop.cond = linkNode(np, parseParenListExpression(cp));
    np->forLoop.body = linkNode(np, parseSubstatement(cp));
    return LEAVE(cp, np);
}


/*
    ForStatement -o- (357)
        for ( ForInitializer ; OptionalExpression ; OptionalExpression )
                Substatement
        for ( ForInBinding in ListExpression -allowin- ) Substatement
        for each ( ForInBinding in ListExpression -allowin- ) Substatement

    Where:

    ForIntializer (360)
        EMPTY
        ListExpression -noin-
        VariableDefinition -noin-

    ForInBinding (363)
        Pattern -allowList,noIn,allowExpr-
        VariableDefinitionKind VariableBinding -allowList,noIn-

    VariableDefinition -b- (429)
        VariableDefinitionKind VariableBindingList -allowList,b-

    VariableDefinitionKind (430)
        const
        let
        let const
        var

    MemberExpression Input tokens
        null
        true
        false
        this
        function
        Identifier
        {
        [
        (
        @
        NumberLiteral
        StringLiteral
        RegularExpression
        XMLInitializer: <!--, [CDATA, <?, <
        super
        new

    Input
        for ( 'const|let|let const|var' '[|{'

    AST
        N_FOR
        N_FOR_IN
 */
static EcNode *parseForStatement(EcCompiler *cp)
{
    EcNode      *np, *initializer, *body, *iterGet, *block, *callGet, *dot;
    int         each, forIn;

    ENTER(cp);

    initializer = 0;
    np = 0;
    forIn = 0;
    each = 0;

    if (getToken(cp) != T_FOR) {
        return LEAVE(cp, parseError(cp, "Expecting \"for\""));
    }

    if (peekToken(cp) == T_EACH) {
        each++;
        getToken(cp);
    }

    if (getToken(cp) != T_LPAREN) {
        return LEAVE(cp, parseError(cp, "Expecting \"(\""));
    }

    if (peekToken(cp) == T_ID && peekAheadToken(cp, 2) == T_IN) {
        /*
            For in forces the variable to be a let scoped var
         */
        initializer = createNode(cp, N_VAR_DEFINITION);
        if (initializer) {
            initializer->def.varKind = KIND_LET;
            initializer = parseVariableBindingList(cp, initializer, 0);
        }

    } else if (peekToken(cp) == T_CONST || cp->peekToken->tokenId == T_LET || cp->peekToken->tokenId == T_VAR) {
        initializer = parseVariableDefinition(cp, 0);

    } else if (cp->peekToken->tokenId != T_SEMICOLON) {
        cp->state->noin = 1;
        initializer = parseListExpression(cp);
    }
    if (initializer == 0 && cp->error) {
        return LEAVE(cp, 0);
    }

    if (getToken(cp) == T_SEMICOLON) {
        forIn = 0;
        np = createNode(cp, N_FOR);
        np->forLoop.initializer = linkNode(np, initializer);
        if (peekToken(cp) != T_SEMICOLON) {
            np->forLoop.cond = linkNode(np, parseOptionalExpression(cp));
        }
        if (getToken(cp) != T_SEMICOLON) {
            np = parseError(cp, "Expecting \";\"");
        } else if (peekToken(cp) != T_RPAREN) {
            np->forLoop.perLoop = linkNode(np, parseOptionalExpression(cp));
        }

    } else if (cp->token->tokenId == T_IN) {
        forIn = 1;
        np = createNode(cp, N_FOR_IN);
        np->forInLoop.iterVar = linkNode(np, initializer);

        /*
            Create a "listExpression.get/values" node
         */
        dot = createNode(cp, N_DOT);
        iterGet = appendNode(dot, parseListExpression(cp));
        iterGet = appendNode(iterGet, createNameNode(cp, (each) ? "getValues" : "get", EJS_ITERATOR_NAMESPACE));

        /*
            Create a call node for "get"
         */
        callGet = createNode(cp, N_CALL);
        callGet = appendNode(callGet, iterGet);
        callGet = appendNode(callGet, createNode(cp, N_ARGS));
        np->forInLoop.iterGet = linkNode(np, callGet);

        np->forInLoop.iterNext = linkNode(np, createNode(cp, N_NOP));

        if (np->forInLoop.iterVar == 0 || np->forInLoop.iterGet == 0) {
            return LEAVE(cp, 0);
        }

    } else {
        return LEAVE(cp, unexpected(cp));
    }

    if (getToken(cp) != T_RPAREN) {
        np = parseError(cp, "Expecting \")\"");
    }

    body = linkNode(np, parseSubstatement(cp));
    if (body == 0) {
        return LEAVE(cp, body);
    }

    /*
        Fixup the body block and move it outside the entire for loop.
     */
    if (body->kind == N_BLOCK) {
        block = body;
        body = removeNode(block, block->left);

    } else {
        block = createNode(cp, N_BLOCK);
    }

    if (forIn) {
        np->forInLoop.body = linkNode(np, body);
        np->forInLoop.each = each;

    } else {
        if (each) {
            return LEAVE(cp, parseError(cp, "\"for each\" can only be used with \"for .. in\""));
        }
        mprAssert(np != body);
        np->forLoop.body = linkNode(np, body);
    }

    /*
        Now make the for loop node a child of the outer block. Block will initially be a child of np, so must re-parent first
     */
    mprAssert(block != np);
    mprStealBlock(cp->state, block);
    np = appendNode(block, np);
    return LEAVE(cp, np);
}


#if UNUSED
/*
    ForIntializer (360)
        EMPTY
        ListExpression -noin-
        VariableDefinition -noin-

    Input

    AST
 */
static EcNode *parseForInitializer(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}


/*
    ForInBinding (363)
        Pattern -allowList,noIn,allowExpr-
        VariableDefinitionKind VariableBinding -allowList,noIn-

    Input

    AST
 */
static EcNode *parseForInBinding(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}
#endif


/*
    HashStatement (EJS)
        # ListExpression

    Input
        # expression directive

    AST
        N_HASH
 */
static EcNode *parseHashStatement(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    if (getToken(cp) != T_HASH) {
        return LEAVE(cp, parseError(cp, "Expecting \"#\""));
    }

    np = createNode(cp, N_HASH);
    np->hash.expr = linkNode(np, parseListExpression(cp));
    np->hash.body = linkNode(np, parseDirective(cp));

    return LEAVE(cp, np);
}


/*
    LetStatement (367)
        let ( LetBindingList ) Substatement -o-

    Input

    AST
 */
static EcNode *parseLetStatement(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}


/*
    WithStatement -o- (368)
        with ( ListExpression -allowin- ) Substatement -o-
        with ( ListExpression -allowin- : TypeExpression ) Substatement -o-

    Input

    AST
 */
static EcNode *parseWithStatement(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    if (getToken(cp) != T_WITH) {
        return LEAVE(cp, expected(cp, "with"));
    }
    if (getToken(cp) != T_LPAREN) {
        return LEAVE(cp, expected(cp, "("));
    }

    np = createNode(cp, N_WITH);
    np->with.object = linkNode(np, parseListExpression(cp));

    if (getToken(cp) != T_RPAREN) {
        return LEAVE(cp, expected(cp, ")"));
    }
    np->with.statement = linkNode(np, parseSubstatement(cp));
    return LEAVE(cp, np);
}


/*
    ContinueStatement (370)
        continue
        continue [no line break] Identifier

    Input
        continue

    AST
        N_CONTINUE
 */
static EcNode *parseContinueStatement(EcCompiler *cp)
{
    EcNode      *np;
    int         lineNumber;

    ENTER(cp);

    if (getToken(cp) != T_CONTINUE) {
        np = expected(cp, "continue");
    } else {
        np = createNode(cp, N_CONTINUE);
        lineNumber = cp->token->lineNumber;
        if (peekToken(cp) == T_ID && lineNumber == cp->peekToken->lineNumber) {
            np = appendNode(np, parseIdentifier(cp));
        }
    }
    return LEAVE(cp, np);
}


/*
    BreakStatement (372)
        break
        break [no line break] Identifier

    Input
        break

    AST
        N_BREAK
 */
static EcNode *parseBreakStatement(EcCompiler *cp)
{
    EcNode      *np;
    int         lineNumber;

    ENTER(cp);

    if (getToken(cp) != T_BREAK) {
        np = expected(cp, "break");
    } else {
        np = createNode(cp, N_BREAK);
        lineNumber = cp->token->lineNumber;
        if (peekToken(cp) == T_ID && lineNumber == cp->peekToken->lineNumber) {
            np = appendNode(np, parseIdentifier(cp));
        }
    }
    return LEAVE(cp, np);
}


/*
    ReturnStatement (374)
        return
        return [no line break] ListExpression -allowin-

    Input
        return ...

    AST
        N_RETURN
 */
static EcNode *parseReturnStatement(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    if (getToken(cp) != T_RETURN) {
        np = unexpected(cp);

    } else {
        if (cp->state->currentFunctionNode == 0) {
            np = parseError(cp, "Return statemeout outside function");

        } else {
            np = createNode(cp, N_RETURN);
            if (peekToken(cp) != T_SEMICOLON && np->lineNumber == cp->peekToken->lineNumber) {
                np = appendNode(np, parseListExpression(cp));
            }
        }
    }
    return LEAVE(cp, np);
}


/*
    ThrowStatement (376)
        throw ListExpression -allowin-

    Input
        throw ...

    AST
 */
static EcNode *parseThrowStatement(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    if (getToken(cp) != T_THROW) {
        return LEAVE(cp, unexpected(cp));
    }
    np = createNode(cp, N_THROW);
    np = appendNode(np, parseListExpression(cp));
    return LEAVE(cp, np);
}


/*
    TryStatement (377)
        try Block -local- CatchClauses
        try Block -local- CatchClauses finally Block -local-
        try Block -local- finally Block -local-

    Input
        try ...

    AST
 */
static EcNode *parseTryStatement(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    /*
        Just ignore try / catch for now
     */
    if (getToken(cp) != T_TRY) {
        return LEAVE(cp, unexpected(cp));
    }
    np = createNode(cp, N_TRY);
    if (np) {
        np->exception.tryBlock = linkNode(np, parseBlock(cp));
        if (peekToken(cp) == T_CATCH) {
            np->exception.catchClauses = linkNode(np, parseCatchClauses(cp));
        }
        if (peekToken(cp) == T_FINALLY) {
            getToken(cp);
            np->exception.finallyBlock = linkNode(np, parseBlock(cp));
        }
    }
    return LEAVE(cp, np);
}


/*
    CatchClauses (380)
        CatchClause
        CatchClauses CatchClause

    Input
        catch
 */
static EcNode *parseCatchClauses(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    if (peekToken(cp) != T_CATCH) {
        getToken(cp);
        return LEAVE(cp, unexpected(cp));
    }
    np = createNode(cp, N_CATCH_CLAUSES);

    do {
        np = appendNode(np, parseCatchClause(cp));
    } while (peekToken(cp) == T_CATCH);
    return LEAVE(cp, np);
}


/*
    CatchClause (382)
        catch ( Parameter ) Block -local-

    Input
        catch

    AST
        T_CATCH
 */
static EcNode *parseCatchClause(EcCompiler *cp)
{
    EcNode      *np, *block, *arg, *varDef, *parent;

    ENTER(cp);


    if (getToken(cp) != T_CATCH) {
        return LEAVE(cp, unexpected(cp));
    }

    np = createNode(cp, N_CATCH);

    /*
        EJS enhancement: allow no (Parameter)
     */
    varDef = 0;
    arg = 0;
    if (peekToken(cp) == T_LPAREN) {
        getToken(cp);
        varDef = parseParameter(cp, 0);
        if (varDef) {
            mprAssert(varDef->kind == N_VAR_DEFINITION);
            varDef->def.varKind = KIND_LET;
            arg = varDef->left;
            mprAssert(arg->kind == N_QNAME);
            removeNode(varDef, arg);
            arg->qname.space = cp->state->namespace;
        }
        if (getToken(cp) != T_RPAREN) {
            return LEAVE(cp, unexpected(cp));
        }
        /*
            Insert an assign node and value
         */
        if (varDef) {
            parent = createNode(cp, N_ASSIGN_OP);
            arg = createAssignNode(cp, arg, createNode(cp, N_CATCH_ARG), parent);
            varDef = appendNode(varDef, arg);
        }
    }
    np->catchBlock.arg = varDef;

    block = parseBlock(cp);
    if (block) {
        if (varDef) {
            block = insertNode(block, varDef, 0);
        }
    }
    np = appendNode(np, block);
    return LEAVE(cp, np);
}


/* -t- == global, class, interface, local */

/*
    Directives -t- (367)
        EMPTY
        DirectivesPrefix Directive -t,abbrev-

    Input
        #
        import
        use
        {
        (
        break
        continue
        ?? DefaultXML
        do
        ?? ExpressionS
        for
        if
        label :
        let
        new
        return
        switch
        throw
        try
        while
        with
        internal, intrinsic, private, protected, public
        final, native, override, prototype, static
        [ attribute AssignmentExpression
        Identifier
        const
        let
        var
        function
        interface
        namespace
        type
        module

    AST
        N_DIRECTIVES
 */
static EcNode *parseDirectives(EcCompiler *cp)
{
    EcNode      *np;
    EcState     *saveState;
    EcState     *state;

    ENTER(cp);

    np = createNode(cp, N_DIRECTIVES);
    state = cp->state;
    state->topVarBlockNode = np;

    saveState = cp->directiveState;
    cp->directiveState = state;
    state->blockNestCount++;

    do {
        switch (peekToken(cp)) {
        case T_ERR:
            cp->directiveState = saveState;
            getToken(cp);
            return LEAVE(cp, unexpected(cp));

        case T_EOF:
            cp->directiveState = saveState;
            return LEAVE(cp, np);

        case T_REQUIRE:
            if (peekAheadToken(cp, 2) != T_ID && peekAheadToken(cp, 2) != T_STRING) {
                np = appendNode(np, parseDirective(cp));
            } else {
                np = appendNode(np, parseDirectivesPrefix(cp));
            }
            break;

        case T_USE:
            np = appendNode(np, parseDirectivesPrefix(cp));
            break;

        case T_RBRACE:
            if (state->blockNestCount == 1) {
                getToken(cp);
            }
            cp->directiveState = saveState;
            return LEAVE(cp, np);

        case T_SEMICOLON:
            getToken(cp);
            break;

        case T_ATTRIBUTE:
        case T_BREAK:
        case T_CLASS:
        case T_CONST:
        case T_CONTINUE:
        case T_DELETE:
        case T_DIV:
        case T_DO:
        case T_DOT:
        case T_FALSE:
        case T_FOR:
        case T_FINAL:
        case T_FUNCTION:
        case T_HASH:
        case T_ID:
        case T_IF:
        case T_INTERFACE:
        case T_MINUS_MINUS:
        case T_LBRACKET:
        case T_LBRACE:
        case T_LPAREN:
        case T_LET:
        case T_NAMESPACE:
        case T_NATIVE:
        case T_NEW:
        case T_NUMBER:
        case T_RESERVED_NAMESPACE:
        case T_RETURN:
        case T_PLUS_PLUS:
        case T_STRING:
        case T_SUPER:
        case T_SWITCH:
        case T_THIS:
        case T_THROW:
        case T_TRUE:
        case T_TRY:
        case T_TYPEOF:
        case T_VAR:
        case T_WHILE:
        case T_MODULE:
        case T_WITH:
            np = appendNode(np, parseDirective(cp));
            break;

        case T_NOP:
            if (state->blockNestCount == 1) {
                getToken(cp);
                break;

            } else {
                /*
                    NOP tokens are injected when reading from the console. If we are nested,
                    we need to eat all input. Then continue.
                 */
                ecResetInput(cp);
            }
            break;

        default:
            getToken(cp);
            np = unexpected(cp);
            cp->directiveState = saveState;
            return LEAVE(cp, np);
        }

        if (cp->error && !cp->fatalError) {
            np = ecResetError(cp, np, 1);
        }
    } while (np && (!cp->interactive || state->blockNestCount > 1));

    cp->directiveState = saveState;
    return LEAVE(cp, np);
}


/*
    DirectivesPrefix -t- (369)
        EMPTY
        Pragmas
        DirectivesPrefix Directive -t,full-

    Rewritten as:
        DirectivesPrefix

    Input
        use
        import

    AST
        N_PRAGMAS
 */
static EcNode *parseDirectivesPrefix(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    np = createNode(cp, N_PRAGMAS);

    do {
        switch (peekToken(cp)) {
        case T_ERR:
            return LEAVE(cp, unexpected(cp));

        case T_EOF:
            return LEAVE(cp, np);

        case T_USE:
        case T_REQUIRE:
            np = parsePragmas(cp, np);
            break;

        default:
            return LEAVE(cp, np);
        }

    } while (np);
    return LEAVE(cp, np);
}


/*
    Scan ahead and see if this is an annotatable directive
 */
static int isAttribute(EcCompiler *cp)
{
    int     i, tid;

    /*
        Assume we have just seen an ID. Handle the following patterns:
            nspace var
            nspace function
            nspace class
            nspace interface
            nspace let
            nspace const
            nspace type
            nspace namespace
            a.nspace namespace
            a.b.c.nspace::nspace namespace
     */
    for (i = 2; i < EC_MAX_LOOK_AHEAD + 2; i++) {
        peekAheadToken(cp, i);
        tid = cp->peekToken->tokenId;
        switch (tid) {
        case T_ATTRIBUTE:
        case T_CLASS:
        case T_CONST:
        case T_FUNCTION:
        case T_INTERFACE:
        case T_LET:
        case T_MUL:
        case T_NAMESPACE:
        case T_RESERVED_NAMESPACE:
        case T_TYPE:
        case T_VAR:
            return 1;

        case T_COLON_COLON:
        case T_DOT:
            break;

        default:
            return 0;
        }

        /*
            Just saw a "." or "::".  Make sure this is part of a PropertyName
         */
        tid = peekAheadToken(cp, ++i);
        if (tid != T_ID && tid != T_RESERVED_NAMESPACE && tid == T_MUL && tid != T_STRING && tid != T_NUMBER &&
                tid != T_LBRACKET && !(cp->peekToken->groupMask & G_RESERVED)) {
            return 0;
        }
    }
    return 0;
}


/*
    Directive -t,o- (372)
        EmptyStatement
        Statement
        AnnotatableDirective -t,o-

    Input
        #
        {
        break
        continue
        ?? DefaultXML
        do
        ?? Expressions
        for
        if
        label :
        let
        return
        switch
        throw
        try
        while
        with
        *
        internal, intrinsic, private, protected, public
        final, native, override, prototype, static
        [ attribute AssignmentExpression
        Identifier
        const
        let
        var
        function
        interface
        namespace
        type

    AST
        N_BLOCK
        N_CONTINUE
        N_BREAK
        N_FOR
        N_FOR_IN
        N_HASH
        N_IF
        N_SWITCH
        N_THROW
        N_TRY
        N_WHILE
 */
static EcNode *parseDirective(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    switch (peekToken(cp)) {
    case T_EOF:
        getToken(cp);
        return LEAVE(cp, 0);

    case T_ERR:
        getToken(cp);
        return LEAVE(cp, unexpected(cp));

    /* EmptyStatement */
    case T_SEMICOLON:
        np = parseEmptyStatement(cp);
        break;

    /* Statement */
    /*
        TBD -- missing:
            - DefaultXMLNamespaceStatement
            - ExpressionStatement
            - LabeledStatement
     */
    case T_LBRACE:
    case T_BREAK:
    case T_CONTINUE:
    case T_DELETE:
    case T_DO:
    case T_FOR:
    case T_HASH:
    case T_IF:
    case T_RETURN:
    case T_SUPER:
    case T_SWITCH:
    case T_THROW:
    case T_TRY:
    case T_WHILE:
    case T_WITH:
        np = parseStatement(cp);
        break;

    case T_ID:
        if (isAttribute(cp)) {
            np = parseAnnotatableDirective(cp, 0);
        } else {
            np = parseStatement(cp);
        }
        break;

    case T_RESERVED_NAMESPACE:
        if (peekAheadToken(cp, 2) == T_COLON_COLON) {
            np = parseStatement(cp);
            break;
        }
        /* Fall through */
                
    /* AnnotatableDirective */
    case T_ATTRIBUTE:
    case T_CLASS:
    case T_CONST:
    case T_FUNCTION:
    case T_INTERFACE:
    case T_LET:
    case T_MUL:
    case T_NAMESPACE:
    case T_TYPE:
    case T_MODULE:
    case T_VAR:
        np = parseAnnotatableDirective(cp, 0);
        break;

    case T_STRING:
        //  TDOO - should we test let ...?
        if (peekAheadToken(cp, 2) == T_VAR || peekAheadToken(cp, 2) == T_CLASS || peekAheadToken(cp, 2) == T_FUNCTION) {
            np = parseAnnotatableDirective(cp, 0);
        } else {
            np = parseStatement(cp);
        }
        break;

#if FUTURE
    /* IncludeDirective */
    case T_INCLUDE:
        np = parseIncludeStatement(cp);
        break;
#endif

    default:
        np = parseStatement(cp);
    }
    return LEAVE(cp, np);
}


/*
    AnnotatableDirective -global,o- (375)
        Attributes [no line break] AnnotatableDirective -t,o-
        VariableDefinition -allowin- Semicolon -o-
        FunctionDefinition -global-
        ClassDefinition
        InterfaceDefintion
        NamespaceDefinition Semicolon -o-
        TypeDefinition Semicolon
        PackageDefinition
        ModuleDefinition

    AnnotatableDirective -interface,o- (384)
        Attributes [no line break] AnnotatableDirective -t,o-
        FunctionDeclaration Semicolon -o-
        TypeDefinition Semicolon -o-

    AnnotatableDirective -t,o- (387)
        Attributes [no line break] AnnotatableDirective -t,o-
        VariableDefinition -allowin- Semicolon -o-
        FunctionDeclaration -t-
        NamespaceDefintion Semicolon -o-
        TypeDefinition Semicolon -o-

    Input
        internal, intrinsic, private, protected, public
        final, native, override, prototype, static
        [ attribute AssignmentExpression
        Identifier
        const
        let
        var
        function
        interface
        namespace
        type
        module
        package

    AST
        N_CLASS
        N_FUNCTION
        N_QNAME
        N_NAMESPACE
        N_VAR_DEFINITION
        N_MODULE??
 */
static EcNode *parseAnnotatableDirective(EcCompiler *cp, EcNode *attributes)
{
    EcState     *state;
    EcNode      *nextAttribute, *np;
    int         expectSemi;

    ENTER(cp);

    np = 0;
    expectSemi = 0;
    state = cp->state;

    switch (peekToken(cp)) {

    /* Attributes AnnotatableDirective */
    case T_STRING:
    case T_ATTRIBUTE:
    case T_RESERVED_NAMESPACE:
    case T_ID:
        nextAttribute = parseAttribute(cp);
        if (nextAttribute) {
            getToken(cp);
            putToken(cp);
            if (nextAttribute->lineNumber < cp->token->lineNumber) {
                /* Must be no line break after the attribute */
                return LEAVE(cp, unexpected(cp));
            }

            /*
                Aggregate the attributes and pass in. Must do this to allow "private static var a, b, c"
             */
            if (attributes) {
                nextAttribute->attributes |= attributes->attributes;
                if (attributes->qname.space && nextAttribute->qname.space) {
                    return LEAVE(cp, parseError(cp, "Can't define multiple namespaces for directive"));
                }
                if (attributes->qname.space) {
                    nextAttribute->qname.space = mprStrdup(nextAttribute, attributes->qname.space);
                }
            }
            np = parseAnnotatableDirective(cp, nextAttribute);
        }
        break;


    case T_CONST:
    case T_LET:
    case T_VAR:
        np = parseVariableDefinition(cp, attributes);
        expectSemi++;
        break;

    case T_FUNCTION:
        if (state->inInterface) {
            np = parseFunctionDeclaration(cp, attributes);
        } else {
            np = parseFunctionDefinition(cp, attributes);
        }
        break;

    case T_CLASS:
        if (state->inClass == 0) {
            /* Nested classes are not supported */
            np = parseClassDefinition(cp, attributes);
        } else {
            getToken(cp);
            np = unexpected(cp);
        }
        break;

    case T_INTERFACE:
        if (state->inClass == 0) {
            np = parseInterfaceDefinition(cp, attributes);
        } else {
            np = unexpected(cp);
        }
        break;

    case T_NAMESPACE:
        np = parseNamespaceDefinition(cp, attributes);
        expectSemi++;
        break;

    case T_TYPE:
        np = parseTypeDefinition(cp, attributes);
        expectSemi++;
        break;

    case T_MODULE:
        np = parseModuleDefinition(cp);
        break;

    default:
        getToken(cp);
        np = parseError(cp, "Unknown directive \"%s\"", cp->token->text);
    }

    if (np && expectSemi) {
        if (getToken(cp) != T_SEMICOLON) {
            if (np->lineNumber < cp->token->lineNumber || cp->token->tokenId == T_EOF) {
                putToken(cp);
            } else if (cp->token->tokenId != T_NOP) {
                np = unexpected(cp);
            }
        }
    }
    return LEAVE(cp, np);
}


/*
    Attribute -global- (391)
        NamespaceAttribute
        dynamic
        final
        native
        [ AssignmentExpression allowList,allowIn]

    Attribute -class- (396)
        NamespaceAttribute
        final
        native
        override
        prototype
        static
        [ AssignmentExpression allowList,allowIn]

    Attribute -interface- (419)
        NamespaceAttribute

    Attribute -local- (420)
        NamespaceAttribute

    Input -common-
        NamespaceAttribute
            Path . Identifier
            Identifier
            public
            internal
        final
        native
        [

    Input -global-
        NamespaceAttribute -global-
            intrinsic
        dynamic

    Input -class-
        NamespaceAttribute -class-
            intrinsic
            private
            protected
        override
        prototype
        static

    AST
        N_ATTRIBUTES
            attribute
                flags
            attributes
 */
static EcNode *parseAttribute(EcCompiler *cp)
{
    EcNode      *np;
    EcState     *state;
    int         inClass, subId;

    ENTER(cp);

    state = cp->state;
    np = 0;
    inClass = (cp->state->inClass) ? 1 : 0;

    if (state->currentFunctionNode /* || inInterface */) {
        np = parseNamespaceAttribute(cp);
        return LEAVE(cp, np);
    }

    peekToken(cp);
    subId = cp->peekToken->subId;
    switch (cp->peekToken->tokenId) {
    case T_ID:
    case T_RESERVED_NAMESPACE:
    case T_STRING:
        if (!inClass && (subId == T_PRIVATE || subId ==  T_PROTECTED)) {
            getToken(cp);
            return LEAVE(cp, parseError(cp, "Can't use private or protected in this context"));
        }
        np = parseNamespaceAttribute(cp);
        break;

    case T_ATTRIBUTE:
        getToken(cp);
        np = createNode(cp, N_ATTRIBUTES);
        switch (cp->token->subId) {
        case T_DYNAMIC:
            if (inClass) {
                np = unexpected(cp);
            } else {
                np->attributes |= EJS_TYPE_DYNAMIC_INSTANCE;
            }
            break;

        case T_FINAL:
            np->attributes |= EJS_TYPE_FINAL;
            break;

        case T_NATIVE:
            np->attributes |= EJS_PROP_NATIVE;
            break;

        case T_OVERRIDE:
            if (inClass) {
                np->attributes |= EJS_FUN_OVERRIDE;
            } else {
                np = unexpected(cp);
            }
            break;

#if FUTURE
        case T_PROTOTYPE:
            if (inClass) {
                np->attributes |= EJS_ATTR_PROTOTYPE;
            } else {
                np = unexpected(cp);
            }
            break;
#endif

        case T_SHARED:
            np->attributes |= EJS_PROP_SHARED;
            break;

        case T_STATIC:
            if (inClass) {
                np->attributes |= EJS_PROP_STATIC;
            } else {
                np = unexpected(cp);
            }
            break;

        case T_ENUMERABLE:
            np->attributes |= EJS_PROP_ENUMERABLE;
            break;

        default:
            np = parseError(cp, "Unknown or invalid attribute in this context %s", cp->token->text);
        }
        break;

    case T_LBRACKET:
        np = appendNode(np, parseAssignmentExpression(cp));
        break;

    default:
        np = parseError(cp, "Unknown or invalid attribute in this context %s", cp->token->text);
        break;
    }
    return LEAVE(cp, np);
}


/*
    NamespaceAttribute -global- (405)
        public
        internal
        intrinsic
        PrimaryName

    NamespaceAttribute -class- (409)
        ReservedNamespace
        PrimaryName

    Input -common-
        Identifier
        internal
        public

    Input -global-
        intrinsic

    Input -class-
        intrinsic
        private
        protected

    AST
        N_ATTRIBUTES
            attribute
                flags
            left: N_QNAME | N_DOT
 */
static EcNode *parseNamespaceAttribute(EcCompiler *cp)
{
    EcNode      *np, *qualifier;
    int         inClass, subId;

    ENTER(cp);

    inClass = (cp->state->inClass) ? 1 : 0;

    peekToken(cp);
    subId = cp->peekToken->subId;

    np = createNode(cp, N_ATTRIBUTES);
    np->lineNumber = cp->peekToken->lineNumber;

    switch (cp->peekToken->tokenId) {
    case T_RESERVED_NAMESPACE:
        if (!inClass && (subId == T_PRIVATE || subId ==  T_PROTECTED)) {
            return LEAVE(cp, unexpected(cp));
        }
        qualifier = parseReservedNamespace(cp);
        np->attributes = qualifier->attributes;
        np->specialNamespace = qualifier->specialNamespace;
        np->qname.space = mprStrdup(np, qualifier->qname.space);
        break;

    case T_ID:
        qualifier = parsePrimaryName(cp);
        if (qualifier->kind == N_QNAME) {
            np->attributes = qualifier->attributes;
            np->qname.space = mprStrdup(np, qualifier->qname.name);
        } else {
            /*
                This is a N_DOT expression compile-time constant expression.
             */
            mprAssert(0);
#if UNUSED
            np->qualifierNode = linkNode(np, qualifier);
#endif
        }
        break;

    case T_STRING:
        getToken(cp);
        np->qname.space = mprStrdup(np, (char*) cp->token->text);
        np->literalNamespace = 1;
        break;

    case T_ATTRIBUTE:
        getToken(cp);
        np = parseError(cp, "Attribute \"%s\" not supported on local variables", cp->token->text);
        break;

    default:
        np = unexpected(cp);
        break;
    }
    return LEAVE(cp, np);
}


/*
    VariableDefinition -b- (411)
        VariableDefinitionKind VariableBindingList -allowList,b-

    Input
        const
        let
        let const
        var

    AST
        N_VAR_DEFINITION
            def: varKind
 */
static EcNode *parseVariableDefinition(EcCompiler *cp, EcNode *attributes)
{
    EcNode      *np;

    ENTER(cp);
    np = parseVariableDefinitionKind(cp, attributes);
    np = parseVariableBindingList(cp, np, attributes);
    return LEAVE(cp, np);
}


/*
    VariableDefinitionKind (412)
        const
        let
        let const
        var

    Input

    AST
        N_VAR_DEFINITION
            def: varKind
 */
static EcNode *parseVariableDefinitionKind(EcCompiler *cp, EcNode *attributes)
{
    EcNode      *np;

    ENTER(cp);

    np = createNode(cp, N_VAR_DEFINITION);
    setNodeDoc(cp, np);

    switch (getToken(cp)) {
    case T_CONST:
        np->def.varKind = KIND_CONST;
        np->attributes |= EJS_TRAIT_READONLY;
        break;

    case T_LET:
        if (attributes && attributes->attributes & EJS_PROP_STATIC) {
            np = parseError(cp, "Static and let are not a valid combination. Use var instead.");

        } else {
            np->def.varKind = KIND_LET;
            if (peekToken(cp) == T_CONST) {
                np->def.varKind |= KIND_CONST;
                np->attributes |= EJS_TRAIT_READONLY;
            }
        }
        break;

    case T_VAR:
        np->def.varKind = KIND_VAR;
        break;

    default:
        np = parseError(cp, "Bad variable definition kind");
    }
    return LEAVE(cp, np);
}


/*
    VariableBindingList -a,b- (416)
        VariableBinding
        VariableBindingList -noList,b- , VariableBinding -a,b-

    Input

    AST
 */
static EcNode *parseVariableBindingList(EcCompiler *cp, EcNode *varList, EcNode *attributes)
{
    ENTER(cp);

    varList = appendNode(varList, parseVariableBinding(cp, varList, attributes));

    while (peekToken(cp) == T_COMMA) {
        getToken(cp);
        varList = appendNode(varList, parseVariableBinding(cp, varList, attributes));
    }
    return LEAVE(cp, varList);
}


/*
    VariableBinding -a,b- (418)
        TypedIdentifier (258)
        TypedPattern (260) -noList,noIn- VariableInitialisation -a,b-

    TypedIdentifier (258)
        SimplePattern -noList,noin,noExpr-
        SimplePattern -a,b,noExpr- : TypeExpression

    TypedPattern (260)
        SimplePattern -a,b,noExpr-
        SimplePattern -a,b,noExpr- : NullableTypeExpression
        ObjectPattern -noExpr-
        ObjectPattern -noExpr- : TypeExpression
        ArrayPattern -noExpr-
        ArrayPattern -noExpr- : TypeExpression

    Input

    AST
        N_QNAME variableId
        N_ASSIGN
            left: N_QNAME variableId
            right: N_LITERAL

 */
static EcNode *parseVariableBinding(EcCompiler *cp, EcNode *varList, EcNode *attributes)
{
    EcNode      *np, *parent;

    ENTER(cp);

    np = 0;

    switch (peekToken(cp)) {
    case T_LBRACKET:
        getToken(cp);
        unexpected(cp);
        break;

    case T_LBRACE:
        getToken(cp);
        unexpected(cp);
        break;

    default:
        np = parseTypedIdentifier(cp);
        if (np == 0) {
            return LEAVE(cp, np);
        }
        if (np->kind != N_QNAME) {
            return LEAVE(cp, parseError(cp, "Bad variable name"));
        }
        //  Accumulate CONST attributes
        np->attributes |= varList->attributes;
        applyAttributes(cp, np, attributes, 0);
        copyDocString(cp, np, varList);

        if (STRICT_MODE(cp)) {
            if (np->typeNode == 0) {
                parseError(cp, "Variable untyped. Variables must be typed when declared in strict mode");
                np = ecResetError(cp, np, 0);
                /* Keep parsing */
            }
        }
        if (peekToken(cp) == T_ASSIGN) {
            parent = createNode(cp, N_ASSIGN_OP);
            np = createAssignNode(cp, np, parseVariableInitialisation(cp), parent);
        }
        break;
    }
    return LEAVE(cp, np);
}


/*
    VariableInitialisation -a,b- (426)
        = AssignmentExpression -a,b-

    Input
        =

    AST
        N_EXPRESSIONS
 */
static EcNode *parseVariableInitialisation(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    if (getToken(cp) == T_ASSIGN) {
        np = parseAssignmentExpression(cp);
    } else {
        np = unexpected(cp);
    }
    return LEAVE(cp, np);
}


/*
    FunctionDeclaration (421)                                   # For interfaces
        function FunctionName FunctionSignature

    Notes:
        This is for function declarations in interfaces only.

    Input
        function

    AST
        N_FUNCTION
            function: name, getter, setter, block,
                children: parameters
 */
static EcNode *parseFunctionDeclaration(EcCompiler *cp, EcNode *attributes)
{
    EcNode      *np;
    int         tid;

    ENTER(cp);

    cp->state->defaultNamespace = NULL;

    if (getToken(cp) != T_FUNCTION) {
        return LEAVE(cp, parseError(cp, "Expecting \"function\""));
    }

    tid = peekToken(cp);
    if (tid != T_ID && tid != T_GET && tid != T_SET) {
        getToken(cp);
        return LEAVE(cp, parseError(cp, "Expecting function or class name"));
    }

    np = parseFunctionName(cp);
    if (np) {
        setNodeDoc(cp, np);
        applyAttributes(cp, np, attributes, 0);
        np = parseFunctionSignature(cp, np);
        if (np) {
            np->function.isMethod = 1;
            if (STRICT_MODE(cp)) {
                if (np->function.resultType == 0) {
                    np = parseError(cp, 
                        "Function has not defined a return type. Fuctions must be typed when declared in strict mode");
                }
            }
        }
    }

    return LEAVE(cp, np);
}


/*
    FunctionDefinition -class- (424)
        function ClassName ConstructorSignature FunctionBody -allowin-
        function FunctionName FunctionSignature FunctionBody -allowin-

    FunctionDeclaration -t- (442)
        function FunctionName FunctionSignature FunctionBody -allowin-
        let function FunctionName FunctionSignature FunctionBody -allowin-
        const function FunctionName FunctionSignature FunctionBody -allowin-

    Input
        function
        let
        const

    AST N_FUNCTION
        function: name, getter, setter, block,
            children: parameters
 */
static EcNode *parseFunctionDefinition(EcCompiler *cp, EcNode *attributeNode)
{
    EcNode      *np, *className;
    EcState     *state;

    ENTER(cp);

    state = cp->state;
    state->defaultNamespace = NULL;

    if (getToken(cp) != T_FUNCTION) {
        return LEAVE(cp, parseError(cp, "Expecting \"function\""));
    }
    if (getToken(cp) != T_ID && !(cp->token->groupMask & (G_CONREV | G_OPERATOR))) {
        return LEAVE(cp, parseError(cp, "Expecting function or class name"));
    }
    if (cp->state->currentClassName.name && strcmp(cp->state->currentClassName.name, (char*) cp->token->text) == 0) {
        /*
            Constructor
         */
        putToken(cp);
        np = createNode(cp, N_FUNCTION);
        setNodeDoc(cp, np);
        applyAttributes(cp, np, attributeNode, EJS_PUBLIC_NAMESPACE);
        className = parseClassName(cp);

        if (className) {
            np->qname.name = mprStrdup(np, className->qname.name);
            np->function.isConstructor = 1;
            cp->state->currentClassNode->klass.constructor = np;
        }
        if (np) {
            np = parseConstructorSignature(cp, np);
            if (np) {
                cp->state->currentFunctionNode = np;
                if (!(np->attributes & EJS_PROP_NATIVE)) {
                    np->function.body = linkNode(np, parseFunctionBody(cp, np));
                    mprStealBlock(np, np->function.body);
                    if (np->function.body == 0) {
                        return LEAVE(cp, 0);
                    }
                }
                np->function.isMethod = 1;
            }
        }

    } else {
        putToken(cp);
        np = parseFunctionName(cp);
        if (np) {
            setNodeDoc(cp, np);
            applyAttributes(cp, np, attributeNode, 0);
            np = parseFunctionSignature(cp, np);
            if (np) {
                cp->state->currentFunctionNode = np;
                if (attributeNode && (attributeNode->attributes & EJS_PROP_NATIVE)) {
                    if (peekToken(cp) == T_LBRACE) {
                        return LEAVE(cp, parseError(cp, "Native functions declarations must not have bodies"));
                    }

                } else {
#if UNUSED
                    if (peekToken(cp) != T_LBRACE) {
                        np->function.noBlock = 1;
                    }
#endif
                    np->function.body = linkNode(np, parseFunctionBody(cp, np));
                    if (np->function.body == 0) {
                        return LEAVE(cp, 0);
                    }
                }
                if (state->inClass && !state->inFunction && 
                        cp->classState->blockNestCount == (cp->state->blockNestCount - 1)) {
                    np->function.isMethod = 1;
                }
            }

            if (STRICT_MODE(cp)) {
                if (np->function.resultType == 0) {
                    parseError(cp, "Function has not defined a return type. Functions must be typed in strict mode");
                    np = ecResetError(cp, np, 0);
                    /* Keep parsing */
                }
            }
        }
    }
    return LEAVE(cp, np);
}


/*
    FunctionName (427)
        Identifier
        OverloadedOperator
        get Identifier
        set Identifier

    Input
        Identifier
        get
        set
        + - ~ * / % < > <= >= == << >> >>> & | === != !==

    AST N_FUNCTION
        function: name, getter, setter
 */
static EcNode *parseFunctionName(EcCompiler *cp)
{
    EcNode      *name, *np;
    int         accessorId, tid;

    ENTER(cp);

    tid = peekToken(cp);
    if (tid != T_GET && tid != T_SET) {
        if (cp->peekToken->groupMask & G_CONREV) {
            tid = T_ID;
        }
    }

    switch (tid) {
    case T_GET:
    case T_SET:
    case T_DELETE:
        getToken(cp);
        accessorId = cp->token->tokenId;

        tid = peekToken(cp);
        if (cp->peekToken->groupMask & G_CONREV) {
            tid = T_ID;
        }
        if (tid == T_LPAREN) {
            /*
                Function is called get() or set(). So put back the name and fall through to T_ID
             */
            putToken(cp);

        } else {
            if (tid != T_ID) {
                getToken(cp);
                return LEAVE(cp, parseError(cp, "Expecting identifier"));
            }
            name = parseIdentifier(cp);
            np = createNode(cp, N_FUNCTION);
            if (accessorId == T_GET) {
                np->function.getter = 1;
                np->attributes |= EJS_TRAIT_GETTER;
            } else {
                np->function.setter = 1;
                np->attributes |= EJS_TRAIT_SETTER;
            }
            np->qname.name = mprStrdup(np, name->qname.name);
            break;
        }
        /* Fall through */

    case T_ID:
        name = parseIdentifier(cp);
        np = createNode(cp, N_FUNCTION);
        np->qname.name = mprStrdup(np, name->qname.name);
        break;

    default:
        getToken(cp);
        if (cp->token->groupMask == G_OPERATOR) {
            putToken(cp);
            np = parseOverloadedOperator(cp);
        } else {
            np = unexpected(cp);
        }
    }
    return LEAVE(cp, np);
}


/*
    OverloadedOperator (431)
        + - ~ * / % < > <= >= == << >> >>> & | === != !==

    Input
        + - ~ * / % < > <= >= == << >> >>> & | === != !==
        [ . (  =        EJS exceptions

    AST
        N_QNAME
 */
static EcNode *parseOverloadedOperator(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    switch (getToken(cp)) {
    /*
        EJS extensions
     */
    case T_LBRACKET:
    case T_LPAREN:
    case T_DOT:
    case T_ASSIGN:
        /* Fall through */

    case T_PLUS:
    case T_MINUS:
    case T_TILDE:
    case T_MUL:
    case T_DIV:
    case T_MOD:
    case T_LT:
    case T_GT:
    case T_LE:
    case T_GE:
    case T_EQ:
    case T_LSH:
    case T_RSH:
    case T_RSH_ZERO:
    case T_BIT_AND:
    case T_BIT_OR:
    case T_STRICT_EQ:
    case T_NE:
    case T_STRICT_NE:
        /* Node holds the token */
        np = createNode(cp, N_FUNCTION);
        np->qname.name = mprStrdup(np, (char*) cp->token->text);
        break;

    default:
        np = unexpected(cp);
        break;
    }

    return LEAVE(cp, np);
}


/*
    FunctionSignature (450) (See also FunctionSignatureType)
        TypeParameters ( Parameters ) ResultType
        TypeParameters ( this : PrimaryName ) ResultType
        TypeParameters ( this : PrimaryName , NonemptyParameters )
                ResultType

    Input
        .< TypeParameterList >

    AST
 */
static EcNode *parseFunctionSignature(EcCompiler *cp, EcNode *np)
{
    EcNode      *parameters;

    if (np == 0) {
        return np;
    }
    ENTER(cp);
    mprAssert(np->kind == N_FUNCTION);

    if (getToken(cp) != T_LPAREN) {
        return LEAVE(cp, parseError(cp, "Expecting \"(\""));
    }
    np->function.parameters = linkNode(np, createNode(cp, N_ARGS));

    //  TODO - should accep
    if (peekToken(cp) == T_ID || cp->peekToken->tokenId == T_ELIPSIS || cp->peekToken->groupMask & G_CONREV) {
        if (strcmp((char*) cp->peekToken->text, "this") == 0) {
            ;
        } else {
            parameters = parseParameters(cp, np->function.parameters);
            if (parameters == 0) {
                while (getToken(cp) != T_RPAREN && cp->token->tokenId != T_EOF);
                return LEAVE(cp, 0);
            }
            np->function.parameters = linkNode(np, parameters);
        }
    }
    if (getToken(cp) != T_RPAREN) {
        return LEAVE(cp, parseError(cp, "Expecting \")\""));
    }

    if (np) {
        if (peekToken(cp) == T_COLON) {
            np->function.resultType = linkNode(np, parseResultType(cp));
        }
    }
    return LEAVE(cp, np);
}


#if UNUSED
/*
    TypeParameters (453)
        EMPTY
        .< TypeParameterList >
    Input

    AST
 */
static EcNode *parseTypeParameters(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}


/*
    TypeParametersList (455)
        Identifier
        Identifier , TypeParameterList

    Input

    AST
 */
static EcNode *parseTypeParameterList(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}
#endif


/*
    Parameters (457)
        EMPTY
        NonemptyParameters

    Input

    AST
 */
static EcNode *parseParameters(EcCompiler *cp, EcNode *args)
{
    ENTER(cp);

    if (peekToken(cp) != T_RPAREN) {
        args = parseNonemptyParameters(cp, args);
    }
    return LEAVE(cp, args);
}


/*
    NonemptyParameters (459)
        ParameterInit
        ParameterInit , NonemptyParameters
        RestParameter

    Input
        Identifier
        ...

    AST
        N_ARGS
            N_VAR_DEFN
                N_QNAME
                N_ASSIGN_OP
                    N_QNAME, N_LITERAL

 */
static EcNode *parseNonemptyParameters(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);

    if (peekToken(cp) == T_ELIPSIS) {
        np = appendNode(np, parseRestParameter(cp));

    } else {
        np = appendNode(np, parseParameterInit(cp, np));
        if (np) {
            if (peekToken(cp) == T_COMMA) {
                getToken(cp);
                np = parseNonemptyParameters(cp, np);
            }
        }
    }
    return LEAVE(cp, np);
}


/*
    ParameterInit (462)
        Parameter
        Parameter = NonAssignmentExpression -noList,allowIn-

    Input

    AST
 */
static EcNode *parseParameterInit(EcCompiler *cp, EcNode *args)
{
    EcNode      *np, *assignOp, *lastArg;

    ENTER(cp);

    np = parseParameter(cp, 0);

    if (peekToken(cp) == T_ASSIGN) {
        getToken(cp);
        /*
            Insert a N_ASSIGN_OP node under the VAR_DEFN
         */
        assignOp = createNode(cp, N_ASSIGN_OP);
        assignOp = appendNode(assignOp, np->left);
        mprAssert(mprGetListCount(np->children) == 1);
        mprRemoveItem(np->children, mprGetItem(np->children, 0));
        assignOp = appendNode(assignOp, parseNonAssignmentExpression(cp));
        np = appendNode(np, assignOp);

        if (assignOp) {
            appendDocString(cp, args->parent, assignOp->left, assignOp->right);
        }

    } else if (args->children) {
        lastArg = (EcNode*) mprGetLastItem(args->children);
        if (lastArg && lastArg->left->kind == N_ASSIGN_OP) {
            np = parseError(cp, "Cannot have required parameters after parameters with initializers");
        }
    }
    return LEAVE(cp, np);
}


/*
    Parameter (464)
        ParameterKind TypedPattern -noList,noIn-

    Input

    AST
 */
static EcNode *parseParameter(EcCompiler *cp, bool rest)
{
    EcNode      *np, *parameter;

    ENTER(cp);

    np = parseParameterKind(cp);
    parameter = parseTypedPattern(cp);
    np = appendNode(np, parameter);

    if (parameter) {
        if (STRICT_MODE(cp)) {
            if (parameter->typeNode == 0 && !rest) {
                parseError(cp, "Parameter untyped. Parameters must be typed when declared in strict mode.");
                np = ecResetError(cp, np, 0);
                /* Keep parsing */
            }
        }
    }
    return LEAVE(cp, np);
}


/*
    ParameterKind (465)
        EMPTY
        const

    Input

    AST
 */
static EcNode *parseParameterKind(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    np = createNode(cp, N_VAR_DEFINITION);

    if (peekToken(cp) == T_CONST) {
        getToken(cp);
        np->def.varKind = KIND_CONST;
        np->attributes |= EJS_TRAIT_READONLY;
    }
    return LEAVE(cp, np);
}


/*
    RestParameter (467)
        ...
        ... Parameter

    Input

    AST
 */
static EcNode *parseRestParameter(EcCompiler *cp)
{
    EcNode      *np, *varNode;

    ENTER(cp);

    if (getToken(cp) == T_ELIPSIS) {
        np = parseParameter(cp, 1);
        if (np && np->left) {
            if (np->left->kind == N_QNAME) {
                varNode = np->left;
            } else if (np->left->kind == N_ASSIGN_OP) {
                varNode = np->left->left;
            } else {
                varNode = 0;
                mprAssert(0);
            }
            if (varNode) {
                mprAssert(varNode->kind == N_QNAME);
                varNode->name.isRest = 1;
            }
        }

    } else {
        np = unexpected(cp);
    }
    return LEAVE(cp, np);
}


/*
    ResultType (469)
        EMPTY
        : void
        : NullableTypeExpression

    Input

    AST
        N_DOT
        N_QNAME
        N_VOID

    NOTE: we do not handle EMPTY here. Caller must handle.
 */
static EcNode *parseResultType(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    if (peekToken(cp) == T_COLON) {
        getToken(cp);
        if (peekToken(cp) == T_VOID) {
            getToken(cp);
            np = createNode(cp, N_QNAME);
            setId(np, "Void");
            np->name.isType = 1;

        } else {
            np = parseNullableTypeExpression(cp);
        }

    } else {
        /*  Don't handle EMPTY here */
        mprAssert(0);
        np = unexpected(cp);;
    }
    return LEAVE(cp, np);
}


/*
    ConstructorSignature (472)
        TypeParameters ( Parameters )
        TypeParameters ( Parameters ) : ConstructorInitializer

    Input

    AST
 */
static EcNode *parseConstructorSignature(EcCompiler *cp, EcNode *np)
{
    if (np == 0) {
        return np;
    }

    ENTER(cp);

    mprAssert(np->kind == N_FUNCTION);

    if (getToken(cp) != T_LPAREN) {
        return LEAVE(cp, parseError(cp, "Expecting \"(\""));
    }

    np->function.parameters = linkNode(np, createNode(cp, N_ARGS));
    np->function.parameters =
        linkNode(np, parseParameters(cp, np->function.parameters));

    if (getToken(cp) != T_RPAREN) {
        return LEAVE(cp, parseError(cp, "Expecting \")\""));
    }

    if (np) {
        if (peekToken(cp) == T_COLON) {
            getToken(cp);
            np->function.constructorSettings = linkNode(np, parseConstructorInitializer(cp));
            // mprStealBlock(np, np->function.settings);
        }
    }

    return LEAVE(cp, np);
}


/*
    ConstructorInitializer (462)
        InitializerList
        InitializerList SuperInitializer
        SuperInitializer

    Input
        TDB
        super

    AST
        N_DIRECTIVES
 */
static EcNode *parseConstructorInitializer(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    np = createNode(cp, N_DIRECTIVES);

    if (peekToken(cp) != T_SUPER) {
        np = parseInitializerList(cp, np);
    }
    if (peekToken(cp) == T_SUPER) {
        np = appendNode(np, parseSuperInitializer(cp));
    }
    return LEAVE(cp, np);
}


/*
    InitializerList (465)
        Initializer
        InitializerList , Initializer

    Input
        TBD

    AST
        N_DIRECTIVES
 */
static EcNode *parseInitializerList(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);

    mprAssert(np && np->kind == N_DIRECTIVES);

    while (1) {
        np = appendNode(np, parseInitializer(cp));
        if (peekToken(cp) == T_COMMA) {
            getToken(cp);
        } else {
            break;
        }
    }
    return LEAVE(cp, np);
}


/*
    Initializer (467)
        Pattern -noList,noIn,noExpr- VariableInitialisation -nolist,allowIn-

    Input
        TBD

    AST
        N_ASSIGN
 */
static EcNode *parseInitializer(EcCompiler *cp)
{
    EcNode      *np, *parent;

    ENTER(cp);

    np = parsePattern(cp);

    if (peekToken(cp) != T_ASSIGN) {
        return LEAVE(cp, expected(cp, "="));
    }
    parent = createNode(cp, N_ASSIGN_OP);
    np = createAssignNode(cp, np, parseVariableInitialisation(cp), parent);
    return LEAVE(cp, np);
}


/*
    SuperInitializer (481)
        super Arguments

    Input
        super

    AST
        N_SUPER
 */
static EcNode *parseSuperInitializer(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    if (getToken(cp) != T_SUPER) {
        return LEAVE(cp, expected(cp, "super"));
    }
    np = createNode(cp, N_SUPER);

    np = appendNode(np, parseArguments(cp));
    return LEAVE(cp, np);
}


/*
    FunctionBody -b- (469)
        Block -local-
        AssignmentExpression -b-

    Input
        {
        (

    AST
 */
static EcNode *parseFunctionBody(EcCompiler *cp, EcNode *fun)
{
    EcNode      *np, *end, *ret;

    ENTER(cp);

    cp->state->inFunction = 1;
    cp->state->namespace = EJS_PRIVATE_NAMESPACE;

    if (peekToken(cp) == T_LBRACE) {
        np = parseBlock(cp);
        if (np) {
            np = np->left;
        }

    } else {
        /*
            Create a return for block-less functions
         */
        np = createNode(cp, N_DIRECTIVES);
        ret = createNode(cp, N_RETURN);
        ret->ret.blockLess = 1;
        ret = appendNode(ret, parseAssignmentExpression(cp));
        np = appendNode(np, ret);
    }
    if (np) {
        end = createNode(cp, N_END_FUNCTION);
        np = appendNode(np, end);
    }
    return LEAVE(cp, np);
}


/*
    ClassDefinition (484)
        class ClassName ClassInheritance ClassBody

    Input
        class id ...

    AST
        N_CLASS
            name
                id
            extends: id

 */
static EcNode *parseClassDefinition(EcCompiler *cp, EcNode *attributeNode)
{
    EcState     *state;
    EcNode      *np, *classNameNode, *inheritance, *constructor;
    int         tid;

    ENTER(cp);

    state = cp->state;

    if (getToken(cp) != T_CLASS) {
        return LEAVE(cp, expected(cp, "class"));
    }

    if (peekToken(cp) != T_ID) {
        getToken(cp);
        return LEAVE(cp, expected(cp, "identifier"));
    }

    np = createNode(cp, N_CLASS);
    state->currentClassNode = np;
    state->topVarBlockNode = np;
    cp->classState = state;
    state->defaultNamespace = NULL;

    classNameNode = parseClassName(cp);
    if (classNameNode == 0) {
        return LEAVE(cp, 0);
    }

    applyAttributes(cp, np, attributeNode, 0);
    setNodeDoc(cp, np);

    np->qname.name = mprStrdup(np, classNameNode->qname.name);
    state->currentClassName = np->qname;
    state->inClass = 1;

    tid = peekToken(cp);
    if (tid == T_EXTENDS || tid == T_IMPLEMENTS) {
        inheritance = parseClassInheritance(cp);
        if (inheritance->klass.extends) {
            np->klass.extends = mprStrdup(np, inheritance->klass.extends);
        }
        if (inheritance->klass.implements) {
            np->klass.implements = inheritance->klass.implements;
            mprStealBlock(np, np->klass.implements);
        }
    }

    if (peekToken(cp) != T_LBRACE) {
        getToken(cp);
        return LEAVE(cp, expected(cp, "{"));
    }

    np = appendNode(np, parseClassBody(cp));

    if (np && np->klass.constructor == 0) {
        /*
            Create a default constructor because the user did not supply a constructor. We always
            create a constructor node even if one is not required (or generated). This makes binding easier later.
         */
        constructor = createNode(cp, N_FUNCTION);
        np->klass.constructor = linkNode(np, constructor);
        constructor->qname.name = mprStrdup(np, np->qname.name);
        applyAttributes(cp, constructor, 0, EJS_PUBLIC_NAMESPACE);
        constructor->function.isConstructor = 1;
        constructor->function.isDefaultConstructor = 1;
    }
    return LEAVE(cp, np);
}


/*
    ClassName (485)
        ParameterisedTypeName
        ParameterisedTypeName !
    Input

    AST
 */
static EcNode *parseClassName(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    np = parseParameterisedTypeName(cp);
    if (peekToken(cp) == T_LOGICAL_NOT) {
        getToken(cp);
    }
    return LEAVE(cp, np);
}


/*
    ParameterisedTypeName (487)
        Identifier
        Identifier TypeParameters

    Input

    AST
 */
static EcNode *parseParameterisedTypeName(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    if (peekToken(cp) != T_ID) {
        getToken(cp);
        return LEAVE(cp, expected(cp, "identifier"));
    }
    np = parseIdentifier(cp);

#if FUTURE
    if (peekToken(cp) == T_DOT_LESS) {
        np = parseTypeParameters(cp);
    }
#endif
    return LEAVE(cp, np);
}


/*
    ClassInheritance (489)
        EMPTY
        extends PrimaryName
        implements TypeIdentifierList
        extends PrimaryName implements TypeIdentifierList

    Input

    AST N_CLASS
        extends: id
        left: implements list if ids
 */
static EcNode *parseClassInheritance(EcCompiler *cp)
{
    EcNode      *np, *id;

    ENTER(cp);

    np = createNode(cp, N_CLASS);

    switch (getToken(cp)) {
    case T_EXTENDS:
        id = parsePrimaryName(cp);
        if (id) {
            np->klass.extends = mprStrdup(np, id->qname.name);
        }
        if (peekToken(cp) == T_IMPLEMENTS) {
            getToken(cp);
            np->klass.implements = linkNode(np, parseTypeIdentifierList(cp));
            mprStealBlock(np, np->klass.implements);
        }
        break;

    case T_IMPLEMENTS:
        np->klass.implements = linkNode(np, parseTypeIdentifierList(cp));
        mprStealBlock(np, np->klass.implements);
        break;

    default:
        putToken(cp);
        break;
    }
    return LEAVE(cp, np);
}


/*
    TypeIdentifierList (493)
        PrimaryName
        PrimaryName , TypeIdentifierList

    Input

    AST
 */
static EcNode *parseTypeIdentifierList(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    np = createNode(cp, N_TYPE_IDENTIFIERS);
    while (peekToken(cp) == T_ID) {
        np = appendNode(np, parsePrimaryName(cp));
        if (peekToken(cp) != T_COMMA) {
            break;
        }
        getToken(cp);
    }

    /*
        Discard the first NOP node
     */
    return LEAVE(cp, np);
}


/*
    ClassBody (495)
        Block -class-

    Input

    AST
 */
static EcNode *parseClassBody(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    if (peekToken(cp) != T_LBRACE) {
        getToken(cp);
        return LEAVE(cp, expected(cp, "class body { }"));
    }

    np = parseBlock(cp);
    if (np) {
        np = np->left;
        mprAssert(np->kind == N_DIRECTIVES);
    }

    return LEAVE(cp, np);
}


/*
    InterfaceDefinition (496)
        interface ClassName InterfaceInheritance InterfaceBody

    Input

    AST
 */
static EcNode *parseInterfaceDefinition(EcCompiler *cp, EcNode *attributeNode)
{
    EcState     *state;
    EcNode      *np, *classNameNode, *inheritance;

    ENTER(cp);
    
    state = cp->state;

    np = 0;
    if (getToken(cp) != T_INTERFACE) {
        return LEAVE(cp, expected(cp, "interface"));
    }
    
    if (peekToken(cp) != T_ID) {
        getToken(cp);
        return LEAVE(cp, expected(cp, "identifier"));
    }

    np = createNode(cp, N_CLASS);
    state->currentClassNode = np;
    state->topVarBlockNode = np;
    cp->classState = state;
    state->defaultNamespace = NULL;
    
    classNameNode = parseClassName(cp);
    if (classNameNode == 0) {
        return LEAVE(cp, 0);
    }

    applyAttributes(cp, np, attributeNode, 0);
    setNodeDoc(cp, np);
    
    np->qname.name = mprStrdup(np, classNameNode->qname.name);
    np->klass.isInterface = 1;
    state->currentClassName.name = np->qname.name;
    state->inInterface = 1;
    
    if (peekToken(cp) == T_EXTENDS) {
        inheritance = parseInterfaceInheritance(cp);
        if (inheritance->klass.extends) {
            np->klass.extends = mprStrdup(np, inheritance->klass.extends);
        }
    }

    if (peekToken(cp) != T_LBRACE) {
        getToken(cp);
        return LEAVE(cp, expected(cp, "{"));
    }

    np = appendNode(np, parseInterfaceBody(cp));

    return LEAVE(cp, np);
}


/*
    InterfaceInheritance (497)
        EMPTY
        extends TypeIdentifierList

    Input

    AST
 */
static EcNode *parseInterfaceInheritance(EcCompiler *cp)
{
    EcNode      *np, *id;

    ENTER(cp);

    np = createNode(cp, N_CLASS);

    if (peekToken(cp) == T_EXTENDS) {
        id = parseTypeIdentifierList(cp);
        if (id) {
            np->klass.extends = mprStrdup(np, id->qname.name);
        }
    }
    return LEAVE(cp, np);
}


/*
    InterfaceBody (499)
        Block -interface-

    Input

    AST
 */
static EcNode *parseInterfaceBody(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);

    if (peekToken(cp) != T_LBRACE) {
        getToken(cp);
        return LEAVE(cp, expected(cp, "interface body { }"));
    }

    np = parseBlock(cp);
    if (np) {
        np = np->left;
        mprAssert(np->kind == N_DIRECTIVES);
    }

    return LEAVE(cp, np);
}


/*
    NamespaceDefinition (500)
        namespace Identifier NamespaceInitialisation

    Input
        namespace

    AST
        N_NAMESPACE
 */
static EcNode *parseNamespaceDefinition(EcCompiler *cp, EcNode *attributeNode)
{
    EcNode      *varDefNode, *assignNode, *nameNode, *typeNode, *namespaceNode, *parent;
    EjsObj      *vp;

    ENTER(cp);

    if (getToken(cp) != T_NAMESPACE) {
        return LEAVE(cp, unexpected(cp));
    }

    /*
        Handle namespace definitions like:
            let NAME : Namespace = NAMESPACE_LITERAL
     */
    nameNode = parseIdentifier(cp);
    nameNode->name.isNamespace = 1;
    setNodeDoc(cp, nameNode);

    /*
        Hand-craft a "Namespace" type node
     */
    typeNode = createNode(cp, N_QNAME);
    typeNode->qname.name = "Namespace";
    nameNode->typeNode = linkNode(nameNode, typeNode);
    applyAttributes(cp, nameNode, attributeNode, 0);

    if (peekToken(cp) == T_ASSIGN) {
        namespaceNode = parseNamespaceInitialisation(cp, nameNode);

    } else {
        /*
            Create a namespace literal node from which to assign.
         */
        namespaceNode = createNode(cp, N_LITERAL);
        vp = (EjsObj*) ejsCreateNamespace(cp->ejs, nameNode->qname.name, nameNode->qname.name);
        namespaceNode->literal.var = vp;
        nameNode->name.value = vp;
    }

    parent = createNode(cp, N_ASSIGN_OP);
    assignNode = createAssignNode(cp, nameNode, namespaceNode, parent);

    varDefNode = createNode(cp, N_VAR_DEFINITION);
    varDefNode->def.varKind = KIND_VAR;

    varDefNode = appendNode(varDefNode, assignNode);

    return LEAVE(cp, varDefNode);
}


/*
    NamespaceInitialisation (501)
        EMPTY
        = StringLiteral
        = SimpleQualifiedName

    Input
        =

    AST
        N_LITERAL
        N_QNAME
        N_DOT
 */
static EcNode *parseNamespaceInitialisation(EcCompiler *cp, EcNode *nameNode)
{
    EcNode      *np;
    EjsObj      *vp;

    ENTER(cp);

    if (getToken(cp) != T_ASSIGN) {
        return LEAVE(cp, unexpected(cp));
    }

    if (peekToken(cp) == T_STRING) {
        getToken(cp);
        np = createNode(cp, N_LITERAL);
        vp = (EjsObj*) ejsCreateNamespace(cp->ejs, nameNode->qname.name, mprStrdup(np, (char*) cp->token->text));
        np->literal.var = vp;

    } else {
        np = parsePrimaryName(cp);
    }

    return LEAVE(cp, np);
}


/*
    TypeDefinition (504)
        type ParameterisedTypeName TypeInitialisation

    Input

    AST
 */
static EcNode *parseTypeDefinition(EcCompiler *cp, EcNode *attributeNode)
{
    EcNode      *np;

    ENTER(cp);
    np = parseTypeInitialisation(cp);
    return LEAVE(cp, np);
}


/*
    TypeInitialisation (505)
        = NullableTypeExpression

    Input

    AST
 */
static EcNode *parseTypeInitialisation(EcCompiler *cp)
{
    EcNode      *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}


/*
    ModuleDefinition (493)
        module ModuleBody
        module ModuleName ModuleBody

    Input
        module ...

    AST
        N_MODULE
 */
static EcNode *parseModuleDefinition(EcCompiler *cp)
{
    EcNode      *np, *moduleName, *body;
    cchar       *name, *namespace;
    int         next, isDefault, pos, version;

    ENTER(cp);
    version = 0;

    if (getToken(cp) != T_MODULE) {
        return LEAVE(cp, unexpected(cp));
    }
    np = createNode(cp, N_MODULE);

    if (peekToken(cp) == T_ID) {
        isDefault = 0;
        moduleName = parseModuleName(cp);
        if (moduleName == 0) {
            return LEAVE(cp, 0);
        }
        version = 0;
        if (peekToken(cp) == T_STRING || cp->peekToken->tokenId == T_NUMBER) {
            if ((version = parseVersion(cp, 0)) < 0) {
                expected(cp, "A version number NUM[.NUM[.NUM]]");
                return 0;
            }
        }
        np->module.name = mprStrdup(np, moduleName->qname.name);
        if (version) {
            namespace = mprAsprintf(np, -1, "%s-%d", moduleName->qname.name, version);
        } else if (cp->modver) { 
            namespace = mprAsprintf(np, -1, "%s-%d", moduleName->qname.name, cp->modver);
            version = cp->modver;
        } else {
            namespace = mprStrdup(np, moduleName->qname.name);
        }
    } else {
        isDefault = 1;
    }
    
    if (isDefault) {
        /*
            No module name. Set the namespace to the unique internal namespace name.
         */
        np->module.name = mprStrdup(np, EJS_DEFAULT_MODULE);
        namespace = cp->fileState->namespace;
    }
    np->qname.name = np->module.name;
    np->module.version = version;
    cp->state->currentModule = ejsCreateModule(cp->ejs, np->qname.name, np->module.version);
    cp->state->defaultNamespace = namespace;

    body = parseModuleBody(cp);
    if (body == 0) {
        return LEAVE(cp, 0);
    }
    
    /* 
        Append the module namespace and also modules provided via ec/ejs --require switch
     */
    pos = 0;
    if (!isDefault) {
        body = insertNode(body, createNamespaceNode(cp, cp->fileState->namespace, 0, 1), pos++);
    }
    body = insertNode(body, createNamespaceNode(cp, namespace, 1, 1), pos++);
    for (next = 0; (name = mprGetNextItem(cp->require, &next)) != 0; ) {
        body = insertNode(body, createNamespaceNode(cp, name, 0, 1), pos++);
    }
    
    mprAssert(body->kind == N_BLOCK);
    np = appendNode(np, body);
    return LEAVE(cp, np);
}


/*
    ModuleName (494)
        Identifier
        ModuleName . Identifier

    Input
        ID
        ID. ... .ID

    AST
        N_QNAME
            name: name
 */
static EcNode *parseModuleName(EcCompiler *cp)
{
    EcNode      *np, *idp;
    Ejs *ejs;
    EjsObj      *lastPackage;
    char        *name;

    ENTER(cp);

    np = parseIdentifier(cp);
    if (np == 0) {
        return LEAVE(cp, np);
    }
    name = mprStrdup(np, np->qname.name);

    ejs = cp->ejs;
    lastPackage = 0;

    while (np && getToken(cp) == T_DOT) {
        /*
            Stop if not "identifier"
         */
        if (peekAheadToken(cp, 1) != T_ID) {
            break;
        }
        idp = parseIdentifier(cp);
        if (idp == 0) {
            return LEAVE(cp, idp);
        }
        np = appendNode(np, idp);
        name = mprReallocStrcat(np, -1, name, ".", idp->qname.name, NULL);
    }
    putToken(cp);
    setId(np, name);
    return LEAVE(cp, np);
}


/*
    ModuleBody (496)
        Block -global-

    Input
        {

    AST
        N_BLOCK
 */
static EcNode *parseModuleBody(EcCompiler *cp)
{
    return parseBlock(cp);
}


/*
    Pragma (505)
        UsePragma Semicolon |
        ImportPragma Semicolon

    Input
        use ...
        import ...

    AST
        N_IMPORT
        N_PRAGMAS
 */
static EcNode *parsePragma(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);

    switch (peekToken(cp)) {
    case T_USE:
    case T_REQUIRE:
        np = parseUsePragma(cp, np);
        break;

    default:
        np = unexpected(cp);
        break;
    }
    return LEAVE(cp, np);
}


/*
    Pragmas (497)
        Pragma
        Pragmas Pragma

    Input
        use ...
        import

    AST
        N_PRAGMAS
            N_IMPORT
            N_PRAGMA
 */
static EcNode *parsePragmas(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);

    while (peekToken(cp) == T_USE || cp->peekToken->tokenId == T_REQUIRE) {
        np = parsePragma(cp, np);
        if (np == 0) {
            break;
        }
    }
    return LEAVE(cp, np);
}


/*
    UsePragma (501)
        use PragmaItems
        require

    Input
        use ...

    AST
        N_PRAGMAS
 */
static EcNode *parseUsePragma(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);

    if (peekToken(cp) == T_REQUIRE) {
        getToken(cp);
        np = parseRequireItems(cp, np);
    } else if (peekToken(cp) == T_USE) {
        getToken(cp);
        np = parsePragmaItems(cp, np);
    } else{
        getToken(cp);
        np = parseError(cp, "Expecting \"use\" or \"require\"");
    }
    return LEAVE(cp, np);
}


static EcNode *parseRequireItems(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);
    do {
        np = appendNode(np, parseRequireItem(cp));
    } while (peekToken(cp) == T_COMMA);
    return LEAVE(cp, np);
}


//  TODO - should return an EcNode
/*
    Parse "NUM[.NUM[.NUM]]" and return a version number. Return < 0 on parse errors.
 */
static int parseVersion(EcCompiler *cp, int parseMax)
{
    char    *str, *p, *next;
    int     major, minor, patch;

    if (parseMax) {
        major = minor = patch = EJS_VERSION_FACTOR - 1;
    } else {
        major = minor = patch = 0;
    }
    if (getToken(cp) != T_STRING && cp->token->tokenId != T_NUMBER) {
        return MPR_ERR_BAD_VALUE;
    }

    str = mprStrdup(cp, (char*) cp->token->text);
    if ((p = mprStrTok(str, ".", &next)) != 0) {
        major = (int) mprAtoi(p, 10);
    }
    if ((p = mprStrTok(next, ".", &next)) != 0) {
        minor = (int) mprAtoi(p, 10);
    }
    if ((p = mprStrTok(next, ".", &next)) != 0) {
        patch = (int) mprAtoi(p, 10);
    }
    mprFree(str);
    return EJS_MAKE_VERSION(major, minor, patch);
}


//  TODO - should return an EcNode
/*
    Parse [version:version]. Valid forms include:
        [version]
        [:version]
        [version:version]
 */
static int parseVersions(EcCompiler *cp, int *minVersion, int *maxVersion)
{
    *minVersion = 0;
    *maxVersion = EJS_MAX_VERSION;

    getToken(cp);
    if (peekToken(cp) != T_COLON) {
        if ((*minVersion= parseVersion(cp, 0)) < 0) {
            expected(cp, "A version number NUM[.NUM[.NUM]]");
            return MPR_ERR_BAD_VALUE;
        }
    }
    if (peekToken(cp) == T_COLON) {
        getToken(cp);
        if ((*maxVersion = parseVersion(cp, 1)) < 0) {
            expected(cp, "A version number NUM[.NUM[.NUM]]");
            return MPR_ERR_BAD_VALUE;
        }
    }
    if (getToken(cp) != T_RBRACKET) {
        expected(cp, "]");
    }
    return 0;
}


static EcNode *parseRequireItem(EcCompiler *cp)
{
    EcNode      *np, *ns, *moduleName;
    int         minVersion, maxVersion;

    ENTER(cp);
    
    np = createNode(cp, N_USE_MODULE);
    ns = createNode(cp, N_USE_NAMESPACE);
    np->useModule.minVersion = 0;
    np->useModule.maxVersion = EJS_MAX_VERSION;

    moduleName = parseModuleName(cp);
    np->qname.name = mprStrdup(np, moduleName->qname.name);

    /*
        Optional [version:version]
     */
    if (peekToken(cp) == T_LBRACKET) {
        if (parseVersions(cp, &minVersion, &maxVersion) < 0) {
            return 0;
        }
        np->useModule.minVersion = minVersion;
        np->useModule.maxVersion = maxVersion;
    }

    ns->qname.name = mprStrdup(ns, np->qname.name);
    ns->useNamespace.isLiteral = 1;
    np = appendNode(np, ns);
    return LEAVE(cp, np);
}


/*
    PragmaItems (502)
        PragmaItem
        PragmaItems , PragmaItem

    Input
        decimal
        default
        namespace
        standard
        strict
        module

    AST
        N_PRAGMAS
        N_MODULE
 */
static EcNode *parsePragmaItems(EcCompiler *cp, EcNode *np)
{
    ENTER(cp);

    do {
        np = appendNode(np, parsePragmaItem(cp));
    } while (peekToken(cp) == T_COMMA);
    return LEAVE(cp, np);
}


/*
    PragmaItem (504)
        decimal LeftHandSideExpression
        default namespace PrimaryName
        // default number [decimal | default | double | int | long | uint | ulong]
        namespace PrimaryName
        standard
        strict
        module ModuleName OptionalStringLiteral

    Input
        See above

    AST
        N_PRAGMA
        N_MODULE
 */
static EcNode *parsePragmaItem(EcCompiler *cp)
{
    EcNode      *np, *ns;
    EcState     *upper;
    EjsModule   *module;
    int         attributes;

    ENTER(cp);

    attributes = 0;

    np = createNode(cp, N_PRAGMA);
    np->pragma.strict = cp->fileState->strict;
    module = 0;

    /*
        PragmaIdentifiers (737)
     */
    switch (getToken(cp)) {
    case T_DECIMAL:
        np->pragma.decimalContext = linkNode(np, parseLeftHandSideExpression(cp));
        break;

    case T_MODULE:
        /* TODO DEPRECATE */
        np = parseRequireItem(cp);
        break;

    case T_DEFAULT:
        getToken(cp);
        if (cp->token->tokenId == T_NAMESPACE) {
            if (peekToken(cp) == T_MODULE) {
                getToken(cp);
                module = cp->state->currentModule;
                if (module == 0) {
                    np = parseError(cp, "No open module");
                    break;
                }
                np = createNode(cp, N_USE_NAMESPACE);
                if (module->version) {
                    np->qname.name = mprAsprintf(np, -1, "%s-%d", module->name, module->version);
                    np->useNamespace.isLiteral = 1;
                } else {
                    np->qname.name = mprStrdup(np, module->name);
                    np->useNamespace.isLiteral = 1;
                }
                np->useNamespace.isLiteral = 1;

            } else if (peekToken(cp) == T_STRING) {
                getToken(cp);
                np = createNode(cp, N_USE_NAMESPACE);
                np->qname.name = mprStrdup(np, (char*) cp->token->text);
                np->useNamespace.isLiteral = 1;

            } else {
                ns = parsePrimaryName(cp);
                if (ns) {
                    np = createNode(cp, N_USE_NAMESPACE);
                    np->qname.name = mprStrdup(np, ns->qname.name);
                }
            }
            if (np) {
                /*
                    Must apply this default namespace upwards to all blocks below the blockState. It will define the
                    new namespace value. Note that functions and classes null this so it does not propagate into classes or
                    functions.
                 */
                for (upper = cp->state->prev; upper; upper = upper->prev) {
                    upper->defaultNamespace = np->qname.name;
                    if (upper == cp->blockState) {
                        break;
                    }
                }
                cp->blockState->namespace = np->qname.name;
                np->useNamespace.isDefault = 1;
            }
        }
        break;

    case T_STANDARD:
        cp->fileState->strict = np->pragma.strict = 0;
        break;

    case T_STRICT:
        cp->fileState->strict = np->pragma.strict = 1;
        break;

    case T_NAMESPACE:
        np = createNode(cp, N_USE_NAMESPACE);
        if (peekToken(cp) == T_STRING) {
            getToken(cp);
            np->qname.name = mprStrdup(np, (char*) cp->token->text);
            np->useNamespace.isLiteral = 1;

        } else {
            ns = parsePrimaryName(cp);
            if (ns) {
                np = appendNode(np, ns);
                if (ns->kind == N_DOT) {
                    np->qname.name = ns->right->qname.name;
                } else {
                    np->qname.name = ns->qname.name;
                }
            }
        }
        break;

    default:
        np = parseError(cp, "Unknown pragma identifier");
    }
    return LEAVE(cp, np);
}


/*
    Block -t- (514)
        { Directives }

    Input
        {

    AST
        N_BLOCK
 */
static EcNode *parseBlock(EcCompiler *cp)
{
    EcNode      *np;
    EcState     *state, *saveState;

    ENTER(cp);

    state = cp->state;
    saveState = cp->blockState;
    cp->blockState = state;

    if (getToken(cp) != T_LBRACE) {
        // putToken(cp);
        np = parseError(cp, "Expecting \"{\"");

    } else {
        np = createNode(cp, N_BLOCK);
        np = appendNode(np, parseDirectives(cp));

        if (np) {
            if (getToken(cp) != T_RBRACE) {
                // putToken(cp);
                np = parseError(cp, "Expecting \"}\"");
            }
        }
    }
    cp->blockState = saveState;
    return LEAVE(cp, np);
}


/*
    Program (515)
        Directives -global-

    Input
        AnyDirective

    AST N_PROGRAM
        N_DIRECTIVES ...

 */
static EcNode *parseProgram(EcCompiler *cp, cchar *path)
{
    EcState     *state;
    EcNode      *np, *module, *block, *require;
    cchar       *name;
    char        *md5, *apath;
    int         next;

    ENTER(cp);

    state = cp->state;
    np = createNode(cp, N_PROGRAM);

    np->qname.space = EJS_PUBLIC_NAMESPACE;

#if UNUSED && KEEP
    if (cp->fileState->lang == EJS_SPEC_ECMA) {
        np->qname.name = EJS_PUBLIC_NAMESPACE;
    } else {
#endif
    if (path) {
        apath = mprGetAbsPath(cp, path);
        md5 = mprGetMD5Hash(cp, apath, strlen(apath), NULL);
        np->qname.name = mprAsprintf(np, -1, "%s-%s-%d", EJS_INTERNAL_NAMESPACE, md5, cp->uid++);
        mprFree(md5);
        mprFree(apath);
    } else {
        np->qname.name = EJS_INTERNAL_NAMESPACE;
    }
    state->namespace = np->qname.name;
    cp->fileState->namespace = state->namespace;

    /*
        Create the default module node
     */
    module = createNode(cp, N_MODULE);
    module->qname.name = EJS_DEFAULT_MODULE;

    /*
        Create a block to hold the namespaces. Add a require node for the default module and add modules specified 
        via --require switch
     */
    block = createNode(cp, N_BLOCK);
    block = appendNode(block, createNamespaceNode(cp, cp->fileState->namespace, 0, 1));
    for (next = 0; (name = mprGetNextItem(cp->require, &next)) != 0; ) {
        require = createNode(cp, N_USE_MODULE);
        require->qname.name = mprStrdup(require, name);
        require->useModule.minVersion = 0;
        require->useModule.maxVersion = EJS_MAX_VERSION;
        require = appendNode(require, createNamespaceNode(cp, name, 0, 1));
        block = appendNode(block, require);
    }

    block = appendNode(block, parseDirectives(cp));
    module = appendNode(module, block);
    np = appendNode(np, module);

    if (!cp->interactive && peekToken(cp) != T_EOF) {
        if (np) {
            np = unexpected(cp);
        }
        return LEAVE(cp, np);
    }

    /*
        Reset the line number to prevent debug source lines preceeding these elements
     */
    if (np) {
        np->lineNumber = 0;
    }
    if (module) {
        module->lineNumber = 0;
    }
    if (block) {
        block->lineNumber = 0;
    }
    return LEAVE(cp, np);
}


#if UNUSED
static EcNode *parseBreak(EcCompiler *cp)
{
    EcNode  *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}


static EcNode *parseContinue(EcCompiler *cp)
{
    EcNode  *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}


static EcNode *parseDo(EcCompiler *cp)
{
    EcNode  *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}


static EcNode *parseFor(EcCompiler *cp)
{
    EcNode  *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}


static EcNode *parseIf(EcCompiler *cp)
{
    EcNode  *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}


static EcNode *parseLet(EcCompiler *cp)
{
    EcNode  *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}


static EcNode *parseReturn(EcCompiler *cp)
{
    EcNode  *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}


static EcNode *parseSwitch(EcCompiler *cp)
{
    EcNode  *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}


static EcNode *parseThrow(EcCompiler *cp)
{
    EcNode  *np;

    ENTER(cp);
    return LEAVE(cp, np);
}


static EcNode *parseTry(EcCompiler *cp)
{
    EcNode  *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}


static EcNode *parseWhile(EcCompiler *cp)
{
    EcNode  *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}


static EcNode *parseWith(EcCompiler *cp)
{
    EcNode  *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}


static EcNode *parseVarDefinition(EcCompiler *cp)
{
    EcNode  *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}


static EcNode *parseFunctionDefinition(EcCompiler *cp)
{
    EcNode  *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}


static EcNode *parseInclude(EcCompiler *cp)
{
    EcNode  *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}
#endif


#if NOT_USED_IN_GRAMMAR
static EcNode *parseSuper(EcCompiler *cp)
{
    EcNode  *np;

    ENTER(cp);
    np = 0;
    mprAssert(0);
    return LEAVE(cp, np);
}
#endif


/*
    Report an error. Return a null EcNode so callers can report an error and return the null in one statement.
 */
static EcNode *parseError(EcCompiler *cp, char *fmt, ...)
{
    EcToken     *tp;
    va_list     arg;
    char        *msg;

    va_start(arg, fmt);

    if ((msg = mprVasprintf(cp, 0, fmt, arg)) == NULL) {
        msg = "Memory allocation error";
    }
    cp->errorCount++;
    cp->error = 1;
    tp = cp->token;
    if (tp) {
        ecReportError(cp, "error", tp->filename, tp->lineNumber, tp->currentLine, tp->column, msg);
    } else {
        ecReportError(cp, "error", 0, 0, 0, 0, msg);
    }
    mprFree(msg);
    va_end(arg);
    return 0;
}


EcNode *ecParseWarning(EcCompiler *cp, char *fmt, ...)
{
    EcToken     *tp;
    va_list     arg;
    char        *msg;

    va_start(arg, fmt);

    if ((msg = mprVasprintf(cp, 0, fmt, arg)) == NULL) {
        msg = "Memory allocation error";
    }

    cp->warningCount++;

    tp = cp->token;
    ecReportError(cp, "warning", tp->filename, tp->lineNumber, tp->currentLine, tp->column, msg);

    mprFree(msg);
    va_end(arg);

    return 0;
}


/*
    Recover from a parse error to allow parsing to continue.
 */
EcNode *ecResetError(EcCompiler *cp, EcNode *np, bool eatInput)
{
    int     tid;

    mprAssert(cp->error);

    if (cp->error) {
        if (!cp->fatalError && cp->errorCount < EC_MAX_ERRORS) {
            cp->error = 0;
            np = createNode(cp, N_DIRECTIVES);
        }
    }


    /*
        Try to resync by eating input up to the next statement / directive
     */
    while (!cp->interactive) {
        tid = peekToken(cp);
        if (tid == T_SEMICOLON || tid == T_RBRACE || tid == T_RBRACKET || tid == T_RPAREN || tid == T_ERR || tid == T_EOF)  {
            break;
        }
        if (np && np->lineNumber < cp->peekToken->lineNumber) {
            /* Virtual semicolon */
            break;
        }
        getToken(cp);
    }

    return np;
}


#if FUTURE
/*
    Returns an allocated buffer. Caller must free.
 */
static char *detab(EcCompiler *cp, char *src)
{
    char    *p, *dest;
    int     tabCount;

    tabCount = 0;

    for (p = src; *p; p++) {
        if (*p == '\t') {
            tabCount++;
        }
    }

    dest = mprAlloc(cp, strlen(src) + 1 + (tabCount * cp->tabWidth));
    if (dest == 0) {
        mprAssert(dest);
        return src;
    }
    for (p = dest; *src; src++) {
        if (*src== '\t') {
            *p++ = ' ';
            *p++ = ' ';
            *p++ = ' ';
            *p++ = ' ';
        } else {
            *p++ = *src;
        }
    }
    *p = '\0';

    return dest;
}
#endif

/*
    Create a line of spaces with an "^" pointer at the current parse error.
    Returns an allocated buffer. Caller must free.
 */
static char *makeHighlight(EcCompiler *cp, char *src, int col)
{
    char    *p, *dest;
    int     tabCount, len, i;

    tabCount = 0;

    for (p = src; *p; p++) {
        if (*p == '\t') {
            tabCount++;
        }
    }

    len = (int) strlen(src) + (tabCount * cp->tabWidth);
    len = max(len, col);

    /*
        Allow for "^" to be after the last char, plus one null.
     */
    dest = (char*) mprAlloc(cp, len + 2);
    if (dest == 0) {
        mprAssert(dest);
        return src;
    }
    for (i = 0, p = dest; *src; src++, i++) {
        if (*src== '\t') {
            *p++ = *src;
        } else {
            *p++ = ' ';
        }
    }

    /*
        Cover the case where the ^ must go after the end of the input
     */
    dest[col] = '^';
    if (p == &dest[col]) {
        ++p;
    }
    *p = '\0';

    return dest;
}



void ecReportError(EcCompiler *cp, cchar *severity, cchar *filename, int lineNumber, char *currentLine, int column, char *msg)
{
    cchar   *appName;
    char    *highlightPtr, *errorMsg;
    int     errCode;

    errCode = 0;

    appName = mprGetAppName(cp);
    if (filename == 0 || *filename == '\0') {
        filename = "stdin";
    }

#if FUTURE_WITH_ERROR_CODES
    if (currentLine) {
        highlightPtr = makeHighlight(cp, (char*) currentLine, column);
        errorMsg = mprAsprintf(cp, -1, "%s: %s: %d: %d: %s: %s\n  %s  \n  %s\n", appName, filename, lineNumber, errCode, severity,
            msg, currentLine, highlightPtr);

    } else if (lineNumber >= 0) {
        errorMsg = mprAsprintf(cp, -1, "%s: %s: %d: %d: %s: %s\n", appName, filename, lineNumber, errCode, severity, msg);

     else {
        errorMsg = mprAsprintf(cp, -1, "%s: %s: 0: %d: %s: %s\n", appName, filename, errCode, severity, msg);
    }
#else
    if (currentLine) {
        highlightPtr = makeHighlight(cp, (char*) currentLine, column);
        errorMsg = mprAsprintf(cp, -1, "%s: %s: %d: %s: %s\n  %s  \n  %s\n", appName, filename, lineNumber, severity,
            msg, currentLine, highlightPtr);

    } else if (lineNumber >= 0) {
        errorMsg = mprAsprintf(cp, -1, "%s: %s: %d: %s: %s\n", appName, filename, lineNumber, severity, msg);

    } else {
        errorMsg = mprAsprintf(cp, -1, "%s: %s: 0: %s: %s\n", appName, filename, severity, msg);
    }
#endif
    cp->errorMsg = mprReallocStrcat(cp, -1, cp->errorMsg, errorMsg, NULL);
    mprPrintfError(cp, "%s", cp->errorMsg);
    mprBreakpoint();
}


static void updateTokenInfo(EcCompiler *cp)
{
    mprAssert(cp);
    mprAssert(cp->input);

    cp->token = cp->input->token;

#if BLD_DEBUG
    /*
        Update source file and line number information.
     */
    if (cp->token) {
        cp->tokenName = tokenNames[cp->token->tokenId];
        cp->currentLine = cp->token->currentLine;
    }
#endif
}


/*
    Get the next input token. May have been previous obtained and putback.
 */
static int getToken(EcCompiler *cp)
{
    int         id;

    if (cp->fatalError) {
        return T_ERR;
    }
    id = ecGetToken(cp->input);
    updateTokenInfo(cp);

    cp->peekToken = 0;
#if BLD_DEBUG
    cp->peekTokenName = 0;
#endif
    return id;
}


/*
    Peek ahead (K) tokens and return the token id
 */
static int peekAheadToken(EcCompiler *cp, int ahead)
{
    EcToken     *token;

    token = peekAheadTokenStruct(cp, ahead);
    if (token == 0) {
        return EJS_ERR;
    }
    return token->tokenId;
}


int ecPeekToken(EcCompiler *cp)
{
    return peekAheadToken(cp, 1);
}


/*
    Peek ahead (K) tokens and return the token.
 */
static EcToken *peekAheadTokenStruct(EcCompiler *cp, int ahead)
{
    EcToken     *token, *currentToken, *tokens[EC_MAX_LOOK_AHEAD];
    int         i;

    mprAssert(ahead > 0 && ahead <= EC_MAX_LOOK_AHEAD);

    cp->peeking = 1;

    if (ahead == 1) {

        /*
            Fast look ahead of one token.
         */
        if (cp->input->putBack) {
#if BLD_DEBUG
            cp->peekTokenName = tokenNames[cp->input->putBack->tokenId];
#endif
            cp->peekToken = cp->input->putBack;
            return cp->input->putBack;
        }
    }

    /*
        takeToken will take the current token and remove it from the input
        We must preserve the current token throughout.
     */
    currentToken = ecTakeToken(cp->input);
    for (i = 0; i < ahead; i++) {
        if (ecGetToken(cp->input) < 0) {
            cp->peeking = 0;
            mprAssert(0);
            return 0;
        }
        tokens[i] = ecTakeToken(cp->input);
    }

    /*
        Peek at the token of interest
     */
    token = tokens[i - 1];

    for (i = ahead - 1; i >= 0; i--) {
        putSpecificToken(cp, tokens[i]);
    }

    if (currentToken) {
        ecPutSpecificToken(cp->input, currentToken);
        ecGetToken(cp->input);
        updateTokenInfo(cp);
    }

#if BLD_DEBUG
    cp->peekTokenName = tokenNames[token->tokenId];
#endif

    cp->peekToken = token;
    cp->peeking = 0;
    return token;
}


static void putToken(EcCompiler *cp)
{
    ecPutToken(cp->input);
}


static void putSpecificToken(EcCompiler *cp, EcToken *token)
{
    ecPutSpecificToken(cp->input, token);
}


/*
    Create a new node. This will be automatically freed when returning from a non-terminal production (ie. the state
    is destroyed). Returning results are preserved by stealing the node from the state memory context.

    NOTE: we are using a tree based memory allocator with destructors.
 */
static EcNode *createNode(EcCompiler *cp, int kind)
{
    EcNode      *np;
    EcToken     *token;
    int         len;

    mprAssert(cp->state);

    np = mprAllocObjZeroed(cp->state, EcNode);
    if (np == 0) {
        cp->memError = 1;
        return 0;
    }

    np->seqno = cp->nextSeqno++;
    np->kind = kind;
    np->cp = cp;
    np->slotNum = -1;

#if BLD_DEBUG
    np->kindName = nodes[kind];
#endif

    np->lookup.slotNum = -1;

    /*
        Remember the current input token. Don't do for initial program and module nodes.
     */
    if (cp->token == 0 && cp->state->blockNestCount > 0) {
        getToken(cp);
        putToken(cp);
        peekToken(cp);
    }

    token = cp->token;
    if (token) {
        np->tokenId = token->tokenId;
        np->groupMask = token->groupMask;
        np->subId = token->subId;

#if BLD_DEBUG
        if (token->tokenId >= 0) {
            np->tokenName = tokenNames[token->tokenId];
        }
#endif
    }

    np->children = mprCreateList(np);

    if (token && token->currentLine) {
        np->filename = mprStrdup(np, token->filename);
        np->currentLine = mprStrdup(np, token->currentLine);
        len = (int) strlen(np->currentLine);
        if (len > 0 && np->currentLine[len - 1] == '\n') {
            np->currentLine[len - 1] = '\0';
        }
        np->lineNumber = token->lineNumber;
        np->column = token->column;

        mprLog(np, 9, "At line %d, token \"%s\", line %s", token->lineNumber, token->text, np->currentLine);
    }

    /*
        Per AST node type initialisation
     */
    switch (kind) {
    case N_LITERAL:
        break;
    }
    return np;
}


static void setNodeDoc(EcCompiler *cp, EcNode *np)
{
    Ejs     *ejs;

    ejs = cp->ejs;

    if (ejs->flags & EJS_FLAG_DOC && cp->input->doc) {
        np->doc = cp->input->doc;
        cp->input->doc = 0;
        mprStealBlock(np, np->doc);
    }
}


static void appendDocString(EcCompiler *cp, EcNode *np, EcNode *parameter, EcNode *value)
{
    char        *doc, arg[MPR_MAX_STRING];
    cchar       *defaultValue;
    int         found;
    
    if (!(cp->ejs->flags & EJS_FLAG_DOC)) {
        return;
    }
    if (np == 0 || parameter == 0 || parameter->kind != N_QNAME || value == 0) {
        return;
    }

    defaultValue = 0;
    if (value->kind == N_QNAME) {
        defaultValue = value->qname.name;
    } else if (value->kind == N_UNARY_OP) {
        if (value->left->kind == N_LITERAL) {
            if (value->tokenId == T_MINUS) {
                defaultValue = mprAsprintf(np, -1, "-%s", ejsToString(cp->ejs, value->left->literal.var)->value);
            }
        }
    } else if (value->kind == N_LITERAL) {
        defaultValue = ejsToString(cp->ejs, value->literal.var)->value;
    }
    if (defaultValue == 0) {
        defaultValue = "expression";
    }

    if (np->doc) {
        found = 0;
        mprSprintf(arg, sizeof(arg), "@param %s ", parameter->qname.name);
        if (strstr(np->doc, arg) != 0) {
            found++;
        } else {
            mprSprintf(arg, sizeof(arg), "@params %s ", parameter->qname.name);
            if (strstr(np->doc, arg) != 0) {
                found++;
            }
        }
        if (found) {
            doc = mprAsprintf(np, -1, "%s\n@default %s %s", np->doc, parameter->qname.name, defaultValue);
        } else {
            doc = mprAsprintf(np, -1, "%s\n@param %s\n@default %s %s", np->doc, parameter->qname.name,
                parameter->qname.name, defaultValue);
        }
        mprFree(np->doc);
        np->doc = doc;
    }
}


static void copyDocString(EcCompiler *cp, EcNode *np, EcNode *from)
{
    Ejs     *ejs;

    ejs = cp->ejs;

    if (ejs->flags & EJS_FLAG_DOC && from->doc) {
        np->doc = from->doc;
        from->doc = 0;
        mprStealBlock(np, np->doc);
    }
}


/*
    This is used outside the parser. It must reset the line number as the
    node will not correspond to any actual source code line;
 */
EcNode *ecCreateNode(EcCompiler *cp, int kind)
{
    EcNode  *node;

    node = createNode(cp, kind);
    if (node) {
        node->lineNumber = -1;
        node->currentLine = 0;
    }
    return node;
}


static EcNode *createNameNode(EcCompiler *cp, cchar *name, cchar *space)
{
    EcNode      *np;

    np = createNode(cp, N_QNAME);
    if (np) {
        np->qname.name = mprStrdup(np, name);
        np->qname.space = mprStrdup(np, space);
    }
    return np;
}


static EcNode *createNamespaceNode(EcCompiler *cp, cchar *name, bool isDefault, bool isLiteral)
{
    EcNode      *np;
    
    np = createNode(cp, N_USE_NAMESPACE);
    np->qname.name = mprStrdup(np, name);
    np->useNamespace.isDefault = isDefault;
    np->useNamespace.isLiteral = isLiteral;
    return np;
}


/*
    This is used outside the parser.
 */
EcNode *ecLinkNode(EcNode *np, EcNode *child)
{
    return linkNode(np, child);
}


/*
    Create a binary tree node.
 */
static EcNode *createBinaryNode(EcCompiler *cp, EcNode *lhs, EcNode *rhs, EcNode *parent)
{
    mprAssert(cp);
    mprAssert(lhs);
    mprAssert(parent);

    /*
        appendNode will return the parent if no error
     */
    parent = appendNode(parent, lhs);
    parent = appendNode(parent, rhs);

    return parent;
}


/*
    Create an assignment op node.
 */
static EcNode *createAssignNode(EcCompiler *cp, EcNode *lhs, EcNode *rhs, EcNode *parent)
{
    mprAssert(cp);
    mprAssert(lhs);
    mprAssert(parent);

    /*
        appendNode will return the parent if no error
     */
    parent = appendNode(parent, lhs);
    parent = appendNode(parent, rhs);
    return parent;
}


/*
    Add a child node. If an allocation error, return 0, otherwise return the
    parent node.
 */
static EcNode *appendNode(EcNode *np, EcNode *child)
{
    EcCompiler      *cp;
    MprList         *list;
    int             index;

    mprAssert(np != child);

    if (child == 0 || np == 0) {
        return 0;
    }
    list = np->children;

    cp = np->cp;

    index = mprAddItem(list, child);
    if (index < 0) {
        cp->memError = 1;
        return 0;
    }

    if (index == 0) {
        np->left = (EcNode*) list->items[index];
    } else if (index == 1) {
        np->right = (EcNode*) list->items[index];
    }
    child->parent = np;
    mprStealBlock(list, child);
    return np;
}


EcNode *ecAppendNode(EcNode *np, EcNode *child)
{
    return appendNode(np, child);
}


EcNode *ecChangeNode(EcNode *np, EcNode *oldNode, EcNode *newNode)
{
    EcNode      *child;
    MprList     *list;
    int         next, index;

    next = 0;
    while ((child = (EcNode*) mprGetNextItem(np->children, &next))) {
        if (child == oldNode) {
            index = next - 1;
            mprSetItem(np->children, index, newNode);
            mprStealBlock(np, newNode);
            list = np->children;
            if (index == 0) {
                np->left = (EcNode*) list->items[index];
            } else if (index == 1) {
                np->right = (EcNode*) list->items[index];
            }
            newNode->parent = np;
            return np;
        }
    }
    mprAssert(0);
    return 0;
}


/*
    Link a node. This only steals the node.
 */
static EcNode *linkNode(EcNode *np, EcNode *node)
{
    if (node == 0 || np == 0) {
        return 0;
    }
    node->parent = np;
    mprStealBlock(np, node);

    return node;
}


/*
    Insert a child node. If an allocation error, return 0, otherwise return the parent node.
 */
static EcNode *insertNode(EcNode *np, EcNode *child, int pos)
{
    EcCompiler      *cp;
    MprList         *list;
    int             index, len;

    if (child == 0 || np == 0) {
        return 0;
    }
    list = np->children;

    cp = np->cp;

    index = mprInsertItemAtPos(list, pos, child);
    if (index < 0) {
        cp->memError = 1;
        return 0;
    }

    len = mprGetListCount(list);
    if (len > 0) {
        np->left = (EcNode*) list->items[0];
    }
    if (len > 1) {
        np->right = (EcNode*) list->items[1];
    }
    child->parent = np;
    mprStealBlock(list, child);
    return np;
}


/*
    Remove a child node and return it.
 */
static EcNode *removeNode(EcNode *np, EcNode *child)
{
    EcCompiler      *cp;
    MprList         *list;
    int             index;

    if (child == 0 || np == 0) {
        return 0;
    }
    list = np->children;

    cp = np->cp;

    index = mprRemoveItem(list, child);
    mprAssert(index >= 0);

    if (index == 0) {
        np->left = np->right;
    } else if (index == 1) {
        np->right = 0;
    }
    child->parent = 0;
    return child;
}


/* XXX */

static void setId(EcNode *np, char *name)
{
    mprAssert(np);
    mprAssert(np->kind == N_QNAME || np->kind == N_VOID);
    mprAssert(name);

    if (np->qname.name != name) {
        mprFree((char*) np->qname.name);
        np->qname.name = mprStrdup(np, name);
    }
}



static EcNode *unexpected(EcCompiler *cp)
{
    int     junk = 0;

    /*
        This is just to avoid a Vxworks 5.4 linker bug. The link crashes when this function has no local vars.
     */
    dummy(junk);
    return parseError(cp, "Unexpected input \"%s\"", cp->token->text);
}


static EcNode *expected(EcCompiler *cp, const char *str)
{
    return parseError(cp, "Expected input \"%s\"", str);
}


static const char *getExt(const char *path)
{
    char    *cp;

    if ((cp = strrchr(path, '.')) != 0) {
        return cp;
    }
    return "";
}


static void applyAttributes(EcCompiler *cp, EcNode *np, EcNode *attributeNode, cchar *overrideNamespace)
{
    EcState     *state;
    cchar       *namespace;
    int         attributes;

    state = cp->state;

    attributes = 0;
    namespace = 0;

    if (attributeNode) {
        /*
            Attribute node passed in.
         */
        attributes = attributeNode->attributes;
        if (attributeNode->qname.space) {
            namespace = mprStrdup(np, attributeNode->qname.space);
        }
        if (attributeNode->literalNamespace) {
            np->literalNamespace = 1;
        }
    } else {
        /*
            "space"::var
         */
        if (np->qname.space) {
            namespace = np->qname.space;
        }
    }
    if (namespace == 0) {
        if (overrideNamespace) {
            namespace = overrideNamespace;
        } else if (cp->blockState->defaultNamespace) {
            namespace = cp->blockState->defaultNamespace;
        } else {
            namespace = cp->blockState->namespace;
        }
    }
    mprAssert(namespace);

    if (state->inFunction) {
        /*
            Functions don't need qualification of private properties.
         */
        if (strcmp(namespace, EJS_PRIVATE_NAMESPACE) == 0) {
            namespace = (char*) mprStrdup(np, namespace);
        } else {
            namespace = (char*) mprStrdup(np, namespace);
        }

    } else if (state->inClass) {
        if (strcmp(namespace, EJS_INTERNAL_NAMESPACE) == 0) {
            namespace = mprStrdup(np, cp->fileState->namespace);
        } else if (strcmp(namespace, EJS_PRIVATE_NAMESPACE) == 0 || strcmp(namespace, EJS_PROTECTED_NAMESPACE) == 0) {
            namespace = (char*) ejsFormatReservedNamespace(np, &state->currentClassName, namespace);
        } else {
            namespace = (char*) mprStrdup(np, namespace);
        }

    } else {
        if (strcmp(namespace, EJS_INTERNAL_NAMESPACE) == 0) {
            namespace = mprStrdup(np, cp->fileState->namespace);
        } else {
            namespace = (char*) mprStrdup(np, namespace);
        }
    }
    np->qname.space = namespace;

    mprLog(np, 7, "Parser apply attributes namespace = \"%s\", current line %s", namespace, np->currentLine);
    mprAssert(np->qname.space);
    np->attributes |= attributes;
}


static void addTokenToBuf(EcCompiler *cp, EcNode *np)
{
    MprBuf      *buf;

    if (np) {
        buf = np->literal.data;
        mprPutStringToBuf(buf, (cchar*) cp->token->text);
        mprAddNullToBuf(buf);
        mprLog(cp, 7, "Literal: \n%s\n", buf->start);
    }
}


/*
    Reset the input. Eat all tokens, clear errors, exceptions and the result value. Used by ejs for console input.
 */
void ecResetInput(EcCompiler *cp)
{
    EcToken     *tp;

    while ((tp = cp->input->putBack) != 0 && (tp->tokenId == T_EOF || tp->tokenId == T_NOP)) {
        ecGetToken(cp->input);
    }
    cp->input->stream->flags &= ~EC_STREAM_EOL;

    cp->error = 0;
    cp->ejs->exception = 0;
    cp->ejs->result = cp->ejs->undefinedValue;
}


void ecSetOptimizeLevel(EcCompiler *cp, int level)
{
    cp->optimizeLevel = level;
}


void ecSetWarnLevel(EcCompiler *cp, int level)
{
    cp->warnLevel = level;
}


void ecSetStrictMode(EcCompiler *cp, int enabled)
{
    cp->strict = enabled;
}


void ecSetTabWidth(EcCompiler *cp, int width)
{
    cp->tabWidth = width;
}


void ecSetOutputFile(EcCompiler *cp, cchar *outputFile)
{
    if (outputFile) {
        mprFree(cp->outputFile);
        cp->outputFile = mprStrdup(cp, outputFile);
    }
}


void ecSetCertFile(EcCompiler *cp, cchar *certFile)
{
    mprFree(cp->certFile);
    cp->certFile = mprStrdup(cp, certFile);
}

/*
    Just part of a VxWorks 5.4 compiler bug to avoid a linker crash
 */
static void dummy(int junk) { }

/*
    @copy   default

    Copyright (c) Embedthis Software LLC, 2003-2010. All Rights Reserved.
    Copyright (c) Michael O'Brien, 1993-2010. All Rights Reserved.

    This software is distributed under commercial and open source licenses.
    You may use the GPL open source license described below or you may acquire
    a commercial license from Embedthis Software. You agree to be fully bound
    by the terms of either license. Consult the LICENSE.TXT distributed with
    this software for full details.

    This software is open source; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version. See the GNU General Public License for more
    details at: http://www.embedthis.com/downloads/gplLicense.html

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

    This GPL license does NOT permit incorporating this software into
    proprietary programs. If you are unable to comply with the GPL, you must
    acquire a commercial license to use this software. Commercial licenses
    for this software and support services are available from Embedthis
    Software at http://www.embedthis.com

    @end
 */
/************************************************************************/
/*
 *  End of file "../src/compiler/ecParser.c"
 */
/************************************************************************/



/************************************************************************/
/*
 *  Start of file "../src/compiler/ecState.c"
 */
/************************************************************************/

/**
 *  ecState.c - Manage state for the parser
 *
 *  Copyright (c) All Rights Reserved. See details at the end of the file.
 */



/*
 *  Push the state onto the stack
 */
int ecPushState(EcCompiler *cp, EcState *newState)
{
    EcState     *prev;

    prev = cp->state;
    if (prev) {
        /*
         *  Copy inherited fields.
         *  OPT - could we just use structure assignment?
         */
        newState->inClass = prev->inClass;
        newState->inFunction = prev->inFunction;
        newState->captureBreak = prev->captureBreak;
        newState->inMethod = prev->inMethod;
        newState->blockIsMethod = prev->blockIsMethod;

        newState->stateLevel = prev->stateLevel;
        newState->currentClass = prev->currentClass;
        newState->currentClassNode = prev->currentClassNode;
        newState->currentClassName = prev->currentClassName;
        newState->currentModule = prev->currentModule;
        newState->currentFunction = prev->currentFunction;
        newState->currentFunctionName = prev->currentFunctionName;
        newState->currentFunctionNode = prev->currentFunctionNode;
        newState->topVarBlockNode = prev->topVarBlockNode;
        newState->currentObjectNode = prev->currentObjectNode;
        newState->onLeft = prev->onLeft;
        newState->needsValue = prev->needsValue;
        newState->needsStackReset = prev->needsStackReset;
        newState->code = prev->code;
        newState->varBlock = prev->varBlock;
        newState->optimizedLetBlock = prev->optimizedLetBlock;
        newState->letBlock = prev->letBlock;
        newState->letBlockNode = prev->letBlockNode;
        newState->conditional = prev->conditional;
        newState->instanceCode = prev->instanceCode;
        newState->instanceCodeBuf = prev->instanceCodeBuf;
        newState->staticCodeBuf = prev->staticCodeBuf;
        newState->strict = prev->strict;
        newState->inheritedTraits = prev->inheritedTraits;
        newState->disabled = prev->disabled;
        newState->inHashExpression = prev->inHashExpression;
        newState->inSettings = prev->inSettings;
        newState->noin = prev->noin;
        newState->blockNestCount = prev->blockNestCount;
        newState->namespace = prev->namespace;
        newState->defaultNamespace = prev->defaultNamespace;
        newState->breakState = prev->breakState;
        newState->inInterface = prev->inInterface;

    } else {
        newState->strict = cp->strict;
    }
    newState->prev = prev;
    newState->stateLevel++;
    cp->state = newState;
    return 0;
}


/*
 *  Pop the state. Clear out old notes and put onto the state free list.
 */
EcState *ecPopState(EcCompiler *cp)
{
    EcState *prev, *state;

    state = cp->state;
    mprAssert(state);

    prev = state->prev;
    mprFree(state);
    return prev;
}


/*
 *  Enter a new level. For the parser, this is a new production rule. For the ASP processor or code generator, 
 *  it is a new AST node. Push old state and setup a new production state
 */
int ecEnterState(EcCompiler *cp)
{
    EcState *state;

    //  OPT - keep state free list for speed
    state = mprAllocObjZeroed(cp, EcState);
    if (state == 0) {
        mprAssert(state);
        //  TBD -- convenience function for this.
        cp->memError = 1;
        cp->error = 1;
        cp->fatalError = 1;
        /* Memory erorrs are reported globally */
        return MPR_ERR_NO_MEMORY;
    }
    if (ecPushState(cp, state) < 0) {
        cp->memError = 1;
        cp->error = 1;
        cp->fatalError = 1;
        return MPR_ERR_NO_MEMORY;
    }
    return 0;
}


/*
 *  Leave a level. Pop the state and pass back the current node.
 */
EcNode *ecLeaveStateWithResult(EcCompiler *cp, EcNode *np)
{
    /*
     *  Steal the result from the current state and pass back to be owned by the previous state.
     */
    if (cp->state->prev) {
        mprStealBlock(cp->state->prev, np);
    } else {
        mprAssert(cp->state);
        mprStealBlock(cp, np);
    }
    cp->state = ecPopState(cp);

    if (cp->fatalError || cp->error) {
        return 0;
    }
    return np;
}


/*
 *  Leave a level. Pop the state and pass back the current node.
 */
void ecLeaveState(EcCompiler *cp)
{
    cp->state = ecPopState(cp);
}


/*
 *  @copy   default
 *
 *  Copyright (c) Embedthis Software LLC, 2003-2010. All Rights Reserved.
 *  Copyright (c) Michael O'Brien, 1993-2010. All Rights Reserved.
 *
 *  This software is distributed under commercial and open source licenses.
 *  You may use the GPL open source license described below or you may acquire
 *  a commercial license from Embedthis Software. You agree to be fully bound
 *  by the terms of either license. Consult the LICENSE.TXT distributed with
 *  this software for full details.
 *
 *  This software is open source; you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by the
 *  Free Software Foundation; either version 2 of the License, or (at your
 *  option) any later version. See the GNU General Public License for more
 *  details at: http://www.embedthis.com/downloads/gplLicense.html
 *
 *  This program is distributed WITHOUT ANY WARRANTY; without even the
 *  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 *  This GPL license does NOT permit incorporating this software into
 *  proprietary programs. If you are unable to comply with the GPL, you must
 *  acquire a commercial license to use this software. Commercial licenses
 *  for this software and support services are available from Embedthis
 *  Software at http://www.embedthis.com
 *
 *  @end
 */
/************************************************************************/
/*
 *  End of file "../src/compiler/ecState.c"
 */
/************************************************************************/

